
internal uint8 readCpu8(uint16 Address, cpu *Cpu)
{
    Address = cpuMemoryMirror(Address);


    bool32 OnPpuPalette = (0x3F00 <= Cpu->PpuVramIO->VRamAdrs && Cpu->PpuVramIO->VRamAdrs < 0x4000);
    if(Address == 0x2007 && OnPpuPalette)
    {
        uint16 PpuAddress = ppuMemoryMirror(Cpu->PpuVramIO->VRamAdrs);
        uint8 NewRegValue = read8(PpuAddress, GlobalPpuMemoryBase);
        write8(NewRegValue, 0x2007, GlobalCpuMemoryBase);
    }
    
    uint8 Value = read8(Address, Cpu->MemoryBase);
    
    if(Address == 0x2002)
    {
        uint8 ResetValue = Value & ~(1 << 7);
        write8(ResetValue, 0x2002, Cpu->MemoryBase);
        Cpu->PpuVramIO->LatchWrite = 0;
    }

    if(Address == 0x2007)
        ppuIORead(Address, Cpu->PpuVramIO);
    
    // Input
    if(Address == 0x4016 || Address == 0x4017)
    {
        if( !Cpu->PadStrobe )
        {
            if(Address == 0x4016)
                Cpu->Pad1CurrentButton = ++(Cpu->Pad1CurrentButton);
            else
                Cpu->Pad2CurrentButton = ++(Cpu->Pad2CurrentButton);
        }
        
        uint16 InputAddress;
        uint8 BtnValue;
        if(Address == 0x4016)
        {
            InputAddress = 0x4016;
            BtnValue = Cpu->InputPad1.buttons[Cpu->Pad1CurrentButton] & 1;
        }
        else
        {
            InputAddress = 0x4017;
            BtnValue = Cpu->InputPad2.buttons[Cpu->Pad2CurrentButton] & 1;
        }

        uint8 CurrentValue = read8(InputAddress, Cpu->MemoryBase);
        uint8 NewValue = (CurrentValue & 0xFE) | BtnValue;
        write8(NewValue, InputAddress, Cpu->MemoryBase);
    }
    
    return(Value);
}

internal void writeCpu8(uint8 Byte, uint16 Address, cpu *Cpu)
{
    Address = cpuMemoryMirror(Address);

    if(Address == 0x2002)
        return;
    
    write8(Byte, Address, Cpu->MemoryBase);

    // NOTE: Writes that all affect the Ppu Vram IO Address
    if(Address == 0x2000 || Address == 0x2005 || Address == 0x2006 || Address == 0x2007)
    {
        vram_io *VRamIO = Cpu->PpuVramIO;
        
        // PpuVRamIO Nametable updating
        // Low two bits of new 0x2000 value give the nametable.
        // This is read into bit 10 and 11 of the temporary vramIO address 
        if(Address == 0x2000)
        {
            VRamIO->TempVRamAdrs &= ~(0x0C00);
            VRamIO->TempVRamAdrs |= (Byte & 3) << 10;
        }
        
        // PpuVRamIO scroll updating.
        // Register 0x2005 and 0x2006 share Vram Address. 
        if(Address == 0x2005) 
        {
            if(VRamIO->LatchWrite == 0)
            {
                VRamIO->FineX = Byte & 7; // Bit 0,1, and 2 are fine X
                VRamIO->TempVRamAdrs &= ~(0x001F); // Clear Bits
                VRamIO->TempVRamAdrs |= ((uint16)Byte) >> 3;
                VRamIO->LatchWrite = 1;
            }
            else
            {
                VRamIO->TempVRamAdrs &= ~(0x73E0); // Clear Bits
                VRamIO->TempVRamAdrs |= ((uint16)(Byte & 0x0007)) << 12; // Set fine scroll Y, bits 0-2 set bit 12-14
                VRamIO->TempVRamAdrs |= ((uint16)(Byte & 0x00F8)) << 2; // Set coarse Y, bits 3-7 set bit 5-9
                VRamIO->LatchWrite = 0;
            }
        }
        if(Address == 0x2006)
        {
            if(VRamIO->LatchWrite == 0)
            {
                VRamIO->TempVRamAdrs &= ~(0x7F00); // Clear Bits. 14th bit does not get set again
                VRamIO->TempVRamAdrs |= ((uint16)(Byte & 0x003F)) << 8;
                VRamIO->LatchWrite = 1;
            }
            else
            { 
                VRamIO->TempVRamAdrs &= ~(0x00FF); // Clear Bit that are about to be loaded
                VRamIO->TempVRamAdrs |= (uint16)(Byte & 0x00FF); 
                VRamIO->VRamAdrs = VRamIO->TempVRamAdrs;
                VRamIO->LatchWrite = 0;
            }
        }
        if(Address == 0x2007) // Write to IO for ppu.
        {
            uint16 PpuAddress = ppuMemoryMirror(VRamIO->VRamAdrs);
            
            write8(Byte, PpuAddress, GlobalPpuMemoryBase);

            uint8 PpuCtrl1 = read8(0x2000, GlobalCpuMemoryBase);
            if(PpuCtrl1 & (1 << 2))
                VRamIO->VRamAdrs += 32;
            else
                VRamIO->VRamAdrs += 1;
        }
    }
 
    if(Address == 0x2004) // OAM data
        OamDataChange = true;

    // NOTE: OAM DMA Write
    if(Address == 0x4014)
    {
        uint8 OamAddress = read8(0x2003, Cpu->MemoryBase);

        if(OamData == 0)
        {
            Assert(0);
        }
        
        for(uint16 index = OamAddress; index < OAM_SIZE; ++index)
        {
            uint16 NewAddress = (Byte << 8) | index; 
            OamData[index] = read8(NewAddress, Cpu->MemoryBase);
        }
    }
    
    // Input
    if(Address == 0x4016 || Address == 0x4017)
    {
        uint8 Reg1Value = read8(0x4016, Cpu->MemoryBase);
        uint8 Reg2Value = read8(0x4017, Cpu->MemoryBase);

        uint8 Bit0 = (Reg1Value | Reg2Value) & 1;

        if(Bit0 == 0)
        {
            if(Cpu->PadStrobe)
            {
                Cpu->Pad1CurrentButton = Cpu->Pad2CurrentButton = input::B_A;
            }
            Cpu->PadStrobe = false;
        }
        else if(Bit0 == 1)
        {
            Cpu->PadStrobe = true;
        }        

        uint8 BtnValue = Cpu->InputPad1.buttons[Cpu->Pad1CurrentButton] & 1;
        write8(BtnValue, 0x4016, Cpu->MemoryBase);

        BtnValue = Cpu->InputPad2.buttons[Cpu->Pad2CurrentButton] & 1;
        write8(BtnValue, 0x4017, Cpu->MemoryBase);
    }

    if(Address >= 0x8000)
    {
        Cpu->MapperWrite = true;
        Cpu->MapperReg = Byte;
        Cpu->MapperWriteAddress = Address;
    }
}
