/*
                // NOTE TODO: TAKEN FROM HANDMADE HERO. CHANGE TO SUITE ME
                LARGE_INTEGER AudioWallClock;
                QueryPerformanceCounter(&AudioWallClock);
                real32 FromBeginToAudioSeconds = Win32GetSecondsElapsed(FlipWallClock, AudioWallClock, WinPerfCountFrequency);

                DWORD PlayCursor;
                DWORD WriteCursor;
                if(SoundBuffer->GetCurrentPosition(&PlayCursor, &WriteCursor) == DS_OK)
                {
                */
                    /* NOTE(casey):
                       Here is how sound output computation works.
                       We define a safety value that is the number
                       of samples we think our game update loop
                       may vary by (let's say up to 2ms)
                       When we wake up to write audio, we will look
                       and see what the play cursor position is and we
                       will forecast ahead where we think the play
                       cursor will be on the next frame boundary.
                       We will then look to see if the write cursor is
                       before that by at least our safety value.  If
                       it is, the target fill position is that frame
                       boundary plus one frame.  This gives us perfect
                       audio sync in the case of a card that has low
                       enough latency.
                       If the write cursor is _after_ that safety
                       margin, then we assume we can never sync the
                       audio perfectly, so we will write one frame's
                       worth of audio plus the safety margin's worth
                       of guard samples.
                    */
                    /*
                    if(!SoundIsValid)
                    {
                        SoundOutput.RunningSampleIndex = WriteCursor / SoundOutput.BytesPerSample;
                        SoundIsValid = true;
                    }

                   
                    
                    DWORD ByteToLock = ((SoundOutput.RunningSampleIndex*SoundOutput.BytesPerSample) %
                                        SoundOutput.SecondaryBufferSize);

                    DWORD ExpectedSoundBytesPerFrame =
                        (int)((real32)(SoundOutput.SamplesPerSecond*SoundOutput.BytesPerSample) /
                              GameUpdateHz);
                    real32 SecondsLeftUntilFlip = (TargetSecondsPerFrame - FromBeginToAudioSeconds);
                    DWORD ExpectedBytesUntilFlip = (DWORD)((SecondsLeftUntilFlip/TargetSecondsPerFrame)*(real32)ExpectedSoundBytesPerFrame);

                    DWORD ExpectedFrameBoundaryByte = PlayCursor + ExpectedBytesUntilFlip;

                    DWORD SafeWriteCursor = WriteCursor;
                    if(SafeWriteCursor < PlayCursor)
                    {
                        SafeWriteCursor += SoundOutput.SecondaryBufferSize;
                    }
                    Assert(SafeWriteCursor >= PlayCursor);
                    SafeWriteCursor += SoundOutput.SafetyBytes;

                    bool32 AudioCardIsLowLatency = (SafeWriteCursor < ExpectedFrameBoundaryByte);

                    DWORD TargetCursor = 0;
                    if(AudioCardIsLowLatency)
                    {
                        TargetCursor = (ExpectedFrameBoundaryByte + ExpectedSoundBytesPerFrame);
                    }
                    else
                    {
                        TargetCursor = (WriteCursor + ExpectedSoundBytesPerFrame +
                                        SoundOutput.SafetyBytes);
                    }
                    TargetCursor = (TargetCursor % SoundOutput.SecondaryBufferSize);

                    DWORD BytesToWrite = 0;
                    if(ByteToLock > TargetCursor)
                    {
                        BytesToWrite = (SoundOutput.SecondaryBufferSize - ByteToLock);
                        BytesToWrite += TargetCursor;
                    }
                    else
                    {
                        BytesToWrite = TargetCursor - ByteToLock;
                    }

                    game_sound_output_buffer SoundBuffer = {};
                    SoundBuffer.SamplesPerSecond = SoundOutput.SamplesPerSecond;
                    SoundBuffer.SampleCount = Align8(BytesToWrite / SoundOutput.BytesPerSample);
                    BytesToWrite = SoundBuffer.SampleCount*SoundOutput.BytesPerSample;
                    SoundBuffer.Samples = Samples;
                    if(Game.GetSoundSamples)
                    {
                        Game.GetSoundSamples(&GameMemory, &SoundBuffer);
                    }

                    Win32FillSoundBuffer(&SoundOutput, ByteToLock, BytesToWrite, &SoundBuffer);
                }
                else
                {
                    SoundIsValid = false;
                }
*/
