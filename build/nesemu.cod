; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?Palette@@3PAY02EA				; Palette
PUBLIC	?Prev@@3UprevDraw@@A				; Prev
PUBLIC	?NMICalled@@3HA					; NMICalled
PUBLIC	?ResetScrollIOAdrs@@3HA				; ResetScrollIOAdrs
PUBLIC	?ResetVRamIOAdrs@@3HA				; ResetVRamIOAdrs
PUBLIC	?VRamIOAdrsCount@@3EA				; VRamIOAdrsCount
PUBLIC	?PrevVRamIOAdrsCount@@3EA			; PrevVRamIOAdrsCount
PUBLIC	?VRamIOWriteCount@@3EA				; VRamIOWriteCount
PUBLIC	?PrevVRamIOWriteCount@@3EA			; PrevVRamIOWriteCount
_BSS	SEGMENT
?Prev@@3UprevDraw@@A DB 020H DUP (?)			; Prev
?WinInput@@3Uinput@@A DB 020H DUP (?)			; WinInput
?NMICalled@@3HA DD 01H DUP (?)				; NMICalled
?ResetScrollIOAdrs@@3HA DD 01H DUP (?)			; ResetScrollIOAdrs
?ResetVRamIOAdrs@@3HA DD 01H DUP (?)			; ResetVRamIOAdrs
?VRamIOAdrsCount@@3EA DB 01H DUP (?)			; VRamIOAdrsCount
	ALIGN	4

?PrevVRamIOAdrsCount@@3EA DB 01H DUP (?)		; PrevVRamIOAdrsCount
	ALIGN	4

?VRamIOWriteCount@@3EA DB 01H DUP (?)			; VRamIOWriteCount
	ALIGN	4

?PrevVRamIOWriteCount@@3EA DB 01H DUP (?)		; PrevVRamIOWriteCount
_BSS	ENDS
_DATA	SEGMENT
?Palette@@3PAY02EA DB 075H				; Palette
	DB	075H
	DB	075H
	DB	027H
	DB	01bH
	DB	08fH
	DB	00H
	DB	00H
	DB	0abH
	DB	047H
	DB	00H
	DB	09fH
	DB	08fH
	DB	00H
	DB	077H
	DB	0abH
	DB	00H
	DB	013H
	DB	0a7H
	DB	00H
	DB	00H
	DB	07fH
	DB	0bH
	DB	00H
	DB	043H
	DB	02fH
	DB	00H
	DB	00H
	DB	047H
	DB	00H
	DB	00H
	DB	051H
	DB	00H
	DB	00H
	DB	03fH
	DB	017H
	DB	01bH
	DB	03fH
	DB	05fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0bcH
	DB	0bcH
	DB	0bcH
	DB	00H
	DB	073H
	DB	0efH
	DB	023H
	DB	03bH
	DB	0efH
	DB	083H
	DB	00H
	DB	0f3H
	DB	0bfH
	DB	00H
	DB	0bfH
	DB	0e7H
	DB	00H
	DB	05bH
	DB	0dbH
	DB	02bH
	DB	00H
	DB	0cbH
	DB	04fH
	DB	0fH
	DB	08bH
	DB	073H
	DB	00H
	DB	00H
	DB	097H
	DB	00H
	DB	00H
	DB	0abH
	DB	00H
	DB	00H
	DB	093H
	DB	03bH
	DB	00H
	DB	083H
	DB	08bH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	03fH
	DB	0bfH
	DB	0ffH
	DB	05fH
	DB	097H
	DB	0ffH
	DB	0a7H
	DB	08bH
	DB	0fdH
	DB	0f7H
	DB	07bH
	DB	0ffH
	DB	0ffH
	DB	077H
	DB	0b7H
	DB	0ffH
	DB	077H
	DB	063H
	DB	0ffH
	DB	09bH
	DB	03bH
	DB	0f3H
	DB	0bfH
	DB	03fH
	DB	083H
	DB	0d3H
	DB	013H
	DB	04fH
	DB	0dfH
	DB	04bH
	DB	058H
	DB	0f8H
	DB	098H
	DB	00H
	DB	0ebH
	DB	0dbH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0abH
	DB	0e7H
	DB	0ffH
	DB	0c7H
	DB	0d7H
	DB	0ffH
	DB	0d7H
	DB	0cbH
	DB	0ffH
	DB	0ffH
	DB	0c7H
	DB	0ffH
	DB	0ffH
	DB	0c7H
	DB	0dbH
	DB	0ffH
	DB	0bfH
	DB	0b3H
	DB	0ffH
	DB	0dbH
	DB	0abH
	DB	0ffH
	DB	0e7H
	DB	0a3H
	DB	0e3H
	DB	0ffH
	DB	0a3H
	DB	0abH
	DB	0f3H
	DB	0bfH
	DB	0b3H
	DB	0ffH
	DB	0cfH
	DB	09fH
	DB	0ffH
	DB	0f3H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_DATA	ENDS
CONST	SEGMENT
$SG88064 DB	'BRC', 00H
$SG88082 DB	'LDA', 00H
$SG88084 DB	'LDX', 00H
$SG88086 DB	'LDY', 00H
$SG88102 DB	'STA', 00H
$SG88104 DB	'STX', 00H
$SG88106 DB	'STY', 00H
$SG88112 DB	'ASL', 00H
$SG88116 DB	'ASL', 00H
$SG88120 DB	'LSR', 00H
$SG88124 DB	'LSR', 00H
$SG88129 DB	'ROL', 00H
$SG88136 DB	'ROL', 00H
$SG88141 DB	'ROR', 00H
$SG88148 DB	'ROR', 00H
$SG88152 DB	'BIT', 00H
$SG88171 DB	'AND', 00H
$SG88173 DB	'EOR', 00H
$SG88175 DB	'ORA', 00H
$SG88178 DB	'TXA', 00H
$SG88180 DB	'TAX', 00H
$SG88182 DB	'TAY', 00H
$SG88184 DB	'TYA', 00H
$SG88186 DB	'TXS', 00H
$SG88188 DB	'PHA', 00H
$SG88190 DB	'PLA', 00H
$SG88198 DB	'INC', 00H
$SG88201 DB	'DEC', 00H
$SG88206 DB	'DEC', 00H
$SG88210 DB	'INC', 00H
$SG88216 DB	'ADC', 00H
$SG88220 DB	'SBC', 00H
$SG88234 DB	'CMP', 00H
$SG88236 DB	'CPX', 00H
$SG88238 DB	'CPY', 00H
$SG88244 DB	'FLG', 00H
$SG88246 DB	'NOP', 00H
$SG88248 DB	'%X', 0aH, 00H
$SG88279 DB	0aH, 00H
	ORG $+6
$SG88254 DB	'$%.4X:%.2X        %s $%.4X = $%.2X        A:%.2X X:%.2X,'
	DB	' Y:%.2X S:%.2X P:%X', 0aH, 00H
	ORG $+3
$SG88255 DB	'$%.4X:%.2X        %s                      A:%.2X X:%2X, '
	DB	'Y:%.2X S:%.2X P:%X', 0aH, 00H
	ORG $+4
$SG88259 DB	'$%.4X:%2X %2X     %s $%.4X = $%.2X          A:%.2X X:%.2'
	DB	'X, Y:%.2X S:%.2X P:%X', 0aH, 00H
	ORG $+1
$SG88260 DB	'$%.4X:%2X %2X     %s $%.4X                A:%.2X X:%.2X,'
	DB	' Y:%.2X S:%.2X P:%X', 0aH, 00H
	ORG $+3
$SG88264 DB	'$%.4X:%.2X %.2X %.2X  %s $%.4X = $%.2X          A:%.2X X'
	DB	':%.2X, Y:%.2X S:%.2X P:%X', 0aH, 00H
	ORG $+5
$SG88611 DB	'Baseball.nes', 00H
	ORG $+3
$SG88623 DB	'Error: Unknown mapper number = %d', 0aH, 00H
	ORG $+5
$SG88265 DB	'$%.4X:%.2X %.2X %.2X  %s $%.4X                A:%.2X X:%'
	DB	'.2X, Y:%.2X S:%.2X P:%X', 0aH, 00H
	ORG $+3
$SG88625 DB	'NesEmu', 00H
	ORG $+1
$SG88041 DB	'BRK', 00H
$SG88278 DB	'%X: %X, ', 00H
	ORG $+3
$SG88628 DB	'NesEmu', 00H
	ORG $+1
$SG88043 DB	'RTI', 00H
$SG88045 DB	'JSR', 00H
$SG88047 DB	'RTS', 00H
$SG88049 DB	'JMP', 00H
$SG88053 DB	'JMP', 00H
CONST	ENDS
PUBLIC	WinMain
PUBLIC	__local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z	; WinInputCallback
PUBLIC	?setCarry@@YAXPEAE@Z				; setCarry
PUBLIC	?clearCarry@@YAXPEAE@Z				; clearCarry
PUBLIC	?setZero@@YAXEPEAE@Z				; setZero
PUBLIC	?setInterrupt@@YAXPEAE@Z			; setInterrupt
PUBLIC	?clearInterrupt@@YAXPEAE@Z			; clearInterrupt
PUBLIC	?clearDecimal@@YAXPEAE@Z			; clearDecimal
PUBLIC	?setBreak@@YAXPEAE@Z				; setBreak
PUBLIC	?setOverflow@@YAXPEAE@Z				; setOverflow
PUBLIC	?clearOverflow@@YAXPEAE@Z			; clearOverflow
PUBLIC	?setNegative@@YAXEPEAE@Z			; setNegative
PUBLIC	?adc@@YAXEPEAUcpuRegisters@@@Z			; adc
PUBLIC	?sbc@@YAXEPEAUcpuRegisters@@@Z			; sbc
PUBLIC	?cmp@@YAXEEPEAE@Z				; cmp
PUBLIC	?immediate@@YAEPEAUcpuRegisters@@_K@Z		; immediate
PUBLIC	?zeroPage@@YAEPEAUcpuRegisters@@_K@Z		; zeroPage
PUBLIC	?zeroPageX@@YAEPEAUcpuRegisters@@_K@Z		; zeroPageX
PUBLIC	?zeroPageY@@YAEPEAUcpuRegisters@@_K@Z		; zeroPageY
PUBLIC	?abs@@YAEPEAUcpuRegisters@@_K@Z			; abs
PUBLIC	?absX@@YAEPEAUcpuRegisters@@_K@Z		; absX
PUBLIC	?absY@@YAEPEAUcpuRegisters@@_K@Z		; absY
PUBLIC	?indirectX@@YAEPEAUcpuRegisters@@_K@Z		; indirectX
PUBLIC	?indirectY@@YAEPEAUcpuRegisters@@_K@Z		; indirectY
PUBLIC	?relative@@YACPEAUcpuRegisters@@_K@Z		; relative
PUBLIC	?debugPrintStack@@YAXE_K@Z			; debugPrintStack
PUBLIC	?getPaletteValue@@YAXEPEAE00@Z			; getPaletteValue
PUBLIC	?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z	; ppuTick
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	__real@447a0000
PUBLIC	__real@5f800000
EXTRN	__imp_CreateFileA:PROC
EXTRN	__imp_GetFileSizeEx:PROC
EXTRN	__imp_ReadFile:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_QueryPerformanceCounter:PROC
EXTRN	__imp_QueryPerformanceFrequency:PROC
EXTRN	__imp_VirtualAlloc:PROC
EXTRN	__imp_VirtualFree:PROC
EXTRN	__imp_StretchDIBits:PROC
EXTRN	__imp_TranslateMessage:PROC
EXTRN	__imp_DispatchMessageA:PROC
EXTRN	__imp_PeekMessageA:PROC
EXTRN	__imp_DefWindowProcA:PROC
EXTRN	__imp_RegisterClassA:PROC
EXTRN	__imp_CreateWindowExA:PROC
EXTRN	__imp_GetDC:PROC
EXTRN	__imp_ReleaseDC:PROC
EXTRN	__imp_GetClientRect:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	4

?GlobalRunning@@3HA DD 01H DUP (?)			; GlobalRunning
?Log@@3UcpuLog@@A DB 018H DUP (?)			; Log
_BSS	ENDS
;	COMDAT ?linecount@?1??cpuTick@@YAXPEAUcpu@@@Z@4_KA
_BSS	SEGMENT
?linecount@?1??cpuTick@@YAXPEAUcpu@@@Z@4_KA DQ 01H DUP (?) ; `cpuTick'::`2'::linecount
_BSS	ENDS
pdata	SEGMENT
$pdata$WinMain DD imagerel $LN30
	DD	imagerel $LN30+1751
	DD	imagerel $unwind$WinMain
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$?getMilliSeconds@@YAM_K@Z DD imagerel ?getMilliSeconds@@YAM_K@Z
	DD	imagerel ?getMilliSeconds@@YAM_K@Z+112
	DD	imagerel $unwind$?getMilliSeconds@@YAM_K@Z
$pdata$?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z DD imagerel $LN51
	DD	imagerel $LN51+1159
	DD	imagerel $unwind$?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z
$pdata$?LoadFile@@YAPEAXPEADPEAI@Z DD imagerel ?LoadFile@@YAPEAXPEADPEAI@Z
	DD	imagerel ?LoadFile@@YAPEAXPEADPEAI@Z+259
	DD	imagerel $unwind$?LoadFile@@YAPEAXPEADPEAI@Z
$pdata$?cpyMemory@@YAXPEAE0G@Z DD imagerel ?cpyMemory@@YAXPEAE0G@Z
	DD	imagerel ?cpyMemory@@YAXPEAE0G@Z+85
	DD	imagerel $unwind$?cpyMemory@@YAXPEAE0G@Z
$pdata$?writeMemory8@@YAXEG_K@Z DD imagerel ?writeMemory8@@YAXEG_K@Z
	DD	imagerel ?writeMemory8@@YAXEG_K@Z+48
	DD	imagerel $unwind$?writeMemory8@@YAXEG_K@Z
$pdata$?readMemory8@@YAEG_K@Z DD imagerel ?readMemory8@@YAEG_K@Z
	DD	imagerel ?readMemory8@@YAEG_K@Z+49
	DD	imagerel $unwind$?readMemory8@@YAEG_K@Z
$pdata$?readCpuMemory8@@YAEG_K@Z DD imagerel ?readCpuMemory8@@YAEG_K@Z
	DD	imagerel ?readCpuMemory8@@YAEG_K@Z+225
	DD	imagerel $unwind$?readCpuMemory8@@YAEG_K@Z
$pdata$?readCpuMemory16@@YAGG_K@Z DD imagerel ?readCpuMemory16@@YAGG_K@Z
	DD	imagerel ?readCpuMemory16@@YAGG_K@Z+87
	DD	imagerel $unwind$?readCpuMemory16@@YAGG_K@Z
$pdata$?writeCpuMemory8@@YAXEG_K@Z DD imagerel ?writeCpuMemory8@@YAXEG_K@Z
	DD	imagerel ?writeCpuMemory8@@YAXEG_K@Z+244
	DD	imagerel $unwind$?writeCpuMemory8@@YAXEG_K@Z
$pdata$?adc@@YAXEPEAUcpuRegisters@@@Z DD imagerel $LN13
	DD	imagerel $LN13+345
	DD	imagerel $unwind$?adc@@YAXEPEAUcpuRegisters@@@Z
$pdata$?sbc@@YAXEPEAUcpuRegisters@@@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$?sbc@@YAXEPEAUcpuRegisters@@@Z
$pdata$?cmp@@YAXEEPEAE@Z DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$?cmp@@YAXEEPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?immediate@@YAEPEAUcpuRegisters@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$?immediate@@YAEPEAUcpuRegisters@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?zeroPage@@YAEPEAUcpuRegisters@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+110
	DD	imagerel $unwind$?zeroPage@@YAEPEAUcpuRegisters@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?zeroPageX@@YAEPEAUcpuRegisters@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+139
	DD	imagerel $unwind$?zeroPageX@@YAEPEAUcpuRegisters@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?zeroPageY@@YAEPEAUcpuRegisters@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+139
	DD	imagerel $unwind$?zeroPageY@@YAEPEAUcpuRegisters@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?abs@@YAEPEAUcpuRegisters@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$?abs@@YAEPEAUcpuRegisters@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?absX@@YAEPEAUcpuRegisters@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+141
	DD	imagerel $unwind$?absX@@YAEPEAUcpuRegisters@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?absY@@YAEPEAUcpuRegisters@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+141
	DD	imagerel $unwind$?absY@@YAEPEAUcpuRegisters@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?indirectX@@YAEPEAUcpuRegisters@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+148
	DD	imagerel $unwind$?indirectX@@YAEPEAUcpuRegisters@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?indirectY@@YAEPEAUcpuRegisters@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+149
	DD	imagerel $unwind$?indirectY@@YAEPEAUcpuRegisters@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?relative@@YACPEAUcpuRegisters@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$?relative@@YACPEAUcpuRegisters@@_K@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?pushStack@@YAXEPEAE_K@Z DD imagerel ?pushStack@@YAXEPEAE_K@Z
	DD	imagerel ?pushStack@@YAXEPEAE_K@Z+75
	DD	imagerel $unwind$?pushStack@@YAXEPEAE_K@Z
$pdata$?popStack@@YAEPEAE_K@Z DD imagerel ?popStack@@YAEPEAE_K@Z
	DD	imagerel ?popStack@@YAEPEAE_K@Z+84
	DD	imagerel $unwind$?popStack@@YAEPEAE_K@Z
$pdata$?cpuTick@@YAXPEAUcpu@@@Z DD imagerel ?cpuTick@@YAXPEAUcpu@@@Z
	DD	imagerel ?cpuTick@@YAXPEAUcpu@@@Z+11573
	DD	imagerel $unwind$?cpuTick@@YAXPEAUcpu@@@Z
$pdata$?debugPrintStack@@YAXE_K@Z DD imagerel $LN6
	DD	imagerel $LN6+179
	DD	imagerel $unwind$?debugPrintStack@@YAXE_K@Z
$pdata$?writePpuMemory8@@YAXEG_K@Z DD imagerel ?writePpuMemory8@@YAXEG_K@Z
	DD	imagerel ?writePpuMemory8@@YAXEG_K@Z+81
	DD	imagerel $unwind$?writePpuMemory8@@YAXEG_K@Z
$pdata$?getColourIndex@@YAEE_K@Z DD imagerel ?getColourIndex@@YAEE_K@Z
	DD	imagerel ?getColourIndex@@YAEE_K@Z+59
	DD	imagerel $unwind$?getColourIndex@@YAEE_K@Z
$pdata$?getAttribute@@YAEPEAUppu@@EE@Z DD imagerel ?getAttribute@@YAEPEAUppu@@EE@Z
	DD	imagerel ?getAttribute@@YAEPEAUppu@@EE@Z+296
	DD	imagerel $unwind$?getAttribute@@YAEPEAUppu@@EE@Z
$pdata$?getBkgrdPattern@@YA?AUbkgrd_pattern@@PEAUppu@@E@Z DD imagerel ?getBkgrdPattern@@YA?AUbkgrd_pattern@@PEAUppu@@E@Z
	DD	imagerel ?getBkgrdPattern@@YA?AUbkgrd_pattern@@PEAUppu@@E@Z+140
	DD	imagerel $unwind$?getBkgrdPattern@@YA?AUbkgrd_pattern@@PEAUppu@@E@Z
$pdata$?getNametableValue@@YAEPEAUppu@@EE@Z DD imagerel ?getNametableValue@@YAEPEAUppu@@EE@Z
	DD	imagerel ?getNametableValue@@YAEPEAUppu@@EE@Z+86
	DD	imagerel $unwind$?getNametableValue@@YAEPEAUppu@@EE@Z
$pdata$?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z DD imagerel $LN41
	DD	imagerel $LN41+2053
	DD	imagerel $unwind$?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z
$pdata$?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z DD imagerel ?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z
	DD	imagerel ?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z+108
	DD	imagerel $unwind$?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z
$pdata$?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z DD imagerel ?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z
	DD	imagerel ?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z+262
	DD	imagerel $unwind$?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z
$pdata$?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z DD imagerel ?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z
	DD	imagerel ?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z+165
	DD	imagerel $unwind$?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z
pdata	ENDS
;	COMDAT __real@5f800000
CONST	SEGMENT
__real@5f800000 DD 05f800000r			; 1.84467e+19
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?relative@@YACPEAUcpuRegisters@@_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?indirectY@@YAEPEAUcpuRegisters@@_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?indirectX@@YAEPEAUcpuRegisters@@_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?absY@@YAEPEAUcpuRegisters@@_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?absX@@YAEPEAUcpuRegisters@@_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?abs@@YAEPEAUcpuRegisters@@_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?zeroPageY@@YAEPEAUcpuRegisters@@_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?zeroPageX@@YAEPEAUcpuRegisters@@_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?zeroPage@@YAEPEAUcpuRegisters@@_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?immediate@@YAEPEAUcpuRegisters@@_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
xdata	SEGMENT
$unwind$WinMain DD 032e19H
	DD	048011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0238H
$unwind$?getMilliSeconds@@YAM_K@Z DD 010901H
	DD	08209H
$unwind$?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z DD 011701H
	DD	0e217H
$unwind$?LoadFile@@YAPEAXPEADPEAI@Z DD 010e01H
	DD	0c20eH
$unwind$?cpyMemory@@YAXPEAE0G@Z DD 011401H
	DD	02214H
$unwind$?writeMemory8@@YAXEG_K@Z DD 011201H
	DD	02212H
$unwind$?readMemory8@@YAEG_K@Z DD 010e01H
	DD	0220eH
$unwind$?readCpuMemory8@@YAEG_K@Z DD 010e01H
	DD	0620eH
$unwind$?readCpuMemory16@@YAGG_K@Z DD 010e01H
	DD	0620eH
$unwind$?writeCpuMemory8@@YAXEG_K@Z DD 011201H
	DD	04212H
$unwind$?adc@@YAXEPEAUcpuRegisters@@@Z DD 010d01H
	DD	0620dH
$unwind$?sbc@@YAXEPEAUcpuRegisters@@@Z DD 010d01H
	DD	0420dH
$unwind$?cmp@@YAXEEPEAE@Z DD 011101H
	DD	06211H
$unwind$?pushStack@@YAXEPEAE_K@Z DD 011201H
	DD	02212H
$unwind$?popStack@@YAEPEAE_K@Z DD 010e01H
	DD	0220eH
$unwind$?cpuTick@@YAXPEAUcpu@@@Z DD 062219H
	DD	06d0110H
	DD	060087009H
	DD	030065007H
	DD	imagerel __GSHandlerCheck
	DD	0350H
$unwind$?debugPrintStack@@YAXE_K@Z DD 022219H
	DD	0490110H
	DD	imagerel __GSHandlerCheck
	DD	0230H
$unwind$?writePpuMemory8@@YAXEG_K@Z DD 011201H
	DD	04212H
$unwind$?getColourIndex@@YAEE_K@Z DD 010d01H
	DD	0220dH
$unwind$?getAttribute@@YAEPEAUppu@@EE@Z DD 011201H
	DD	04212H
$unwind$?getBkgrdPattern@@YA?AUbkgrd_pattern@@PEAUppu@@E@Z DD 031501H
	DD	070114215H
	DD	06010H
$unwind$?getNametableValue@@YAEPEAUppu@@EE@Z DD 011201H
	DD	02212H
$unwind$?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z DD 042519H
	DD	0190113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z DD 012219H
	DD	08213H
	DD	imagerel __GSHandlerCheck
	DD	030H
$unwind$?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z DD 011401H
	DD	06214H
$unwind$?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z DD 011a01H
	DD	0e21aH
xdata	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
BackBuffer$ = 128
DeviceContext$ = 136
WindowWidth$ = 144
WindowHeight$ = 152
?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z PROC ; drawScreenBuffer

; 305  : {                

  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000c	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00011	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00016	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 306  :     StretchDIBits(DeviceContext,

  0001a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  00022	0f b7 8c 24 98
	00 00 00	 movzx	 ecx, WORD PTR WindowHeight$[rsp]
  0002a	0f b7 94 24 90
	00 00 00	 movzx	 edx, WORD PTR WindowWidth$[rsp]
  00032	c7 44 24 60 20
	00 cc 00	 mov	 DWORD PTR [rsp+96], 13369376 ; 00cc0020H
  0003a	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR [rsp+88], 0
  00042	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00047	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  0004f	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00053	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00058	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  00060	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00063	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00067	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  0006f	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00072	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00076	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  0007e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00086	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0008a	44 8b ca	 mov	 r9d, edx
  0008d	45 33 c0	 xor	 r8d, r8d
  00090	33 d2		 xor	 edx, edx
  00092	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR DeviceContext$[rsp]
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_StretchDIBits

; 307  :                   0, 0, WindowWidth, WindowHeight,
; 308  :                   0, 0, BackBuffer->Width, BackBuffer->Height,
; 309  :                   BackBuffer->Memory,
; 310  :                   &BackBuffer->Info,
; 311  :                   DIB_RGB_COLORS, SRCCOPY);
; 312  : }

  000a0	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000a4	c3		 ret	 0
?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z ENDP ; drawScreenBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
MemorySize$ = 32
Buffer$ = 64
Width$ = 72
Height$ = 80
?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z PROC	; createBackBuffer

; 279  : {

  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 280  :     // TODO: This is based on Handmade Hero code. Will need to reference and look at licences later on
; 281  :     //       website: handmadehero.org
; 282  :     if(Buffer->Memory)

  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  00019	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  0001e	74 17		 je	 SHORT $LN2@createBack

; 283  :     {
; 284  :         VirtualFree(Buffer->Memory, 0, MEM_RELEASE);

  00020	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00026	33 d2		 xor	 edx, edx
  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  0002d	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualFree
$LN2@createBack:

; 285  :     }
; 286  : 
; 287  :     Buffer->Width = Width;

  00037	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  00041	89 41 38	 mov	 DWORD PTR [rcx+56], eax

; 288  :     Buffer->Height = Height;

  00044	0f b7 44 24 50	 movzx	 eax, WORD PTR Height$[rsp]
  00049	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  0004e	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 289  :     Buffer->BytesPerPixel = 4;

  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  00056	c7 40 44 04 00
	00 00		 mov	 DWORD PTR [rax+68], 4

; 290  : 
; 291  :     Buffer->Info.bmiHeader.biSize = sizeof(Buffer->Info.bmiHeader);

  0005d	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  00062	c7 00 28 00 00
	00		 mov	 DWORD PTR [rax], 40	; 00000028H

; 292  :     Buffer->Info.bmiHeader.biWidth = Width;

  00068	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  0006d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  00072	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 293  :     Buffer->Info.bmiHeader.biHeight = -Height; // Negative tells windows that we raster top to bottom

  00075	0f b7 44 24 50	 movzx	 eax, WORD PTR Height$[rsp]
  0007a	f7 d8		 neg	 eax
  0007c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  00081	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 294  :     Buffer->Info.bmiHeader.biPlanes = 1;

  00084	b8 01 00 00 00	 mov	 eax, 1
  00089	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  0008e	66 89 41 0c	 mov	 WORD PTR [rcx+12], ax

; 295  :     Buffer->Info.bmiHeader.biBitCount = 32;

  00092	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  0009c	66 89 41 0e	 mov	 WORD PTR [rcx+14], ax

; 296  :     Buffer->Info.bmiHeader.biCompression = BI_RGB;

  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  000a5	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 297  : 
; 298  :     int MemorySize = Width * Height * Buffer->BytesPerPixel;

  000ac	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  000b1	0f b7 4c 24 50	 movzx	 ecx, WORD PTR Height$[rsp]
  000b6	0f af c1	 imul	 eax, ecx
  000b9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000be	0f af 41 44	 imul	 eax, DWORD PTR [rcx+68]
  000c2	89 44 24 20	 mov	 DWORD PTR MemorySize$[rsp], eax

; 299  :     Buffer->Memory = VirtualAlloc(0, MemorySize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);

  000c6	48 63 44 24 20	 movsxd	 rax, DWORD PTR MemorySize$[rsp]
  000cb	41 b9 04 00 00
	00		 mov	 r9d, 4
  000d1	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  000d7	48 8b d0	 mov	 rdx, rax
  000da	33 c9		 xor	 ecx, ecx
  000dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  000e2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000e7	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 300  :     Buffer->Pitch = Width * Buffer->BytesPerPixel;

  000eb	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  000f0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000f5	0f af 41 44	 imul	 eax, DWORD PTR [rcx+68]
  000f9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000fe	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 301  : }

  00101	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00105	c3		 ret	 0
?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z ENDP	; createBackBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
ClientRect$ = 32
__$ArrayPad$ = 48
Window$ = 80
Width$ = 88
Height$ = 96
?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z PROC		; getWindowSize

; 270  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 271  :     RECT ClientRect;
; 272  :     GetClientRect(Window, &ClientRect);

  00022	48 8d 54 24 20	 lea	 rdx, QWORD PTR ClientRect$[rsp]
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Window$[rsp]
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetClientRect

; 273  :     *Width = ClientRect.right - ClientRect.left;

  00032	8b 44 24 20	 mov	 eax, DWORD PTR ClientRect$[rsp]
  00036	8b 4c 24 28	 mov	 ecx, DWORD PTR ClientRect$[rsp+8]
  0003a	2b c8		 sub	 ecx, eax
  0003c	8b c1		 mov	 eax, ecx
  0003e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Width$[rsp]
  00043	66 89 01	 mov	 WORD PTR [rcx], ax

; 274  :     *Height = ClientRect.bottom - ClientRect.top;

  00046	8b 44 24 24	 mov	 eax, DWORD PTR ClientRect$[rsp+4]
  0004a	8b 4c 24 2c	 mov	 ecx, DWORD PTR ClientRect$[rsp+12]
  0004e	2b c8		 sub	 ecx, eax
  00050	8b c1		 mov	 eax, ecx
  00052	48 8b 4c 24 60	 mov	 rcx, QWORD PTR Height$[rsp]
  00057	66 89 01	 mov	 WORD PTR [rcx], ax

; 275  : }

  0005a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0005f	48 33 cc	 xor	 rcx, rsp
  00062	e8 00 00 00 00	 call	 __security_check_cookie
  00067	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006b	c3		 ret	 0
?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z ENDP		; getWindowSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
PatternIndex$1 = 32
BlockX$2 = 33
TileX$3 = 34
TileY$4 = 35
AddressIncrement$ = 36
BlockY$5 = 37
TilePixelY$6 = 38
TilePixelX$7 = 39
CombinedBits$8 = 40
Registers$ = 48
Value$9 = 56
Group2Bit$10 = 57
Group1Bit$11 = 58
Attribute$12 = 59
ColourIndex$13 = 60
Blue$14 = 61
Green$15 = 62
Red$16 = 63
NameTableFlag$ = 64
tv70 = 68
FullAttribute$17 = 72
ColourIntensity$ = 73
SpritesAre8x16$ = 76
NmiOnVBlank$ = 80
ColourMode$ = 84
ClipBackground$ = 88
ClipSprites$ = 92
HideBackground$ = 96
HideSprites$ = 100
Pattern$18 = 104
CurrentPixel$19 = 120
Test$20 = 128
$T21 = 136
$T22 = 152
Palette$23 = 168
__$ArrayPad$ = 184
BackBuffer$ = 224
PpuData$ = 232
?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z PROC	; ppuTick

; 197  : {

$LN41:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 198  :     ppu_registers *Registers = PpuData->Registers; 

  00025	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	48 89 44 24 30	 mov	 QWORD PTR Registers$[rsp], rax

; 199  :     
; 200  :     uint8 NameTableFlag = Registers->Ctrl1 & 0x03;

  00035	48 8b 44 24 30	 mov	 rax, QWORD PTR Registers$[rsp]
  0003a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003d	83 e0 03	 and	 eax, 3
  00040	88 44 24 40	 mov	 BYTE PTR NameTableFlag$[rsp], al

; 201  :     switch(NameTableFlag)

  00044	0f b6 44 24 40	 movzx	 eax, BYTE PTR NameTableFlag$[rsp]
  00049	88 44 24 44	 mov	 BYTE PTR tv70[rsp], al
  0004d	80 7c 24 44 00	 cmp	 BYTE PTR tv70[rsp], 0
  00052	74 17		 je	 SHORT $LN4@ppuTick
  00054	80 7c 24 44 01	 cmp	 BYTE PTR tv70[rsp], 1
  00059	74 23		 je	 SHORT $LN5@ppuTick
  0005b	80 7c 24 44 02	 cmp	 BYTE PTR tv70[rsp], 2
  00060	74 2f		 je	 SHORT $LN6@ppuTick
  00062	80 7c 24 44 03	 cmp	 BYTE PTR tv70[rsp], 3
  00067	74 3b		 je	 SHORT $LN7@ppuTick
  00069	eb 4a		 jmp	 SHORT $LN2@ppuTick
$LN4@ppuTick:

; 202  :     {
; 203  :         case 0:
; 204  :         {
; 205  :             PpuData->NameTableAddress = 0x2000;

  0006b	b8 00 20 00 00	 mov	 eax, 8192		; 00002000H
  00070	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  00078	66 89 41 20	 mov	 WORD PTR [rcx+32], ax

; 206  :             break;

  0007c	eb 37		 jmp	 SHORT $LN2@ppuTick
$LN5@ppuTick:

; 207  :         }
; 208  :         case 1:
; 209  :         {
; 210  :             PpuData->NameTableAddress = 0x2400;

  0007e	b8 00 24 00 00	 mov	 eax, 9216		; 00002400H
  00083	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  0008b	66 89 41 20	 mov	 WORD PTR [rcx+32], ax

; 211  :             break;

  0008f	eb 24		 jmp	 SHORT $LN2@ppuTick
$LN6@ppuTick:

; 212  :         }
; 213  :         case 2:
; 214  :         {
; 215  :             PpuData->NameTableAddress = 0x2800;

  00091	b8 00 28 00 00	 mov	 eax, 10240		; 00002800H
  00096	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  0009e	66 89 41 20	 mov	 WORD PTR [rcx+32], ax

; 216  :             break;

  000a2	eb 11		 jmp	 SHORT $LN2@ppuTick
$LN7@ppuTick:

; 217  :         }
; 218  :         case 3:
; 219  :         {
; 220  :             PpuData->NameTableAddress = 0x2C00;

  000a4	b8 00 2c 00 00	 mov	 eax, 11264		; 00002c00H
  000a9	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  000b1	66 89 41 20	 mov	 WORD PTR [rcx+32], ax
$LN2@ppuTick:

; 221  :             break;
; 222  :         }
; 223  :     }
; 224  :     
; 225  :     uint8 AddressIncrement = 1;

  000b5	c6 44 24 24 01	 mov	 BYTE PTR AddressIncrement$[rsp], 1

; 226  :     if(Registers->Ctrl1 & (1 << 2))

  000ba	48 8b 44 24 30	 mov	 rax, QWORD PTR Registers$[rsp]
  000bf	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000c2	83 e0 04	 and	 eax, 4
  000c5	85 c0		 test	 eax, eax
  000c7	74 05		 je	 SHORT $LN8@ppuTick

; 227  :         AddressIncrement = 32;

  000c9	c6 44 24 24 20	 mov	 BYTE PTR AddressIncrement$[rsp], 32 ; 00000020H
$LN8@ppuTick:

; 228  : 
; 229  :     
; 230  :     if(Registers->Ctrl1 & (1 << 3))

  000ce	48 8b 44 24 30	 mov	 rax, QWORD PTR Registers$[rsp]
  000d3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000d6	83 e0 08	 and	 eax, 8
  000d9	85 c0		 test	 eax, eax
  000db	74 13		 je	 SHORT $LN9@ppuTick

; 231  :         PpuData->SprtPatAddress = 0x1000;

  000dd	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  000e2	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  000ea	66 89 41 24	 mov	 WORD PTR [rcx+36], ax

; 232  :     else

  000ee	eb 0e		 jmp	 SHORT $LN10@ppuTick
$LN9@ppuTick:

; 233  :         PpuData->SprtPatAddress = 0x0000;

  000f0	33 c0		 xor	 eax, eax
  000f2	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  000fa	66 89 41 24	 mov	 WORD PTR [rcx+36], ax
$LN10@ppuTick:

; 234  :     
; 235  :     if(Registers->Ctrl1 & (1 << 4))

  000fe	48 8b 44 24 30	 mov	 rax, QWORD PTR Registers$[rsp]
  00103	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00106	83 e0 10	 and	 eax, 16
  00109	85 c0		 test	 eax, eax
  0010b	74 13		 je	 SHORT $LN11@ppuTick

; 236  :         PpuData->BkgrdPatAddress = 0x1000;

  0010d	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  00112	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  0011a	66 89 41 22	 mov	 WORD PTR [rcx+34], ax

; 237  :     else

  0011e	eb 0e		 jmp	 SHORT $LN12@ppuTick
$LN11@ppuTick:

; 238  :         PpuData->BkgrdPatAddress = 0x0000;

  00120	33 c0		 xor	 eax, eax
  00122	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  0012a	66 89 41 22	 mov	 WORD PTR [rcx+34], ax
$LN12@ppuTick:

; 239  : 
; 240  :     
; 241  :     bool32 SpritesAre8x16 = false;

  0012e	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR SpritesAre8x16$[rsp], 0

; 242  :     if(Registers->Ctrl1 & (1 << 5))

  00136	48 8b 44 24 30	 mov	 rax, QWORD PTR Registers$[rsp]
  0013b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0013e	83 e0 20	 and	 eax, 32			; 00000020H
  00141	85 c0		 test	 eax, eax
  00143	74 08		 je	 SHORT $LN13@ppuTick

; 243  :         SpritesAre8x16 = true;

  00145	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR SpritesAre8x16$[rsp], 1
$LN13@ppuTick:

; 244  : 
; 245  :     bool32 NmiOnVBlank = false;

  0014d	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR NmiOnVBlank$[rsp], 0

; 246  :     if(Registers->Ctrl1 & (1 << 7))

  00155	48 8b 44 24 30	 mov	 rax, QWORD PTR Registers$[rsp]
  0015a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0015d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00162	85 c0		 test	 eax, eax
  00164	74 08		 je	 SHORT $LN14@ppuTick

; 247  :         NmiOnVBlank = true;

  00166	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR NmiOnVBlank$[rsp], 1
$LN14@ppuTick:

; 248  : 
; 249  : 
; 250  :     bool32 ColourMode = true;

  0016e	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR ColourMode$[rsp], 1

; 251  :     if(Registers->Ctrl2 & 1)

  00176	48 8b 44 24 30	 mov	 rax, QWORD PTR Registers$[rsp]
  0017b	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0017f	83 e0 01	 and	 eax, 1
  00182	85 c0		 test	 eax, eax
  00184	74 08		 je	 SHORT $LN15@ppuTick

; 252  :         ColourMode = false;

  00186	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR ColourMode$[rsp], 0
$LN15@ppuTick:

; 253  : 
; 254  :     bool32 ClipBackground = false;

  0018e	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR ClipBackground$[rsp], 0

; 255  :     if(Registers->Ctrl2 & (1 << 1))

  00196	48 8b 44 24 30	 mov	 rax, QWORD PTR Registers$[rsp]
  0019b	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0019f	83 e0 02	 and	 eax, 2
  001a2	85 c0		 test	 eax, eax
  001a4	74 08		 je	 SHORT $LN16@ppuTick

; 256  :         ClipBackground = true;

  001a6	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR ClipBackground$[rsp], 1
$LN16@ppuTick:

; 257  : 
; 258  :     bool32 ClipSprites = false;

  001ae	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR ClipSprites$[rsp], 0

; 259  :     if(Registers->Ctrl2 & (1 << 2))

  001b6	48 8b 44 24 30	 mov	 rax, QWORD PTR Registers$[rsp]
  001bb	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001bf	83 e0 04	 and	 eax, 4
  001c2	85 c0		 test	 eax, eax
  001c4	74 08		 je	 SHORT $LN17@ppuTick

; 260  :         ClipSprites = true;

  001c6	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR ClipSprites$[rsp], 1
$LN17@ppuTick:

; 261  : 
; 262  :     bool32 HideBackground = true;

  001ce	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR HideBackground$[rsp], 1

; 263  :     if(Registers->Ctrl2 & (1 << 3))

  001d6	48 8b 44 24 30	 mov	 rax, QWORD PTR Registers$[rsp]
  001db	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001df	83 e0 08	 and	 eax, 8
  001e2	85 c0		 test	 eax, eax
  001e4	74 08		 je	 SHORT $LN18@ppuTick

; 264  :         HideBackground = false;

  001e6	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR HideBackground$[rsp], 0
$LN18@ppuTick:

; 265  : 
; 266  :     bool32 HideSprites = true;

  001ee	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR HideSprites$[rsp], 1

; 267  :     if(Registers->Ctrl2 & (1 << 4))

  001f6	48 8b 44 24 30	 mov	 rax, QWORD PTR Registers$[rsp]
  001fb	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001ff	83 e0 10	 and	 eax, 16
  00202	85 c0		 test	 eax, eax
  00204	74 08		 je	 SHORT $LN19@ppuTick

; 268  :         HideSprites = false;

  00206	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR HideSprites$[rsp], 0
$LN19@ppuTick:

; 269  : 
; 270  :     uint8 ColourIntensity = Registers->Ctrl2 >> 5;    

  0020e	48 8b 44 24 30	 mov	 rax, QWORD PTR Registers$[rsp]
  00213	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00217	c1 f8 05	 sar	 eax, 5
  0021a	88 44 24 49	 mov	 BYTE PTR ColourIntensity$[rsp], al

; 271  : 
; 272  :     if(VRamIOAdrsCount > PrevVRamIOAdrsCount)

  0021e	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?VRamIOAdrsCount@@3EA ; VRamIOAdrsCount
  00225	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?PrevVRamIOAdrsCount@@3EA ; PrevVRamIOAdrsCount
  0022c	3b c1		 cmp	 eax, ecx
  0022e	7e 26		 jle	 SHORT $LN20@ppuTick

; 273  :     {
; 274  :         PpuData->VRamIOAdrs = (PpuData->VRamIOAdrs << 8) | Registers->VRamAddress;

  00230	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  00238	0f b7 40 2c	 movzx	 eax, WORD PTR [rax+44]
  0023c	c1 e0 08	 shl	 eax, 8
  0023f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Registers$[rsp]
  00244	0f b6 49 06	 movzx	 ecx, BYTE PTR [rcx+6]
  00248	0b c1		 or	 eax, ecx
  0024a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  00252	66 89 41 2c	 mov	 WORD PTR [rcx+44], ax
$LN20@ppuTick:

; 275  :     }
; 276  :     PrevVRamIOAdrsCount = VRamIOAdrsCount;

  00256	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?VRamIOAdrsCount@@3EA ; VRamIOAdrsCount
  0025d	88 05 00 00 00
	00		 mov	 BYTE PTR ?PrevVRamIOAdrsCount@@3EA, al ; PrevVRamIOAdrsCount

; 277  :     
; 278  :     if(VRamIOWriteCount > PrevVRamIOWriteCount)

  00263	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?VRamIOWriteCount@@3EA ; VRamIOWriteCount
  0026a	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?PrevVRamIOWriteCount@@3EA ; PrevVRamIOWriteCount
  00271	3b c1		 cmp	 eax, ecx
  00273	7e 50		 jle	 SHORT $LN21@ppuTick

; 279  :     {
; 280  :         uint8 Value = Registers->VRamIO;        

  00275	48 8b 44 24 30	 mov	 rax, QWORD PTR Registers$[rsp]
  0027a	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  0027e	88 44 24 38	 mov	 BYTE PTR Value$9[rsp], al

; 281  :         writePpuMemory8(Value, PpuData->VRamIOAdrs, PpuData->MemoryOffset);

  00282	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  0028a	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  0028e	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  00296	0f b7 50 2c	 movzx	 edx, WORD PTR [rax+44]
  0029a	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR Value$9[rsp]
  0029f	e8 00 00 00 00	 call	 ?writePpuMemory8@@YAXEG_K@Z ; writePpuMemory8

; 282  : 
; 283  :         PpuData->VRamIOAdrs += AddressIncrement;

  002a4	0f b6 44 24 24	 movzx	 eax, BYTE PTR AddressIncrement$[rsp]
  002a9	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  002b1	0f b7 49 2c	 movzx	 ecx, WORD PTR [rcx+44]
  002b5	03 c8		 add	 ecx, eax
  002b7	8b c1		 mov	 eax, ecx
  002b9	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  002c1	66 89 41 2c	 mov	 WORD PTR [rcx+44], ax
$LN21@ppuTick:

; 284  :     }
; 285  :     PrevVRamIOWriteCount = VRamIOWriteCount;

  002c5	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?VRamIOWriteCount@@3EA ; VRamIOWriteCount
  002cc	88 05 00 00 00
	00		 mov	 BYTE PTR ?PrevVRamIOWriteCount@@3EA, al ; PrevVRamIOWriteCount

; 286  : 
; 287  :     
; 288  :     if(ResetScrollIOAdrs) // TODO: Finish this

  002d2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ResetScrollIOAdrs@@3HA, 0 ; ResetScrollIOAdrs
  002d9	74 0a		 je	 SHORT $LN22@ppuTick

; 289  :     {
; 290  :         ResetScrollIOAdrs = false;

  002db	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ResetScrollIOAdrs@@3HA, 0 ; ResetScrollIOAdrs
$LN22@ppuTick:

; 291  :     }
; 292  :     if(ResetVRamIOAdrs)

  002e5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ResetVRamIOAdrs@@3HA, 0 ; ResetVRamIOAdrs
  002ec	74 40		 je	 SHORT $LN23@ppuTick

; 293  :     {
; 294  :         PpuData->VRamIOAdrs = 0;

  002ee	33 c0		 xor	 eax, eax
  002f0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  002f8	66 89 41 2c	 mov	 WORD PTR [rcx+44], ax

; 295  :         VRamIOAdrsCount = PrevVRamIOAdrsCount = 0;

  002fc	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?PrevVRamIOAdrsCount@@3EA, 0 ; PrevVRamIOAdrsCount
  00303	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?PrevVRamIOAdrsCount@@3EA ; PrevVRamIOAdrsCount
  0030a	88 05 00 00 00
	00		 mov	 BYTE PTR ?VRamIOAdrsCount@@3EA, al ; VRamIOAdrsCount

; 296  :         VRamIOWriteCount = PrevVRamIOWriteCount = 0;        

  00310	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?PrevVRamIOWriteCount@@3EA, 0 ; PrevVRamIOWriteCount
  00317	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?PrevVRamIOWriteCount@@3EA ; PrevVRamIOWriteCount
  0031e	88 05 00 00 00
	00		 mov	 BYTE PTR ?VRamIOWriteCount@@3EA, al ; VRamIOWriteCount

; 297  :         ResetVRamIOAdrs = false;

  00324	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ResetVRamIOAdrs@@3HA, 0 ; ResetVRamIOAdrs
$LN23@ppuTick:

; 298  :     }
; 299  :     
; 300  :     
; 301  : 
; 302  :     
; 303  :     if(!Prev.Initialised)

  0032e	83 3d 18 00 00
	00 00		 cmp	 DWORD PTR ?Prev@@3UprevDraw@@A+24, 0
  00335	75 43		 jne	 SHORT $LN24@ppuTick

; 304  :     {
; 305  :         Prev.Pattern.Group1 = (uint8 *)255;

  00337	48 c7 05 00 00
	00 00 ff 00 00
	00		 mov	 QWORD PTR ?Prev@@3UprevDraw@@A, 255 ; 000000ffH

; 306  :         Prev.Pattern.Group2 = (uint8 *)255;

  00342	48 c7 05 08 00
	00 00 ff 00 00
	00		 mov	 QWORD PTR ?Prev@@3UprevDraw@@A+8, 255 ; 000000ffH

; 307  :         Prev.PatternIndex = 255;

  0034d	c6 05 10 00 00
	00 ff		 mov	 BYTE PTR ?Prev@@3UprevDraw@@A+16, 255 ; 000000ffH

; 308  :         Prev.TileX = 255;

  00354	c6 05 11 00 00
	00 ff		 mov	 BYTE PTR ?Prev@@3UprevDraw@@A+17, 255 ; 000000ffH

; 309  :         Prev.TileY = 255;

  0035b	c6 05 12 00 00
	00 ff		 mov	 BYTE PTR ?Prev@@3UprevDraw@@A+18, 255 ; 000000ffH

; 310  :         Prev.BlockX = 255;

  00362	c6 05 13 00 00
	00 ff		 mov	 BYTE PTR ?Prev@@3UprevDraw@@A+19, 255 ; 000000ffH

; 311  :         Prev.BlockY = 255;

  00369	c6 05 14 00 00
	00 ff		 mov	 BYTE PTR ?Prev@@3UprevDraw@@A+20, 255 ; 000000ffH

; 312  :         Prev.Initialised = true;

  00370	c7 05 18 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?Prev@@3UprevDraw@@A+24, 1
$LN24@ppuTick:

; 313  :     }
; 314  :         
; 315  :     /*
; 316  :       Palette is stored at 0x3F00 to 0x3F20
; 317  :       0x3F00 - 0x3F0F is Image Palette
; 318  :       0x3F10 - 0x3F1F is Sprie Palette
; 319  : 
; 320  :       This is mirrored from 0x3F20 to 0x4000
; 321  : 
; 322  :       A palette is 16 indexes to colours stored
; 323  :       in the colour palette. This does not mean 16
; 324  :       seperate colours however as a shared colour is
; 325  :       found every 4 bytes. So 0x3F00 = 0x3F04 = 0x3F08 = 0x3F0C
; 326  : 
; 327  :       Each group of palette is 4 colours.
; 328  :       There are 4 groups.
; 329  :       Attribute tables will name one of the four groups
; 330  :       This is the 4 colours used by a 2x2 tile section
; 331  :       Tiles are 8x8 pixels.
; 332  :       Pattern Tables hold the 8x8 pixel data. Each pattern is
; 333  :       16 bytes.
; 334  :       The nametable points to which pattern is used for a 8x8 pixeled
; 335  :       section.
; 336  :       
; 337  :      */
; 338  : 
; 339  :     // 341 PPU cycles in a scanline, and 262 scanlines in a frame
; 340  :     
; 341  :     if(PpuData->ScanLine == 0)

  0037a	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  00382	0f b7 40 2a	 movzx	 eax, WORD PTR [rax+42]
  00386	85 c0		 test	 eax, eax
  00388	75 42		 jne	 SHORT $LN25@ppuTick

; 342  :     {
; 343  :         Registers->Status = Registers->Status & ~(1 << 7); // clear vblank

  0038a	48 8b 44 24 30	 mov	 rax, QWORD PTR Registers$[rsp]
  0038f	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00393	0f ba f0 07	 btr	 eax, 7
  00397	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Registers$[rsp]
  0039c	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 344  :         Registers->Status = Registers->Status & ~(1 << 6); // clear sprite0

  0039f	48 8b 44 24 30	 mov	 rax, QWORD PTR Registers$[rsp]
  003a4	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  003a8	83 e0 bf	 and	 eax, -65		; ffffffffffffffbfH
  003ab	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Registers$[rsp]
  003b0	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 345  :         Registers->Status = Registers->Status & ~(1 << 5); // clear spriteOverflow

  003b3	48 8b 44 24 30	 mov	 rax, QWORD PTR Registers$[rsp]
  003b8	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  003bc	83 e0 df	 and	 eax, -33		; ffffffffffffffdfH
  003bf	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Registers$[rsp]
  003c4	88 41 02	 mov	 BYTE PTR [rcx+2], al
  003c7	e9 e2 03 00 00	 jmp	 $LN26@ppuTick
$LN25@ppuTick:

; 346  :     }
; 347  :     else if(PpuData->ScanLine > 0 && PpuData->ScanLine < 240)

  003cc	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  003d4	0f b7 40 2a	 movzx	 eax, WORD PTR [rax+42]
  003d8	85 c0		 test	 eax, eax
  003da	0f 8e 91 03 00
	00		 jle	 $LN27@ppuTick
  003e0	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  003e8	0f b7 40 2a	 movzx	 eax, WORD PTR [rax+42]
  003ec	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  003f1	0f 8d 7a 03 00
	00		 jge	 $LN27@ppuTick

; 348  :     {
; 349  :         uint8 Red, Green, Blue;
; 350  :         palette Palette = {};

  003f7	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR Palette$23[rsp]
  003ff	48 8b f8	 mov	 rdi, rax
  00402	33 c0		 xor	 eax, eax
  00404	b9 0c 00 00 00	 mov	 ecx, 12
  00409	f3 aa		 rep stosb

; 351  :         
; 352  :         // NOTE: Pattern Tile
; 353  :         uint8 TileX = PpuData->CurrentXPixel / 8;

  0040b	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  00413	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00417	99		 cdq
  00418	83 e2 07	 and	 edx, 7
  0041b	03 c2		 add	 eax, edx
  0041d	c1 f8 03	 sar	 eax, 3
  00420	88 44 24 22	 mov	 BYTE PTR TileX$3[rsp], al

; 354  :         uint8 TileY = PpuData->CurrentYPixel / 8; 

  00424	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  0042c	0f b7 40 12	 movzx	 eax, WORD PTR [rax+18]
  00430	99		 cdq
  00431	83 e2 07	 and	 edx, 7
  00434	03 c2		 add	 eax, edx
  00436	c1 f8 03	 sar	 eax, 3
  00439	88 44 24 23	 mov	 BYTE PTR TileY$4[rsp], al

; 355  :         // NOTE: Pixel relative to a tile
; 356  :         uint8 TilePixelX = PpuData->CurrentXPixel % 8;

  0043d	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  00445	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00449	99		 cdq
  0044a	83 e2 07	 and	 edx, 7
  0044d	03 c2		 add	 eax, edx
  0044f	83 e0 07	 and	 eax, 7
  00452	2b c2		 sub	 eax, edx
  00454	88 44 24 27	 mov	 BYTE PTR TilePixelX$7[rsp], al

; 357  :         uint8 TilePixelY = PpuData->CurrentYPixel % 8;

  00458	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  00460	0f b7 40 12	 movzx	 eax, WORD PTR [rax+18]
  00464	99		 cdq
  00465	83 e2 07	 and	 edx, 7
  00468	03 c2		 add	 eax, edx
  0046a	83 e0 07	 and	 eax, 7
  0046d	2b c2		 sub	 eax, edx
  0046f	88 44 24 26	 mov	 BYTE PTR TilePixelY$6[rsp], al

; 358  :         // NOTE: Attribute Block
; 359  :         uint8 BlockX = PpuData->CurrentXPixel / 16; 

  00473	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  0047b	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  0047f	99		 cdq
  00480	83 e2 0f	 and	 edx, 15
  00483	03 c2		 add	 eax, edx
  00485	c1 f8 04	 sar	 eax, 4
  00488	88 44 24 21	 mov	 BYTE PTR BlockX$2[rsp], al

; 360  :         uint8 BlockY = PpuData->CurrentYPixel / 16;

  0048c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  00494	0f b7 40 12	 movzx	 eax, WORD PTR [rax+18]
  00498	99		 cdq
  00499	83 e2 0f	 and	 edx, 15
  0049c	03 c2		 add	 eax, edx
  0049e	c1 f8 04	 sar	 eax, 4
  004a1	88 44 24 25	 mov	 BYTE PTR BlockY$5[rsp], al

; 361  : 
; 362  :         // NOTE: Retrieve the pattern index for this tile 
; 363  :         uint8 PatternIndex;
; 364  :         if((TileX != Prev.TileX) || (TileY != Prev.TileY))

  004a5	0f b6 44 24 22	 movzx	 eax, BYTE PTR TileX$3[rsp]
  004aa	0f b6 0d 11 00
	00 00		 movzx	 ecx, BYTE PTR ?Prev@@3UprevDraw@@A+17
  004b1	3b c1		 cmp	 eax, ecx
  004b3	75 10		 jne	 SHORT $LN31@ppuTick
  004b5	0f b6 44 24 23	 movzx	 eax, BYTE PTR TileY$4[rsp]
  004ba	0f b6 0d 12 00
	00 00		 movzx	 ecx, BYTE PTR ?Prev@@3UprevDraw@@A+18
  004c1	3b c1		 cmp	 eax, ecx
  004c3	74 1e		 je	 SHORT $LN29@ppuTick
$LN31@ppuTick:

; 365  :             PatternIndex = getNametableValue(PpuData, TileX, TileY);

  004c5	44 0f b6 44 24
	23		 movzx	 r8d, BYTE PTR TileY$4[rsp]
  004cb	0f b6 54 24 22	 movzx	 edx, BYTE PTR TileX$3[rsp]
  004d0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  004d8	e8 00 00 00 00	 call	 ?getNametableValue@@YAEPEAUppu@@EE@Z ; getNametableValue
  004dd	88 44 24 20	 mov	 BYTE PTR PatternIndex$1[rsp], al

; 366  :         else

  004e1	eb 0b		 jmp	 SHORT $LN30@ppuTick
$LN29@ppuTick:

; 367  :             PatternIndex = Prev.PatternIndex;

  004e3	0f b6 05 10 00
	00 00		 movzx	 eax, BYTE PTR ?Prev@@3UprevDraw@@A+16
  004ea	88 44 24 20	 mov	 BYTE PTR PatternIndex$1[rsp], al
$LN30@ppuTick:

; 368  :         
; 369  :         Prev.TileX = TileX;

  004ee	0f b6 44 24 22	 movzx	 eax, BYTE PTR TileX$3[rsp]
  004f3	88 05 11 00 00
	00		 mov	 BYTE PTR ?Prev@@3UprevDraw@@A+17, al

; 370  :         Prev.TileY = TileY;

  004f9	0f b6 44 24 23	 movzx	 eax, BYTE PTR TileY$4[rsp]
  004fe	88 05 12 00 00
	00		 mov	 BYTE PTR ?Prev@@3UprevDraw@@A+18, al

; 371  : 
; 372  :         bkgrd_pattern Pattern;
; 373  : 
; 374  :         // Grab the Pattern data based on the index given
; 375  :         if(PatternIndex != Prev.PatternIndex)

  00504	0f b6 44 24 20	 movzx	 eax, BYTE PTR PatternIndex$1[rsp]
  00509	0f b6 0d 10 00
	00 00		 movzx	 ecx, BYTE PTR ?Prev@@3UprevDraw@@A+16
  00510	3b c1		 cmp	 eax, ecx
  00512	74 4c		 je	 SHORT $LN32@ppuTick

; 376  :             Pattern = getBkgrdPattern(PpuData, PatternIndex);

  00514	44 0f b6 44 24
	20		 movzx	 r8d, BYTE PTR PatternIndex$1[rsp]
  0051a	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR PpuData$[rsp]
  00522	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR $T22[rsp]
  0052a	e8 00 00 00 00	 call	 ?getBkgrdPattern@@YA?AUbkgrd_pattern@@PEAUppu@@E@Z ; getBkgrdPattern
  0052f	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR $T21[rsp]
  00537	48 8b f9	 mov	 rdi, rcx
  0053a	48 8b f0	 mov	 rsi, rax
  0053d	b9 10 00 00 00	 mov	 ecx, 16
  00542	f3 a4		 rep movsb
  00544	48 8d 44 24 68	 lea	 rax, QWORD PTR Pattern$18[rsp]
  00549	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR $T21[rsp]
  00551	48 8b f8	 mov	 rdi, rax
  00554	48 8b f1	 mov	 rsi, rcx
  00557	b9 10 00 00 00	 mov	 ecx, 16
  0055c	f3 a4		 rep movsb

; 377  :         else

  0055e	eb 19		 jmp	 SHORT $LN33@ppuTick
$LN32@ppuTick:

; 378  :             Pattern = Prev.Pattern;

  00560	48 8d 44 24 68	 lea	 rax, QWORD PTR Pattern$18[rsp]
  00565	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Prev@@3UprevDraw@@A
  0056c	48 8b f8	 mov	 rdi, rax
  0056f	48 8b f1	 mov	 rsi, rcx
  00572	b9 10 00 00 00	 mov	 ecx, 16
  00577	f3 a4		 rep movsb
$LN33@ppuTick:

; 379  :         
; 380  :         Prev.PatternIndex = PatternIndex;

  00579	0f b6 44 24 20	 movzx	 eax, BYTE PTR PatternIndex$1[rsp]
  0057e	88 05 10 00 00
	00		 mov	 BYTE PTR ?Prev@@3UprevDraw@@A+16, al

; 381  :         Prev.Pattern = Pattern;

  00584	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?Prev@@3UprevDraw@@A
  0058b	48 8d 4c 24 68	 lea	 rcx, QWORD PTR Pattern$18[rsp]
  00590	48 8b f8	 mov	 rdi, rax
  00593	48 8b f1	 mov	 rsi, rcx
  00596	b9 10 00 00 00	 mov	 ecx, 16
  0059b	f3 a4		 rep movsb

; 382  : 
; 383  :         uint8 Attribute;
; 384  :         if((BlockX != Prev.BlockX) || (BlockX != Prev.BlockY))

  0059d	0f b6 44 24 21	 movzx	 eax, BYTE PTR BlockX$2[rsp]
  005a2	0f b6 0d 13 00
	00 00		 movzx	 ecx, BYTE PTR ?Prev@@3UprevDraw@@A+19
  005a9	3b c1		 cmp	 eax, ecx
  005ab	75 10		 jne	 SHORT $LN35@ppuTick
  005ad	0f b6 44 24 21	 movzx	 eax, BYTE PTR BlockX$2[rsp]
  005b2	0f b6 0d 14 00
	00 00		 movzx	 ecx, BYTE PTR ?Prev@@3UprevDraw@@A+20
  005b9	3b c1		 cmp	 eax, ecx
  005bb	74 1c		 je	 SHORT $LN34@ppuTick
$LN35@ppuTick:

; 385  :             Attribute = getAttribute(PpuData, BlockX, BlockY);

  005bd	44 0f b6 44 24
	25		 movzx	 r8d, BYTE PTR BlockY$5[rsp]
  005c3	0f b6 54 24 21	 movzx	 edx, BYTE PTR BlockX$2[rsp]
  005c8	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  005d0	e8 00 00 00 00	 call	 ?getAttribute@@YAEPEAUppu@@EE@Z ; getAttribute
  005d5	88 44 24 3b	 mov	 BYTE PTR Attribute$12[rsp], al
$LN34@ppuTick:

; 386  :   
; 387  :         Prev.BlockX = BlockX;

  005d9	0f b6 44 24 21	 movzx	 eax, BYTE PTR BlockX$2[rsp]
  005de	88 05 13 00 00
	00		 mov	 BYTE PTR ?Prev@@3UprevDraw@@A+19, al

; 388  :         Prev.BlockY = BlockY;

  005e4	0f b6 44 24 25	 movzx	 eax, BYTE PTR BlockY$5[rsp]
  005e9	88 05 14 00 00
	00		 mov	 BYTE PTR ?Prev@@3UprevDraw@@A+20, al

; 389  :     
; 390  :         // NOTE: Each pixel for a pattern has 2 bits for colour. The other 3 bits
; 391  :         //       for colour are stored in the attribute table. Each bit is stored
; 392  :         //       seperately in two seperate groups. This calculation will retrieve the
; 393  :         //       required bit for a specific pixel and combine them to make a 2 bits
; 394  :         uint8 Group1Bit = (Pattern.Group1[TilePixelY] >> (7 - TilePixelX)) & 1;

  005ef	0f b6 44 24 26	 movzx	 eax, BYTE PTR TilePixelY$6[rsp]
  005f4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Pattern$18[rsp]
  005f9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005fd	0f b6 4c 24 27	 movzx	 ecx, BYTE PTR TilePixelX$7[rsp]
  00602	ba 07 00 00 00	 mov	 edx, 7
  00607	2b d1		 sub	 edx, ecx
  00609	8b ca		 mov	 ecx, edx
  0060b	d3 f8		 sar	 eax, cl
  0060d	83 e0 01	 and	 eax, 1
  00610	88 44 24 3a	 mov	 BYTE PTR Group1Bit$11[rsp], al

; 395  :         uint8 Group2Bit = (Pattern.Group2[TilePixelY] >> (7 - TilePixelX)) & 1;

  00614	0f b6 44 24 26	 movzx	 eax, BYTE PTR TilePixelY$6[rsp]
  00619	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Pattern$18[rsp+8]
  0061e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00622	0f b6 4c 24 27	 movzx	 ecx, BYTE PTR TilePixelX$7[rsp]
  00627	ba 07 00 00 00	 mov	 edx, 7
  0062c	2b d1		 sub	 edx, ecx
  0062e	8b ca		 mov	 ecx, edx
  00630	d3 f8		 sar	 eax, cl
  00632	83 e0 01	 and	 eax, 1
  00635	88 44 24 39	 mov	 BYTE PTR Group2Bit$10[rsp], al

; 396  :         uint8 CombinedBits = Group2Bit << 1 | Group1Bit;

  00639	0f b6 44 24 39	 movzx	 eax, BYTE PTR Group2Bit$10[rsp]
  0063e	d1 e0		 shl	 eax, 1
  00640	0f b6 4c 24 3a	 movzx	 ecx, BYTE PTR Group1Bit$11[rsp]
  00645	0b c1		 or	 eax, ecx
  00647	88 44 24 28	 mov	 BYTE PTR CombinedBits$8[rsp], al

; 397  : 
; 398  :         uint8 FullAttribute = (Attribute << 2) & CombinedBits;

  0064b	0f b6 44 24 3b	 movzx	 eax, BYTE PTR Attribute$12[rsp]
  00650	c1 e0 02	 shl	 eax, 2
  00653	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR CombinedBits$8[rsp]
  00658	23 c1		 and	 eax, ecx
  0065a	88 44 24 48	 mov	 BYTE PTR FullAttribute$17[rsp], al

; 399  : 
; 400  :         // TODO: This should fetch the Colour index from the image palette at 0x3F00
; 401  :         uint8 ColourIndex = getColourIndex(CombinedBits, PpuData->MemoryOffset);

  0065e	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  00666	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0066a	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR CombinedBits$8[rsp]
  0066f	e8 00 00 00 00	 call	 ?getColourIndex@@YAEE_K@Z ; getColourIndex
  00674	88 44 24 3c	 mov	 BYTE PTR ColourIndex$13[rsp], al

; 402  : 
; 403  :         getPaletteValue(ColourIndex, &Red, &Green, &Blue);

  00678	4c 8d 4c 24 3d	 lea	 r9, QWORD PTR Blue$14[rsp]
  0067d	4c 8d 44 24 3e	 lea	 r8, QWORD PTR Green$15[rsp]
  00682	48 8d 54 24 3f	 lea	 rdx, QWORD PTR Red$16[rsp]
  00687	0f b6 4c 24 3c	 movzx	 ecx, BYTE PTR ColourIndex$13[rsp]
  0068c	e8 00 00 00 00	 call	 ?getPaletteValue@@YAXEPEAE00@Z ; getPaletteValue

; 404  :         uint32 *CurrentPixel = (PpuData->ZeroPixel + (PpuData->CurrentYPixel * BackBuffer->Width)) + PpuData->CurrentXPixel;

  00691	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  00699	0f b7 40 12	 movzx	 eax, WORD PTR [rax+18]
  0069d	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR BackBuffer$[rsp]
  006a5	0f af 41 38	 imul	 eax, DWORD PTR [rcx+56]
  006a9	48 98		 cdqe
  006ab	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  006b3	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  006b7	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  006bb	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  006c3	0f b7 49 10	 movzx	 ecx, WORD PTR [rcx+16]
  006c7	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  006cb	48 89 44 24 78	 mov	 QWORD PTR CurrentPixel$19[rsp], rax

; 405  :          
; 406  :         *CurrentPixel  = ((Blue << 16) | (Green << 8) | Red);

  006d0	0f b6 44 24 3d	 movzx	 eax, BYTE PTR Blue$14[rsp]
  006d5	c1 e0 10	 shl	 eax, 16
  006d8	0f b6 4c 24 3e	 movzx	 ecx, BYTE PTR Green$15[rsp]
  006dd	c1 e1 08	 shl	 ecx, 8
  006e0	0b c1		 or	 eax, ecx
  006e2	0f b6 4c 24 3f	 movzx	 ecx, BYTE PTR Red$16[rsp]
  006e7	0b c1		 or	 eax, ecx
  006e9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR CurrentPixel$19[rsp]
  006ee	89 01		 mov	 DWORD PTR [rcx], eax

; 407  : 
; 408  :         uint32 *Test = (PpuData->ZeroPixel);

  006f0	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  006f8	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  006fc	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR Test$20[rsp], rax

; 409  :         
; 410  :         
; 411  :         // Advance to the next pixel,
; 412  :         // TODO: Make this a loop that updates once before vblank?
; 413  :         if((PpuData->CurrentXPixel + 1) >= BackBuffer->Width)

  00704	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  0070c	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00710	ff c0		 inc	 eax
  00712	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR BackBuffer$[rsp]
  0071a	3b 41 38	 cmp	 eax, DWORD PTR [rcx+56]
  0071d	7c 28		 jl	 SHORT $LN36@ppuTick

; 414  :             PpuData->CurrentYPixel = (PpuData->CurrentYPixel + 1) % BackBuffer->Height;

  0071f	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  00727	0f b7 40 12	 movzx	 eax, WORD PTR [rax+18]
  0072b	ff c0		 inc	 eax
  0072d	99		 cdq
  0072e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR BackBuffer$[rsp]
  00736	f7 79 3c	 idiv	 DWORD PTR [rcx+60]
  00739	8b c2		 mov	 eax, edx
  0073b	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  00743	66 89 41 12	 mov	 WORD PTR [rcx+18], ax
$LN36@ppuTick:

; 415  :         PpuData->CurrentXPixel = (PpuData->CurrentXPixel + 1) % BackBuffer->Width;

  00747	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  0074f	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00753	ff c0		 inc	 eax
  00755	99		 cdq
  00756	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR BackBuffer$[rsp]
  0075e	f7 79 38	 idiv	 DWORD PTR [rcx+56]
  00761	8b c2		 mov	 eax, edx
  00763	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  0076b	66 89 41 10	 mov	 WORD PTR [rcx+16], ax
  0076f	eb 3d		 jmp	 SHORT $LN28@ppuTick
$LN27@ppuTick:

; 416  :     }
; 417  :     else if(PpuData->ScanLine == 240) // Idle

  00771	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  00779	0f b7 40 2a	 movzx	 eax, WORD PTR [rax+42]
  0077d	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  00782	75 02		 jne	 SHORT $LN37@ppuTick
  00784	eb 28		 jmp	 SHORT $LN38@ppuTick
$LN37@ppuTick:

; 418  :     {
; 419  :         
; 420  :     }
; 421  :     else if(PpuData->ScanLine == 241) // VBlank Start

  00786	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  0078e	0f b7 40 2a	 movzx	 eax, WORD PTR [rax+42]
  00792	3d f1 00 00 00	 cmp	 eax, 241		; 000000f1H
  00797	75 15		 jne	 SHORT $LN39@ppuTick

; 422  :     {
; 423  :         
; 424  :         Registers->Status = Registers->Status | (1 << 7);

  00799	48 8b 44 24 30	 mov	 rax, QWORD PTR Registers$[rsp]
  0079e	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  007a2	0f ba e8 07	 bts	 eax, 7
  007a6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Registers$[rsp]
  007ab	88 41 02	 mov	 BYTE PTR [rcx+2], al
$LN39@ppuTick:
$LN38@ppuTick:
$LN28@ppuTick:
$LN26@ppuTick:

; 425  :         /*if(NmiOnVBlank)
; 426  :             NMICalled = true;
; 427  :         */
; 428  :     }
; 429  :     
; 430  :     
; 431  : 
; 432  :     // 1 pre-render scanline,               0
; 433  :     // 240 scanlines of picture,            1   - 240
; 434  :     // 20 scanlines of VBlank               241 - 261   (70 for PAL)
; 435  :     // and finally, 1 dummy scanline        262         (51 for Dendy)
; 436  :     
; 437  :     ++PpuData->ScanLine;

  007ae	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  007b6	0f b7 40 2a	 movzx	 eax, WORD PTR [rax+42]
  007ba	66 ff c0	 inc	 ax
  007bd	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  007c5	66 89 41 2a	 mov	 WORD PTR [rcx+42], ax

; 438  :     PpuData->ScanLine = PpuData->ScanLine % 262;

  007c9	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  007d1	0f b7 40 2a	 movzx	 eax, WORD PTR [rax+42]
  007d5	99		 cdq
  007d6	b9 06 01 00 00	 mov	 ecx, 262		; 00000106H
  007db	f7 f9		 idiv	 ecx
  007dd	8b c2		 mov	 eax, edx
  007df	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  007e7	66 89 41 2a	 mov	 WORD PTR [rcx+42], ax

; 439  : }

  007eb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  007f3	48 33 cc	 xor	 rcx, rsp
  007f6	e8 00 00 00 00	 call	 __security_check_cookie
  007fb	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00802	5f		 pop	 rdi
  00803	5e		 pop	 rsi
  00804	c3		 ret	 0
?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z ENDP	; ppuTick
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
NameTableAddress$ = 0
Value$ = 8
PpuData$ = 32
TileX$ = 40
TileY$ = 48
?getNametableValue@@YAEPEAUppu@@EE@Z PROC		; getNametableValue

; 179  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 180  :     uint64 NameTableAddress = PpuData->NameTableAddress + PpuData->MemoryOffset;

  00012	48 8b 44 24 20	 mov	 rax, QWORD PTR PpuData$[rsp]
  00017	0f b7 40 20	 movzx	 eax, WORD PTR [rax+32]
  0001b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR PpuData$[rsp]
  00020	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00024	48 89 04 24	 mov	 QWORD PTR NameTableAddress$[rsp], rax

; 181  :     uint8 *Value = (uint8 *)(NameTableAddress + (TileY * TILE_COUNT_X) + TileX);    

  00028	0f b6 44 24 30	 movzx	 eax, BYTE PTR TileY$[rsp]
  0002d	6b c0 20	 imul	 eax, eax, 32		; 00000020H
  00030	48 98		 cdqe
  00032	48 8b 0c 24	 mov	 rcx, QWORD PTR NameTableAddress$[rsp]
  00036	48 03 c8	 add	 rcx, rax
  00039	48 8b c1	 mov	 rax, rcx
  0003c	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR TileX$[rsp]
  00041	48 03 c1	 add	 rax, rcx
  00044	48 89 44 24 08	 mov	 QWORD PTR Value$[rsp], rax

; 182  :     return(*Value);

  00049	48 8b 44 24 08	 mov	 rax, QWORD PTR Value$[rsp]
  0004e	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 183  : }

  00051	48 83 c4 18	 add	 rsp, 24
  00055	c3		 ret	 0
?getNametableValue@@YAEPEAUppu@@EE@Z ENDP		; getNametableValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
PatAddress$ = 0
PatTableAddress$ = 8
Result$ = 16
$T1 = 64
PpuData$ = 72
PatternIndex$ = 80
?getBkgrdPattern@@YA?AUbkgrd_pattern@@PEAUppu@@E@Z PROC	; getBkgrdPattern

; 165  : {   

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 166  :     bkgrd_pattern Result = {};

  00015	48 8d 44 24 10	 lea	 rax, QWORD PTR Result$[rsp]
  0001a	48 8b f8	 mov	 rdi, rax
  0001d	33 c0		 xor	 eax, eax
  0001f	b9 10 00 00 00	 mov	 ecx, 16
  00024	f3 aa		 rep stosb

; 167  :     
; 168  :     uint64 PatTableAddress = PpuData->BkgrdPatAddress + PpuData->MemoryOffset;

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR PpuData$[rsp]
  0002b	0f b7 40 22	 movzx	 eax, WORD PTR [rax+34]
  0002f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR PpuData$[rsp]
  00034	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00038	48 89 44 24 08	 mov	 QWORD PTR PatTableAddress$[rsp], rax

; 169  : 
; 170  :     uint8 *PatAddress = (uint8 *)(PatTableAddress + (PatternIndex * BYTES_PER_PATTERN));

  0003d	0f b6 44 24 50	 movzx	 eax, BYTE PTR PatternIndex$[rsp]
  00042	6b c0 10	 imul	 eax, eax, 16
  00045	48 98		 cdqe
  00047	48 8b 4c 24 08	 mov	 rcx, QWORD PTR PatTableAddress$[rsp]
  0004c	48 03 c8	 add	 rcx, rax
  0004f	48 8b c1	 mov	 rax, rcx
  00052	48 89 04 24	 mov	 QWORD PTR PatAddress$[rsp], rax

; 171  : 
; 172  :     Result.Group1 = PatAddress;

  00056	48 8b 04 24	 mov	 rax, QWORD PTR PatAddress$[rsp]
  0005a	48 89 44 24 10	 mov	 QWORD PTR Result$[rsp], rax

; 173  :     Result.Group2 = PatAddress + (BYTES_PER_PATTERN / 2);

  0005f	48 8b 04 24	 mov	 rax, QWORD PTR PatAddress$[rsp]
  00063	48 83 c0 08	 add	 rax, 8
  00067	48 89 44 24 18	 mov	 QWORD PTR Result$[rsp+8], rax

; 174  :     
; 175  :     return(Result);

  0006c	48 8d 44 24 10	 lea	 rax, QWORD PTR Result$[rsp]
  00071	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  00076	48 8b f0	 mov	 rsi, rax
  00079	b9 10 00 00 00	 mov	 ecx, 16
  0007e	f3 a4		 rep movsb
  00080	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 176  : }

  00085	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00089	5f		 pop	 rdi
  0008a	5e		 pop	 rsi
  0008b	c3		 ret	 0
?getBkgrdPattern@@YA?AUbkgrd_pattern@@PEAUppu@@E@Z ENDP	; getBkgrdPattern
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
Result$ = 0
TileNumY$ = 1
AtrbByte$ = 2
TileNumX$ = 3
Tile4x4Y$ = 4
Tile4x4Width$ = 5
Tile4x4X$ = 6
AttributeAddress$ = 8
Attribute$ = 16
PpuData$ = 48
BlockX$ = 56
BlockY$ = 64
?getAttribute@@YAEPEAUppu@@EE@Z PROC			; getAttribute

; 111  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 112  :     uint8 Result = {};

  00012	c6 04 24 00	 mov	 BYTE PTR Result$[rsp], 0

; 113  :     
; 114  :     uint64 AttributeAddress = PpuData->NameTableAddress + PpuData->MemoryOffset + NAMETABLE_BYTE_COUNT;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR PpuData$[rsp]
  0001b	0f b7 40 20	 movzx	 eax, WORD PTR [rax+32]
  0001f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR PpuData$[rsp]
  00024	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00028	48 8d 84 08 c0
	03 00 00	 lea	 rax, QWORD PTR [rax+rcx+960]
  00030	48 89 44 24 08	 mov	 QWORD PTR AttributeAddress$[rsp], rax

; 115  : 
; 116  :     // NOTE: Attribute data is condensed into one byte per 4x4 tiles.
; 117  :     //       I have the blockX and Y which is a 2x2 Tile, Dividing this by 2 will give 4x4
; 118  :     //       One byte is 0011 2233 where the attribute data is layout as following
; 119  :     //       00 11         Each 2 bits represents a block
; 120  :     //       22 33
; 121  : 
; 122  :     uint8 Tile4x4Width = TILE_COUNT_X / 4;

  00035	c6 44 24 05 08	 mov	 BYTE PTR Tile4x4Width$[rsp], 8

; 123  :     
; 124  :     uint8 Tile4x4X = BlockX / 2;

  0003a	0f b6 44 24 38	 movzx	 eax, BYTE PTR BlockX$[rsp]
  0003f	99		 cdq
  00040	2b c2		 sub	 eax, edx
  00042	d1 f8		 sar	 eax, 1
  00044	88 44 24 06	 mov	 BYTE PTR Tile4x4X$[rsp], al

; 125  :     uint8 Tile4x4Y = BlockY / 2;

  00048	0f b6 44 24 40	 movzx	 eax, BYTE PTR BlockY$[rsp]
  0004d	99		 cdq
  0004e	2b c2		 sub	 eax, edx
  00050	d1 f8		 sar	 eax, 1
  00052	88 44 24 04	 mov	 BYTE PTR Tile4x4Y$[rsp], al

; 126  : 
; 127  :     uint8 *Attribute = (uint8 *)(AttributeAddress + (Tile4x4Y * Tile4x4Width) + Tile4x4X);

  00056	0f b6 44 24 04	 movzx	 eax, BYTE PTR Tile4x4Y$[rsp]
  0005b	0f b6 4c 24 05	 movzx	 ecx, BYTE PTR Tile4x4Width$[rsp]
  00060	0f af c1	 imul	 eax, ecx
  00063	48 98		 cdqe
  00065	48 8b 4c 24 08	 mov	 rcx, QWORD PTR AttributeAddress$[rsp]
  0006a	48 03 c8	 add	 rcx, rax
  0006d	48 8b c1	 mov	 rax, rcx
  00070	0f b6 4c 24 06	 movzx	 ecx, BYTE PTR Tile4x4X$[rsp]
  00075	48 03 c1	 add	 rax, rcx
  00078	48 89 44 24 10	 mov	 QWORD PTR Attribute$[rsp], rax

; 128  :     uint8 AtrbByte = *Attribute;

  0007d	48 8b 44 24 10	 mov	 rax, QWORD PTR Attribute$[rsp]
  00082	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00085	88 44 24 02	 mov	 BYTE PTR AtrbByte$[rsp], al

; 129  : 
; 130  :     uint8 TileNumX = BlockX % 2;

  00089	0f b6 44 24 38	 movzx	 eax, BYTE PTR BlockX$[rsp]
  0008e	99		 cdq
  0008f	83 e0 01	 and	 eax, 1
  00092	33 c2		 xor	 eax, edx
  00094	2b c2		 sub	 eax, edx
  00096	88 44 24 03	 mov	 BYTE PTR TileNumX$[rsp], al

; 131  :     uint8 TileNumY = BlockY % 2;

  0009a	0f b6 44 24 40	 movzx	 eax, BYTE PTR BlockY$[rsp]
  0009f	99		 cdq
  000a0	83 e0 01	 and	 eax, 1
  000a3	33 c2		 xor	 eax, edx
  000a5	2b c2		 sub	 eax, edx
  000a7	88 44 24 01	 mov	 BYTE PTR TileNumY$[rsp], al

; 132  : 
; 133  :     if(TileNumX == 0)

  000ab	0f b6 44 24 03	 movzx	 eax, BYTE PTR TileNumX$[rsp]
  000b0	85 c0		 test	 eax, eax
  000b2	75 33		 jne	 SHORT $LN2@getAttribu

; 134  :     {
; 135  :         if(TileNumY == 0)

  000b4	0f b6 44 24 01	 movzx	 eax, BYTE PTR TileNumY$[rsp]
  000b9	85 c0		 test	 eax, eax
  000bb	75 10		 jne	 SHORT $LN4@getAttribu

; 136  :         {
; 137  :             Result = (AtrbByte << 6) & 3;

  000bd	0f b6 44 24 02	 movzx	 eax, BYTE PTR AtrbByte$[rsp]
  000c2	c1 e0 06	 shl	 eax, 6
  000c5	83 e0 03	 and	 eax, 3
  000c8	88 04 24	 mov	 BYTE PTR Result$[rsp], al
  000cb	eb 18		 jmp	 SHORT $LN5@getAttribu
$LN4@getAttribu:

; 138  :         }
; 139  :         else if(TileNumY == 1)

  000cd	0f b6 44 24 01	 movzx	 eax, BYTE PTR TileNumY$[rsp]
  000d2	83 f8 01	 cmp	 eax, 1
  000d5	75 0e		 jne	 SHORT $LN6@getAttribu

; 140  :         {
; 141  :             Result = (AtrbByte << 2) & 3;

  000d7	0f b6 44 24 02	 movzx	 eax, BYTE PTR AtrbByte$[rsp]
  000dc	c1 e0 02	 shl	 eax, 2
  000df	83 e0 03	 and	 eax, 3
  000e2	88 04 24	 mov	 BYTE PTR Result$[rsp], al
$LN6@getAttribu:
$LN5@getAttribu:

; 142  :         }
; 143  :     }

  000e5	eb 38		 jmp	 SHORT $LN3@getAttribu
$LN2@getAttribu:

; 144  :     else if(TileNumX == 1)

  000e7	0f b6 44 24 03	 movzx	 eax, BYTE PTR TileNumX$[rsp]
  000ec	83 f8 01	 cmp	 eax, 1
  000ef	75 2e		 jne	 SHORT $LN7@getAttribu

; 145  :     {
; 146  :         if(TileNumY == 0)

  000f1	0f b6 44 24 01	 movzx	 eax, BYTE PTR TileNumY$[rsp]
  000f6	85 c0		 test	 eax, eax
  000f8	75 10		 jne	 SHORT $LN8@getAttribu

; 147  :         {
; 148  :             Result = (AtrbByte << 4) & 3;

  000fa	0f b6 44 24 02	 movzx	 eax, BYTE PTR AtrbByte$[rsp]
  000ff	c1 e0 04	 shl	 eax, 4
  00102	83 e0 03	 and	 eax, 3
  00105	88 04 24	 mov	 BYTE PTR Result$[rsp], al
  00108	eb 15		 jmp	 SHORT $LN9@getAttribu
$LN8@getAttribu:

; 149  :         }
; 150  :         else if(TileNumY == 1)

  0010a	0f b6 44 24 01	 movzx	 eax, BYTE PTR TileNumY$[rsp]
  0010f	83 f8 01	 cmp	 eax, 1
  00112	75 0b		 jne	 SHORT $LN10@getAttribu

; 151  :         {
; 152  :             Result = AtrbByte & 3;

  00114	0f b6 44 24 02	 movzx	 eax, BYTE PTR AtrbByte$[rsp]
  00119	83 e0 03	 and	 eax, 3
  0011c	88 04 24	 mov	 BYTE PTR Result$[rsp], al
$LN10@getAttribu:
$LN9@getAttribu:
$LN7@getAttribu:
$LN3@getAttribu:

; 153  :         }
; 154  :     }
; 155  :     return(Result);

  0011f	0f b6 04 24	 movzx	 eax, BYTE PTR Result$[rsp]

; 156  : }

  00123	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00127	c3		 ret	 0
?getAttribute@@YAEPEAUppu@@EE@Z ENDP			; getAttribute
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
Result$ = 0
ColourPaletteAddress$ = 8
CombinedBits$ = 32
MemoryOffset$ = 40
?getColourIndex@@YAEE_K@Z PROC				; getColourIndex

; 102  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00009	48 83 ec 18	 sub	 rsp, 24

; 103  :     uint8 Result = {};

  0000d	c6 04 24 00	 mov	 BYTE PTR Result$[rsp], 0

; 104  :     #define PALETTE_ADDRESS 0x3F00
; 105  :     uint8 *ColourPaletteAddress =  (uint8 *)((uint64)(PALETTE_ADDRESS + CombinedBits) + MemoryOffset);

  00011	0f b6 44 24 20	 movzx	 eax, BYTE PTR CombinedBits$[rsp]
  00016	05 00 3f 00 00	 add	 eax, 16128		; 00003f00H
  0001b	48 98		 cdqe
  0001d	48 03 44 24 28	 add	 rax, QWORD PTR MemoryOffset$[rsp]
  00022	48 89 44 24 08	 mov	 QWORD PTR ColourPaletteAddress$[rsp], rax

; 106  :     Result = *ColourPaletteAddress;

  00027	48 8b 44 24 08	 mov	 rax, QWORD PTR ColourPaletteAddress$[rsp]
  0002c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002f	88 04 24	 mov	 BYTE PTR Result$[rsp], al

; 107  :     return(Result);

  00032	0f b6 04 24	 movzx	 eax, BYTE PTR Result$[rsp]

; 108  : }

  00036	48 83 c4 18	 add	 rsp, 24
  0003a	c3		 ret	 0
?getColourIndex@@YAEE_K@Z ENDP				; getColourIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
Byte$ = 48
Address$ = 56
MemoryOffset$ = 64
?writePpuMemory8@@YAXEG_K@Z PROC			; writePpuMemory8

; 68   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 69   :     if(0x4000 <= Address)

  00012	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00017	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  0001c	7c 1a		 jl	 SHORT $LN2@writePpuMe

; 70   :         Address = (Address % 0x4000);

  0001e	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00023	99		 cdq
  00024	81 e2 ff 3f 00
	00		 and	 edx, 16383		; 00003fffH
  0002a	03 c2		 add	 eax, edx
  0002c	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  00031	2b c2		 sub	 eax, edx
  00033	66 89 44 24 38	 mov	 WORD PTR Address$[rsp], ax
$LN2@writePpuMe:

; 71   : 
; 72   : #if 0
; 73   :     char TextBuffer[256];
; 74   :     _snprintf(TextBuffer, 256, "0x%X: %X\n", Address, Byte);
; 75   :     OutputDebugString(TextBuffer);
; 76   : #endif
; 77   :     writeMemory8(Byte, Address, MemoryOffset);

  00038	4c 8b 44 24 40	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  0003d	0f b7 54 24 38	 movzx	 edx, WORD PTR Address$[rsp]
  00042	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR Byte$[rsp]
  00047	e8 00 00 00 00	 call	 ?writeMemory8@@YAXEG_K@Z ; writeMemory8

; 78   : }

  0004c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00050	c3		 ret	 0
?writePpuMemory8@@YAXEG_K@Z ENDP			; writePpuMemory8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\palette.cpp
_TEXT	SEGMENT
Entry$ = 8
Red$ = 16
Green$ = 24
Blue$ = 32
?getPaletteValue@@YAXEPEAE00@Z PROC			; getPaletteValue

; 31   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 32   :     *Red   = Palette[Entry][0];

  00013	0f b6 44 24 08	 movzx	 eax, BYTE PTR Entry$[rsp]
  00018	48 6b c0 03	 imul	 rax, rax, 3
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Palette@@3PAY02EA ; Palette
  00023	48 03 c8	 add	 rcx, rax
  00026	48 8b c1	 mov	 rax, rcx
  00029	b9 01 00 00 00	 mov	 ecx, 1
  0002e	48 6b c9 00	 imul	 rcx, rcx, 0
  00032	48 8b 54 24 10	 mov	 rdx, QWORD PTR Red$[rsp]
  00037	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0003b	88 02		 mov	 BYTE PTR [rdx], al

; 33   :     *Green = Palette[Entry][1];

  0003d	0f b6 44 24 08	 movzx	 eax, BYTE PTR Entry$[rsp]
  00042	48 6b c0 03	 imul	 rax, rax, 3
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Palette@@3PAY02EA ; Palette
  0004d	48 03 c8	 add	 rcx, rax
  00050	48 8b c1	 mov	 rax, rcx
  00053	b9 01 00 00 00	 mov	 ecx, 1
  00058	48 6b c9 01	 imul	 rcx, rcx, 1
  0005c	48 8b 54 24 18	 mov	 rdx, QWORD PTR Green$[rsp]
  00061	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00065	88 02		 mov	 BYTE PTR [rdx], al

; 34   :     *Blue  = Palette[Entry][2];

  00067	0f b6 44 24 08	 movzx	 eax, BYTE PTR Entry$[rsp]
  0006c	48 6b c0 03	 imul	 rax, rax, 3
  00070	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Palette@@3PAY02EA ; Palette
  00077	48 03 c8	 add	 rcx, rax
  0007a	48 8b c1	 mov	 rax, rcx
  0007d	b9 01 00 00 00	 mov	 ecx, 1
  00082	48 6b c9 02	 imul	 rcx, rcx, 2
  00086	48 8b 54 24 20	 mov	 rdx, QWORD PTR Blue$[rsp]
  0008b	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0008f	88 02		 mov	 BYTE PTR [rdx], al

; 35   : }

  00091	c3		 ret	 0
?getPaletteValue@@YAXEPEAE00@Z ENDP			; getPaletteValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Element$1 = 32
Address$2 = 40
StackBuffer$3 = 48
__$ArrayPad$ = 560
StackPointer$ = 592
MemoryOffset$ = 600
?debugPrintStack@@YAXE_K@Z PROC				; debugPrintStack

; 1468 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00009	48 81 ec 48 02
	00 00		 sub	 rsp, 584		; 00000248H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 30
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1469 :     for(uint8 Element = StackPointer; Element != 0; Element++)

  00022	0f b6 84 24 50
	02 00 00	 movzx	 eax, BYTE PTR StackPointer$[rsp]
  0002a	88 44 24 20	 mov	 BYTE PTR Element$1[rsp], al
  0002e	eb 0b		 jmp	 SHORT $LN4@debugPrint
$LN2@debugPrint:
  00030	0f b6 44 24 20	 movzx	 eax, BYTE PTR Element$1[rsp]
  00035	fe c0		 inc	 al
  00037	88 44 24 20	 mov	 BYTE PTR Element$1[rsp], al
$LN4@debugPrint:
  0003b	0f b6 44 24 20	 movzx	 eax, BYTE PTR Element$1[rsp]
  00040	85 c0		 test	 eax, eax
  00042	74 4a		 je	 SHORT $LN3@debugPrint

; 1470 :     {
; 1471 :         uint8 *Address = (uint8 *)((Element + STACK_ADRS) + MemoryOffset);

  00044	0f b6 44 24 20	 movzx	 eax, BYTE PTR Element$1[rsp]
  00049	05 00 01 00 00	 add	 eax, 256		; 00000100H
  0004e	48 98		 cdqe
  00050	48 03 84 24 58
	02 00 00	 add	 rax, QWORD PTR MemoryOffset$[rsp]
  00058	48 89 44 24 28	 mov	 QWORD PTR Address$2[rsp], rax

; 1472 :         char StackBuffer[512];
; 1473 :         sprintf(StackBuffer, "%X: %X, ", (uint8)Element, *Address);

  0005d	48 8b 44 24 28	 mov	 rax, QWORD PTR Address$2[rsp]
  00062	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00065	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Element$1[rsp]
  0006a	44 8b c8	 mov	 r9d, eax
  0006d	44 8b c1	 mov	 r8d, ecx
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG88278
  00077	48 8d 4c 24 30	 lea	 rcx, QWORD PTR StackBuffer$3[rsp]
  0007c	e8 00 00 00 00	 call	 sprintf

; 1474 :         OutputDebugString(StackBuffer);

  00081	48 8d 4c 24 30	 lea	 rcx, QWORD PTR StackBuffer$3[rsp]
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 1475 :     }

  0008c	eb a2		 jmp	 SHORT $LN2@debugPrint
$LN3@debugPrint:

; 1476 :     OutputDebugString("\n");

  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG88279
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 1477 : }

  0009b	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a3	48 33 cc	 xor	 rcx, rsp
  000a6	e8 00 00 00 00	 call	 __security_check_cookie
  000ab	48 81 c4 48 02
	00 00		 add	 rsp, 584		; 00000248H
  000b2	c3		 ret	 0
?debugPrintStack@@YAXE_K@Z ENDP				; debugPrintStack
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
CurrentInstr$ = 112
BytesRead$ = 113
Registers$ = 120
Value$1 = 128
Value$2 = 129
Value$3 = 130
MemoryOffset$ = 136
Address$4 = 144
Value$5 = 148
Value$6 = 149
Value$7 = 150
StatusFlag$8 = 151
Value$9 = 152
Value$10 = 153
CyclesElapsed$ = 160
Value$11 = 168
Value$12 = 169
Value$13 = 170
Value$14 = 171
Value$15 = 172
RegisterValue$16 = 173
Address$17 = 174
Value$18 = 175
ToCompareAgainst$19 = 176
Value$20 = 177
Value$21 = 178
Value$22 = 179
IndirectAddress$23 = 180
LowByte$24 = 184
HighByte$25 = 185
LowByte$26 = 186
RelAddress$27 = 187
ZeroAddress$28 = 188
ZeroAddress$29 = 189
Address$30 = 190
MissingValue$31 = 191
HighByte$32 = 192
LowByte$33 = 193
NewAddress$34 = 196
NewAddress$35 = 200
Address$36 = 204
HighBytes$37 = 208
LowBytes$38 = 209
HighByte$39 = 210
Address$40 = 212
Address$41 = 216
PrevAdrs$42 = 220
Address$43 = 224
tv367 = 228
tv539 = 232
tv938 = 236
tv1205 = 240
NewAddress$44 = 244
IndirectAddress$45 = 248
tv1274 = 252
Break$46 = 256
Register$47 = 264
tv78 = 272
CarryIsSet$48 = 276
CarryIsSet$49 = 280
CarryIsSet$50 = 284
CarryIsSet$51 = 288
tv1322 = 292
WantedDebugLine$ = 296
$T52 = 304
Buffer$53 = 328
LogBuffer$ = 336
__$ArrayPad$ = 848
CpuData$ = 912
?cpuTick@@YAXPEAUcpu@@@Z PROC				; cpuTick

; 389  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	48 81 ec 68 03
	00 00		 sub	 rsp, 872		; 00000368H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 50
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 390  :     cpuRegisters *Registers = &CpuData->Registers;

  00022	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR CpuData$[rsp]
  0002a	48 89 44 24 78	 mov	 QWORD PTR Registers$[rsp], rax

; 391  :     uint8 *CyclesElapsed = &CpuData->LastTickCycles;

  0002f	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR CpuData$[rsp]
  00037	48 83 c0 10	 add	 rax, 16
  0003b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR CyclesElapsed$[rsp], rax

; 392  :     uint64 MemoryOffset = CpuData->MemoryOffset; 

  00043	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR CpuData$[rsp]
  0004b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR MemoryOffset$[rsp], rax

; 393  :     
; 394  :     Log = {};

  00057	48 8d 84 24 30
	01 00 00	 lea	 rax, QWORD PTR $T52[rsp]
  0005f	48 8b f8	 mov	 rdi, rax
  00062	33 c0		 xor	 eax, eax
  00064	b9 18 00 00 00	 mov	 ecx, 24
  00069	f3 aa		 rep stosb
  0006b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?Log@@3UcpuLog@@A
  00072	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR $T52[rsp]
  0007a	48 8b f8	 mov	 rdi, rax
  0007d	48 8b f1	 mov	 rsi, rcx
  00080	b9 18 00 00 00	 mov	 ecx, 24
  00085	f3 a4		 rep movsb

; 395  :     Log.ProgramLine = Registers->PrgCounter;   

  00087	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0008c	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00090	66 89 05 00 00
	00 00		 mov	 WORD PTR ?Log@@3UcpuLog@@A, ax

; 396  :     
; 397  :     uint8 BytesRead = 0;

  00097	c6 44 24 71 00	 mov	 BYTE PTR BytesRead$[rsp], 0

; 398  :     
; 399  :     uint8 CurrentInstr = readMemory8(Registers->PrgCounter, MemoryOffset);                

  0009c	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  000a4	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  000a9	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  000ad	e8 00 00 00 00	 call	 ?readMemory8@@YAEG_K@Z	; readMemory8
  000b2	88 44 24 70	 mov	 BYTE PTR CurrentInstr$[rsp], al

; 400  :     Log.Instr = CurrentInstr;

  000b6	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  000bb	88 05 02 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+2, al

; 401  : 
; 402  :     static uint64 linecount = 0;
; 403  :     uint64 WantedDebugLine = 330;

  000c1	48 c7 84 24 28
	01 00 00 4a 01
	00 00		 mov	 QWORD PTR WantedDebugLine$[rsp], 330 ; 0000014aH

; 404  :     if(linecount == WantedDebugLine)

  000cd	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR WantedDebugLine$[rsp]
  000d5	48 39 05 00 00
	00 00		 cmp	 QWORD PTR ?linecount@?1??cpuTick@@YAXPEAUcpu@@@Z@4_KA, rax
  000dc	75 08		 jne	 SHORT $LN14@cpuTick

; 405  :         uint8 Break = 1;

  000de	c6 84 24 00 01
	00 00 01	 mov	 BYTE PTR Break$46[rsp], 1
$LN14@cpuTick:

; 406  :     
; 407  :     switch(CurrentInstr)

  000e6	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  000eb	89 84 24 10 01
	00 00		 mov	 DWORD PTR tv78[rsp], eax
  000f2	81 bc 24 10 01
	00 00 f1 00 00
	00		 cmp	 DWORD PTR tv78[rsp], 241 ; 000000f1H
  000fd	0f 87 07 25 00
	00		 ja	 $LN179@cpuTick
  00103	48 63 84 24 10
	01 00 00	 movsxd	 rax, DWORD PTR tv78[rsp]
  0010b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00112	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN200@cpuTick[rcx+rax]
  0011a	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN201@cpuTick[rcx+rax*4]
  00121	48 03 c1	 add	 rax, rcx
  00124	ff e0		 jmp	 rax
$LN15@cpuTick:

; 408  :     {
; 409  :         case 0x00: // BRK - Break
; 410  :         {
; 411  :             Registers->PrgCounter += 2;

  00126	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0012b	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0012f	83 c0 02	 add	 eax, 2
  00132	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  00137	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 412  :             uint8 HighByte = (uint8)(Registers->PrgCounter >> 8);

  0013b	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00140	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00144	c1 f8 08	 sar	 eax, 8
  00147	88 84 24 c0 00
	00 00		 mov	 BYTE PTR HighByte$32[rsp], al

; 413  :             uint8 LowByte = (uint8)Registers->PrgCounter;

  0014e	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00153	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  00157	88 84 24 c1 00
	00 00		 mov	 BYTE PTR LowByte$33[rsp], al

; 414  : 
; 415  :             pushStack(HighByte, &Registers->StackPtr, MemoryOffset);

  0015e	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00163	48 83 c0 04	 add	 rax, 4
  00167	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  0016f	48 8b d0	 mov	 rdx, rax
  00172	0f b6 8c 24 c0
	00 00 00	 movzx	 ecx, BYTE PTR HighByte$32[rsp]
  0017a	e8 00 00 00 00	 call	 ?pushStack@@YAXEPEAE_K@Z ; pushStack

; 416  :             pushStack(LowByte, &Registers->StackPtr, MemoryOffset);

  0017f	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00184	48 83 c0 04	 add	 rax, 4
  00188	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  00190	48 8b d0	 mov	 rdx, rax
  00193	0f b6 8c 24 c1
	00 00 00	 movzx	 ecx, BYTE PTR LowByte$33[rsp]
  0019b	e8 00 00 00 00	 call	 ?pushStack@@YAXEPEAE_K@Z ; pushStack

; 417  : 
; 418  :             setBreak(&Registers->Flags);

  001a0	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  001a5	48 83 c0 03	 add	 rax, 3
  001a9	48 8b c8	 mov	 rcx, rax
  001ac	e8 00 00 00 00	 call	 ?setBreak@@YAXPEAE@Z	; setBreak

; 419  :             setInterrupt(&Registers->Flags);

  001b1	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  001b6	48 83 c0 03	 add	 rax, 3
  001ba	48 8b c8	 mov	 rcx, rax
  001bd	e8 00 00 00 00	 call	 ?setInterrupt@@YAXPEAE@Z ; setInterrupt

; 420  :             pushStack(Registers->Flags, &Registers->StackPtr, MemoryOffset);

  001c2	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  001c7	48 83 c0 04	 add	 rax, 4
  001cb	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  001d3	48 8b d0	 mov	 rdx, rax
  001d6	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  001db	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  001df	e8 00 00 00 00	 call	 ?pushStack@@YAXEPEAE_K@Z ; pushStack

; 421  :             
; 422  :             Registers->PrgCounter = readCpuMemory16(IRQ_BRK_VEC, MemoryOffset);

  001e4	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  001ec	66 b9 fe ff	 mov	 cx, 65534		; 0000fffeH
  001f0	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  001f5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  001fa	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 423  :            
; 424  :             BytesRead = 0; // TODO: Check this

  001fe	c6 44 24 71 00	 mov	 BYTE PTR BytesRead$[rsp], 0

; 425  :             *CyclesElapsed = 7;

  00203	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  0020b	c6 00 07	 mov	 BYTE PTR [rax], 7

; 426  : 
; 427  :             Log.InstrValue1 = (uint8) Registers->PrgCounter;

  0020e	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00213	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  00217	88 05 03 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+3, al

; 428  :             Log.InstrValue2 = (uint8) (Registers->PrgCounter >> 8);

  0021d	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00222	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00226	c1 f8 08	 sar	 eax, 8
  00229	88 05 04 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+4, al

; 429  :             Log.InstrName = "BRK";

  0022f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88041
  00236	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 430  :             Log.InstrAddress = Registers->PrgCounter;

  0023d	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00242	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00246	66 89 05 10 00
	00 00		 mov	 WORD PTR ?Log@@3UcpuLog@@A+16, ax

; 431  :             Log.BytesRead = 3;

  0024d	c6 05 13 00 00
	00 03		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+19, 3

; 432  :             break;

  00254	e9 fc 23 00 00	 jmp	 $LN2@cpuTick
$LN16@cpuTick:

; 433  :         }
; 434  :         case 0x40: // RTI - Return from Interrupt
; 435  :         {
; 436  :             Registers->Flags = popStack(&Registers->StackPtr, MemoryOffset);

  00259	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0025e	48 83 c0 04	 add	 rax, 4
  00262	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0026a	48 8b c8	 mov	 rcx, rax
  0026d	e8 00 00 00 00	 call	 ?popStack@@YAEPEAE_K@Z	; popStack
  00272	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  00277	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 437  :             clearInterrupt(&Registers->Flags);

  0027a	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0027f	48 83 c0 03	 add	 rax, 3
  00283	48 8b c8	 mov	 rcx, rax
  00286	e8 00 00 00 00	 call	 ?clearInterrupt@@YAXPEAE@Z ; clearInterrupt

; 438  :             
; 439  :             uint8 LowBytes = popStack(&Registers->StackPtr, MemoryOffset);

  0028b	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00290	48 83 c0 04	 add	 rax, 4
  00294	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0029c	48 8b c8	 mov	 rcx, rax
  0029f	e8 00 00 00 00	 call	 ?popStack@@YAEPEAE_K@Z	; popStack
  002a4	88 84 24 d1 00
	00 00		 mov	 BYTE PTR LowBytes$38[rsp], al

; 440  :             uint8 HighBytes = popStack(&Registers->StackPtr, MemoryOffset);

  002ab	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  002b0	48 83 c0 04	 add	 rax, 4
  002b4	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  002bc	48 8b c8	 mov	 rcx, rax
  002bf	e8 00 00 00 00	 call	 ?popStack@@YAEPEAE_K@Z	; popStack
  002c4	88 84 24 d0 00
	00 00		 mov	 BYTE PTR HighBytes$37[rsp], al

; 441  :             Registers->PrgCounter = (HighBytes << 8) | LowBytes;

  002cb	0f b6 84 24 d0
	00 00 00	 movzx	 eax, BYTE PTR HighBytes$37[rsp]
  002d3	c1 e0 08	 shl	 eax, 8
  002d6	0f b6 8c 24 d1
	00 00 00	 movzx	 ecx, BYTE PTR LowBytes$38[rsp]
  002de	0b c1		 or	 eax, ecx
  002e0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  002e5	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 442  :             
; 443  :             BytesRead = 0;

  002e9	c6 44 24 71 00	 mov	 BYTE PTR BytesRead$[rsp], 0

; 444  :             *CyclesElapsed = 6;

  002ee	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  002f6	c6 00 06	 mov	 BYTE PTR [rax], 6

; 445  : 
; 446  :             Log.BytesRead = 1;

  002f9	c6 05 13 00 00
	00 01		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+19, 1

; 447  :             Log.InstrName = "RTI";

  00300	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88043
  00307	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 448  :             break;

  0030e	e9 42 23 00 00	 jmp	 $LN2@cpuTick
$LN17@cpuTick:

; 449  :         }               
; 450  :                     
; 451  :         case 0x20: // JSR - Jump to subroutine
; 452  :         {
; 453  :             uint16 NewAddress = readCpuMemory16(Registers->PrgCounter + 1, MemoryOffset);

  00313	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00318	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0031c	ff c0		 inc	 eax
  0031e	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00326	0f b7 c8	 movzx	 ecx, ax
  00329	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  0032e	66 89 84 24 c4
	00 00 00	 mov	 WORD PTR NewAddress$34[rsp], ax

; 454  :                         
; 455  :             uint16 PrevAdrs = Registers->PrgCounter + 2; // Push the next opcode onto the stack                            

  00336	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0033b	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0033f	83 c0 02	 add	 eax, 2
  00342	66 89 84 24 dc
	00 00 00	 mov	 WORD PTR PrevAdrs$42[rsp], ax

; 456  :             uint8 HighByte = (uint8)(PrevAdrs >> 8);

  0034a	0f b7 84 24 dc
	00 00 00	 movzx	 eax, WORD PTR PrevAdrs$42[rsp]
  00352	c1 f8 08	 sar	 eax, 8
  00355	88 84 24 d2 00
	00 00		 mov	 BYTE PTR HighByte$39[rsp], al

; 457  :             uint8 LowByte = (uint8)PrevAdrs;

  0035c	0f b6 84 24 dc
	00 00 00	 movzx	 eax, BYTE PTR PrevAdrs$42[rsp]
  00364	88 84 24 b8 00
	00 00		 mov	 BYTE PTR LowByte$24[rsp], al

; 458  :       
; 459  :             // Push onto stack, little endian
; 460  :             pushStack(HighByte, &Registers->StackPtr, MemoryOffset);

  0036b	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00370	48 83 c0 04	 add	 rax, 4
  00374	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  0037c	48 8b d0	 mov	 rdx, rax
  0037f	0f b6 8c 24 d2
	00 00 00	 movzx	 ecx, BYTE PTR HighByte$39[rsp]
  00387	e8 00 00 00 00	 call	 ?pushStack@@YAXEPEAE_K@Z ; pushStack

; 461  :             pushStack(LowByte, &Registers->StackPtr, MemoryOffset);

  0038c	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00391	48 83 c0 04	 add	 rax, 4
  00395	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  0039d	48 8b d0	 mov	 rdx, rax
  003a0	0f b6 8c 24 b8
	00 00 00	 movzx	 ecx, BYTE PTR LowByte$24[rsp]
  003a8	e8 00 00 00 00	 call	 ?pushStack@@YAXEPEAE_K@Z ; pushStack

; 462  : 
; 463  :             Registers->PrgCounter = NewAddress;

  003ad	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  003b2	0f b7 8c 24 c4
	00 00 00	 movzx	 ecx, WORD PTR NewAddress$34[rsp]
  003ba	66 89 48 06	 mov	 WORD PTR [rax+6], cx

; 464  :             BytesRead = 0; // Moved to the next instruction already

  003be	c6 44 24 71 00	 mov	 BYTE PTR BytesRead$[rsp], 0

; 465  :             *CyclesElapsed = 6;

  003c3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  003cb	c6 00 06	 mov	 BYTE PTR [rax], 6

; 466  : 
; 467  :             
; 468  :             Log.InstrValue1 = (uint8) NewAddress;

  003ce	0f b6 84 24 c4
	00 00 00	 movzx	 eax, BYTE PTR NewAddress$34[rsp]
  003d6	88 05 03 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+3, al

; 469  :             Log.InstrValue2 = (uint8) (NewAddress >> 8);

  003dc	0f b7 84 24 c4
	00 00 00	 movzx	 eax, WORD PTR NewAddress$34[rsp]
  003e4	c1 f8 08	 sar	 eax, 8
  003e7	88 05 04 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+4, al

; 470  :             Log.InstrAddress = Registers->PrgCounter;

  003ed	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  003f2	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  003f6	66 89 05 10 00
	00 00		 mov	 WORD PTR ?Log@@3UcpuLog@@A+16, ax

; 471  :             Log.BytesRead = 3;

  003fd	c6 05 13 00 00
	00 03		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+19, 3

; 472  :             Log.InstrName = "JSR";

  00404	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88045
  0040b	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 473  :             break;

  00412	e9 3e 22 00 00	 jmp	 $LN2@cpuTick
$LN18@cpuTick:

; 474  :         }
; 475  :         case 0x60: // RTS - Return from subroutine
; 476  :         {
; 477  :             uint8 LowByte = popStack(&Registers->StackPtr, MemoryOffset);

  00417	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0041c	48 83 c0 04	 add	 rax, 4
  00420	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00428	48 8b c8	 mov	 rcx, rax
  0042b	e8 00 00 00 00	 call	 ?popStack@@YAEPEAE_K@Z	; popStack
  00430	88 84 24 ba 00
	00 00		 mov	 BYTE PTR LowByte$26[rsp], al

; 478  :             uint8 HighByte = popStack(&Registers->StackPtr, MemoryOffset);

  00437	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0043c	48 83 c0 04	 add	 rax, 4
  00440	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00448	48 8b c8	 mov	 rcx, rax
  0044b	e8 00 00 00 00	 call	 ?popStack@@YAEPEAE_K@Z	; popStack
  00450	88 84 24 b9 00
	00 00		 mov	 BYTE PTR HighByte$25[rsp], al

; 479  :             Registers->PrgCounter = ((uint16)HighByte << 8) | (uint16)LowByte;

  00457	0f b6 84 24 b9
	00 00 00	 movzx	 eax, BYTE PTR HighByte$25[rsp]
  0045f	c1 e0 08	 shl	 eax, 8
  00462	0f b6 8c 24 ba
	00 00 00	 movzx	 ecx, BYTE PTR LowByte$26[rsp]
  0046a	0b c1		 or	 eax, ecx
  0046c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  00471	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 480  :             
; 481  :             BytesRead = 1;

  00475	c6 44 24 71 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 482  :             *CyclesElapsed = 6;

  0047a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00482	c6 00 06	 mov	 BYTE PTR [rax], 6

; 483  :             
; 484  :             Log.InstrName = "RTS";

  00485	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88047
  0048c	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 485  :             break;

  00493	e9 bd 21 00 00	 jmp	 $LN2@cpuTick
$LN19@cpuTick:

; 486  :         }
; 487  :                     
; 488  :         case 0x4C: // JMP(Absolute) - Jump
; 489  :         {
; 490  :             uint16 NewAddress = readCpuMemory16(Registers->PrgCounter + 1, MemoryOffset);

  00498	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0049d	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  004a1	ff c0		 inc	 eax
  004a3	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  004ab	0f b7 c8	 movzx	 ecx, ax
  004ae	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  004b3	66 89 84 24 c8
	00 00 00	 mov	 WORD PTR NewAddress$35[rsp], ax

; 491  :             Registers->PrgCounter = NewAddress;

  004bb	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  004c0	0f b7 8c 24 c8
	00 00 00	 movzx	 ecx, WORD PTR NewAddress$35[rsp]
  004c8	66 89 48 06	 mov	 WORD PTR [rax+6], cx

; 492  :             BytesRead = 0;

  004cc	c6 44 24 71 00	 mov	 BYTE PTR BytesRead$[rsp], 0

; 493  :             *CyclesElapsed = 3;

  004d1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  004d9	c6 00 03	 mov	 BYTE PTR [rax], 3

; 494  : 
; 495  :             Log.InstrValue1 = (uint8) NewAddress;

  004dc	0f b6 84 24 c8
	00 00 00	 movzx	 eax, BYTE PTR NewAddress$35[rsp]
  004e4	88 05 03 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+3, al

; 496  :             Log.InstrValue2 = (uint8) (NewAddress >> 8);

  004ea	0f b7 84 24 c8
	00 00 00	 movzx	 eax, WORD PTR NewAddress$35[rsp]
  004f2	c1 f8 08	 sar	 eax, 8
  004f5	88 05 04 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+4, al

; 497  :             Log.InstrAddress = Registers->PrgCounter;

  004fb	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00500	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00504	66 89 05 10 00
	00 00		 mov	 WORD PTR ?Log@@3UcpuLog@@A+16, ax

; 498  :             Log.BytesRead = 3;

  0050b	c6 05 13 00 00
	00 03		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+19, 3

; 499  :             Log.InstrName = "JMP";

  00512	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88049
  00519	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 500  :             break;

  00520	e9 30 21 00 00	 jmp	 $LN2@cpuTick
$LN20@cpuTick:

; 501  :         }
; 502  :         case 0x6C: // JMP(Indirect)
; 503  :         {
; 504  :             uint16 IndirectAddress = readCpuMemory16(Registers->PrgCounter + 1, MemoryOffset);

  00525	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0052a	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0052e	ff c0		 inc	 eax
  00530	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00538	0f b7 c8	 movzx	 ecx, ax
  0053b	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  00540	66 89 84 24 b4
	00 00 00	 mov	 WORD PTR IndirectAddress$23[rsp], ax

; 505  :             if((IndirectAddress & 0x00FF) == 0xFF)

  00548	0f b7 84 24 b4
	00 00 00	 movzx	 eax, WORD PTR IndirectAddress$23[rsp]
  00550	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00555	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0055a	75 12		 jne	 SHORT $LN21@cpuTick

; 506  :                 Assert(0); // TODO: If this ever hits then was on boundary of page. Fix how nes does this

  0055c	33 c0		 xor	 eax, eax
  0055e	83 f8 01	 cmp	 eax, 1
  00561	74 0b		 je	 SHORT $LN22@cpuTick
  00563	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN22@cpuTick:
$LN21@cpuTick:

; 507  :             uint16 NewAddress = readCpuMemory16(IndirectAddress, MemoryOffset);

  0056e	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00576	0f b7 8c 24 b4
	00 00 00	 movzx	 ecx, WORD PTR IndirectAddress$23[rsp]
  0057e	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  00583	66 89 84 24 f4
	00 00 00	 mov	 WORD PTR NewAddress$44[rsp], ax

; 508  :             
; 509  :             Registers->PrgCounter = NewAddress;

  0058b	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00590	0f b7 8c 24 f4
	00 00 00	 movzx	 ecx, WORD PTR NewAddress$44[rsp]
  00598	66 89 48 06	 mov	 WORD PTR [rax+6], cx

; 510  :             
; 511  :             BytesRead = 0;

  0059c	c6 44 24 71 00	 mov	 BYTE PTR BytesRead$[rsp], 0

; 512  :             *CyclesElapsed = 5;

  005a1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  005a9	c6 00 05	 mov	 BYTE PTR [rax], 5

; 513  :             
; 514  :             Log.InstrValue1 = (uint8) IndirectAddress;

  005ac	0f b6 84 24 b4
	00 00 00	 movzx	 eax, BYTE PTR IndirectAddress$23[rsp]
  005b4	88 05 03 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+3, al

; 515  :             Log.InstrValue2 = (uint8) (IndirectAddress >> 8);

  005ba	0f b7 84 24 b4
	00 00 00	 movzx	 eax, WORD PTR IndirectAddress$23[rsp]
  005c2	c1 f8 08	 sar	 eax, 8
  005c5	88 05 04 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+4, al

; 516  :             Log.InstrAddress = Registers->PrgCounter;

  005cb	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  005d0	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  005d4	66 89 05 10 00
	00 00		 mov	 WORD PTR ?Log@@3UcpuLog@@A+16, ax

; 517  :             Log.BytesRead = 3;

  005db	c6 05 13 00 00
	00 03		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+19, 3

; 518  :             Log.InstrName = "JMP";

  005e2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88053
  005e9	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 519  :             break;

  005f0	e9 60 20 00 00	 jmp	 $LN2@cpuTick
$LN23@cpuTick:

; 520  :         }
; 521  :         
; 522  :         // Branch Instructions 
; 523  :         case 0x10: case 0x30: case 0x50: case 0x70: case 0x90: case 0xB0: case 0xD0: case 0xF0:
; 524  :         {
; 525  :             BytesRead = 2;

  005f5	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 526  :             *CyclesElapsed = 2;

  005fa	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00602	c6 00 02	 mov	 BYTE PTR [rax], 2

; 527  : 
; 528  :             uint8 StatusFlag = Registers->Flags;

  00605	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0060a	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0060e	88 84 24 97 00
	00 00		 mov	 BYTE PTR StatusFlag$8[rsp], al

; 529  :             
; 530  :             if( (CurrentInstr == 0x10 && !isBitSet(NEGATIVE_BIT, StatusFlag)) || // BPL - Negative is clear
; 531  :                 (CurrentInstr == 0x30 &&  isBitSet(NEGATIVE_BIT, StatusFlag)) || // BMI - Negative is set
; 532  :                 (CurrentInstr == 0x50 && !isBitSet(OVERFLOW_BIT, StatusFlag)) || // BVC - Overflow is clear
; 533  :                 (CurrentInstr == 0x70 &&  isBitSet(OVERFLOW_BIT, StatusFlag)) || // BVS - Overflow is set
; 534  :                 (CurrentInstr == 0x90 && !isBitSet(CARRY_BIT, StatusFlag))    || // BCC - Carry is clear
; 535  :                 (CurrentInstr == 0xB0 &&  isBitSet(CARRY_BIT, StatusFlag))    || // BCS - Carry is set
; 536  :                 (CurrentInstr == 0xD0 && !isBitSet(ZERO_BIT, StatusFlag))     || // BNE - Zero is clear

  00615	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0061a	83 f8 10	 cmp	 eax, 16
  0061d	75 1a		 jne	 SHORT $LN26@cpuTick
  0061f	0f b6 94 24 97
	00 00 00	 movzx	 edx, BYTE PTR StatusFlag$8[rsp]
  00627	b9 07 00 00 00	 mov	 ecx, 7
  0062c	e8 00 00 00 00	 call	 ?isBitSet@@YAHW4STATUS_BITS@@E@Z ; isBitSet
  00631	85 c0		 test	 eax, eax
  00633	0f 84 ee 00 00
	00		 je	 $LN25@cpuTick
$LN26@cpuTick:
  00639	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0063e	83 f8 30	 cmp	 eax, 48			; 00000030H
  00641	75 1a		 jne	 SHORT $LN27@cpuTick
  00643	0f b6 94 24 97
	00 00 00	 movzx	 edx, BYTE PTR StatusFlag$8[rsp]
  0064b	b9 07 00 00 00	 mov	 ecx, 7
  00650	e8 00 00 00 00	 call	 ?isBitSet@@YAHW4STATUS_BITS@@E@Z ; isBitSet
  00655	85 c0		 test	 eax, eax
  00657	0f 85 ca 00 00
	00		 jne	 $LN25@cpuTick
$LN27@cpuTick:
  0065d	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00662	83 f8 50	 cmp	 eax, 80			; 00000050H
  00665	75 1a		 jne	 SHORT $LN28@cpuTick
  00667	0f b6 94 24 97
	00 00 00	 movzx	 edx, BYTE PTR StatusFlag$8[rsp]
  0066f	b9 06 00 00 00	 mov	 ecx, 6
  00674	e8 00 00 00 00	 call	 ?isBitSet@@YAHW4STATUS_BITS@@E@Z ; isBitSet
  00679	85 c0		 test	 eax, eax
  0067b	0f 84 a6 00 00
	00		 je	 $LN25@cpuTick
$LN28@cpuTick:
  00681	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00686	83 f8 70	 cmp	 eax, 112		; 00000070H
  00689	75 1a		 jne	 SHORT $LN29@cpuTick
  0068b	0f b6 94 24 97
	00 00 00	 movzx	 edx, BYTE PTR StatusFlag$8[rsp]
  00693	b9 06 00 00 00	 mov	 ecx, 6
  00698	e8 00 00 00 00	 call	 ?isBitSet@@YAHW4STATUS_BITS@@E@Z ; isBitSet
  0069d	85 c0		 test	 eax, eax
  0069f	0f 85 82 00 00
	00		 jne	 $LN25@cpuTick
$LN29@cpuTick:
  006a5	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  006aa	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  006af	75 13		 jne	 SHORT $LN30@cpuTick
  006b1	0f b6 94 24 97
	00 00 00	 movzx	 edx, BYTE PTR StatusFlag$8[rsp]
  006b9	33 c9		 xor	 ecx, ecx
  006bb	e8 00 00 00 00	 call	 ?isBitSet@@YAHW4STATUS_BITS@@E@Z ; isBitSet
  006c0	85 c0		 test	 eax, eax
  006c2	74 63		 je	 SHORT $LN25@cpuTick
$LN30@cpuTick:
  006c4	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  006c9	3d b0 00 00 00	 cmp	 eax, 176		; 000000b0H
  006ce	75 13		 jne	 SHORT $LN31@cpuTick
  006d0	0f b6 94 24 97
	00 00 00	 movzx	 edx, BYTE PTR StatusFlag$8[rsp]
  006d8	33 c9		 xor	 ecx, ecx
  006da	e8 00 00 00 00	 call	 ?isBitSet@@YAHW4STATUS_BITS@@E@Z ; isBitSet
  006df	85 c0		 test	 eax, eax
  006e1	75 44		 jne	 SHORT $LN25@cpuTick
$LN31@cpuTick:
  006e3	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  006e8	3d d0 00 00 00	 cmp	 eax, 208		; 000000d0H
  006ed	75 16		 jne	 SHORT $LN32@cpuTick
  006ef	0f b6 94 24 97
	00 00 00	 movzx	 edx, BYTE PTR StatusFlag$8[rsp]
  006f7	b9 01 00 00 00	 mov	 ecx, 1
  006fc	e8 00 00 00 00	 call	 ?isBitSet@@YAHW4STATUS_BITS@@E@Z ; isBitSet
  00701	85 c0		 test	 eax, eax
  00703	74 22		 je	 SHORT $LN25@cpuTick
$LN32@cpuTick:
  00705	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0070a	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  0070f	75 64		 jne	 SHORT $LN24@cpuTick
  00711	0f b6 94 24 97
	00 00 00	 movzx	 edx, BYTE PTR StatusFlag$8[rsp]
  00719	b9 01 00 00 00	 mov	 ecx, 1
  0071e	e8 00 00 00 00	 call	 ?isBitSet@@YAHW4STATUS_BITS@@E@Z ; isBitSet
  00723	85 c0		 test	 eax, eax
  00725	74 4e		 je	 SHORT $LN24@cpuTick
$LN25@cpuTick:

; 537  :                 (CurrentInstr == 0xF0 &&  isBitSet(ZERO_BIT, StatusFlag)) )      // BEQ - Zero is set
; 538  :             {
; 539  :                 int8 RelAddress = relative(Registers, MemoryOffset);

  00727	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0072f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  00734	e8 00 00 00 00	 call	 ?relative@@YACPEAUcpuRegisters@@_K@Z ; relative
  00739	88 84 24 bb 00
	00 00		 mov	 BYTE PTR RelAddress$27[rsp], al

; 540  :                 Registers->PrgCounter += RelAddress; // Plus two to next instruction

  00740	0f be 84 24 bb
	00 00 00	 movsx	 eax, BYTE PTR RelAddress$27[rsp]
  00748	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  0074d	0f b7 49 06	 movzx	 ecx, WORD PTR [rcx+6]
  00751	03 c8		 add	 ecx, eax
  00753	8b c1		 mov	 eax, ecx
  00755	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  0075a	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 541  :                 *CyclesElapsed += 1; // TODO: Add cycles for crossings boundaries

  0075e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00766	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00769	ff c0		 inc	 eax
  0076b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR CyclesElapsed$[rsp]
  00773	88 01		 mov	 BYTE PTR [rcx], al
$LN24@cpuTick:

; 542  :             }
; 543  :             Log.InstrName = "BRC";

  00775	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88064
  0077c	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 544  :             break;

  00783	e9 cd 1e 00 00	 jmp	 $LN2@cpuTick
$LN33@cpuTick:

; 545  :         }
; 546  :         
; 547  : 
; 548  :         // NOTE: Load Memory Operations
; 549  :              
; 550  :         case 0xA9: case 0xA5: case 0xB5: case 0xAD: case 0xBD:   // LDA
; 551  :         case 0xB9: case 0xA1: case 0xB1: 
; 552  :         case 0xA2: case 0xA6: case 0xB6: case 0xAE: case 0xBE:   // LDX
; 553  :         case 0xA0: case 0xA4: case 0xB4: case 0xAC: case 0xBC:   // LDY   
; 554  :         {
; 555  :             uint8 Value;
; 556  :             if(CurrentInstr == 0xA9 || CurrentInstr == 0xA2 || CurrentInstr == 0xA0) // Immediate

  00788	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0078d	3d a9 00 00 00	 cmp	 eax, 169		; 000000a9H
  00792	74 18		 je	 SHORT $LN35@cpuTick
  00794	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00799	3d a2 00 00 00	 cmp	 eax, 162		; 000000a2H
  0079e	74 0c		 je	 SHORT $LN35@cpuTick
  007a0	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  007a5	3d a0 00 00 00	 cmp	 eax, 160		; 000000a0H
  007aa	75 29		 jne	 SHORT $LN34@cpuTick
$LN35@cpuTick:

; 557  :             {
; 558  :                 Value = immediate(Registers, MemoryOffset);

  007ac	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  007b4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  007b9	e8 00 00 00 00	 call	 ?immediate@@YAEPEAUcpuRegisters@@_K@Z ; immediate
  007be	88 84 24 80 00
	00 00		 mov	 BYTE PTR Value$1[rsp], al

; 559  :                 BytesRead = 2;

  007c5	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 560  :                 *CyclesElapsed = 2;

  007ca	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  007d2	c6 00 02	 mov	 BYTE PTR [rax], 2
$LN34@cpuTick:

; 561  :             }           
; 562  :             if(CurrentInstr == 0xA5 || CurrentInstr == 0xA6 || CurrentInstr == 0xA4) // Zero Page

  007d5	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  007da	3d a5 00 00 00	 cmp	 eax, 165		; 000000a5H
  007df	74 18		 je	 SHORT $LN37@cpuTick
  007e1	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  007e6	3d a6 00 00 00	 cmp	 eax, 166		; 000000a6H
  007eb	74 0c		 je	 SHORT $LN37@cpuTick
  007ed	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  007f2	3d a4 00 00 00	 cmp	 eax, 164		; 000000a4H
  007f7	75 29		 jne	 SHORT $LN36@cpuTick
$LN37@cpuTick:

; 563  :             {
; 564  :                 Value = zeroPage(Registers, MemoryOffset);

  007f9	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00801	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  00806	e8 00 00 00 00	 call	 ?zeroPage@@YAEPEAUcpuRegisters@@_K@Z ; zeroPage
  0080b	88 84 24 80 00
	00 00		 mov	 BYTE PTR Value$1[rsp], al

; 565  :                 BytesRead = 2;

  00812	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 566  :                 *CyclesElapsed = 3;

  00817	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  0081f	c6 00 03	 mov	 BYTE PTR [rax], 3
$LN36@cpuTick:

; 567  :             }
; 568  :             if(CurrentInstr == 0xB5 || CurrentInstr == 0xB4) // (Zero Page, X)

  00822	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00827	3d b5 00 00 00	 cmp	 eax, 181		; 000000b5H
  0082c	74 0c		 je	 SHORT $LN39@cpuTick
  0082e	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00833	3d b4 00 00 00	 cmp	 eax, 180		; 000000b4H
  00838	75 29		 jne	 SHORT $LN38@cpuTick
$LN39@cpuTick:

; 569  :             {
; 570  :                 Value = zeroPageX(Registers, MemoryOffset);

  0083a	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00842	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  00847	e8 00 00 00 00	 call	 ?zeroPageX@@YAEPEAUcpuRegisters@@_K@Z ; zeroPageX
  0084c	88 84 24 80 00
	00 00		 mov	 BYTE PTR Value$1[rsp], al

; 571  :                 BytesRead = 2;

  00853	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 572  :                 *CyclesElapsed = 4;

  00858	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00860	c6 00 04	 mov	 BYTE PTR [rax], 4
$LN38@cpuTick:

; 573  :             }
; 574  :             if(CurrentInstr == 0xB6)

  00863	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00868	3d b6 00 00 00	 cmp	 eax, 182		; 000000b6H
  0086d	75 29		 jne	 SHORT $LN40@cpuTick

; 575  :             {
; 576  :                 Value = zeroPageY(Registers, MemoryOffset);

  0086f	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00877	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  0087c	e8 00 00 00 00	 call	 ?zeroPageY@@YAEPEAUcpuRegisters@@_K@Z ; zeroPageY
  00881	88 84 24 80 00
	00 00		 mov	 BYTE PTR Value$1[rsp], al

; 577  :                 BytesRead = 2;

  00888	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 578  :                 *CyclesElapsed = 4;

  0088d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00895	c6 00 04	 mov	 BYTE PTR [rax], 4
$LN40@cpuTick:

; 579  :             }
; 580  :             if(CurrentInstr == 0xAD || CurrentInstr == 0xAE || CurrentInstr == 0xAC) // Absolute

  00898	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0089d	3d ad 00 00 00	 cmp	 eax, 173		; 000000adH
  008a2	74 18		 je	 SHORT $LN42@cpuTick
  008a4	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  008a9	3d ae 00 00 00	 cmp	 eax, 174		; 000000aeH
  008ae	74 0c		 je	 SHORT $LN42@cpuTick
  008b0	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  008b5	3d ac 00 00 00	 cmp	 eax, 172		; 000000acH
  008ba	75 29		 jne	 SHORT $LN41@cpuTick
$LN42@cpuTick:

; 581  :             {
; 582  :                 Value = abs(Registers, MemoryOffset);

  008bc	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  008c4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  008c9	e8 00 00 00 00	 call	 ?abs@@YAEPEAUcpuRegisters@@_K@Z ; abs
  008ce	88 84 24 80 00
	00 00		 mov	 BYTE PTR Value$1[rsp], al

; 583  :                 BytesRead = 3;

  008d5	c6 44 24 71 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 584  :                 *CyclesElapsed = 4;                        

  008da	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  008e2	c6 00 04	 mov	 BYTE PTR [rax], 4
$LN41@cpuTick:

; 585  :             }
; 586  :             if(CurrentInstr == 0xBD || CurrentInstr == 0xBC) // Absolute, X

  008e5	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  008ea	3d bd 00 00 00	 cmp	 eax, 189		; 000000bdH
  008ef	74 0c		 je	 SHORT $LN44@cpuTick
  008f1	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  008f6	3d bc 00 00 00	 cmp	 eax, 188		; 000000bcH
  008fb	75 29		 jne	 SHORT $LN43@cpuTick
$LN44@cpuTick:

; 587  :             {
; 588  :                 Value = absX(Registers, MemoryOffset);

  008fd	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00905	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  0090a	e8 00 00 00 00	 call	 ?absX@@YAEPEAUcpuRegisters@@_K@Z ; absX
  0090f	88 84 24 80 00
	00 00		 mov	 BYTE PTR Value$1[rsp], al

; 589  :                 BytesRead = 3;

  00916	c6 44 24 71 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 590  :                 *CyclesElapsed = 4; // TODO: Boundary fix                         

  0091b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00923	c6 00 04	 mov	 BYTE PTR [rax], 4
$LN43@cpuTick:

; 591  :             }
; 592  :             if(CurrentInstr == 0xB9 || CurrentInstr == 0xBE) // Absolute, Y

  00926	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0092b	3d b9 00 00 00	 cmp	 eax, 185		; 000000b9H
  00930	74 0c		 je	 SHORT $LN46@cpuTick
  00932	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00937	3d be 00 00 00	 cmp	 eax, 190		; 000000beH
  0093c	75 29		 jne	 SHORT $LN45@cpuTick
$LN46@cpuTick:

; 593  :             {
; 594  :                 Value = absY(Registers, MemoryOffset);

  0093e	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00946	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  0094b	e8 00 00 00 00	 call	 ?absY@@YAEPEAUcpuRegisters@@_K@Z ; absY
  00950	88 84 24 80 00
	00 00		 mov	 BYTE PTR Value$1[rsp], al

; 595  :                 BytesRead = 3;

  00957	c6 44 24 71 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 596  :                 *CyclesElapsed = 4; // TODO: Boundary fix                         

  0095c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00964	c6 00 04	 mov	 BYTE PTR [rax], 4
$LN45@cpuTick:

; 597  :             }
; 598  :             if(CurrentInstr == 0xA1) // Indirect, X

  00967	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0096c	3d a1 00 00 00	 cmp	 eax, 161		; 000000a1H
  00971	75 29		 jne	 SHORT $LN47@cpuTick

; 599  :             {
; 600  :                 Value = indirectX(Registers, MemoryOffset);

  00973	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0097b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  00980	e8 00 00 00 00	 call	 ?indirectX@@YAEPEAUcpuRegisters@@_K@Z ; indirectX
  00985	88 84 24 80 00
	00 00		 mov	 BYTE PTR Value$1[rsp], al

; 601  :                 BytesRead = 2;

  0098c	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 602  :                 *CyclesElapsed = 6;

  00991	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00999	c6 00 06	 mov	 BYTE PTR [rax], 6
$LN47@cpuTick:

; 603  :             }
; 604  :             if(CurrentInstr == 0xB1) // (Indirect), Y

  0099c	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  009a1	3d b1 00 00 00	 cmp	 eax, 177		; 000000b1H
  009a6	75 29		 jne	 SHORT $LN48@cpuTick

; 605  :             {
; 606  :                 Value = indirectY(Registers, MemoryOffset);

  009a8	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  009b0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  009b5	e8 00 00 00 00	 call	 ?indirectY@@YAEPEAUcpuRegisters@@_K@Z ; indirectY
  009ba	88 84 24 80 00
	00 00		 mov	 BYTE PTR Value$1[rsp], al

; 607  :                 BytesRead = 2;

  009c1	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 608  :                 *CyclesElapsed = 5; // TODO: Boundary fix

  009c6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  009ce	c6 00 05	 mov	 BYTE PTR [rax], 5
$LN48@cpuTick:

; 609  :             }
; 610  : 
; 611  :             uint8 RegisterToFill;
; 612  :             switch(CurrentInstr)

  009d1	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  009d6	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv367[rsp], eax
  009dd	8b 84 24 e4 00
	00 00		 mov	 eax, DWORD PTR tv367[rsp]
  009e4	2d a0 00 00 00	 sub	 eax, 160		; 000000a0H
  009e9	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv367[rsp], eax
  009f0	83 bc 24 e4 00
	00 00 1e	 cmp	 DWORD PTR tv367[rsp], 30
  009f8	0f 87 82 00 00
	00		 ja	 $LN52@cpuTick
  009fe	48 63 84 24 e4
	00 00 00	 movsxd	 rax, DWORD PTR tv367[rsp]
  00a06	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00a0d	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN198@cpuTick[rcx+rax]
  00a15	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN199@cpuTick[rcx+rax*4]
  00a1c	48 03 c1	 add	 rax, rcx
  00a1f	ff e0		 jmp	 rax
$LN49@cpuTick:

; 613  :             {
; 614  :                 case 0xA9: case 0xA5: case 0xB5: case 0xAD: // Register A
; 615  :                 case 0xBD: case 0xB9: case 0xA1: case 0xB1: 
; 616  :                     Log.InstrName = "LDA";

  00a21	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88082
  00a28	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 617  :                     Registers->A = Value;

  00a2f	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00a34	0f b6 8c 24 80
	00 00 00	 movzx	 ecx, BYTE PTR Value$1[rsp]
  00a3c	88 08		 mov	 BYTE PTR [rax], cl

; 618  :                     break;

  00a3e	eb 52		 jmp	 SHORT $LN4@cpuTick
$LN50@cpuTick:

; 619  :                 case 0xA2: case 0xA6: case 0xB6: case 0xAE: case 0xBE: // Register X
; 620  :                     Log.InstrName = "LDX";

  00a40	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88084
  00a47	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 621  :                     Registers->X = Value;

  00a4e	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00a53	0f b6 8c 24 80
	00 00 00	 movzx	 ecx, BYTE PTR Value$1[rsp]
  00a5b	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 622  :                     break;

  00a5e	eb 32		 jmp	 SHORT $LN4@cpuTick
$LN51@cpuTick:

; 623  :                 case 0xA0: case 0xA4: case 0xB4: case 0xAC: case 0xBC: // Register Y
; 624  :                     Log.InstrName = "LDY";

  00a60	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88086
  00a67	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 625  :                     Registers->Y = Value;

  00a6e	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00a73	0f b6 8c 24 80
	00 00 00	 movzx	 ecx, BYTE PTR Value$1[rsp]
  00a7b	88 48 02	 mov	 BYTE PTR [rax+2], cl

; 626  :                     break;

  00a7e	eb 12		 jmp	 SHORT $LN4@cpuTick
$LN52@cpuTick:

; 627  :                 default:
; 628  :                     Assert(0);

  00a80	33 c0		 xor	 eax, eax
  00a82	83 f8 01	 cmp	 eax, 1
  00a85	74 0b		 je	 SHORT $LN53@cpuTick
  00a87	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN53@cpuTick:
$LN4@cpuTick:

; 629  :                     break;
; 630  :             }
; 631  :             
; 632  :             setNegative(Value, &Registers->Flags);

  00a92	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00a97	48 83 c0 03	 add	 rax, 3
  00a9b	48 8b d0	 mov	 rdx, rax
  00a9e	0f b6 8c 24 80
	00 00 00	 movzx	 ecx, BYTE PTR Value$1[rsp]
  00aa6	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 633  :             setZero(Value, &Registers->Flags);                        

  00aab	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00ab0	48 83 c0 03	 add	 rax, 3
  00ab4	48 8b d0	 mov	 rdx, rax
  00ab7	0f b6 8c 24 80
	00 00 00	 movzx	 ecx, BYTE PTR Value$1[rsp]
  00abf	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 634  :             break;

  00ac4	e9 8c 1b 00 00	 jmp	 $LN2@cpuTick
$LN54@cpuTick:

; 635  :         }
; 636  : 
; 637  :         // NOTE: Store Memory Operations
; 638  :         
; 639  :         case 0x85: case 0x95: case 0x8D: case 0x9D: // STA
; 640  :         case 0x99: case 0x81: case 0x91:
; 641  :         case 0x86: case 0x96: case 0x8E:            // STX
; 642  :         case 0x84: case 0x94: case 0x8C:            // STY
; 643  :         {
; 644  :             uint16 Address = {};

  00ac9	33 c0		 xor	 eax, eax
  00acb	66 89 84 24 90
	00 00 00	 mov	 WORD PTR Address$4[rsp], ax

; 645  :             
; 646  :             if(CurrentInstr == 0x85 || CurrentInstr == 0x86 || CurrentInstr == 0x84) // Zero Page

  00ad3	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00ad8	3d 85 00 00 00	 cmp	 eax, 133		; 00000085H
  00add	74 18		 je	 SHORT $LN56@cpuTick
  00adf	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00ae4	3d 86 00 00 00	 cmp	 eax, 134		; 00000086H
  00ae9	74 0c		 je	 SHORT $LN56@cpuTick
  00aeb	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00af0	3d 84 00 00 00	 cmp	 eax, 132		; 00000084H
  00af5	75 36		 jne	 SHORT $LN55@cpuTick
$LN56@cpuTick:

; 647  :             {
; 648  :                 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  00af7	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00afc	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00b00	ff c0		 inc	 eax
  00b02	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00b0a	0f b7 c8	 movzx	 ecx, ax
  00b0d	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00b12	0f b6 c0	 movzx	 eax, al
  00b15	66 89 84 24 90
	00 00 00	 mov	 WORD PTR Address$4[rsp], ax

; 649  :                 BytesRead = 2;

  00b1d	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 650  :                 *CyclesElapsed = 3;

  00b22	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00b2a	c6 00 03	 mov	 BYTE PTR [rax], 3
$LN55@cpuTick:

; 651  :             }
; 652  :             
; 653  :             if(CurrentInstr == 0x95 || CurrentInstr == 0x94) // ZeroPage, X

  00b2d	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00b32	3d 95 00 00 00	 cmp	 eax, 149		; 00000095H
  00b37	74 0c		 je	 SHORT $LN58@cpuTick
  00b39	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00b3e	3d 94 00 00 00	 cmp	 eax, 148		; 00000094H
  00b43	75 53		 jne	 SHORT $LN57@cpuTick
$LN58@cpuTick:

; 654  :             {
; 655  :                 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  00b45	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00b4a	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00b4e	ff c0		 inc	 eax
  00b50	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00b58	0f b7 c8	 movzx	 ecx, ax
  00b5b	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00b60	0f b6 c0	 movzx	 eax, al
  00b63	66 89 84 24 90
	00 00 00	 mov	 WORD PTR Address$4[rsp], ax

; 656  :                 Address += Registers->X;

  00b6b	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00b70	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00b74	0f b7 8c 24 90
	00 00 00	 movzx	 ecx, WORD PTR Address$4[rsp]
  00b7c	03 c8		 add	 ecx, eax
  00b7e	8b c1		 mov	 eax, ecx
  00b80	66 89 84 24 90
	00 00 00	 mov	 WORD PTR Address$4[rsp], ax

; 657  :                 BytesRead = 2;

  00b88	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 658  :                 *CyclesElapsed = 4;

  00b8d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00b95	c6 00 04	 mov	 BYTE PTR [rax], 4
$LN57@cpuTick:

; 659  :             }
; 660  :             if(CurrentInstr == 0x96) // ZeroPage, Y

  00b98	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00b9d	3d 96 00 00 00	 cmp	 eax, 150		; 00000096H
  00ba2	75 53		 jne	 SHORT $LN59@cpuTick

; 661  :             {
; 662  :                 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  00ba4	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00ba9	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00bad	ff c0		 inc	 eax
  00baf	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00bb7	0f b7 c8	 movzx	 ecx, ax
  00bba	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00bbf	0f b6 c0	 movzx	 eax, al
  00bc2	66 89 84 24 90
	00 00 00	 mov	 WORD PTR Address$4[rsp], ax

; 663  :                 Address += Registers->Y;

  00bca	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00bcf	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00bd3	0f b7 8c 24 90
	00 00 00	 movzx	 ecx, WORD PTR Address$4[rsp]
  00bdb	03 c8		 add	 ecx, eax
  00bdd	8b c1		 mov	 eax, ecx
  00bdf	66 89 84 24 90
	00 00 00	 mov	 WORD PTR Address$4[rsp], ax

; 664  :                 BytesRead = 2;

  00be7	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 665  :                 *CyclesElapsed = 4;

  00bec	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00bf4	c6 00 04	 mov	 BYTE PTR [rax], 4
$LN59@cpuTick:

; 666  :             }
; 667  :             
; 668  :             if(CurrentInstr == 0x8D || CurrentInstr == 0x8E || CurrentInstr == 0x8C) // Absolute

  00bf7	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00bfc	3d 8d 00 00 00	 cmp	 eax, 141		; 0000008dH
  00c01	74 18		 je	 SHORT $LN61@cpuTick
  00c03	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00c08	3d 8e 00 00 00	 cmp	 eax, 142		; 0000008eH
  00c0d	74 0c		 je	 SHORT $LN61@cpuTick
  00c0f	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00c14	3d 8c 00 00 00	 cmp	 eax, 140		; 0000008cH
  00c19	75 33		 jne	 SHORT $LN60@cpuTick
$LN61@cpuTick:

; 669  :             {
; 670  :                 Address = readCpuMemory16(Registers->PrgCounter + 1, MemoryOffset);

  00c1b	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00c20	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00c24	ff c0		 inc	 eax
  00c26	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00c2e	0f b7 c8	 movzx	 ecx, ax
  00c31	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  00c36	66 89 84 24 90
	00 00 00	 mov	 WORD PTR Address$4[rsp], ax

; 671  :                 BytesRead = 3;

  00c3e	c6 44 24 71 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 672  :                 *CyclesElapsed = 4;

  00c43	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00c4b	c6 00 04	 mov	 BYTE PTR [rax], 4
$LN60@cpuTick:

; 673  :             }
; 674  : 
; 675  :             if(CurrentInstr == 0x9D) // Absolute, X

  00c4e	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00c53	3d 9d 00 00 00	 cmp	 eax, 157		; 0000009dH
  00c58	75 50		 jne	 SHORT $LN62@cpuTick

; 676  :             {
; 677  :                 Address = readCpuMemory16(Registers->PrgCounter + 1, MemoryOffset); 

  00c5a	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00c5f	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00c63	ff c0		 inc	 eax
  00c65	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00c6d	0f b7 c8	 movzx	 ecx, ax
  00c70	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  00c75	66 89 84 24 90
	00 00 00	 mov	 WORD PTR Address$4[rsp], ax

; 678  :                 Address += Registers->X;

  00c7d	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00c82	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00c86	0f b7 8c 24 90
	00 00 00	 movzx	 ecx, WORD PTR Address$4[rsp]
  00c8e	03 c8		 add	 ecx, eax
  00c90	8b c1		 mov	 eax, ecx
  00c92	66 89 84 24 90
	00 00 00	 mov	 WORD PTR Address$4[rsp], ax

; 679  :                 BytesRead = 3;

  00c9a	c6 44 24 71 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 680  :                 *CyclesElapsed = 5; 

  00c9f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00ca7	c6 00 05	 mov	 BYTE PTR [rax], 5
$LN62@cpuTick:

; 681  :             }            
; 682  :             if(CurrentInstr == 0x99) // Absolute, Y

  00caa	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00caf	3d 99 00 00 00	 cmp	 eax, 153		; 00000099H
  00cb4	75 50		 jne	 SHORT $LN63@cpuTick

; 683  :             {
; 684  :                 Address = readCpuMemory16(Registers->PrgCounter + 1, MemoryOffset); 

  00cb6	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00cbb	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00cbf	ff c0		 inc	 eax
  00cc1	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00cc9	0f b7 c8	 movzx	 ecx, ax
  00ccc	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  00cd1	66 89 84 24 90
	00 00 00	 mov	 WORD PTR Address$4[rsp], ax

; 685  :                 Address += Registers->Y;

  00cd9	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00cde	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00ce2	0f b7 8c 24 90
	00 00 00	 movzx	 ecx, WORD PTR Address$4[rsp]
  00cea	03 c8		 add	 ecx, eax
  00cec	8b c1		 mov	 eax, ecx
  00cee	66 89 84 24 90
	00 00 00	 mov	 WORD PTR Address$4[rsp], ax

; 686  :                 BytesRead = 3;

  00cf6	c6 44 24 71 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 687  :                 *CyclesElapsed = 5; 

  00cfb	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00d03	c6 00 05	 mov	 BYTE PTR [rax], 5
$LN63@cpuTick:

; 688  :             }
; 689  : 
; 690  :             if(CurrentInstr == 0x91) // (Indirect, X)

  00d06	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00d0b	3d 91 00 00 00	 cmp	 eax, 145		; 00000091H
  00d10	75 5d		 jne	 SHORT $LN64@cpuTick

; 691  :             {
; 692  :                 uint8 ZeroAddress = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset); 

  00d12	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00d17	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00d1b	ff c0		 inc	 eax
  00d1d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00d25	0f b7 c8	 movzx	 ecx, ax
  00d28	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00d2d	88 84 24 bc 00
	00 00		 mov	 BYTE PTR ZeroAddress$28[rsp], al

; 693  :                 Address = readCpuMemory16(ZeroAddress + Registers->X, MemoryOffset);

  00d34	0f b6 84 24 bc
	00 00 00	 movzx	 eax, BYTE PTR ZeroAddress$28[rsp]
  00d3c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  00d41	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00d45	03 c1		 add	 eax, ecx
  00d47	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00d4f	0f b7 c8	 movzx	 ecx, ax
  00d52	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  00d57	66 89 84 24 90
	00 00 00	 mov	 WORD PTR Address$4[rsp], ax

; 694  :                 BytesRead = 2;

  00d5f	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 695  :                 *CyclesElapsed = 6; // TODO: Check timing on this           

  00d64	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00d6c	c6 00 06	 mov	 BYTE PTR [rax], 6
$LN64@cpuTick:

; 696  :             }
; 697  :             
; 698  :             if(CurrentInstr == 0x91) // (Indirect), Y

  00d6f	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00d74	3d 91 00 00 00	 cmp	 eax, 145		; 00000091H
  00d79	75 6d		 jne	 SHORT $LN65@cpuTick

; 699  :             {
; 700  :                 uint8 ZeroAddress = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset); 

  00d7b	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00d80	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00d84	ff c0		 inc	 eax
  00d86	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00d8e	0f b7 c8	 movzx	 ecx, ax
  00d91	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00d96	88 84 24 bd 00
	00 00		 mov	 BYTE PTR ZeroAddress$29[rsp], al

; 701  :                 uint16 IndirectAddress = readCpuMemory16(ZeroAddress, MemoryOffset);

  00d9d	0f b6 84 24 bd
	00 00 00	 movzx	 eax, BYTE PTR ZeroAddress$29[rsp]
  00da5	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00dad	0f b7 c8	 movzx	 ecx, ax
  00db0	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  00db5	66 89 84 24 f8
	00 00 00	 mov	 WORD PTR IndirectAddress$45[rsp], ax

; 702  :                 Address = IndirectAddress + Registers->Y;

  00dbd	0f b7 84 24 f8
	00 00 00	 movzx	 eax, WORD PTR IndirectAddress$45[rsp]
  00dc5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  00dca	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  00dce	03 c1		 add	 eax, ecx
  00dd0	66 89 84 24 90
	00 00 00	 mov	 WORD PTR Address$4[rsp], ax

; 703  :                 BytesRead = 2;

  00dd8	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 704  :                 *CyclesElapsed = 6; // TODO: Check timing on this           

  00ddd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00de5	c6 00 06	 mov	 BYTE PTR [rax], 6
$LN65@cpuTick:

; 705  :             }
; 706  : 
; 707  : 
; 708  :             
; 709  :             Log.InstrValue1 = (uint8) Address;

  00de8	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR Address$4[rsp]
  00df0	88 05 03 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+3, al

; 710  :             Log.InstrValue2 = (uint8) (Address >> 8);

  00df6	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR Address$4[rsp]
  00dfe	c1 f8 08	 sar	 eax, 8
  00e01	88 05 04 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+4, al

; 711  :             Log.InstrAddress = Address;

  00e07	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR Address$4[rsp]
  00e0f	66 89 05 10 00
	00 00		 mov	 WORD PTR ?Log@@3UcpuLog@@A+16, ax

; 712  :             
; 713  :             uint8 RegisterValue;
; 714  :             switch(CurrentInstr)

  00e16	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00e1b	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv539[rsp], eax
  00e22	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR tv539[rsp]
  00e29	2d 81 00 00 00	 sub	 eax, 129		; 00000081H
  00e2e	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv539[rsp], eax
  00e35	83 bc 24 e8 00
	00 00 1c	 cmp	 DWORD PTR tv539[rsp], 28
  00e3d	0f 87 ae 00 00
	00		 ja	 $LN69@cpuTick
  00e43	48 63 84 24 e8
	00 00 00	 movsxd	 rax, DWORD PTR tv539[rsp]
  00e4b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00e52	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN196@cpuTick[rcx+rax]
  00e5a	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN197@cpuTick[rcx+rax*4]
  00e61	48 03 c1	 add	 rax, rcx
  00e64	ff e0		 jmp	 rax
$LN66@cpuTick:

; 715  :             {
; 716  :                 case 0x85: case 0x95: case 0x8D: case 0x9D: // Register A
; 717  :                 case 0x99: case 0x81: case 0x91:
; 718  :                     Log.InstrName = "STA";

  00e66	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88102
  00e6d	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 719  :                     Log.AddressValue = Registers->A;

  00e74	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00e79	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00e7c	88 05 12 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+18, al

; 720  :                     RegisterValue = Registers->A;

  00e82	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00e87	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00e8a	88 84 24 ad 00
	00 00		 mov	 BYTE PTR RegisterValue$16[rsp], al

; 721  :                     break;

  00e91	eb 70		 jmp	 SHORT $LN6@cpuTick
$LN67@cpuTick:

; 722  :                 case 0x86: case 0x96: case 0x8E: // Register X
; 723  :                     Log.InstrName = "STX";

  00e93	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88104
  00e9a	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 724  :                     Log.AddressValue = Registers->X;

  00ea1	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00ea6	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00eaa	88 05 12 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+18, al

; 725  :                     RegisterValue = Registers->X;

  00eb0	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00eb5	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00eb9	88 84 24 ad 00
	00 00		 mov	 BYTE PTR RegisterValue$16[rsp], al

; 726  :                     break;

  00ec0	eb 41		 jmp	 SHORT $LN6@cpuTick
$LN68@cpuTick:

; 727  :                 case 0x84: case 0x94: case 0x8C: // Register Y
; 728  :                     Log.InstrName = "STY";

  00ec2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88106
  00ec9	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 729  :                     Log.AddressValue = Registers->Y;

  00ed0	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00ed5	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00ed9	88 05 12 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+18, al

; 730  :                     RegisterValue = Registers->Y;

  00edf	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00ee4	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00ee8	88 84 24 ad 00
	00 00		 mov	 BYTE PTR RegisterValue$16[rsp], al

; 731  :                     break;

  00eef	eb 12		 jmp	 SHORT $LN6@cpuTick
$LN69@cpuTick:

; 732  :                 default:
; 733  :                     Assert(0);

  00ef1	33 c0		 xor	 eax, eax
  00ef3	83 f8 01	 cmp	 eax, 1
  00ef6	74 0b		 je	 SHORT $LN70@cpuTick
  00ef8	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN70@cpuTick:
$LN6@cpuTick:

; 734  :                     break;
; 735  :             }
; 736  :             
; 737  :             writeCpuMemory8(RegisterValue, Address, MemoryOffset);

  00f03	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  00f0b	0f b7 94 24 90
	00 00 00	 movzx	 edx, WORD PTR Address$4[rsp]
  00f13	0f b6 8c 24 ad
	00 00 00	 movzx	 ecx, BYTE PTR RegisterValue$16[rsp]
  00f1b	e8 00 00 00 00	 call	 ?writeCpuMemory8@@YAXEG_K@Z ; writeCpuMemory8

; 738  :             break;

  00f20	e9 30 17 00 00	 jmp	 $LN2@cpuTick
$LN71@cpuTick:

; 739  :         }
; 740  :       
; 741  :         
; 742  :         // NOTE: Bit Shifts
; 743  :         
; 744  :         case 0x06: // ASL(ZeroPage) - Shift Mem Left 1 bit
; 745  :         {
; 746  :             uint8 Address = readCpuMemory8(Registers->PrgCounter+1, MemoryOffset);

  00f25	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00f2a	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00f2e	ff c0		 inc	 eax
  00f30	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00f38	0f b7 c8	 movzx	 ecx, ax
  00f3b	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00f40	88 84 24 ae 00
	00 00		 mov	 BYTE PTR Address$17[rsp], al

; 747  :             uint8 Value = readCpuMemory8(Address, MemoryOffset);

  00f47	0f b6 84 24 ae
	00 00 00	 movzx	 eax, BYTE PTR Address$17[rsp]
  00f4f	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00f57	0f b7 c8	 movzx	 ecx, ax
  00f5a	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00f5f	88 84 24 a8 00
	00 00		 mov	 BYTE PTR Value$11[rsp], al

; 748  :             
; 749  :             if(Value & (1 << 7))

  00f66	0f b6 84 24 a8
	00 00 00	 movzx	 eax, BYTE PTR Value$11[rsp]
  00f6e	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00f73	85 c0		 test	 eax, eax
  00f75	74 13		 je	 SHORT $LN72@cpuTick

; 750  :                 setCarry(&Registers->Flags);

  00f77	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00f7c	48 83 c0 03	 add	 rax, 3
  00f80	48 8b c8	 mov	 rcx, rax
  00f83	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 751  :             else

  00f88	eb 11		 jmp	 SHORT $LN73@cpuTick
$LN72@cpuTick:

; 752  :                 clearCarry(&Registers->Flags);

  00f8a	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00f8f	48 83 c0 03	 add	 rax, 3
  00f93	48 8b c8	 mov	 rcx, rax
  00f96	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN73@cpuTick:

; 753  :           
; 754  :             Value = Value << 1;

  00f9b	0f b6 84 24 a8
	00 00 00	 movzx	 eax, BYTE PTR Value$11[rsp]
  00fa3	d1 e0		 shl	 eax, 1
  00fa5	88 84 24 a8 00
	00 00		 mov	 BYTE PTR Value$11[rsp], al

; 755  :             writeCpuMemory8(Value, Address, MemoryOffset);

  00fac	0f b6 84 24 ae
	00 00 00	 movzx	 eax, BYTE PTR Address$17[rsp]
  00fb4	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  00fbc	0f b7 d0	 movzx	 edx, ax
  00fbf	0f b6 8c 24 a8
	00 00 00	 movzx	 ecx, BYTE PTR Value$11[rsp]
  00fc7	e8 00 00 00 00	 call	 ?writeCpuMemory8@@YAXEG_K@Z ; writeCpuMemory8

; 756  :                         
; 757  :             setNegative(Value, &Registers->Flags);

  00fcc	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00fd1	48 83 c0 03	 add	 rax, 3
  00fd5	48 8b d0	 mov	 rdx, rax
  00fd8	0f b6 8c 24 a8
	00 00 00	 movzx	 ecx, BYTE PTR Value$11[rsp]
  00fe0	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 758  :             setZero(Value, &Registers->Flags);

  00fe5	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  00fea	48 83 c0 03	 add	 rax, 3
  00fee	48 8b d0	 mov	 rdx, rax
  00ff1	0f b6 8c 24 a8
	00 00 00	 movzx	 ecx, BYTE PTR Value$11[rsp]
  00ff9	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 759  :             BytesRead = 2;

  00ffe	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 760  :             *CyclesElapsed = 5;

  01003	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  0100b	c6 00 05	 mov	 BYTE PTR [rax], 5

; 761  : 
; 762  :             Log.InstrValue1 = Log.InstrAddress = Address;

  0100e	0f b6 84 24 ae
	00 00 00	 movzx	 eax, BYTE PTR Address$17[rsp]
  01016	66 89 05 10 00
	00 00		 mov	 WORD PTR ?Log@@3UcpuLog@@A+16, ax
  0101d	0f b6 05 10 00
	00 00		 movzx	 eax, BYTE PTR ?Log@@3UcpuLog@@A+16
  01024	88 05 03 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+3, al

; 763  :             Log.AddressValue = Value;

  0102a	0f b6 84 24 a8
	00 00 00	 movzx	 eax, BYTE PTR Value$11[rsp]
  01032	88 05 12 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+18, al

; 764  :             Log.InstrName = "ASL";

  01038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88112
  0103f	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 765  :             break;

  01046	e9 0a 16 00 00	 jmp	 $LN2@cpuTick
$LN74@cpuTick:

; 766  :         }
; 767  :         case 0x0A: // ASL(Accumulator)
; 768  :         {
; 769  :             uint8 Value = Registers->A;

  0104b	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01050	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01053	88 84 24 b1 00
	00 00		 mov	 BYTE PTR Value$20[rsp], al

; 770  :             
; 771  :             if(Value & (1 << 7))

  0105a	0f b6 84 24 b1
	00 00 00	 movzx	 eax, BYTE PTR Value$20[rsp]
  01062	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01067	85 c0		 test	 eax, eax
  01069	74 13		 je	 SHORT $LN75@cpuTick

; 772  :                 setCarry(&Registers->Flags);

  0106b	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01070	48 83 c0 03	 add	 rax, 3
  01074	48 8b c8	 mov	 rcx, rax
  01077	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 773  :             else

  0107c	eb 11		 jmp	 SHORT $LN76@cpuTick
$LN75@cpuTick:

; 774  :                 clearCarry(&Registers->Flags);

  0107e	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01083	48 83 c0 03	 add	 rax, 3
  01087	48 8b c8	 mov	 rcx, rax
  0108a	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN76@cpuTick:

; 775  :           
; 776  :             Registers->A = Value << 1;

  0108f	0f b6 84 24 b1
	00 00 00	 movzx	 eax, BYTE PTR Value$20[rsp]
  01097	d1 e0		 shl	 eax, 1
  01099	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  0109e	88 01		 mov	 BYTE PTR [rcx], al

; 777  :                         
; 778  :             setNegative(Registers->A, &Registers->Flags);

  010a0	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  010a5	48 83 c0 03	 add	 rax, 3
  010a9	48 8b d0	 mov	 rdx, rax
  010ac	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  010b1	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  010b4	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 779  :             setZero(Registers->A, &Registers->Flags);

  010b9	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  010be	48 83 c0 03	 add	 rax, 3
  010c2	48 8b d0	 mov	 rdx, rax
  010c5	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  010ca	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  010cd	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 780  :             BytesRead = 1;

  010d2	c6 44 24 71 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 781  :             *CyclesElapsed = 2;

  010d7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  010df	c6 00 02	 mov	 BYTE PTR [rax], 2

; 782  : 
; 783  :             Log.InstrName = "ASL";

  010e2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88116
  010e9	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 784  :             break;

  010f0	e9 60 15 00 00	 jmp	 $LN2@cpuTick
$LN77@cpuTick:

; 785  :         }
; 786  :         case 0x4A: // LSR(Accumulator) - logical shift right
; 787  :         {
; 788  :             uint8 Value = Registers->A;

  010f5	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  010fa	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  010fd	88 84 24 b2 00
	00 00		 mov	 BYTE PTR Value$21[rsp], al

; 789  :             if(Value & 1)

  01104	0f b6 84 24 b2
	00 00 00	 movzx	 eax, BYTE PTR Value$21[rsp]
  0110c	83 e0 01	 and	 eax, 1
  0110f	85 c0		 test	 eax, eax
  01111	74 13		 je	 SHORT $LN78@cpuTick

; 790  :                 setCarry(&Registers->Flags);

  01113	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01118	48 83 c0 03	 add	 rax, 3
  0111c	48 8b c8	 mov	 rcx, rax
  0111f	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 791  :             else

  01124	eb 11		 jmp	 SHORT $LN79@cpuTick
$LN78@cpuTick:

; 792  :                 clearCarry(&Registers->Flags);

  01126	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0112b	48 83 c0 03	 add	 rax, 3
  0112f	48 8b c8	 mov	 rcx, rax
  01132	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN79@cpuTick:

; 793  :             
; 794  :             Registers->A = Value >> 1;

  01137	0f b6 84 24 b2
	00 00 00	 movzx	 eax, BYTE PTR Value$21[rsp]
  0113f	d1 f8		 sar	 eax, 1
  01141	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  01146	88 01		 mov	 BYTE PTR [rcx], al

; 795  :             
; 796  :             setNegative(Registers->A, &Registers->Flags);

  01148	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0114d	48 83 c0 03	 add	 rax, 3
  01151	48 8b d0	 mov	 rdx, rax
  01154	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01159	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0115c	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 797  :             setZero(Registers->A, &Registers->Flags);

  01161	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01166	48 83 c0 03	 add	 rax, 3
  0116a	48 8b d0	 mov	 rdx, rax
  0116d	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01172	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  01175	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 798  :             BytesRead = 1;

  0117a	c6 44 24 71 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 799  :             *CyclesElapsed = 2;

  0117f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01187	c6 00 02	 mov	 BYTE PTR [rax], 2

; 800  :             
; 801  :             Log.InstrName = "LSR";

  0118a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88120
  01191	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 802  :             break;

  01198	e9 b8 14 00 00	 jmp	 $LN2@cpuTick
$LN80@cpuTick:

; 803  :         }
; 804  :         case 0x46: // LSR(ZeroPage)
; 805  :         {
; 806  :             uint8 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  0119d	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  011a2	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  011a6	ff c0		 inc	 eax
  011a8	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  011b0	0f b7 c8	 movzx	 ecx, ax
  011b3	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  011b8	88 84 24 be 00
	00 00		 mov	 BYTE PTR Address$30[rsp], al

; 807  :             uint8 Value = zeroPage(Registers, MemoryOffset);

  011bf	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  011c7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  011cc	e8 00 00 00 00	 call	 ?zeroPage@@YAEPEAUcpuRegisters@@_K@Z ; zeroPage
  011d1	88 84 24 aa 00
	00 00		 mov	 BYTE PTR Value$13[rsp], al

; 808  :             if(Value & 1)

  011d8	0f b6 84 24 aa
	00 00 00	 movzx	 eax, BYTE PTR Value$13[rsp]
  011e0	83 e0 01	 and	 eax, 1
  011e3	85 c0		 test	 eax, eax
  011e5	74 13		 je	 SHORT $LN81@cpuTick

; 809  :                 setCarry(&Registers->Flags);

  011e7	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  011ec	48 83 c0 03	 add	 rax, 3
  011f0	48 8b c8	 mov	 rcx, rax
  011f3	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 810  :             else

  011f8	eb 11		 jmp	 SHORT $LN82@cpuTick
$LN81@cpuTick:

; 811  :                 clearCarry(&Registers->Flags);

  011fa	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  011ff	48 83 c0 03	 add	 rax, 3
  01203	48 8b c8	 mov	 rcx, rax
  01206	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN82@cpuTick:

; 812  :             
; 813  :             Value = Value >> 1;

  0120b	0f b6 84 24 aa
	00 00 00	 movzx	 eax, BYTE PTR Value$13[rsp]
  01213	d1 f8		 sar	 eax, 1
  01215	88 84 24 aa 00
	00 00		 mov	 BYTE PTR Value$13[rsp], al

; 814  :             
; 815  :             setNegative(Value, &Registers->Flags);

  0121c	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01221	48 83 c0 03	 add	 rax, 3
  01225	48 8b d0	 mov	 rdx, rax
  01228	0f b6 8c 24 aa
	00 00 00	 movzx	 ecx, BYTE PTR Value$13[rsp]
  01230	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 816  :             setZero(Value, &Registers->Flags);

  01235	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0123a	48 83 c0 03	 add	 rax, 3
  0123e	48 8b d0	 mov	 rdx, rax
  01241	0f b6 8c 24 aa
	00 00 00	 movzx	 ecx, BYTE PTR Value$13[rsp]
  01249	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 817  :             
; 818  :             writeCpuMemory8(Value, Address, MemoryOffset);

  0124e	0f b6 84 24 be
	00 00 00	 movzx	 eax, BYTE PTR Address$30[rsp]
  01256	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  0125e	0f b7 d0	 movzx	 edx, ax
  01261	0f b6 8c 24 aa
	00 00 00	 movzx	 ecx, BYTE PTR Value$13[rsp]
  01269	e8 00 00 00 00	 call	 ?writeCpuMemory8@@YAXEG_K@Z ; writeCpuMemory8

; 819  :             BytesRead = 2;

  0126e	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 820  :             *CyclesElapsed = 5;

  01273	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  0127b	c6 00 05	 mov	 BYTE PTR [rax], 5

; 821  :             
; 822  :             Log.InstrName = "LSR";

  0127e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88124
  01285	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 823  :             break;

  0128c	e9 c4 13 00 00	 jmp	 $LN2@cpuTick
$LN83@cpuTick:

; 824  :         }
; 825  : 
; 826  :         case 0x2A: // ROL - Accumulator
; 827  :         {
; 828  :             uint8 Value = Registers->A;

  01291	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01296	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01299	88 84 24 98 00
	00 00		 mov	 BYTE PTR Value$9[rsp], al

; 829  :             
; 830  :             bool32 CarryIsSet = Registers->Flags & 1;

  012a0	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  012a5	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  012a9	83 e0 01	 and	 eax, 1
  012ac	89 84 24 14 01
	00 00		 mov	 DWORD PTR CarryIsSet$48[rsp], eax

; 831  :             if(Value & (1 << 7))

  012b3	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR Value$9[rsp]
  012bb	25 80 00 00 00	 and	 eax, 128		; 00000080H
  012c0	85 c0		 test	 eax, eax
  012c2	74 13		 je	 SHORT $LN84@cpuTick

; 832  :                 setCarry(&Registers->Flags);

  012c4	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  012c9	48 83 c0 03	 add	 rax, 3
  012cd	48 8b c8	 mov	 rcx, rax
  012d0	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 833  :             else

  012d5	eb 11		 jmp	 SHORT $LN85@cpuTick
$LN84@cpuTick:

; 834  :                 clearCarry(&Registers->Flags);

  012d7	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  012dc	48 83 c0 03	 add	 rax, 3
  012e0	48 8b c8	 mov	 rcx, rax
  012e3	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN85@cpuTick:

; 835  : 
; 836  :             Value = Value << 1;

  012e8	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR Value$9[rsp]
  012f0	d1 e0		 shl	 eax, 1
  012f2	88 84 24 98 00
	00 00		 mov	 BYTE PTR Value$9[rsp], al

; 837  :             
; 838  :             if(CarryIsSet)

  012f9	83 bc 24 14 01
	00 00 00	 cmp	 DWORD PTR CarryIsSet$48[rsp], 0
  01301	74 12		 je	 SHORT $LN86@cpuTick

; 839  :                 Value = Value & 1;

  01303	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR Value$9[rsp]
  0130b	83 e0 01	 and	 eax, 1
  0130e	88 84 24 98 00
	00 00		 mov	 BYTE PTR Value$9[rsp], al
$LN86@cpuTick:

; 840  : 
; 841  :             setNegative(Value, &Registers->Flags);

  01315	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0131a	48 83 c0 03	 add	 rax, 3
  0131e	48 8b d0	 mov	 rdx, rax
  01321	0f b6 8c 24 98
	00 00 00	 movzx	 ecx, BYTE PTR Value$9[rsp]
  01329	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 842  :             setZero(Value, &Registers->Flags);

  0132e	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01333	48 83 c0 03	 add	 rax, 3
  01337	48 8b d0	 mov	 rdx, rax
  0133a	0f b6 8c 24 98
	00 00 00	 movzx	 ecx, BYTE PTR Value$9[rsp]
  01342	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 843  : 
; 844  :             Registers->A = Value;

  01347	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0134c	0f b6 8c 24 98
	00 00 00	 movzx	 ecx, BYTE PTR Value$9[rsp]
  01354	88 08		 mov	 BYTE PTR [rax], cl

; 845  : 
; 846  :             BytesRead = 1;

  01356	c6 44 24 71 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 847  :             *CyclesElapsed = 2;

  0135b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01363	c6 00 02	 mov	 BYTE PTR [rax], 2

; 848  :             
; 849  :             Log.InstrName = "ROL";

  01366	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88129
  0136d	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 850  :             break;

  01374	e9 dc 12 00 00	 jmp	 $LN2@cpuTick
$LN87@cpuTick:

; 851  :         }
; 852  :         
; 853  :         case 0x26: case 0x36: // ROL
; 854  :         {
; 855  :             uint16 Address;
; 856  :             uint8 Value;
; 857  :             if(CurrentInstr == 0x26) // ZeroPage

  01379	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0137e	83 f8 26	 cmp	 eax, 38			; 00000026H
  01381	75 4f		 jne	 SHORT $LN88@cpuTick

; 858  :             {
; 859  :                 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  01383	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01388	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0138c	ff c0		 inc	 eax
  0138e	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01396	0f b7 c8	 movzx	 ecx, ax
  01399	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  0139e	0f b6 c0	 movzx	 eax, al
  013a1	66 89 84 24 e0
	00 00 00	 mov	 WORD PTR Address$43[rsp], ax

; 860  :                 Value = zeroPage(Registers, MemoryOffset);

  013a9	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  013b1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  013b6	e8 00 00 00 00	 call	 ?zeroPage@@YAEPEAUcpuRegisters@@_K@Z ; zeroPage
  013bb	88 84 24 94 00
	00 00		 mov	 BYTE PTR Value$5[rsp], al

; 861  :                 BytesRead = 2;

  013c2	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 862  :                 *CyclesElapsed = 5;

  013c7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  013cf	c6 00 05	 mov	 BYTE PTR [rax], 5
$LN88@cpuTick:

; 863  :             }
; 864  :             if(CurrentInstr == 0x36) // ZeroPage, X

  013d2	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  013d7	83 f8 36	 cmp	 eax, 54			; 00000036H
  013da	75 5a		 jne	 SHORT $LN89@cpuTick

; 865  :             {
; 866  :                 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset) + Registers->X;

  013dc	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  013e1	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  013e5	ff c0		 inc	 eax
  013e7	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  013ef	0f b7 c8	 movzx	 ecx, ax
  013f2	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  013f7	0f b6 c0	 movzx	 eax, al
  013fa	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  013ff	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  01403	03 c1		 add	 eax, ecx
  01405	66 89 84 24 e0
	00 00 00	 mov	 WORD PTR Address$43[rsp], ax

; 867  :                 Value = zeroPageX(Registers, MemoryOffset);

  0140d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01415	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  0141a	e8 00 00 00 00	 call	 ?zeroPageX@@YAEPEAUcpuRegisters@@_K@Z ; zeroPageX
  0141f	88 84 24 94 00
	00 00		 mov	 BYTE PTR Value$5[rsp], al

; 868  :                 BytesRead = 2;

  01426	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 869  :                 *CyclesElapsed = 6;

  0142b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01433	c6 00 06	 mov	 BYTE PTR [rax], 6
$LN89@cpuTick:

; 870  :             }
; 871  :             
; 872  :             bool32 CarryIsSet = Registers->Flags & 1;

  01436	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0143b	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0143f	83 e0 01	 and	 eax, 1
  01442	89 84 24 18 01
	00 00		 mov	 DWORD PTR CarryIsSet$49[rsp], eax

; 873  :             if(Value & (1 << 7))

  01449	0f b6 84 24 94
	00 00 00	 movzx	 eax, BYTE PTR Value$5[rsp]
  01451	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01456	85 c0		 test	 eax, eax
  01458	74 13		 je	 SHORT $LN90@cpuTick

; 874  :                 setCarry(&Registers->Flags);

  0145a	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0145f	48 83 c0 03	 add	 rax, 3
  01463	48 8b c8	 mov	 rcx, rax
  01466	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 875  :             else

  0146b	eb 11		 jmp	 SHORT $LN91@cpuTick
$LN90@cpuTick:

; 876  :                 clearCarry(&Registers->Flags);

  0146d	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01472	48 83 c0 03	 add	 rax, 3
  01476	48 8b c8	 mov	 rcx, rax
  01479	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN91@cpuTick:

; 877  : 
; 878  :             Value = Value << 1;

  0147e	0f b6 84 24 94
	00 00 00	 movzx	 eax, BYTE PTR Value$5[rsp]
  01486	d1 e0		 shl	 eax, 1
  01488	88 84 24 94 00
	00 00		 mov	 BYTE PTR Value$5[rsp], al

; 879  :             
; 880  :             if(CarryIsSet)

  0148f	83 bc 24 18 01
	00 00 00	 cmp	 DWORD PTR CarryIsSet$49[rsp], 0
  01497	74 12		 je	 SHORT $LN92@cpuTick

; 881  :                 Value = Value & 1;

  01499	0f b6 84 24 94
	00 00 00	 movzx	 eax, BYTE PTR Value$5[rsp]
  014a1	83 e0 01	 and	 eax, 1
  014a4	88 84 24 94 00
	00 00		 mov	 BYTE PTR Value$5[rsp], al
$LN92@cpuTick:

; 882  : 
; 883  :             setNegative(Value, &Registers->Flags);

  014ab	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  014b0	48 83 c0 03	 add	 rax, 3
  014b4	48 8b d0	 mov	 rdx, rax
  014b7	0f b6 8c 24 94
	00 00 00	 movzx	 ecx, BYTE PTR Value$5[rsp]
  014bf	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 884  :             setZero(Value, &Registers->Flags);

  014c4	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  014c9	48 83 c0 03	 add	 rax, 3
  014cd	48 8b d0	 mov	 rdx, rax
  014d0	0f b6 8c 24 94
	00 00 00	 movzx	 ecx, BYTE PTR Value$5[rsp]
  014d8	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 885  : 
; 886  :             writeCpuMemory8(Value, Address, MemoryOffset);

  014dd	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  014e5	0f b7 94 24 e0
	00 00 00	 movzx	 edx, WORD PTR Address$43[rsp]
  014ed	0f b6 8c 24 94
	00 00 00	 movzx	 ecx, BYTE PTR Value$5[rsp]
  014f5	e8 00 00 00 00	 call	 ?writeCpuMemory8@@YAXEG_K@Z ; writeCpuMemory8

; 887  : 
; 888  :             Log.InstrName = "ROL";

  014fa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88136
  01501	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 889  :             break;

  01508	e9 48 11 00 00	 jmp	 $LN2@cpuTick
$LN93@cpuTick:

; 890  :         }
; 891  : 
; 892  :         
; 893  :         case 0x6A: // ROR - Accumulator
; 894  :         {
; 895  :             uint8 Value = Registers->A;

  0150d	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01512	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01515	88 84 24 99 00
	00 00		 mov	 BYTE PTR Value$10[rsp], al

; 896  : 
; 897  :             bool32 CarryIsSet = Registers->Flags & 1;

  0151c	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01521	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  01525	83 e0 01	 and	 eax, 1
  01528	89 84 24 1c 01
	00 00		 mov	 DWORD PTR CarryIsSet$50[rsp], eax

; 898  :             if(Value & 1)

  0152f	0f b6 84 24 99
	00 00 00	 movzx	 eax, BYTE PTR Value$10[rsp]
  01537	83 e0 01	 and	 eax, 1
  0153a	85 c0		 test	 eax, eax
  0153c	74 13		 je	 SHORT $LN94@cpuTick

; 899  :                 setCarry(&Registers->Flags);

  0153e	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01543	48 83 c0 03	 add	 rax, 3
  01547	48 8b c8	 mov	 rcx, rax
  0154a	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 900  :             else

  0154f	eb 11		 jmp	 SHORT $LN95@cpuTick
$LN94@cpuTick:

; 901  :                 clearCarry(&Registers->Flags);

  01551	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01556	48 83 c0 03	 add	 rax, 3
  0155a	48 8b c8	 mov	 rcx, rax
  0155d	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN95@cpuTick:

; 902  : 
; 903  :             Value = Value >> 1;

  01562	0f b6 84 24 99
	00 00 00	 movzx	 eax, BYTE PTR Value$10[rsp]
  0156a	d1 f8		 sar	 eax, 1
  0156c	88 84 24 99 00
	00 00		 mov	 BYTE PTR Value$10[rsp], al

; 904  :             
; 905  :             if(CarryIsSet)

  01573	83 bc 24 1c 01
	00 00 00	 cmp	 DWORD PTR CarryIsSet$50[rsp], 0
  0157b	74 14		 je	 SHORT $LN96@cpuTick

; 906  :                 Value = Value & (1 << 7);

  0157d	0f b6 84 24 99
	00 00 00	 movzx	 eax, BYTE PTR Value$10[rsp]
  01585	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0158a	88 84 24 99 00
	00 00		 mov	 BYTE PTR Value$10[rsp], al
$LN96@cpuTick:

; 907  : 
; 908  :             setNegative(Value, &Registers->Flags);

  01591	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01596	48 83 c0 03	 add	 rax, 3
  0159a	48 8b d0	 mov	 rdx, rax
  0159d	0f b6 8c 24 99
	00 00 00	 movzx	 ecx, BYTE PTR Value$10[rsp]
  015a5	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 909  :             setZero(Value, &Registers->Flags);

  015aa	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  015af	48 83 c0 03	 add	 rax, 3
  015b3	48 8b d0	 mov	 rdx, rax
  015b6	0f b6 8c 24 99
	00 00 00	 movzx	 ecx, BYTE PTR Value$10[rsp]
  015be	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 910  :             Registers->A = Value;

  015c3	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  015c8	0f b6 8c 24 99
	00 00 00	 movzx	 ecx, BYTE PTR Value$10[rsp]
  015d0	88 08		 mov	 BYTE PTR [rax], cl

; 911  : 
; 912  :             BytesRead = 1;

  015d2	c6 44 24 71 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 913  :             *CyclesElapsed = 2;

  015d7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  015df	c6 00 02	 mov	 BYTE PTR [rax], 2

; 914  :             Log.InstrName = "ROR";

  015e2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88141
  015e9	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 915  :             break;

  015f0	e9 60 10 00 00	 jmp	 $LN2@cpuTick
$LN97@cpuTick:

; 916  :         }
; 917  :         
; 918  :         case 0x66: case 0x6E: // ROR
; 919  :         {
; 920  :             uint16 Address;
; 921  :             uint8 Value;
; 922  : 
; 923  :             if(CurrentInstr == 0x66) // ZeroPage

  015f5	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  015fa	83 f8 66	 cmp	 eax, 102		; 00000066H
  015fd	75 4f		 jne	 SHORT $LN98@cpuTick

; 924  :             {
; 925  :                 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  015ff	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01604	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  01608	ff c0		 inc	 eax
  0160a	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01612	0f b7 c8	 movzx	 ecx, ax
  01615	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  0161a	0f b6 c0	 movzx	 eax, al
  0161d	66 89 84 24 d4
	00 00 00	 mov	 WORD PTR Address$40[rsp], ax

; 926  :                 Value = zeroPage(Registers, MemoryOffset);

  01625	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0162d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  01632	e8 00 00 00 00	 call	 ?zeroPage@@YAEPEAUcpuRegisters@@_K@Z ; zeroPage
  01637	88 84 24 95 00
	00 00		 mov	 BYTE PTR Value$6[rsp], al

; 927  :                 BytesRead = 2;

  0163e	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 928  :                 *CyclesElapsed = 5;

  01643	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  0164b	c6 00 05	 mov	 BYTE PTR [rax], 5
$LN98@cpuTick:

; 929  :             }
; 930  :             if(CurrentInstr == 0x6E) // Absolute

  0164e	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01653	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  01656	75 4c		 jne	 SHORT $LN99@cpuTick

; 931  :             {
; 932  :                 Address = readCpuMemory16(Registers->PrgCounter + 1, MemoryOffset);

  01658	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0165d	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  01661	ff c0		 inc	 eax
  01663	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0166b	0f b7 c8	 movzx	 ecx, ax
  0166e	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  01673	66 89 84 24 d4
	00 00 00	 mov	 WORD PTR Address$40[rsp], ax

; 933  :                 Value = abs(Registers, MemoryOffset);

  0167b	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01683	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  01688	e8 00 00 00 00	 call	 ?abs@@YAEPEAUcpuRegisters@@_K@Z ; abs
  0168d	88 84 24 95 00
	00 00		 mov	 BYTE PTR Value$6[rsp], al

; 934  :                 BytesRead = 3;

  01694	c6 44 24 71 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 935  :                 *CyclesElapsed = 6;

  01699	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  016a1	c6 00 06	 mov	 BYTE PTR [rax], 6
$LN99@cpuTick:

; 936  :             }
; 937  :             
; 938  :             bool32 CarryIsSet = Registers->Flags & 1;

  016a4	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  016a9	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  016ad	83 e0 01	 and	 eax, 1
  016b0	89 84 24 20 01
	00 00		 mov	 DWORD PTR CarryIsSet$51[rsp], eax

; 939  :             if(Value & 1)

  016b7	0f b6 84 24 95
	00 00 00	 movzx	 eax, BYTE PTR Value$6[rsp]
  016bf	83 e0 01	 and	 eax, 1
  016c2	85 c0		 test	 eax, eax
  016c4	74 13		 je	 SHORT $LN100@cpuTick

; 940  :                 setCarry(&Registers->Flags);

  016c6	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  016cb	48 83 c0 03	 add	 rax, 3
  016cf	48 8b c8	 mov	 rcx, rax
  016d2	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 941  :             else

  016d7	eb 11		 jmp	 SHORT $LN101@cpuTick
$LN100@cpuTick:

; 942  :                 clearCarry(&Registers->Flags);

  016d9	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  016de	48 83 c0 03	 add	 rax, 3
  016e2	48 8b c8	 mov	 rcx, rax
  016e5	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN101@cpuTick:

; 943  : 
; 944  :             Value = Value >> 1;

  016ea	0f b6 84 24 95
	00 00 00	 movzx	 eax, BYTE PTR Value$6[rsp]
  016f2	d1 f8		 sar	 eax, 1
  016f4	88 84 24 95 00
	00 00		 mov	 BYTE PTR Value$6[rsp], al

; 945  :             
; 946  :             if(CarryIsSet)

  016fb	83 bc 24 20 01
	00 00 00	 cmp	 DWORD PTR CarryIsSet$51[rsp], 0
  01703	74 14		 je	 SHORT $LN102@cpuTick

; 947  :                 Value = Value & (1 << 7);

  01705	0f b6 84 24 95
	00 00 00	 movzx	 eax, BYTE PTR Value$6[rsp]
  0170d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01712	88 84 24 95 00
	00 00		 mov	 BYTE PTR Value$6[rsp], al
$LN102@cpuTick:

; 948  : 
; 949  :             setNegative(Value, &Registers->Flags);

  01719	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0171e	48 83 c0 03	 add	 rax, 3
  01722	48 8b d0	 mov	 rdx, rax
  01725	0f b6 8c 24 95
	00 00 00	 movzx	 ecx, BYTE PTR Value$6[rsp]
  0172d	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 950  :             setZero(Value, &Registers->Flags);

  01732	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01737	48 83 c0 03	 add	 rax, 3
  0173b	48 8b d0	 mov	 rdx, rax
  0173e	0f b6 8c 24 95
	00 00 00	 movzx	 ecx, BYTE PTR Value$6[rsp]
  01746	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 951  : 
; 952  :             writeCpuMemory8(Value, Address, MemoryOffset);

  0174b	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  01753	0f b7 94 24 d4
	00 00 00	 movzx	 edx, WORD PTR Address$40[rsp]
  0175b	0f b6 8c 24 95
	00 00 00	 movzx	 ecx, BYTE PTR Value$6[rsp]
  01763	e8 00 00 00 00	 call	 ?writeCpuMemory8@@YAXEG_K@Z ; writeCpuMemory8

; 953  : 
; 954  :             Log.InstrName = "ROR";

  01768	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88148
  0176f	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 955  :             break;

  01776	e9 da 0e 00 00	 jmp	 $LN2@cpuTick
$LN103@cpuTick:

; 956  :         }
; 957  :         
; 958  :         case 0x24: // BIT - zeropage
; 959  :         {
; 960  :             uint8 Value = zeroPage(Registers, MemoryOffset);

  0177b	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01783	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  01788	e8 00 00 00 00	 call	 ?zeroPage@@YAEPEAUcpuRegisters@@_K@Z ; zeroPage
  0178d	88 84 24 af 00
	00 00		 mov	 BYTE PTR Value$18[rsp], al

; 961  : 
; 962  :             setNegative(Value, &Registers->Flags);

  01794	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01799	48 83 c0 03	 add	 rax, 3
  0179d	48 8b d0	 mov	 rdx, rax
  017a0	0f b6 8c 24 af
	00 00 00	 movzx	 ecx, BYTE PTR Value$18[rsp]
  017a8	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 963  :             setZero(Registers->A & Value, &Registers->Flags);

  017ad	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  017b2	48 83 c0 03	 add	 rax, 3
  017b6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  017bb	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  017be	0f b6 94 24 af
	00 00 00	 movzx	 edx, BYTE PTR Value$18[rsp]
  017c6	23 ca		 and	 ecx, edx
  017c8	48 8b d0	 mov	 rdx, rax
  017cb	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 964  : 
; 965  :             if(Value & (1 << 6))

  017d0	0f b6 84 24 af
	00 00 00	 movzx	 eax, BYTE PTR Value$18[rsp]
  017d8	83 e0 40	 and	 eax, 64			; 00000040H
  017db	85 c0		 test	 eax, eax
  017dd	74 13		 je	 SHORT $LN104@cpuTick

; 966  :                 setCarry(&Registers->Flags);

  017df	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  017e4	48 83 c0 03	 add	 rax, 3
  017e8	48 8b c8	 mov	 rcx, rax
  017eb	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 967  :             else

  017f0	eb 11		 jmp	 SHORT $LN105@cpuTick
$LN104@cpuTick:

; 968  :                 clearCarry(&Registers->Flags);

  017f2	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  017f7	48 83 c0 03	 add	 rax, 3
  017fb	48 8b c8	 mov	 rcx, rax
  017fe	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN105@cpuTick:

; 969  : 
; 970  :             BytesRead = 2;

  01803	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 971  :             *CyclesElapsed = 3;

  01808	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01810	c6 00 03	 mov	 BYTE PTR [rax], 3

; 972  :             Log.InstrName = "BIT";

  01813	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88152
  0181a	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 973  :             break;

  01821	e9 2f 0e 00 00	 jmp	 $LN2@cpuTick
$LN106@cpuTick:

; 974  :         }
; 975  : 
; 976  :         
; 977  :         // NOTE: Logic Operations          
; 978  :                     
; 979  :         case 0x29: case 0x25: case 0x35: case 0x2D: // AND  
; 980  :         case 0x3D: case 0x39: case 0x21: case 0x31:
; 981  :         case 0x49: case 0x45: case 0x55: case 0x4D: // EOR
; 982  :         case 0x5D: case 0x59: case 0x41: case 0x51:
; 983  :         case 0x09: case 0x05: case 0x15: case 0x0D: // ORA
; 984  :         case 0x1D: case 0x19: case 0x01: case 0x11: 
; 985  :         {
; 986  :             uint8 Value;
; 987  :             if(CurrentInstr == 0x29 || CurrentInstr == 0x49 || CurrentInstr == 0x09) // Immediate 

  01826	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0182b	83 f8 29	 cmp	 eax, 41			; 00000029H
  0182e	74 14		 je	 SHORT $LN108@cpuTick
  01830	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01835	83 f8 49	 cmp	 eax, 73			; 00000049H
  01838	74 0a		 je	 SHORT $LN108@cpuTick
  0183a	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0183f	83 f8 09	 cmp	 eax, 9
  01842	75 29		 jne	 SHORT $LN107@cpuTick
$LN108@cpuTick:

; 988  :             {
; 989  :                 Value = immediate(Registers, MemoryOffset);

  01844	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0184c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  01851	e8 00 00 00 00	 call	 ?immediate@@YAEPEAUcpuRegisters@@_K@Z ; immediate
  01856	88 84 24 81 00
	00 00		 mov	 BYTE PTR Value$2[rsp], al

; 990  :                 BytesRead = 2;

  0185d	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 991  :                 *CyclesElapsed = 2;

  01862	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  0186a	c6 00 02	 mov	 BYTE PTR [rax], 2
$LN107@cpuTick:

; 992  :             }
; 993  :             if(CurrentInstr == 0x25 || CurrentInstr == 0x45 || CurrentInstr == 0x05) // Zeropage

  0186d	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01872	83 f8 25	 cmp	 eax, 37			; 00000025H
  01875	74 14		 je	 SHORT $LN110@cpuTick
  01877	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0187c	83 f8 45	 cmp	 eax, 69			; 00000045H
  0187f	74 0a		 je	 SHORT $LN110@cpuTick
  01881	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01886	83 f8 05	 cmp	 eax, 5
  01889	75 29		 jne	 SHORT $LN109@cpuTick
$LN110@cpuTick:

; 994  :             {
; 995  :                 Value = zeroPage(Registers, MemoryOffset);

  0188b	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01893	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  01898	e8 00 00 00 00	 call	 ?zeroPage@@YAEPEAUcpuRegisters@@_K@Z ; zeroPage
  0189d	88 84 24 81 00
	00 00		 mov	 BYTE PTR Value$2[rsp], al

; 996  :                 BytesRead = 2;

  018a4	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 997  :                 *CyclesElapsed = 3;

  018a9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  018b1	c6 00 03	 mov	 BYTE PTR [rax], 3
$LN109@cpuTick:

; 998  :             }                   
; 999  :             if(CurrentInstr == 0x35 || CurrentInstr == 0x55 || CurrentInstr == 0x15) // ZeroPage, X

  018b4	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  018b9	83 f8 35	 cmp	 eax, 53			; 00000035H
  018bc	74 14		 je	 SHORT $LN112@cpuTick
  018be	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  018c3	83 f8 55	 cmp	 eax, 85			; 00000055H
  018c6	74 0a		 je	 SHORT $LN112@cpuTick
  018c8	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  018cd	83 f8 15	 cmp	 eax, 21
  018d0	75 29		 jne	 SHORT $LN111@cpuTick
$LN112@cpuTick:

; 1000 :             {
; 1001 :                 Value = zeroPageX(Registers, MemoryOffset);

  018d2	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  018da	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  018df	e8 00 00 00 00	 call	 ?zeroPageX@@YAEPEAUcpuRegisters@@_K@Z ; zeroPageX
  018e4	88 84 24 81 00
	00 00		 mov	 BYTE PTR Value$2[rsp], al

; 1002 :                 BytesRead = 2;

  018eb	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 1003 :                 *CyclesElapsed = 4;

  018f0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  018f8	c6 00 04	 mov	 BYTE PTR [rax], 4
$LN111@cpuTick:

; 1004 :             }
; 1005 :             if(CurrentInstr == 0x2D || CurrentInstr == 0x4D || CurrentInstr == 0x0D) // Absolute

  018fb	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01900	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  01903	74 14		 je	 SHORT $LN114@cpuTick
  01905	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0190a	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  0190d	74 0a		 je	 SHORT $LN114@cpuTick
  0190f	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01914	83 f8 0d	 cmp	 eax, 13
  01917	75 29		 jne	 SHORT $LN113@cpuTick
$LN114@cpuTick:

; 1006 :             {
; 1007 :                 Value = abs(Registers, MemoryOffset);

  01919	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01921	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  01926	e8 00 00 00 00	 call	 ?abs@@YAEPEAUcpuRegisters@@_K@Z ; abs
  0192b	88 84 24 81 00
	00 00		 mov	 BYTE PTR Value$2[rsp], al

; 1008 :                 BytesRead = 3;

  01932	c6 44 24 71 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 1009 :                 *CyclesElapsed = 4;

  01937	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  0193f	c6 00 04	 mov	 BYTE PTR [rax], 4
$LN113@cpuTick:

; 1010 :             }          
; 1011 :             if(CurrentInstr == 0x3D  || CurrentInstr == 0x5D || CurrentInstr == 0x1D) // Absolute, X

  01942	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01947	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  0194a	74 14		 je	 SHORT $LN116@cpuTick
  0194c	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01951	83 f8 5d	 cmp	 eax, 93			; 0000005dH
  01954	74 0a		 je	 SHORT $LN116@cpuTick
  01956	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0195b	83 f8 1d	 cmp	 eax, 29
  0195e	75 29		 jne	 SHORT $LN115@cpuTick
$LN116@cpuTick:

; 1012 :             {
; 1013 :                 Value = absX(Registers, MemoryOffset);

  01960	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01968	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  0196d	e8 00 00 00 00	 call	 ?absX@@YAEPEAUcpuRegisters@@_K@Z ; absX
  01972	88 84 24 81 00
	00 00		 mov	 BYTE PTR Value$2[rsp], al

; 1014 :                 BytesRead = 3;

  01979	c6 44 24 71 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 1015 :                 *CyclesElapsed = 4; // TODO: Boundary

  0197e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01986	c6 00 04	 mov	 BYTE PTR [rax], 4
$LN115@cpuTick:

; 1016 :             }
; 1017 :             if(CurrentInstr == 0x39 || CurrentInstr == 0x59 || CurrentInstr == 0x19) // Absolute, Y

  01989	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0198e	83 f8 39	 cmp	 eax, 57			; 00000039H
  01991	74 14		 je	 SHORT $LN118@cpuTick
  01993	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01998	83 f8 59	 cmp	 eax, 89			; 00000059H
  0199b	74 0a		 je	 SHORT $LN118@cpuTick
  0199d	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  019a2	83 f8 19	 cmp	 eax, 25
  019a5	75 29		 jne	 SHORT $LN117@cpuTick
$LN118@cpuTick:

; 1018 :             {
; 1019 :                 Value = absY(Registers, MemoryOffset);

  019a7	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  019af	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  019b4	e8 00 00 00 00	 call	 ?absY@@YAEPEAUcpuRegisters@@_K@Z ; absY
  019b9	88 84 24 81 00
	00 00		 mov	 BYTE PTR Value$2[rsp], al

; 1020 :                 BytesRead = 3;

  019c0	c6 44 24 71 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 1021 :                 *CyclesElapsed = 4; // TODO: Boundary

  019c5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  019cd	c6 00 04	 mov	 BYTE PTR [rax], 4
$LN117@cpuTick:

; 1022 :             }
; 1023 :             if(CurrentInstr == 0x21 || CurrentInstr == 0x41 || CurrentInstr == 0x01) // (Indirect, X)

  019d0	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  019d5	83 f8 21	 cmp	 eax, 33			; 00000021H
  019d8	74 14		 je	 SHORT $LN120@cpuTick
  019da	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  019df	83 f8 41	 cmp	 eax, 65			; 00000041H
  019e2	74 0a		 je	 SHORT $LN120@cpuTick
  019e4	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  019e9	83 f8 01	 cmp	 eax, 1
  019ec	75 29		 jne	 SHORT $LN119@cpuTick
$LN120@cpuTick:

; 1024 :             {
; 1025 :                 Value = indirectX(Registers, MemoryOffset);

  019ee	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  019f6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  019fb	e8 00 00 00 00	 call	 ?indirectX@@YAEPEAUcpuRegisters@@_K@Z ; indirectX
  01a00	88 84 24 81 00
	00 00		 mov	 BYTE PTR Value$2[rsp], al

; 1026 :                 BytesRead = 2;

  01a07	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 1027 :                 *CyclesElapsed = 6;

  01a0c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01a14	c6 00 06	 mov	 BYTE PTR [rax], 6
$LN119@cpuTick:

; 1028 :             }
; 1029 :             if(CurrentInstr == 0x31 || CurrentInstr == 0x51 || CurrentInstr == 0x11) // Indirect, Y

  01a17	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01a1c	83 f8 31	 cmp	 eax, 49			; 00000031H
  01a1f	74 14		 je	 SHORT $LN122@cpuTick
  01a21	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01a26	83 f8 51	 cmp	 eax, 81			; 00000051H
  01a29	74 0a		 je	 SHORT $LN122@cpuTick
  01a2b	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01a30	83 f8 11	 cmp	 eax, 17
  01a33	75 29		 jne	 SHORT $LN121@cpuTick
$LN122@cpuTick:

; 1030 :             {
; 1031 :                 Value = indirectY(Registers, MemoryOffset);

  01a35	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01a3d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  01a42	e8 00 00 00 00	 call	 ?indirectY@@YAEPEAUcpuRegisters@@_K@Z ; indirectY
  01a47	88 84 24 81 00
	00 00		 mov	 BYTE PTR Value$2[rsp], al

; 1032 :                 BytesRead = 2;

  01a4e	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 1033 :                 *CyclesElapsed = 5; //TODO: Boundary 

  01a53	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01a5b	c6 00 05	 mov	 BYTE PTR [rax], 5
$LN121@cpuTick:

; 1034 :             }
; 1035 : 
; 1036 :             switch(CurrentInstr)

  01a5e	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01a63	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv938[rsp], eax
  01a6a	8b 84 24 ec 00
	00 00		 mov	 eax, DWORD PTR tv938[rsp]
  01a71	ff c8		 dec	 eax
  01a73	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv938[rsp], eax
  01a7a	83 bc 24 ec 00
	00 00 5c	 cmp	 DWORD PTR tv938[rsp], 92 ; 0000005cH
  01a82	0f 87 9c 00 00
	00		 ja	 $LN8@cpuTick
  01a88	48 63 84 24 ec
	00 00 00	 movsxd	 rax, DWORD PTR tv938[rsp]
  01a90	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  01a97	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN194@cpuTick[rcx+rax]
  01a9f	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN195@cpuTick[rcx+rax*4]
  01aa6	48 03 c1	 add	 rax, rcx
  01aa9	ff e0		 jmp	 rax
$LN123@cpuTick:

; 1037 :             {
; 1038 :                 case 0x29: case 0x25: case 0x35: case 0x2D: // AND  
; 1039 :                 case 0x3D: case 0x39: case 0x21: case 0x31:
; 1040 :                     Log.InstrName = "AND";

  01aab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88171
  01ab2	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 1041 :                     Registers->A = Registers->A & Value;

  01ab9	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01abe	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01ac1	0f b6 8c 24 81
	00 00 00	 movzx	 ecx, BYTE PTR Value$2[rsp]
  01ac9	23 c1		 and	 eax, ecx
  01acb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  01ad0	88 01		 mov	 BYTE PTR [rcx], al

; 1042 :                     break;

  01ad2	eb 50		 jmp	 SHORT $LN8@cpuTick
$LN124@cpuTick:

; 1043 :                 case 0x49: case 0x45: case 0x55: case 0x4D: // EOR
; 1044 :                 case 0x5D: case 0x59: case 0x41: case 0x51:
; 1045 :                     Log.InstrName = "EOR";

  01ad4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88173
  01adb	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 1046 :                     Registers->A = Registers->A ^ Value;

  01ae2	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01ae7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01aea	0f b6 8c 24 81
	00 00 00	 movzx	 ecx, BYTE PTR Value$2[rsp]
  01af2	33 c1		 xor	 eax, ecx
  01af4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  01af9	88 01		 mov	 BYTE PTR [rcx], al

; 1047 :                     break;

  01afb	eb 27		 jmp	 SHORT $LN8@cpuTick
$LN125@cpuTick:

; 1048 :                 case 0x09: case 0x05: case 0x15: case 0x0D: // ORA
; 1049 :                 case 0x1D: case 0x19: case 0x01: case 0x11:
; 1050 :                     Log.InstrName = "ORA";

  01afd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88175
  01b04	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 1051 :                     Registers->A = Registers->A | Value;

  01b0b	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01b10	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01b13	0f b6 8c 24 81
	00 00 00	 movzx	 ecx, BYTE PTR Value$2[rsp]
  01b1b	0b c1		 or	 eax, ecx
  01b1d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  01b22	88 01		 mov	 BYTE PTR [rcx], al
$LN8@cpuTick:

; 1052 :                     break;
; 1053 :             }            
; 1054 :             setNegative(Value, &Registers->Flags);

  01b24	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01b29	48 83 c0 03	 add	 rax, 3
  01b2d	48 8b d0	 mov	 rdx, rax
  01b30	0f b6 8c 24 81
	00 00 00	 movzx	 ecx, BYTE PTR Value$2[rsp]
  01b38	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 1055 :             setZero(Value, &Registers->Flags);

  01b3d	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01b42	48 83 c0 03	 add	 rax, 3
  01b46	48 8b d0	 mov	 rdx, rax
  01b49	0f b6 8c 24 81
	00 00 00	 movzx	 ecx, BYTE PTR Value$2[rsp]
  01b51	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 1056 :             break;

  01b56	e9 fa 0a 00 00	 jmp	 $LN2@cpuTick
$LN126@cpuTick:

; 1057 :         }
; 1058 :                 
; 1059 :         // NOTE: Transfering Register Values 
; 1060 :         
; 1061 :         case 0x8A: case 0xAA: case 0xA8: case 0x98: case 0x9A:
; 1062 :         {
; 1063 :             uint8 Value;
; 1064 :             if(CurrentInstr == 0x8A) // TXA

  01b5b	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01b60	3d 8a 00 00 00	 cmp	 eax, 138		; 0000008aH
  01b65	75 2d		 jne	 SHORT $LN127@cpuTick

; 1065 :             {
; 1066 :                 Log.InstrName = "TXA";

  01b67	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88178
  01b6e	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 1067 :                 Registers->A = Value = Registers->X;

  01b75	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01b7a	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  01b7e	88 84 24 82 00
	00 00		 mov	 BYTE PTR Value$3[rsp], al
  01b85	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01b8a	0f b6 8c 24 82
	00 00 00	 movzx	 ecx, BYTE PTR Value$3[rsp]
  01b92	88 08		 mov	 BYTE PTR [rax], cl
$LN127@cpuTick:

; 1068 :             }
; 1069 :             if(CurrentInstr == 0xAA) // TAX

  01b94	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01b99	3d aa 00 00 00	 cmp	 eax, 170		; 000000aaH
  01b9e	75 2d		 jne	 SHORT $LN128@cpuTick

; 1070 :             {
; 1071 :                 Log.InstrName = "TAX";

  01ba0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88180
  01ba7	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 1072 :                 Registers->X = Value = Registers->A;

  01bae	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01bb3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01bb6	88 84 24 82 00
	00 00		 mov	 BYTE PTR Value$3[rsp], al
  01bbd	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01bc2	0f b6 8c 24 82
	00 00 00	 movzx	 ecx, BYTE PTR Value$3[rsp]
  01bca	88 48 01	 mov	 BYTE PTR [rax+1], cl
$LN128@cpuTick:

; 1073 :             }
; 1074 :             if(CurrentInstr == 0xA8) // TAY

  01bcd	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01bd2	3d a8 00 00 00	 cmp	 eax, 168		; 000000a8H
  01bd7	75 2d		 jne	 SHORT $LN129@cpuTick

; 1075 :             {
; 1076 :                 Log.InstrName = "TAY";

  01bd9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88182
  01be0	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 1077 :                 Registers->Y = Value = Registers->A;

  01be7	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01bec	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01bef	88 84 24 82 00
	00 00		 mov	 BYTE PTR Value$3[rsp], al
  01bf6	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01bfb	0f b6 8c 24 82
	00 00 00	 movzx	 ecx, BYTE PTR Value$3[rsp]
  01c03	88 48 02	 mov	 BYTE PTR [rax+2], cl
$LN129@cpuTick:

; 1078 :             }
; 1079 :             if(CurrentInstr == 0x98) // TYA

  01c06	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01c0b	3d 98 00 00 00	 cmp	 eax, 152		; 00000098H
  01c10	75 2d		 jne	 SHORT $LN130@cpuTick

; 1080 :             {
; 1081 :                 Log.InstrName = "TYA";

  01c12	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88184
  01c19	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 1082 :                 Registers->A = Value = Registers->Y;

  01c20	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01c25	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  01c29	88 84 24 82 00
	00 00		 mov	 BYTE PTR Value$3[rsp], al
  01c30	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01c35	0f b6 8c 24 82
	00 00 00	 movzx	 ecx, BYTE PTR Value$3[rsp]
  01c3d	88 08		 mov	 BYTE PTR [rax], cl
$LN130@cpuTick:

; 1083 :             }
; 1084 :             if(CurrentInstr == 0x9A) // TXS

  01c3f	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01c44	3d 9a 00 00 00	 cmp	 eax, 154		; 0000009aH
  01c49	75 2e		 jne	 SHORT $LN131@cpuTick

; 1085 :             {
; 1086 :                 Log.InstrName = "TXS";

  01c4b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88186
  01c52	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 1087 :                 Registers->StackPtr = Value = Registers->X;

  01c59	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01c5e	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  01c62	88 84 24 82 00
	00 00		 mov	 BYTE PTR Value$3[rsp], al
  01c69	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01c6e	0f b6 8c 24 82
	00 00 00	 movzx	 ecx, BYTE PTR Value$3[rsp]
  01c76	88 48 04	 mov	 BYTE PTR [rax+4], cl
$LN131@cpuTick:

; 1088 :             }
; 1089 :             setNegative(Value, &Registers->Flags);

  01c79	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01c7e	48 83 c0 03	 add	 rax, 3
  01c82	48 8b d0	 mov	 rdx, rax
  01c85	0f b6 8c 24 82
	00 00 00	 movzx	 ecx, BYTE PTR Value$3[rsp]
  01c8d	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 1090 :             setZero(Value, &Registers->Flags);

  01c92	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01c97	48 83 c0 03	 add	 rax, 3
  01c9b	48 8b d0	 mov	 rdx, rax
  01c9e	0f b6 8c 24 82
	00 00 00	 movzx	 ecx, BYTE PTR Value$3[rsp]
  01ca6	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 1091 :             BytesRead = 1;

  01cab	c6 44 24 71 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 1092 :             *CyclesElapsed = 2;

  01cb0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01cb8	c6 00 02	 mov	 BYTE PTR [rax], 2

; 1093 :             break;

  01cbb	e9 95 09 00 00	 jmp	 $LN2@cpuTick
$LN132@cpuTick:

; 1094 :         }
; 1095 : 
; 1096 :         // NOTE: Stack Operations
; 1097 :         
; 1098 :         case 0x48: // PHA - Push accumulator on stack
; 1099 :         {
; 1100 :             pushStack(Registers->A, &Registers->StackPtr, MemoryOffset);

  01cc0	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01cc5	48 83 c0 04	 add	 rax, 4
  01cc9	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  01cd1	48 8b d0	 mov	 rdx, rax
  01cd4	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01cd9	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  01cdc	e8 00 00 00 00	 call	 ?pushStack@@YAXEPEAE_K@Z ; pushStack

; 1101 :             BytesRead = 1;

  01ce1	c6 44 24 71 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 1102 :             *CyclesElapsed = 3;

  01ce6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01cee	c6 00 03	 mov	 BYTE PTR [rax], 3

; 1103 :                    
; 1104 :             Log.InstrName = "PHA";

  01cf1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88188
  01cf8	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 1105 :             break;

  01cff	e9 51 09 00 00	 jmp	 $LN2@cpuTick
$LN133@cpuTick:

; 1106 :         }
; 1107 :         case 0x68: // PLA - Pop to accumulator
; 1108 :         {
; 1109 :             Registers->A = popStack(&Registers->StackPtr, MemoryOffset);

  01d04	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01d09	48 83 c0 04	 add	 rax, 4
  01d0d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01d15	48 8b c8	 mov	 rcx, rax
  01d18	e8 00 00 00 00	 call	 ?popStack@@YAEPEAE_K@Z	; popStack
  01d1d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  01d22	88 01		 mov	 BYTE PTR [rcx], al

; 1110 :             BytesRead = 1;

  01d24	c6 44 24 71 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 1111 :             *CyclesElapsed = 4;

  01d29	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01d31	c6 00 04	 mov	 BYTE PTR [rax], 4

; 1112 : 
; 1113 :             Log.InstrName = "PLA";

  01d34	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88190
  01d3b	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 1114 :             break;

  01d42	e9 0e 09 00 00	 jmp	 $LN2@cpuTick
$LN134@cpuTick:

; 1115 :         }
; 1116 : 
; 1117 :         // NOTE: Increment and Decrement
; 1118 :         
; 1119 :         case 0xCA: case 0x88: case 0xE8: case 0xC8:
; 1120 :         {
; 1121 :             uint8 *Register;
; 1122 :             if(CurrentInstr == 0xCA || CurrentInstr == 0xE8)

  01d47	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01d4c	3d ca 00 00 00	 cmp	 eax, 202		; 000000caH
  01d51	74 0c		 je	 SHORT $LN136@cpuTick
  01d53	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01d58	3d e8 00 00 00	 cmp	 eax, 232		; 000000e8H
  01d5d	75 10		 jne	 SHORT $LN135@cpuTick
$LN136@cpuTick:

; 1123 :                 Register = &Registers->X;

  01d5f	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01d64	48 ff c0	 inc	 rax
  01d67	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR Register$47[rsp], rax
$LN135@cpuTick:

; 1124 :             if(CurrentInstr == 0x88 || CurrentInstr == 0xC8)

  01d6f	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01d74	3d 88 00 00 00	 cmp	 eax, 136		; 00000088H
  01d79	74 0c		 je	 SHORT $LN138@cpuTick
  01d7b	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01d80	3d c8 00 00 00	 cmp	 eax, 200		; 000000c8H
  01d85	75 11		 jne	 SHORT $LN137@cpuTick
$LN138@cpuTick:

; 1125 :                 Register = &Registers->Y;

  01d87	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01d8c	48 83 c0 02	 add	 rax, 2
  01d90	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR Register$47[rsp], rax
$LN137@cpuTick:

; 1126 : 
; 1127 :             if(CurrentInstr == 0xE8 || CurrentInstr == 0xC8) // Increment

  01d98	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01d9d	3d e8 00 00 00	 cmp	 eax, 232		; 000000e8H
  01da2	74 0c		 je	 SHORT $LN140@cpuTick
  01da4	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01da9	3d c8 00 00 00	 cmp	 eax, 200		; 000000c8H
  01dae	75 25		 jne	 SHORT $LN139@cpuTick
$LN140@cpuTick:

; 1128 :             {
; 1129 :                 Log.InstrName = "INC";

  01db0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88198
  01db7	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 1130 :                 *Register += 1;

  01dbe	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR Register$47[rsp]
  01dc6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01dc9	ff c0		 inc	 eax
  01dcb	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR Register$47[rsp]
  01dd3	88 01		 mov	 BYTE PTR [rcx], al
$LN139@cpuTick:

; 1131 :             }
; 1132 :             if(CurrentInstr == 0xCA || CurrentInstr == 0x88) // Decrement

  01dd5	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01dda	3d ca 00 00 00	 cmp	 eax, 202		; 000000caH
  01ddf	74 0c		 je	 SHORT $LN142@cpuTick
  01de1	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01de6	3d 88 00 00 00	 cmp	 eax, 136		; 00000088H
  01deb	75 25		 jne	 SHORT $LN141@cpuTick
$LN142@cpuTick:

; 1133 :             {
; 1134 :                 Log.InstrName = "DEC";

  01ded	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88201
  01df4	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 1135 :                 *Register -= 1;

  01dfb	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR Register$47[rsp]
  01e03	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01e06	ff c8		 dec	 eax
  01e08	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR Register$47[rsp]
  01e10	88 01		 mov	 BYTE PTR [rcx], al
$LN141@cpuTick:

; 1136 :             }
; 1137 :                         
; 1138 :             setNegative(*Register, &Registers->Flags);

  01e12	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01e17	48 83 c0 03	 add	 rax, 3
  01e1b	48 8b d0	 mov	 rdx, rax
  01e1e	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR Register$47[rsp]
  01e26	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  01e29	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 1139 :             setZero(*Register, &Registers->Flags);

  01e2e	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01e33	48 83 c0 03	 add	 rax, 3
  01e37	48 8b d0	 mov	 rdx, rax
  01e3a	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR Register$47[rsp]
  01e42	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  01e45	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 1140 :             BytesRead = 1;

  01e4a	c6 44 24 71 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 1141 :             *CyclesElapsed = 2;

  01e4f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01e57	c6 00 02	 mov	 BYTE PTR [rax], 2

; 1142 :             break;

  01e5a	e9 f6 07 00 00	 jmp	 $LN2@cpuTick
$LN143@cpuTick:

; 1143 :         }
; 1144 : 
; 1145 :         case 0xC6: case 0xD6: case 0xCE: // DEC
; 1146 :         {
; 1147 :             uint16 Address;
; 1148 :             uint8 Value;
; 1149 :             if(CurrentInstr == 0xC6) // ZeroPage

  01e5f	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01e64	3d c6 00 00 00	 cmp	 eax, 198		; 000000c6H
  01e69	75 4f		 jne	 SHORT $LN144@cpuTick

; 1150 :             {
; 1151 :                 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  01e6b	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01e70	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  01e74	ff c0		 inc	 eax
  01e76	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01e7e	0f b7 c8	 movzx	 ecx, ax
  01e81	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  01e86	0f b6 c0	 movzx	 eax, al
  01e89	66 89 84 24 cc
	00 00 00	 mov	 WORD PTR Address$36[rsp], ax

; 1152 :                 Value = zeroPage(Registers, MemoryOffset);

  01e91	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01e99	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  01e9e	e8 00 00 00 00	 call	 ?zeroPage@@YAEPEAUcpuRegisters@@_K@Z ; zeroPage
  01ea3	88 84 24 a9 00
	00 00		 mov	 BYTE PTR Value$12[rsp], al

; 1153 :                 BytesRead = 2;

  01eaa	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 1154 :                 *CyclesElapsed = 5;

  01eaf	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01eb7	c6 00 05	 mov	 BYTE PTR [rax], 5
$LN144@cpuTick:

; 1155 :             }
; 1156 :             if(CurrentInstr == 0xD6) // ZeroPage, X

  01eba	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01ebf	3d d6 00 00 00	 cmp	 eax, 214		; 000000d6H
  01ec4	75 5a		 jne	 SHORT $LN145@cpuTick

; 1157 :             {
; 1158 :                 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset) + Registers->X;

  01ec6	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01ecb	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  01ecf	ff c0		 inc	 eax
  01ed1	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01ed9	0f b7 c8	 movzx	 ecx, ax
  01edc	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  01ee1	0f b6 c0	 movzx	 eax, al
  01ee4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  01ee9	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  01eed	03 c1		 add	 eax, ecx
  01eef	66 89 84 24 cc
	00 00 00	 mov	 WORD PTR Address$36[rsp], ax

; 1159 :                 Value = zeroPageX(Registers, MemoryOffset);

  01ef7	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01eff	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  01f04	e8 00 00 00 00	 call	 ?zeroPageX@@YAEPEAUcpuRegisters@@_K@Z ; zeroPageX
  01f09	88 84 24 a9 00
	00 00		 mov	 BYTE PTR Value$12[rsp], al

; 1160 :                 BytesRead = 2;

  01f10	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 1161 :                 *CyclesElapsed = 6;

  01f15	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01f1d	c6 00 06	 mov	 BYTE PTR [rax], 6
$LN145@cpuTick:

; 1162 :             }
; 1163 :             if(CurrentInstr == 0xCE) // Absolute

  01f20	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01f25	3d ce 00 00 00	 cmp	 eax, 206		; 000000ceH
  01f2a	75 4c		 jne	 SHORT $LN146@cpuTick

; 1164 :             {
; 1165 :                 Address = readCpuMemory16(Registers->PrgCounter + 1, MemoryOffset);

  01f2c	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01f31	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  01f35	ff c0		 inc	 eax
  01f37	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01f3f	0f b7 c8	 movzx	 ecx, ax
  01f42	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  01f47	66 89 84 24 cc
	00 00 00	 mov	 WORD PTR Address$36[rsp], ax

; 1166 :                 Value = abs(Registers, MemoryOffset);

  01f4f	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01f57	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  01f5c	e8 00 00 00 00	 call	 ?abs@@YAEPEAUcpuRegisters@@_K@Z ; abs
  01f61	88 84 24 a9 00
	00 00		 mov	 BYTE PTR Value$12[rsp], al

; 1167 :                 BytesRead = 3;

  01f68	c6 44 24 71 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 1168 :                 *CyclesElapsed = 6;

  01f6d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01f75	c6 00 06	 mov	 BYTE PTR [rax], 6
$LN146@cpuTick:

; 1169 :             }
; 1170 :            
; 1171 :             --Value;

  01f78	0f b6 84 24 a9
	00 00 00	 movzx	 eax, BYTE PTR Value$12[rsp]
  01f80	fe c8		 dec	 al
  01f82	88 84 24 a9 00
	00 00		 mov	 BYTE PTR Value$12[rsp], al

; 1172 :             
; 1173 :             setNegative(Value, &Registers->Flags);

  01f89	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01f8e	48 83 c0 03	 add	 rax, 3
  01f92	48 8b d0	 mov	 rdx, rax
  01f95	0f b6 8c 24 a9
	00 00 00	 movzx	 ecx, BYTE PTR Value$12[rsp]
  01f9d	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 1174 :             setZero(Value, &Registers->Flags);

  01fa2	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01fa7	48 83 c0 03	 add	 rax, 3
  01fab	48 8b d0	 mov	 rdx, rax
  01fae	0f b6 8c 24 a9
	00 00 00	 movzx	 ecx, BYTE PTR Value$12[rsp]
  01fb6	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 1175 : 
; 1176 :             writeCpuMemory8(Value, Address, MemoryOffset);

  01fbb	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  01fc3	0f b7 94 24 cc
	00 00 00	 movzx	 edx, WORD PTR Address$36[rsp]
  01fcb	0f b6 8c 24 a9
	00 00 00	 movzx	 ecx, BYTE PTR Value$12[rsp]
  01fd3	e8 00 00 00 00	 call	 ?writeCpuMemory8@@YAXEG_K@Z ; writeCpuMemory8

; 1177 : 
; 1178 :             Log.InstrName = "DEC";    

  01fd8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88206
  01fdf	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 1179 :             break;

  01fe6	e9 6a 06 00 00	 jmp	 $LN2@cpuTick
$LN147@cpuTick:

; 1180 :         }
; 1181 :         
; 1182 :         case 0xE6: case 0xEE: // INC
; 1183 :         {
; 1184 :             uint16 Address;
; 1185 :             uint8 Value;
; 1186 :             if(CurrentInstr == 0xE6) // Zero Page

  01feb	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01ff0	3d e6 00 00 00	 cmp	 eax, 230		; 000000e6H
  01ff5	75 4f		 jne	 SHORT $LN148@cpuTick

; 1187 :             {
; 1188 :                 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  01ff7	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  01ffc	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  02000	ff c0		 inc	 eax
  02002	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0200a	0f b7 c8	 movzx	 ecx, ax
  0200d	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  02012	0f b6 c0	 movzx	 eax, al
  02015	66 89 84 24 d8
	00 00 00	 mov	 WORD PTR Address$41[rsp], ax

; 1189 :                 Value = zeroPage(Registers, MemoryOffset);

  0201d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  02025	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  0202a	e8 00 00 00 00	 call	 ?zeroPage@@YAEPEAUcpuRegisters@@_K@Z ; zeroPage
  0202f	88 84 24 ab 00
	00 00		 mov	 BYTE PTR Value$14[rsp], al

; 1190 :                 BytesRead = 2;

  02036	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 1191 :                 *CyclesElapsed = 5;

  0203b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  02043	c6 00 05	 mov	 BYTE PTR [rax], 5
$LN148@cpuTick:

; 1192 :             }
; 1193 :             if(CurrentInstr == 0xEE) // Absolute

  02046	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0204b	3d ee 00 00 00	 cmp	 eax, 238		; 000000eeH
  02050	75 4c		 jne	 SHORT $LN149@cpuTick

; 1194 :             {
; 1195 :                 Address = readCpuMemory16(Registers->PrgCounter + 1, MemoryOffset);

  02052	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  02057	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0205b	ff c0		 inc	 eax
  0205d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  02065	0f b7 c8	 movzx	 ecx, ax
  02068	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  0206d	66 89 84 24 d8
	00 00 00	 mov	 WORD PTR Address$41[rsp], ax

; 1196 :                 Value = abs(Registers, MemoryOffset);

  02075	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0207d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  02082	e8 00 00 00 00	 call	 ?abs@@YAEPEAUcpuRegisters@@_K@Z ; abs
  02087	88 84 24 ab 00
	00 00		 mov	 BYTE PTR Value$14[rsp], al

; 1197 :                 BytesRead = 3;

  0208e	c6 44 24 71 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 1198 :                 *CyclesElapsed = 6;

  02093	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  0209b	c6 00 06	 mov	 BYTE PTR [rax], 6
$LN149@cpuTick:

; 1199 :             }
; 1200 : 
; 1201 :             ++Value;

  0209e	0f b6 84 24 ab
	00 00 00	 movzx	 eax, BYTE PTR Value$14[rsp]
  020a6	fe c0		 inc	 al
  020a8	88 84 24 ab 00
	00 00		 mov	 BYTE PTR Value$14[rsp], al

; 1202 :             
; 1203 :             setNegative(Value, &Registers->Flags);

  020af	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  020b4	48 83 c0 03	 add	 rax, 3
  020b8	48 8b d0	 mov	 rdx, rax
  020bb	0f b6 8c 24 ab
	00 00 00	 movzx	 ecx, BYTE PTR Value$14[rsp]
  020c3	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 1204 :             setZero(Value, &Registers->Flags);

  020c8	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  020cd	48 83 c0 03	 add	 rax, 3
  020d1	48 8b d0	 mov	 rdx, rax
  020d4	0f b6 8c 24 ab
	00 00 00	 movzx	 ecx, BYTE PTR Value$14[rsp]
  020dc	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 1205 :             writeCpuMemory8(Value, Address, MemoryOffset);

  020e1	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  020e9	0f b7 94 24 d8
	00 00 00	 movzx	 edx, WORD PTR Address$41[rsp]
  020f1	0f b6 8c 24 ab
	00 00 00	 movzx	 ecx, BYTE PTR Value$14[rsp]
  020f9	e8 00 00 00 00	 call	 ?writeCpuMemory8@@YAXEG_K@Z ; writeCpuMemory8

; 1206 : 
; 1207 :             Log.InstrName = "INC";

  020fe	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88210
  02105	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 1208 :             break;

  0210c	e9 44 05 00 00	 jmp	 $LN2@cpuTick
$LN150@cpuTick:

; 1209 :         }
; 1210 :         
; 1211 :         // NOTE: Add and Subtract with Carry
; 1212 :         
; 1213 :         case 0x69: case 0x65: case 0x6D: case 0x7D:// ADC - add with carry
; 1214 :         {
; 1215 :             uint8 Value;
; 1216 :             if(CurrentInstr == 0x69)// Immediate

  02111	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  02116	83 f8 69	 cmp	 eax, 105		; 00000069H
  02119	75 29		 jne	 SHORT $LN151@cpuTick

; 1217 :             {
; 1218 :                 Value = immediate(Registers, MemoryOffset);

  0211b	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  02123	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  02128	e8 00 00 00 00	 call	 ?immediate@@YAEPEAUcpuRegisters@@_K@Z ; immediate
  0212d	88 84 24 ac 00
	00 00		 mov	 BYTE PTR Value$15[rsp], al

; 1219 :                 BytesRead = 2;

  02134	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 1220 :                 *CyclesElapsed = 2;

  02139	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  02141	c6 00 02	 mov	 BYTE PTR [rax], 2
$LN151@cpuTick:

; 1221 :             }
; 1222 :             if(CurrentInstr == 0x65) // zeropage

  02144	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  02149	83 f8 65	 cmp	 eax, 101		; 00000065H
  0214c	75 29		 jne	 SHORT $LN152@cpuTick

; 1223 :             {
; 1224 :                 Value = zeroPage(Registers, MemoryOffset);

  0214e	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  02156	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  0215b	e8 00 00 00 00	 call	 ?zeroPage@@YAEPEAUcpuRegisters@@_K@Z ; zeroPage
  02160	88 84 24 ac 00
	00 00		 mov	 BYTE PTR Value$15[rsp], al

; 1225 :                 BytesRead = 2;

  02167	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 1226 :                 *CyclesElapsed = 3;

  0216c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  02174	c6 00 03	 mov	 BYTE PTR [rax], 3
$LN152@cpuTick:

; 1227 :             }
; 1228 :             if(CurrentInstr == 0x6D) // Absolute

  02177	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0217c	83 f8 6d	 cmp	 eax, 109		; 0000006dH
  0217f	75 29		 jne	 SHORT $LN153@cpuTick

; 1229 :             {
; 1230 :                 Value = abs(Registers, MemoryOffset);

  02181	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  02189	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  0218e	e8 00 00 00 00	 call	 ?abs@@YAEPEAUcpuRegisters@@_K@Z ; abs
  02193	88 84 24 ac 00
	00 00		 mov	 BYTE PTR Value$15[rsp], al

; 1231 :                 BytesRead = 3;

  0219a	c6 44 24 71 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 1232 :                 *CyclesElapsed = 4;

  0219f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  021a7	c6 00 04	 mov	 BYTE PTR [rax], 4
$LN153@cpuTick:

; 1233 :             }
; 1234 :             if(CurrentInstr == 0x7D) // Absolute, X

  021aa	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  021af	83 f8 7d	 cmp	 eax, 125		; 0000007dH
  021b2	75 29		 jne	 SHORT $LN154@cpuTick

; 1235 :             {
; 1236 :                 Value = absX(Registers, MemoryOffset);

  021b4	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  021bc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  021c1	e8 00 00 00 00	 call	 ?absX@@YAEPEAUcpuRegisters@@_K@Z ; absX
  021c6	88 84 24 ac 00
	00 00		 mov	 BYTE PTR Value$15[rsp], al

; 1237 :                 BytesRead = 3;

  021cd	c6 44 24 71 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 1238 :                 *CyclesElapsed = 4; // TODO: Boundary

  021d2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  021da	c6 00 04	 mov	 BYTE PTR [rax], 4
$LN154@cpuTick:

; 1239 :             }
; 1240 :             adc(Value, Registers);

  021dd	48 8b 54 24 78	 mov	 rdx, QWORD PTR Registers$[rsp]
  021e2	0f b6 8c 24 ac
	00 00 00	 movzx	 ecx, BYTE PTR Value$15[rsp]
  021ea	e8 00 00 00 00	 call	 ?adc@@YAXEPEAUcpuRegisters@@@Z ; adc

; 1241 :             Log.InstrName = "ADC";

  021ef	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88216
  021f6	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 1242 :             break;

  021fd	e9 53 04 00 00	 jmp	 $LN2@cpuTick
$LN155@cpuTick:

; 1243 :         }
; 1244 :         case 0xE1: case 0xF1: // SBC - Subtract with Carry
; 1245 :         {
; 1246 :             uint8 Value;
; 1247 :             if(CurrentInstr == 0xE1) // (Indirect, X)

  02202	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  02207	3d e1 00 00 00	 cmp	 eax, 225		; 000000e1H
  0220c	75 29		 jne	 SHORT $LN156@cpuTick

; 1248 :             {
; 1249 :                 Value = indirectX(Registers, MemoryOffset);

  0220e	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  02216	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  0221b	e8 00 00 00 00	 call	 ?indirectX@@YAEPEAUcpuRegisters@@_K@Z ; indirectX
  02220	88 84 24 b3 00
	00 00		 mov	 BYTE PTR Value$22[rsp], al

; 1250 :                 BytesRead = 2;

  02227	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 1251 :                 *CyclesElapsed = 6;

  0222c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  02234	c6 00 06	 mov	 BYTE PTR [rax], 6
$LN156@cpuTick:

; 1252 :             }
; 1253 :             if(CurrentInstr == 0xF1) // (Indirect), Y

  02237	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0223c	3d f1 00 00 00	 cmp	 eax, 241		; 000000f1H
  02241	75 29		 jne	 SHORT $LN157@cpuTick

; 1254 :             {
; 1255 :                 Value = indirectY(Registers, MemoryOffset); 

  02243	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0224b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  02250	e8 00 00 00 00	 call	 ?indirectY@@YAEPEAUcpuRegisters@@_K@Z ; indirectY
  02255	88 84 24 b3 00
	00 00		 mov	 BYTE PTR Value$22[rsp], al

; 1256 :                 BytesRead = 2;

  0225c	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 1257 :                 *CyclesElapsed = 5; // TODO: Boundary cross is +1

  02261	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  02269	c6 00 05	 mov	 BYTE PTR [rax], 5
$LN157@cpuTick:

; 1258 :             }
; 1259 :             sbc(Value, Registers);

  0226c	48 8b 54 24 78	 mov	 rdx, QWORD PTR Registers$[rsp]
  02271	0f b6 8c 24 b3
	00 00 00	 movzx	 ecx, BYTE PTR Value$22[rsp]
  02279	e8 00 00 00 00	 call	 ?sbc@@YAXEPEAUcpuRegisters@@@Z ; sbc

; 1260 :             Log.InstrName = "SBC";

  0227e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88220
  02285	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 1261 :             break;

  0228c	e9 c4 03 00 00	 jmp	 $LN2@cpuTick
$LN158@cpuTick:

; 1262 :         }
; 1263 :         
; 1264 :         // NOTE: Compare instructions       
; 1265 :         case 0xC9: case 0xC5: case 0xD5: case 0xCD: // CMP
; 1266 :         case 0xDD: case 0xD9: case 0xC1: case 0xD1:
; 1267 :         case 0xE0: case 0xE4: case 0xEC:            // CPX
; 1268 :         case 0xC0: case 0xC4: case 0xCC:            // CPY
; 1269 :         {
; 1270 :             uint8 Value = {};

  02291	c6 84 24 96 00
	00 00 00	 mov	 BYTE PTR Value$7[rsp], 0

; 1271 :             
; 1272 :             if(CurrentInstr == 0xC9 || CurrentInstr == 0xE0 || CurrentInstr == 0xC0) // Immediate

  02299	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0229e	3d c9 00 00 00	 cmp	 eax, 201		; 000000c9H
  022a3	74 18		 je	 SHORT $LN160@cpuTick
  022a5	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  022aa	3d e0 00 00 00	 cmp	 eax, 224		; 000000e0H
  022af	74 0c		 je	 SHORT $LN160@cpuTick
  022b1	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  022b6	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  022bb	75 29		 jne	 SHORT $LN159@cpuTick
$LN160@cpuTick:

; 1273 :             {
; 1274 :                 Value = immediate(Registers, MemoryOffset);

  022bd	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  022c5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  022ca	e8 00 00 00 00	 call	 ?immediate@@YAEPEAUcpuRegisters@@_K@Z ; immediate
  022cf	88 84 24 96 00
	00 00		 mov	 BYTE PTR Value$7[rsp], al

; 1275 :                 BytesRead = 2;

  022d6	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 1276 :                 *CyclesElapsed = 2;

  022db	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  022e3	c6 00 02	 mov	 BYTE PTR [rax], 2
$LN159@cpuTick:

; 1277 :             }
; 1278 :             if(CurrentInstr == 0xC5 || CurrentInstr == 0xE4 || CurrentInstr == 0xC4) // Zero Page

  022e6	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  022eb	3d c5 00 00 00	 cmp	 eax, 197		; 000000c5H
  022f0	74 18		 je	 SHORT $LN162@cpuTick
  022f2	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  022f7	3d e4 00 00 00	 cmp	 eax, 228		; 000000e4H
  022fc	74 0c		 je	 SHORT $LN162@cpuTick
  022fe	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  02303	3d c4 00 00 00	 cmp	 eax, 196		; 000000c4H
  02308	75 29		 jne	 SHORT $LN161@cpuTick
$LN162@cpuTick:

; 1279 :             {
; 1280 :                 Value = zeroPage(Registers, MemoryOffset);

  0230a	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  02312	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  02317	e8 00 00 00 00	 call	 ?zeroPage@@YAEPEAUcpuRegisters@@_K@Z ; zeroPage
  0231c	88 84 24 96 00
	00 00		 mov	 BYTE PTR Value$7[rsp], al

; 1281 :                 BytesRead = 2;

  02323	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 1282 :                 *CyclesElapsed = 3;

  02328	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  02330	c6 00 03	 mov	 BYTE PTR [rax], 3
$LN161@cpuTick:

; 1283 :             }
; 1284 :             if(CurrentInstr == 0xD5) // ZeroPage, X

  02333	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  02338	3d d5 00 00 00	 cmp	 eax, 213		; 000000d5H
  0233d	75 29		 jne	 SHORT $LN163@cpuTick

; 1285 :             {
; 1286 :                 Value = zeroPageX(Registers, MemoryOffset);

  0233f	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  02347	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  0234c	e8 00 00 00 00	 call	 ?zeroPageX@@YAEPEAUcpuRegisters@@_K@Z ; zeroPageX
  02351	88 84 24 96 00
	00 00		 mov	 BYTE PTR Value$7[rsp], al

; 1287 :                 BytesRead = 2;

  02358	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 1288 :                 *CyclesElapsed = 4;

  0235d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  02365	c6 00 04	 mov	 BYTE PTR [rax], 4
$LN163@cpuTick:

; 1289 :             }
; 1290 :             if(CurrentInstr == 0xCD || CurrentInstr == 0xEC || CurrentInstr == 0xCC) // Absolute

  02368	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0236d	3d cd 00 00 00	 cmp	 eax, 205		; 000000cdH
  02372	74 18		 je	 SHORT $LN165@cpuTick
  02374	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  02379	3d ec 00 00 00	 cmp	 eax, 236		; 000000ecH
  0237e	74 0c		 je	 SHORT $LN165@cpuTick
  02380	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  02385	3d cc 00 00 00	 cmp	 eax, 204		; 000000ccH
  0238a	75 29		 jne	 SHORT $LN164@cpuTick
$LN165@cpuTick:

; 1291 :             {
; 1292 :                 Value = abs(Registers, MemoryOffset);

  0238c	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  02394	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  02399	e8 00 00 00 00	 call	 ?abs@@YAEPEAUcpuRegisters@@_K@Z ; abs
  0239e	88 84 24 96 00
	00 00		 mov	 BYTE PTR Value$7[rsp], al

; 1293 :                 BytesRead = 3;

  023a5	c6 44 24 71 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 1294 :                 *CyclesElapsed = 4;

  023aa	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  023b2	c6 00 04	 mov	 BYTE PTR [rax], 4
$LN164@cpuTick:

; 1295 :             }
; 1296 :             if(CurrentInstr == 0xDD) // Absolute, X

  023b5	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  023ba	3d dd 00 00 00	 cmp	 eax, 221		; 000000ddH
  023bf	75 29		 jne	 SHORT $LN166@cpuTick

; 1297 :             {
; 1298 :                 Value = absX(Registers, MemoryOffset);

  023c1	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  023c9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  023ce	e8 00 00 00 00	 call	 ?absX@@YAEPEAUcpuRegisters@@_K@Z ; absX
  023d3	88 84 24 96 00
	00 00		 mov	 BYTE PTR Value$7[rsp], al

; 1299 :                 BytesRead = 3;

  023da	c6 44 24 71 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 1300 :                 *CyclesElapsed = 4; // TODO: **

  023df	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  023e7	c6 00 04	 mov	 BYTE PTR [rax], 4
$LN166@cpuTick:

; 1301 :             }
; 1302 :             if(CurrentInstr == 0xD9) // Absolute, Y

  023ea	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  023ef	3d d9 00 00 00	 cmp	 eax, 217		; 000000d9H
  023f4	75 29		 jne	 SHORT $LN167@cpuTick

; 1303 :             {
; 1304 :                 Value = absY(Registers, MemoryOffset);

  023f6	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  023fe	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  02403	e8 00 00 00 00	 call	 ?absY@@YAEPEAUcpuRegisters@@_K@Z ; absY
  02408	88 84 24 96 00
	00 00		 mov	 BYTE PTR Value$7[rsp], al

; 1305 :                 BytesRead = 3;

  0240f	c6 44 24 71 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 1306 :                 *CyclesElapsed = 4; // TODO: **

  02414	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  0241c	c6 00 04	 mov	 BYTE PTR [rax], 4
$LN167@cpuTick:

; 1307 :             }
; 1308 :             if(CurrentInstr == 0xC1) // Indirect, X

  0241f	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  02424	3d c1 00 00 00	 cmp	 eax, 193		; 000000c1H
  02429	75 29		 jne	 SHORT $LN168@cpuTick

; 1309 :             {
; 1310 :                 Value = indirectX(Registers, MemoryOffset);

  0242b	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  02433	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  02438	e8 00 00 00 00	 call	 ?indirectX@@YAEPEAUcpuRegisters@@_K@Z ; indirectX
  0243d	88 84 24 96 00
	00 00		 mov	 BYTE PTR Value$7[rsp], al

; 1311 :                 BytesRead = 2;

  02444	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 1312 :                 *CyclesElapsed = 6;

  02449	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  02451	c6 00 06	 mov	 BYTE PTR [rax], 6
$LN168@cpuTick:

; 1313 :             }
; 1314 :             if(CurrentInstr == 0xD1) // Indirect, Y

  02454	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  02459	3d d1 00 00 00	 cmp	 eax, 209		; 000000d1H
  0245e	75 29		 jne	 SHORT $LN169@cpuTick

; 1315 :             {
; 1316 :                 Value = indirectY(Registers, MemoryOffset);

  02460	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  02468	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  0246d	e8 00 00 00 00	 call	 ?indirectY@@YAEPEAUcpuRegisters@@_K@Z ; indirectY
  02472	88 84 24 96 00
	00 00		 mov	 BYTE PTR Value$7[rsp], al

; 1317 :                 BytesRead = 2;

  02479	c6 44 24 71 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 1318 :                 *CyclesElapsed = 5; // TODO: Boundary

  0247e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  02486	c6 00 05	 mov	 BYTE PTR [rax], 5
$LN169@cpuTick:

; 1319 :             }            
; 1320 : 
; 1321 :             uint8 ToCompareAgainst;
; 1322 :             switch(CurrentInstr)

  02489	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0248e	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv1205[rsp], eax
  02495	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR tv1205[rsp]
  0249c	2d c0 00 00 00	 sub	 eax, 192		; 000000c0H
  024a1	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv1205[rsp], eax
  024a8	83 bc 24 f0 00
	00 00 2c	 cmp	 DWORD PTR tv1205[rsp], 44 ; 0000002cH
  024b0	0f 87 80 00 00
	00		 ja	 $LN10@cpuTick
  024b6	48 63 84 24 f0
	00 00 00	 movsxd	 rax, DWORD PTR tv1205[rsp]
  024be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  024c5	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN192@cpuTick[rcx+rax]
  024cd	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN193@cpuTick[rcx+rax*4]
  024d4	48 03 c1	 add	 rax, rcx
  024d7	ff e0		 jmp	 rax
$LN170@cpuTick:

; 1323 :             {
; 1324 :                 case 0xC9: case 0xC5: case 0xD5: case 0xCD: // CMP
; 1325 :                 case 0xDD: case 0xD9: case 0xC1: case 0xD1:
; 1326 :                     Log.InstrName = "CMP";

  024d9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88234
  024e0	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 1327 :                     ToCompareAgainst = Registers->A;

  024e7	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  024ec	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  024ef	88 84 24 b0 00
	00 00		 mov	 BYTE PTR ToCompareAgainst$19[rsp], al

; 1328 :                     break;

  024f6	eb 3e		 jmp	 SHORT $LN10@cpuTick
$LN171@cpuTick:

; 1329 :                 case 0xE0: case 0xE4: case 0xEC: // CPX
; 1330 :                     Log.InstrName = "CPX";

  024f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88236
  024ff	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 1331 :                     ToCompareAgainst = Registers->X;

  02506	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0250b	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0250f	88 84 24 b0 00
	00 00		 mov	 BYTE PTR ToCompareAgainst$19[rsp], al

; 1332 :                     break;

  02516	eb 1e		 jmp	 SHORT $LN10@cpuTick
$LN172@cpuTick:

; 1333 :                 case 0xC0: case 0xC4: case 0xCC: // CPY
; 1334 :                     Log.InstrName = "CPY";

  02518	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88238
  0251f	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 1335 :                     ToCompareAgainst = Registers->Y;

  02526	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0252b	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0252f	88 84 24 b0 00
	00 00		 mov	 BYTE PTR ToCompareAgainst$19[rsp], al
$LN10@cpuTick:

; 1336 :                     break;
; 1337 :             }
; 1338 :             cmp(Value, ToCompareAgainst, &Registers->Flags);

  02536	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0253b	48 83 c0 03	 add	 rax, 3
  0253f	4c 8b c0	 mov	 r8, rax
  02542	0f b6 94 24 b0
	00 00 00	 movzx	 edx, BYTE PTR ToCompareAgainst$19[rsp]
  0254a	0f b6 8c 24 96
	00 00 00	 movzx	 ecx, BYTE PTR Value$7[rsp]
  02552	e8 00 00 00 00	 call	 ?cmp@@YAXEEPEAE@Z	; cmp

; 1339 :             break;

  02557	e9 f9 00 00 00	 jmp	 $LN2@cpuTick
$LN173@cpuTick:

; 1340 :         }
; 1341 :        
; 1342 :         // NOTE: Status Flag set and clear opcodes
; 1343 :         case 0x78: case 0xD8: case 0x38: case 0x18: // Set Interrupt Disable Flag
; 1344 :         {
; 1345 :             if(CurrentInstr == 0x78)

  0255c	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  02561	83 f8 78	 cmp	 eax, 120		; 00000078H
  02564	75 11		 jne	 SHORT $LN174@cpuTick

; 1346 :                 setInterrupt(&Registers->Flags);

  02566	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0256b	48 83 c0 03	 add	 rax, 3
  0256f	48 8b c8	 mov	 rcx, rax
  02572	e8 00 00 00 00	 call	 ?setInterrupt@@YAXPEAE@Z ; setInterrupt
$LN174@cpuTick:

; 1347 :             if(CurrentInstr == 0xD8)

  02577	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0257c	3d d8 00 00 00	 cmp	 eax, 216		; 000000d8H
  02581	75 11		 jne	 SHORT $LN175@cpuTick

; 1348 :                 clearDecimal(&Registers->Flags);

  02583	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  02588	48 83 c0 03	 add	 rax, 3
  0258c	48 8b c8	 mov	 rcx, rax
  0258f	e8 00 00 00 00	 call	 ?clearDecimal@@YAXPEAE@Z ; clearDecimal
$LN175@cpuTick:

; 1349 :             if(CurrentInstr == 0x38)

  02594	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  02599	83 f8 38	 cmp	 eax, 56			; 00000038H
  0259c	75 11		 jne	 SHORT $LN176@cpuTick

; 1350 :                 setCarry(&Registers->Flags);

  0259e	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  025a3	48 83 c0 03	 add	 rax, 3
  025a7	48 8b c8	 mov	 rcx, rax
  025aa	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry
$LN176@cpuTick:

; 1351 :             if(CurrentInstr == 0x18)

  025af	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  025b4	83 f8 18	 cmp	 eax, 24
  025b7	75 11		 jne	 SHORT $LN177@cpuTick

; 1352 :                 clearCarry(&Registers->Flags);

  025b9	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  025be	48 83 c0 03	 add	 rax, 3
  025c2	48 8b c8	 mov	 rcx, rax
  025c5	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN177@cpuTick:

; 1353 :             BytesRead = 1;

  025ca	c6 44 24 71 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 1354 :             *CyclesElapsed = 2;

  025cf	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  025d7	c6 00 02	 mov	 BYTE PTR [rax], 2

; 1355 :             Log.InstrName = "FLG";

  025da	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88244
  025e1	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 1356 :             break;

  025e8	eb 6b		 jmp	 SHORT $LN2@cpuTick
$LN178@cpuTick:

; 1357 :         }
; 1358 : 
; 1359 :         case 0xEA: // NOP
; 1360 :         {
; 1361 :             BytesRead = 1;

  025ea	c6 44 24 71 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 1362 :             *CyclesElapsed = 2;

  025ef	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  025f7	c6 00 02	 mov	 BYTE PTR [rax], 2

; 1363 :             Log.InstrName = "NOP";

  025fa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88246
  02601	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?Log@@3UcpuLog@@A+8, rax

; 1364 :             break;

  02608	eb 4b		 jmp	 SHORT $LN2@cpuTick
$LN179@cpuTick:

; 1365 :         }
; 1366 : 
; 1367 :         default:
; 1368 :         {
; 1369 :             uint8 MissingValue = CurrentInstr;

  0260a	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0260f	88 84 24 bf 00
	00 00		 mov	 BYTE PTR MissingValue$31[rsp], al

; 1370 :             char Buffer[8];
; 1371 :             sprintf(Buffer, "%X\n", MissingValue);

  02616	0f b6 84 24 bf
	00 00 00	 movzx	 eax, BYTE PTR MissingValue$31[rsp]
  0261e	44 8b c0	 mov	 r8d, eax
  02621	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG88248
  02628	48 8d 8c 24 48
	01 00 00	 lea	 rcx, QWORD PTR Buffer$53[rsp]
  02630	e8 00 00 00 00	 call	 sprintf

; 1372 :             OutputDebugString(Buffer);

  02635	48 8d 8c 24 48
	01 00 00	 lea	 rcx, QWORD PTR Buffer$53[rsp]
  0263d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 1373 :             Assert(0);

  02643	33 c0		 xor	 eax, eax
  02645	83 f8 01	 cmp	 eax, 1
  02648	74 0b		 je	 SHORT $LN180@cpuTick
  0264a	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN180@cpuTick:
$LN2@cpuTick:

; 1374 :             break;
; 1375 :         }
; 1376 :     }
; 1377 : 
; 1378 : #if 1
; 1379 :     
; 1380 :     char LogBuffer[512];
; 1381 : 
; 1382 :     if(BytesRead != 0)

  02655	0f b6 44 24 71	 movzx	 eax, BYTE PTR BytesRead$[rsp]
  0265a	85 c0		 test	 eax, eax
  0265c	74 0b		 je	 SHORT $LN181@cpuTick

; 1383 :         Log.BytesRead = BytesRead;

  0265e	0f b6 44 24 71	 movzx	 eax, BYTE PTR BytesRead$[rsp]
  02663	88 05 13 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+19, al
$LN181@cpuTick:

; 1384 : 
; 1385 :     
; 1386 :     
; 1387 :     switch(Log.BytesRead)

  02669	0f b6 05 13 00
	00 00		 movzx	 eax, BYTE PTR ?Log@@3UcpuLog@@A+19
  02670	88 84 24 fc 00
	00 00		 mov	 BYTE PTR tv1274[rsp], al
  02677	80 bc 24 fc 00
	00 00 01	 cmp	 BYTE PTR tv1274[rsp], 1
  0267f	74 21		 je	 SHORT $LN182@cpuTick
  02681	80 bc 24 fc 00
	00 00 02	 cmp	 BYTE PTR tv1274[rsp], 2
  02689	0f 84 41 01 00
	00		 je	 $LN185@cpuTick
  0268f	80 bc 24 fc 00
	00 00 03	 cmp	 BYTE PTR tv1274[rsp], 3
  02697	0f 84 73 02 00
	00		 je	 $LN188@cpuTick
  0269d	e9 bf 03 00 00	 jmp	 $LN12@cpuTick
$LN182@cpuTick:

; 1388 :     {
; 1389 :         case 1:
; 1390 :         {
; 1391 :             if(Log.AddressValue)

  026a2	0f b6 05 12 00
	00 00		 movzx	 eax, BYTE PTR ?Log@@3UcpuLog@@A+18
  026a9	85 c0		 test	 eax, eax
  026ab	0f 84 95 00 00
	00		 je	 $LN183@cpuTick

; 1392 :                 sprintf(LogBuffer, "$%.4X:%.2X        %s $%.4X = $%.2X        A:%.2X X:%.2X, Y:%.2X S:%.2X P:%X\n",

  026b1	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  026b6	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  026ba	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  026bf	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  026c3	48 8b 54 24 78	 mov	 rdx, QWORD PTR Registers$[rsp]
  026c8	0f b6 52 02	 movzx	 edx, BYTE PTR [rdx+2]
  026cc	48 8b 7c 24 78	 mov	 rdi, QWORD PTR Registers$[rsp]
  026d1	0f b6 7f 01	 movzx	 edi, BYTE PTR [rdi+1]
  026d5	48 8b 74 24 78	 mov	 rsi, QWORD PTR Registers$[rsp]
  026da	0f b6 36	 movzx	 esi, BYTE PTR [rsi]
  026dd	44 0f b6 05 12
	00 00 00	 movzx	 r8d, BYTE PTR ?Log@@3UcpuLog@@A+18
  026e5	44 0f b7 0d 10
	00 00 00	 movzx	 r9d, WORD PTR ?Log@@3UcpuLog@@A+16
  026ed	44 0f b6 15 02
	00 00 00	 movzx	 r10d, BYTE PTR ?Log@@3UcpuLog@@A+2
  026f5	44 0f b7 1d 00
	00 00 00	 movzx	 r11d, WORD PTR ?Log@@3UcpuLog@@A
  026fd	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  02701	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  02705	89 54 24 48	 mov	 DWORD PTR [rsp+72], edx
  02709	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  0270d	89 74 24 38	 mov	 DWORD PTR [rsp+56], esi
  02711	44 89 44 24 30	 mov	 DWORD PTR [rsp+48], r8d
  02716	44 89 4c 24 28	 mov	 DWORD PTR [rsp+40], r9d
  0271b	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR ?Log@@3UcpuLog@@A+8
  02722	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02727	45 8b ca	 mov	 r9d, r10d
  0272a	45 8b c3	 mov	 r8d, r11d
  0272d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG88254
  02734	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR LogBuffer$[rsp]
  0273c	e8 00 00 00 00	 call	 sprintf

; 1393 :                         Log.ProgramLine, Log.Instr, Log.InstrName, Log.InstrAddress, Log.AddressValue,
; 1394 :                         Registers->A, Registers->X, Registers->Y, Registers->StackPtr, Registers->Flags);
; 1395 :             else

  02741	e9 85 00 00 00	 jmp	 $LN184@cpuTick
$LN183@cpuTick:

; 1396 :                 sprintf(LogBuffer, "$%.4X:%.2X        %s                      A:%.2X X:%2X, Y:%.2X S:%.2X P:%X\n",

  02746	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  0274b	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0274f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  02754	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  02758	48 8b 54 24 78	 mov	 rdx, QWORD PTR Registers$[rsp]
  0275d	0f b6 52 02	 movzx	 edx, BYTE PTR [rdx+2]
  02761	48 8b 7c 24 78	 mov	 rdi, QWORD PTR Registers$[rsp]
  02766	0f b6 7f 01	 movzx	 edi, BYTE PTR [rdi+1]
  0276a	48 8b 74 24 78	 mov	 rsi, QWORD PTR Registers$[rsp]
  0276f	0f b6 36	 movzx	 esi, BYTE PTR [rsi]
  02772	44 0f b6 05 02
	00 00 00	 movzx	 r8d, BYTE PTR ?Log@@3UcpuLog@@A+2
  0277a	44 0f b7 0d 00
	00 00 00	 movzx	 r9d, WORD PTR ?Log@@3UcpuLog@@A
  02782	44 89 8c 24 24
	01 00 00	 mov	 DWORD PTR tv1322[rsp], r9d
  0278a	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  0278e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  02792	89 54 24 38	 mov	 DWORD PTR [rsp+56], edx
  02796	89 7c 24 30	 mov	 DWORD PTR [rsp+48], edi
  0279a	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  0279e	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR ?Log@@3UcpuLog@@A+8
  027a5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  027aa	45 8b c8	 mov	 r9d, r8d
  027ad	8b 84 24 24 01
	00 00		 mov	 eax, DWORD PTR tv1322[rsp]
  027b4	44 8b c0	 mov	 r8d, eax
  027b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG88255
  027be	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR LogBuffer$[rsp]
  027c6	e8 00 00 00 00	 call	 sprintf
$LN184@cpuTick:

; 1397 :                         Log.ProgramLine, Log.Instr, Log.InstrName,
; 1398 :                         Registers->A, Registers->X, Registers->Y, Registers->StackPtr, Registers->Flags);
; 1399 :             
; 1400 : 
; 1401 :             break;

  027cb	e9 91 02 00 00	 jmp	 $LN12@cpuTick
$LN185@cpuTick:

; 1402 :         }
; 1403 :         case 2:
; 1404 :         {
; 1405 :             if(Log.AddressValue)

  027d0	0f b6 05 12 00
	00 00		 movzx	 eax, BYTE PTR ?Log@@3UcpuLog@@A+18
  027d7	85 c0		 test	 eax, eax
  027d9	0f 84 a1 00 00
	00		 je	 $LN186@cpuTick

; 1406 :                 sprintf(LogBuffer, "$%.4X:%2X %2X     %s $%.4X = $%.2X          A:%.2X X:%.2X, Y:%.2X S:%.2X P:%X\n",

  027df	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  027e4	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  027e8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  027ed	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  027f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR Registers$[rsp]
  027f6	0f b6 52 02	 movzx	 edx, BYTE PTR [rdx+2]
  027fa	48 8b 7c 24 78	 mov	 rdi, QWORD PTR Registers$[rsp]
  027ff	0f b6 7f 01	 movzx	 edi, BYTE PTR [rdi+1]
  02803	48 8b 74 24 78	 mov	 rsi, QWORD PTR Registers$[rsp]
  02808	0f b6 36	 movzx	 esi, BYTE PTR [rsi]
  0280b	44 0f b6 05 12
	00 00 00	 movzx	 r8d, BYTE PTR ?Log@@3UcpuLog@@A+18
  02813	44 0f b7 0d 10
	00 00 00	 movzx	 r9d, WORD PTR ?Log@@3UcpuLog@@A+16
  0281b	44 0f b6 15 03
	00 00 00	 movzx	 r10d, BYTE PTR ?Log@@3UcpuLog@@A+3
  02823	44 0f b6 1d 02
	00 00 00	 movzx	 r11d, BYTE PTR ?Log@@3UcpuLog@@A+2
  0282b	0f b7 1d 00 00
	00 00		 movzx	 ebx, WORD PTR ?Log@@3UcpuLog@@A
  02832	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  02836	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0283a	89 54 24 50	 mov	 DWORD PTR [rsp+80], edx
  0283e	89 7c 24 48	 mov	 DWORD PTR [rsp+72], edi
  02842	89 74 24 40	 mov	 DWORD PTR [rsp+64], esi
  02846	44 89 44 24 38	 mov	 DWORD PTR [rsp+56], r8d
  0284b	44 89 4c 24 30	 mov	 DWORD PTR [rsp+48], r9d
  02850	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR ?Log@@3UcpuLog@@A+8
  02857	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0285c	44 89 54 24 20	 mov	 DWORD PTR [rsp+32], r10d
  02861	45 8b cb	 mov	 r9d, r11d
  02864	44 8b c3	 mov	 r8d, ebx
  02867	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG88259
  0286e	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR LogBuffer$[rsp]
  02876	e8 00 00 00 00	 call	 sprintf

; 1407 :                         Log.ProgramLine, Log.Instr, Log.InstrValue1, Log.InstrName, Log.InstrAddress, Log.AddressValue,
; 1408 :                         Registers->A, Registers->X, Registers->Y, Registers->StackPtr, Registers->Flags);
; 1409 :             else

  0287b	e9 8b 00 00 00	 jmp	 $LN187@cpuTick
$LN186@cpuTick:

; 1410 :                 sprintf(LogBuffer, "$%.4X:%2X %2X     %s $%.4X                A:%.2X X:%.2X, Y:%.2X S:%.2X P:%X\n",

  02880	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  02885	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  02889	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  0288e	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  02892	48 8b 54 24 78	 mov	 rdx, QWORD PTR Registers$[rsp]
  02897	0f b6 52 02	 movzx	 edx, BYTE PTR [rdx+2]
  0289b	48 8b 5c 24 78	 mov	 rbx, QWORD PTR Registers$[rsp]
  028a0	0f b6 5b 01	 movzx	 ebx, BYTE PTR [rbx+1]
  028a4	48 8b 7c 24 78	 mov	 rdi, QWORD PTR Registers$[rsp]
  028a9	0f b6 3f	 movzx	 edi, BYTE PTR [rdi]
  028ac	0f b7 35 10 00
	00 00		 movzx	 esi, WORD PTR ?Log@@3UcpuLog@@A+16
  028b3	44 0f b6 05 03
	00 00 00	 movzx	 r8d, BYTE PTR ?Log@@3UcpuLog@@A+3
  028bb	44 0f b6 0d 02
	00 00 00	 movzx	 r9d, BYTE PTR ?Log@@3UcpuLog@@A+2
  028c3	44 0f b7 15 00
	00 00 00	 movzx	 r10d, WORD PTR ?Log@@3UcpuLog@@A
  028cb	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  028cf	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  028d3	89 54 24 48	 mov	 DWORD PTR [rsp+72], edx
  028d7	89 5c 24 40	 mov	 DWORD PTR [rsp+64], ebx
  028db	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  028df	89 74 24 30	 mov	 DWORD PTR [rsp+48], esi
  028e3	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR ?Log@@3UcpuLog@@A+8
  028ea	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  028ef	44 89 44 24 20	 mov	 DWORD PTR [rsp+32], r8d
  028f4	45 8b c2	 mov	 r8d, r10d
  028f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG88260
  028fe	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR LogBuffer$[rsp]
  02906	e8 00 00 00 00	 call	 sprintf
$LN187@cpuTick:

; 1411 :                         Log.ProgramLine, Log.Instr, Log.InstrValue1, Log.InstrName, Log.InstrAddress, 
; 1412 :                         Registers->A, Registers->X, Registers->Y, Registers->StackPtr, Registers->Flags);
; 1413 :             
; 1414 :                 break;

  0290b	e9 51 01 00 00	 jmp	 $LN12@cpuTick
$LN188@cpuTick:

; 1415 :         }
; 1416 :         case 3:
; 1417 :         {
; 1418 :             if(Log.AddressValue)

  02910	0f b6 05 12 00
	00 00		 movzx	 eax, BYTE PTR ?Log@@3UcpuLog@@A+18
  02917	85 c0		 test	 eax, eax
  02919	0f 84 ac 00 00
	00		 je	 $LN189@cpuTick

; 1419 :                 sprintf(LogBuffer, "$%.4X:%.2X %.2X %.2X  %s $%.4X = $%.2X          A:%.2X X:%.2X, Y:%.2X S:%.2X P:%X\n",

  0291f	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  02924	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  02928	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  0292d	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  02931	48 8b 54 24 78	 mov	 rdx, QWORD PTR Registers$[rsp]
  02936	0f b6 52 02	 movzx	 edx, BYTE PTR [rdx+2]
  0293a	48 8b 5c 24 78	 mov	 rbx, QWORD PTR Registers$[rsp]
  0293f	0f b6 5b 01	 movzx	 ebx, BYTE PTR [rbx+1]
  02943	48 8b 7c 24 78	 mov	 rdi, QWORD PTR Registers$[rsp]
  02948	0f b6 3f	 movzx	 edi, BYTE PTR [rdi]
  0294b	0f b6 35 12 00
	00 00		 movzx	 esi, BYTE PTR ?Log@@3UcpuLog@@A+18
  02952	44 0f b7 05 10
	00 00 00	 movzx	 r8d, WORD PTR ?Log@@3UcpuLog@@A+16
  0295a	44 0f b6 0d 04
	00 00 00	 movzx	 r9d, BYTE PTR ?Log@@3UcpuLog@@A+4
  02962	44 0f b6 15 03
	00 00 00	 movzx	 r10d, BYTE PTR ?Log@@3UcpuLog@@A+3
  0296a	44 0f b6 1d 02
	00 00 00	 movzx	 r11d, BYTE PTR ?Log@@3UcpuLog@@A+2
  02972	0f b7 2d 00 00
	00 00		 movzx	 ebp, WORD PTR ?Log@@3UcpuLog@@A
  02979	89 44 24 68	 mov	 DWORD PTR [rsp+104], eax
  0297d	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  02981	89 54 24 58	 mov	 DWORD PTR [rsp+88], edx
  02985	89 5c 24 50	 mov	 DWORD PTR [rsp+80], ebx
  02989	89 7c 24 48	 mov	 DWORD PTR [rsp+72], edi
  0298d	89 74 24 40	 mov	 DWORD PTR [rsp+64], esi
  02991	44 89 44 24 38	 mov	 DWORD PTR [rsp+56], r8d
  02996	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR ?Log@@3UcpuLog@@A+8
  0299d	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  029a2	44 89 4c 24 28	 mov	 DWORD PTR [rsp+40], r9d
  029a7	44 89 54 24 20	 mov	 DWORD PTR [rsp+32], r10d
  029ac	45 8b cb	 mov	 r9d, r11d
  029af	44 8b c5	 mov	 r8d, ebp
  029b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG88264
  029b9	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR LogBuffer$[rsp]
  029c1	e8 00 00 00 00	 call	 sprintf

; 1420 :                     Log.ProgramLine, Log.Instr, Log.InstrValue1, Log.InstrValue2, Log.InstrName, Log.InstrAddress, Log.AddressValue,
; 1421 :                         Registers->A, Registers->X, Registers->Y, Registers->StackPtr, Registers->Flags);
; 1422 :             
; 1423 :             else

  029c6	e9 96 00 00 00	 jmp	 $LN190@cpuTick
$LN189@cpuTick:

; 1424 :                 sprintf(LogBuffer, "$%.4X:%.2X %.2X %.2X  %s $%.4X                A:%.2X X:%.2X, Y:%.2X S:%.2X P:%X\n",

  029cb	48 8b 44 24 78	 mov	 rax, QWORD PTR Registers$[rsp]
  029d0	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  029d4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  029d9	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  029dd	48 8b 54 24 78	 mov	 rdx, QWORD PTR Registers$[rsp]
  029e2	0f b6 52 02	 movzx	 edx, BYTE PTR [rdx+2]
  029e6	48 8b 5c 24 78	 mov	 rbx, QWORD PTR Registers$[rsp]
  029eb	0f b6 5b 01	 movzx	 ebx, BYTE PTR [rbx+1]
  029ef	48 8b 7c 24 78	 mov	 rdi, QWORD PTR Registers$[rsp]
  029f4	0f b6 3f	 movzx	 edi, BYTE PTR [rdi]
  029f7	0f b7 35 10 00
	00 00		 movzx	 esi, WORD PTR ?Log@@3UcpuLog@@A+16
  029fe	0f b6 2d 04 00
	00 00		 movzx	 ebp, BYTE PTR ?Log@@3UcpuLog@@A+4
  02a05	44 0f b6 05 03
	00 00 00	 movzx	 r8d, BYTE PTR ?Log@@3UcpuLog@@A+3
  02a0d	44 0f b6 0d 02
	00 00 00	 movzx	 r9d, BYTE PTR ?Log@@3UcpuLog@@A+2
  02a15	44 0f b7 15 00
	00 00 00	 movzx	 r10d, WORD PTR ?Log@@3UcpuLog@@A
  02a1d	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  02a21	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  02a25	89 54 24 50	 mov	 DWORD PTR [rsp+80], edx
  02a29	89 5c 24 48	 mov	 DWORD PTR [rsp+72], ebx
  02a2d	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  02a31	89 74 24 38	 mov	 DWORD PTR [rsp+56], esi
  02a35	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR ?Log@@3UcpuLog@@A+8
  02a3c	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  02a41	89 6c 24 28	 mov	 DWORD PTR [rsp+40], ebp
  02a45	44 89 44 24 20	 mov	 DWORD PTR [rsp+32], r8d
  02a4a	45 8b c2	 mov	 r8d, r10d
  02a4d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG88265
  02a54	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR LogBuffer$[rsp]
  02a5c	e8 00 00 00 00	 call	 sprintf
$LN190@cpuTick:
$LN12@cpuTick:

; 1425 :                         Log.ProgramLine, Log.Instr, Log.InstrValue1, Log.InstrValue2, Log.InstrName, Log.InstrAddress,
; 1426 :                         Registers->A, Registers->X, Registers->Y, Registers->StackPtr, Registers->Flags);
; 1427 :                 
; 1428 :             break;
; 1429 :         }
; 1430 :     }
; 1431 :     
; 1432 : 
; 1433 :     OutputDebugString(LogBuffer);

  02a61	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR LogBuffer$[rsp]
  02a69	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 1434 : 
; 1435 : 
; 1436 : #endif
; 1437 :    
; 1438 :     Registers->PrgCounter += BytesRead;

  02a6f	0f b6 44 24 71	 movzx	 eax, BYTE PTR BytesRead$[rsp]
  02a74	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  02a79	0f b7 49 06	 movzx	 ecx, WORD PTR [rcx+6]
  02a7d	03 c8		 add	 ecx, eax
  02a7f	8b c1		 mov	 eax, ecx
  02a81	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Registers$[rsp]
  02a86	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 1439 :     linecount++;

  02a8a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?linecount@?1??cpuTick@@YAXPEAUcpu@@@Z@4_KA
  02a91	48 ff c0	 inc	 rax
  02a94	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?linecount@?1??cpuTick@@YAXPEAUcpu@@@Z@4_KA, rax

; 1440 :     /*
; 1441 :     if(NMICalled)
; 1442 :     {
; 1443 :         NMICalled = false;
; 1444 : 
; 1445 :         uint8 HighByte = (uint8)(Registers->PrgCounter >> 8);
; 1446 :         uint8 LowByte = (uint8)Registers->PrgCounter;
; 1447 :                         
; 1448 :         pushStack(HighByte, &Registers->StackPtr, MemoryOffset);
; 1449 :         pushStack(LowByte, &Registers->StackPtr, MemoryOffset);
; 1450 : 
; 1451 :         setInterrupt(&Registers->Flags);
; 1452 :         pushStack(Registers->Flags, &Registers->StackPtr, MemoryOffset);
; 1453 : 
; 1454 :         Registers->PrgCounter = readCpuMemory16(NMI_VEC, MemoryOffset);
; 1455 :            
; 1456 :         BytesRead = 0; // TODO: Check this
; 1457 :         *CyclesElapsed = *CyclesElapsed + 7;        
; 1458 :     }
; 1459 :     */
; 1460 : }

  02a9b	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  02aa3	48 33 cc	 xor	 rcx, rsp
  02aa6	e8 00 00 00 00	 call	 __security_check_cookie
  02aab	48 81 c4 68 03
	00 00		 add	 rsp, 872		; 00000368H
  02ab2	5f		 pop	 rdi
  02ab3	5e		 pop	 rsi
  02ab4	5d		 pop	 rbp
  02ab5	5b		 pop	 rbx
  02ab6	c3		 ret	 0
  02ab7	90		 npad	 1
$LN201@cpuTick:
  02ab8	00 00 00 00	 DD	 $LN15@cpuTick
  02abc	00 00 00 00	 DD	 $LN106@cpuTick
  02ac0	00 00 00 00	 DD	 $LN71@cpuTick
  02ac4	00 00 00 00	 DD	 $LN74@cpuTick
  02ac8	00 00 00 00	 DD	 $LN23@cpuTick
  02acc	00 00 00 00	 DD	 $LN173@cpuTick
  02ad0	00 00 00 00	 DD	 $LN17@cpuTick
  02ad4	00 00 00 00	 DD	 $LN103@cpuTick
  02ad8	00 00 00 00	 DD	 $LN87@cpuTick
  02adc	00 00 00 00	 DD	 $LN83@cpuTick
  02ae0	00 00 00 00	 DD	 $LN16@cpuTick
  02ae4	00 00 00 00	 DD	 $LN80@cpuTick
  02ae8	00 00 00 00	 DD	 $LN132@cpuTick
  02aec	00 00 00 00	 DD	 $LN77@cpuTick
  02af0	00 00 00 00	 DD	 $LN19@cpuTick
  02af4	00 00 00 00	 DD	 $LN18@cpuTick
  02af8	00 00 00 00	 DD	 $LN150@cpuTick
  02afc	00 00 00 00	 DD	 $LN97@cpuTick
  02b00	00 00 00 00	 DD	 $LN133@cpuTick
  02b04	00 00 00 00	 DD	 $LN93@cpuTick
  02b08	00 00 00 00	 DD	 $LN20@cpuTick
  02b0c	00 00 00 00	 DD	 $LN54@cpuTick
  02b10	00 00 00 00	 DD	 $LN134@cpuTick
  02b14	00 00 00 00	 DD	 $LN126@cpuTick
  02b18	00 00 00 00	 DD	 $LN33@cpuTick
  02b1c	00 00 00 00	 DD	 $LN158@cpuTick
  02b20	00 00 00 00	 DD	 $LN143@cpuTick
  02b24	00 00 00 00	 DD	 $LN155@cpuTick
  02b28	00 00 00 00	 DD	 $LN147@cpuTick
  02b2c	00 00 00 00	 DD	 $LN178@cpuTick
  02b30	00 00 00 00	 DD	 $LN179@cpuTick
$LN200@cpuTick:
  02b34	00		 DB	 0
  02b35	01		 DB	 1
  02b36	1e		 DB	 30
  02b37	1e		 DB	 30
  02b38	1e		 DB	 30
  02b39	01		 DB	 1
  02b3a	02		 DB	 2
  02b3b	1e		 DB	 30
  02b3c	1e		 DB	 30
  02b3d	01		 DB	 1
  02b3e	03		 DB	 3
  02b3f	1e		 DB	 30
  02b40	1e		 DB	 30
  02b41	01		 DB	 1
  02b42	1e		 DB	 30
  02b43	1e		 DB	 30
  02b44	04		 DB	 4
  02b45	01		 DB	 1
  02b46	1e		 DB	 30
  02b47	1e		 DB	 30
  02b48	1e		 DB	 30
  02b49	01		 DB	 1
  02b4a	1e		 DB	 30
  02b4b	1e		 DB	 30
  02b4c	05		 DB	 5
  02b4d	01		 DB	 1
  02b4e	1e		 DB	 30
  02b4f	1e		 DB	 30
  02b50	1e		 DB	 30
  02b51	01		 DB	 1
  02b52	1e		 DB	 30
  02b53	1e		 DB	 30
  02b54	06		 DB	 6
  02b55	01		 DB	 1
  02b56	1e		 DB	 30
  02b57	1e		 DB	 30
  02b58	07		 DB	 7
  02b59	01		 DB	 1
  02b5a	08		 DB	 8
  02b5b	1e		 DB	 30
  02b5c	1e		 DB	 30
  02b5d	01		 DB	 1
  02b5e	09		 DB	 9
  02b5f	1e		 DB	 30
  02b60	1e		 DB	 30
  02b61	01		 DB	 1
  02b62	1e		 DB	 30
  02b63	1e		 DB	 30
  02b64	04		 DB	 4
  02b65	01		 DB	 1
  02b66	1e		 DB	 30
  02b67	1e		 DB	 30
  02b68	1e		 DB	 30
  02b69	01		 DB	 1
  02b6a	08		 DB	 8
  02b6b	1e		 DB	 30
  02b6c	05		 DB	 5
  02b6d	01		 DB	 1
  02b6e	1e		 DB	 30
  02b6f	1e		 DB	 30
  02b70	1e		 DB	 30
  02b71	01		 DB	 1
  02b72	1e		 DB	 30
  02b73	1e		 DB	 30
  02b74	0a		 DB	 10
  02b75	01		 DB	 1
  02b76	1e		 DB	 30
  02b77	1e		 DB	 30
  02b78	1e		 DB	 30
  02b79	01		 DB	 1
  02b7a	0b		 DB	 11
  02b7b	1e		 DB	 30
  02b7c	0c		 DB	 12
  02b7d	01		 DB	 1
  02b7e	0d		 DB	 13
  02b7f	1e		 DB	 30
  02b80	0e		 DB	 14
  02b81	01		 DB	 1
  02b82	1e		 DB	 30
  02b83	1e		 DB	 30
  02b84	04		 DB	 4
  02b85	01		 DB	 1
  02b86	1e		 DB	 30
  02b87	1e		 DB	 30
  02b88	1e		 DB	 30
  02b89	01		 DB	 1
  02b8a	1e		 DB	 30
  02b8b	1e		 DB	 30
  02b8c	1e		 DB	 30
  02b8d	01		 DB	 1
  02b8e	1e		 DB	 30
  02b8f	1e		 DB	 30
  02b90	1e		 DB	 30
  02b91	01		 DB	 1
  02b92	1e		 DB	 30
  02b93	1e		 DB	 30
  02b94	0f		 DB	 15
  02b95	1e		 DB	 30
  02b96	1e		 DB	 30
  02b97	1e		 DB	 30
  02b98	1e		 DB	 30
  02b99	10		 DB	 16
  02b9a	11		 DB	 17
  02b9b	1e		 DB	 30
  02b9c	12		 DB	 18
  02b9d	10		 DB	 16
  02b9e	13		 DB	 19
  02b9f	1e		 DB	 30
  02ba0	14		 DB	 20
  02ba1	10		 DB	 16
  02ba2	11		 DB	 17
  02ba3	1e		 DB	 30
  02ba4	04		 DB	 4
  02ba5	1e		 DB	 30
  02ba6	1e		 DB	 30
  02ba7	1e		 DB	 30
  02ba8	1e		 DB	 30
  02ba9	1e		 DB	 30
  02baa	1e		 DB	 30
  02bab	1e		 DB	 30
  02bac	05		 DB	 5
  02bad	1e		 DB	 30
  02bae	1e		 DB	 30
  02baf	1e		 DB	 30
  02bb0	1e		 DB	 30
  02bb1	10		 DB	 16
  02bb2	1e		 DB	 30
  02bb3	1e		 DB	 30
  02bb4	1e		 DB	 30
  02bb5	15		 DB	 21
  02bb6	1e		 DB	 30
  02bb7	1e		 DB	 30
  02bb8	15		 DB	 21
  02bb9	15		 DB	 21
  02bba	15		 DB	 21
  02bbb	1e		 DB	 30
  02bbc	16		 DB	 22
  02bbd	1e		 DB	 30
  02bbe	17		 DB	 23
  02bbf	1e		 DB	 30
  02bc0	15		 DB	 21
  02bc1	15		 DB	 21
  02bc2	15		 DB	 21
  02bc3	1e		 DB	 30
  02bc4	04		 DB	 4
  02bc5	15		 DB	 21
  02bc6	1e		 DB	 30
  02bc7	1e		 DB	 30
  02bc8	15		 DB	 21
  02bc9	15		 DB	 21
  02bca	15		 DB	 21
  02bcb	1e		 DB	 30
  02bcc	17		 DB	 23
  02bcd	15		 DB	 21
  02bce	17		 DB	 23
  02bcf	1e		 DB	 30
  02bd0	1e		 DB	 30
  02bd1	15		 DB	 21
  02bd2	1e		 DB	 30
  02bd3	1e		 DB	 30
  02bd4	18		 DB	 24
  02bd5	18		 DB	 24
  02bd6	18		 DB	 24
  02bd7	1e		 DB	 30
  02bd8	18		 DB	 24
  02bd9	18		 DB	 24
  02bda	18		 DB	 24
  02bdb	1e		 DB	 30
  02bdc	17		 DB	 23
  02bdd	18		 DB	 24
  02bde	17		 DB	 23
  02bdf	1e		 DB	 30
  02be0	18		 DB	 24
  02be1	18		 DB	 24
  02be2	18		 DB	 24
  02be3	1e		 DB	 30
  02be4	04		 DB	 4
  02be5	18		 DB	 24
  02be6	1e		 DB	 30
  02be7	1e		 DB	 30
  02be8	18		 DB	 24
  02be9	18		 DB	 24
  02bea	18		 DB	 24
  02beb	1e		 DB	 30
  02bec	1e		 DB	 30
  02bed	18		 DB	 24
  02bee	1e		 DB	 30
  02bef	1e		 DB	 30
  02bf0	18		 DB	 24
  02bf1	18		 DB	 24
  02bf2	18		 DB	 24
  02bf3	1e		 DB	 30
  02bf4	19		 DB	 25
  02bf5	19		 DB	 25
  02bf6	1e		 DB	 30
  02bf7	1e		 DB	 30
  02bf8	19		 DB	 25
  02bf9	19		 DB	 25
  02bfa	1a		 DB	 26
  02bfb	1e		 DB	 30
  02bfc	16		 DB	 22
  02bfd	19		 DB	 25
  02bfe	16		 DB	 22
  02bff	1e		 DB	 30
  02c00	19		 DB	 25
  02c01	19		 DB	 25
  02c02	1a		 DB	 26
  02c03	1e		 DB	 30
  02c04	04		 DB	 4
  02c05	19		 DB	 25
  02c06	1e		 DB	 30
  02c07	1e		 DB	 30
  02c08	1e		 DB	 30
  02c09	19		 DB	 25
  02c0a	1a		 DB	 26
  02c0b	1e		 DB	 30
  02c0c	05		 DB	 5
  02c0d	19		 DB	 25
  02c0e	1e		 DB	 30
  02c0f	1e		 DB	 30
  02c10	1e		 DB	 30
  02c11	19		 DB	 25
  02c12	1e		 DB	 30
  02c13	1e		 DB	 30
  02c14	19		 DB	 25
  02c15	1b		 DB	 27
  02c16	1e		 DB	 30
  02c17	1e		 DB	 30
  02c18	19		 DB	 25
  02c19	1e		 DB	 30
  02c1a	1c		 DB	 28
  02c1b	1e		 DB	 30
  02c1c	16		 DB	 22
  02c1d	1e		 DB	 30
  02c1e	1d		 DB	 29
  02c1f	1e		 DB	 30
  02c20	19		 DB	 25
  02c21	1e		 DB	 30
  02c22	1c		 DB	 28
  02c23	1e		 DB	 30
  02c24	04		 DB	 4
  02c25	1b		 DB	 27
  02c26	66 90		 npad	 2
$LN199@cpuTick:
  02c28	00 00 00 00	 DD	 $LN51@cpuTick
  02c2c	00 00 00 00	 DD	 $LN49@cpuTick
  02c30	00 00 00 00	 DD	 $LN50@cpuTick
  02c34	00 00 00 00	 DD	 $LN52@cpuTick
$LN198@cpuTick:
  02c38	00		 DB	 0
  02c39	01		 DB	 1
  02c3a	02		 DB	 2
  02c3b	03		 DB	 3
  02c3c	00		 DB	 0
  02c3d	01		 DB	 1
  02c3e	02		 DB	 2
  02c3f	03		 DB	 3
  02c40	03		 DB	 3
  02c41	01		 DB	 1
  02c42	03		 DB	 3
  02c43	03		 DB	 3
  02c44	00		 DB	 0
  02c45	01		 DB	 1
  02c46	02		 DB	 2
  02c47	03		 DB	 3
  02c48	03		 DB	 3
  02c49	01		 DB	 1
  02c4a	03		 DB	 3
  02c4b	03		 DB	 3
  02c4c	00		 DB	 0
  02c4d	01		 DB	 1
  02c4e	02		 DB	 2
  02c4f	03		 DB	 3
  02c50	03		 DB	 3
  02c51	01		 DB	 1
  02c52	03		 DB	 3
  02c53	03		 DB	 3
  02c54	00		 DB	 0
  02c55	01		 DB	 1
  02c56	02		 DB	 2
  02c57	90		 npad	 1
$LN197@cpuTick:
  02c58	00 00 00 00	 DD	 $LN66@cpuTick
  02c5c	00 00 00 00	 DD	 $LN68@cpuTick
  02c60	00 00 00 00	 DD	 $LN67@cpuTick
  02c64	00 00 00 00	 DD	 $LN69@cpuTick
$LN196@cpuTick:
  02c68	00		 DB	 0
  02c69	03		 DB	 3
  02c6a	03		 DB	 3
  02c6b	01		 DB	 1
  02c6c	00		 DB	 0
  02c6d	02		 DB	 2
  02c6e	03		 DB	 3
  02c6f	03		 DB	 3
  02c70	03		 DB	 3
  02c71	03		 DB	 3
  02c72	03		 DB	 3
  02c73	01		 DB	 1
  02c74	00		 DB	 0
  02c75	02		 DB	 2
  02c76	03		 DB	 3
  02c77	03		 DB	 3
  02c78	00		 DB	 0
  02c79	03		 DB	 3
  02c7a	03		 DB	 3
  02c7b	01		 DB	 1
  02c7c	00		 DB	 0
  02c7d	02		 DB	 2
  02c7e	03		 DB	 3
  02c7f	03		 DB	 3
  02c80	00		 DB	 0
  02c81	03		 DB	 3
  02c82	03		 DB	 3
  02c83	03		 DB	 3
  02c84	00		 DB	 0
  02c85	0f 1f 00	 npad	 3
$LN195@cpuTick:
  02c88	00 00 00 00	 DD	 $LN125@cpuTick
  02c8c	00 00 00 00	 DD	 $LN123@cpuTick
  02c90	00 00 00 00	 DD	 $LN124@cpuTick
  02c94	00 00 00 00	 DD	 $LN8@cpuTick
$LN194@cpuTick:
  02c98	00		 DB	 0
  02c99	03		 DB	 3
  02c9a	03		 DB	 3
  02c9b	03		 DB	 3
  02c9c	00		 DB	 0
  02c9d	03		 DB	 3
  02c9e	03		 DB	 3
  02c9f	03		 DB	 3
  02ca0	00		 DB	 0
  02ca1	03		 DB	 3
  02ca2	03		 DB	 3
  02ca3	03		 DB	 3
  02ca4	00		 DB	 0
  02ca5	03		 DB	 3
  02ca6	03		 DB	 3
  02ca7	03		 DB	 3
  02ca8	00		 DB	 0
  02ca9	03		 DB	 3
  02caa	03		 DB	 3
  02cab	03		 DB	 3
  02cac	00		 DB	 0
  02cad	03		 DB	 3
  02cae	03		 DB	 3
  02caf	03		 DB	 3
  02cb0	00		 DB	 0
  02cb1	03		 DB	 3
  02cb2	03		 DB	 3
  02cb3	03		 DB	 3
  02cb4	00		 DB	 0
  02cb5	03		 DB	 3
  02cb6	03		 DB	 3
  02cb7	03		 DB	 3
  02cb8	01		 DB	 1
  02cb9	03		 DB	 3
  02cba	03		 DB	 3
  02cbb	03		 DB	 3
  02cbc	01		 DB	 1
  02cbd	03		 DB	 3
  02cbe	03		 DB	 3
  02cbf	03		 DB	 3
  02cc0	01		 DB	 1
  02cc1	03		 DB	 3
  02cc2	03		 DB	 3
  02cc3	03		 DB	 3
  02cc4	01		 DB	 1
  02cc5	03		 DB	 3
  02cc6	03		 DB	 3
  02cc7	03		 DB	 3
  02cc8	01		 DB	 1
  02cc9	03		 DB	 3
  02cca	03		 DB	 3
  02ccb	03		 DB	 3
  02ccc	01		 DB	 1
  02ccd	03		 DB	 3
  02cce	03		 DB	 3
  02ccf	03		 DB	 3
  02cd0	01		 DB	 1
  02cd1	03		 DB	 3
  02cd2	03		 DB	 3
  02cd3	03		 DB	 3
  02cd4	01		 DB	 1
  02cd5	03		 DB	 3
  02cd6	03		 DB	 3
  02cd7	03		 DB	 3
  02cd8	02		 DB	 2
  02cd9	03		 DB	 3
  02cda	03		 DB	 3
  02cdb	03		 DB	 3
  02cdc	02		 DB	 2
  02cdd	03		 DB	 3
  02cde	03		 DB	 3
  02cdf	03		 DB	 3
  02ce0	02		 DB	 2
  02ce1	03		 DB	 3
  02ce2	03		 DB	 3
  02ce3	03		 DB	 3
  02ce4	02		 DB	 2
  02ce5	03		 DB	 3
  02ce6	03		 DB	 3
  02ce7	03		 DB	 3
  02ce8	02		 DB	 2
  02ce9	03		 DB	 3
  02cea	03		 DB	 3
  02ceb	03		 DB	 3
  02cec	02		 DB	 2
  02ced	03		 DB	 3
  02cee	03		 DB	 3
  02cef	03		 DB	 3
  02cf0	02		 DB	 2
  02cf1	03		 DB	 3
  02cf2	03		 DB	 3
  02cf3	03		 DB	 3
  02cf4	02		 DB	 2
  02cf5	0f 1f 00	 npad	 3
$LN193@cpuTick:
  02cf8	00 00 00 00	 DD	 $LN172@cpuTick
  02cfc	00 00 00 00	 DD	 $LN170@cpuTick
  02d00	00 00 00 00	 DD	 $LN171@cpuTick
  02d04	00 00 00 00	 DD	 $LN10@cpuTick
$LN192@cpuTick:
  02d08	00		 DB	 0
  02d09	01		 DB	 1
  02d0a	03		 DB	 3
  02d0b	03		 DB	 3
  02d0c	00		 DB	 0
  02d0d	01		 DB	 1
  02d0e	03		 DB	 3
  02d0f	03		 DB	 3
  02d10	03		 DB	 3
  02d11	01		 DB	 1
  02d12	03		 DB	 3
  02d13	03		 DB	 3
  02d14	00		 DB	 0
  02d15	01		 DB	 1
  02d16	03		 DB	 3
  02d17	03		 DB	 3
  02d18	03		 DB	 3
  02d19	01		 DB	 1
  02d1a	03		 DB	 3
  02d1b	03		 DB	 3
  02d1c	03		 DB	 3
  02d1d	01		 DB	 1
  02d1e	03		 DB	 3
  02d1f	03		 DB	 3
  02d20	03		 DB	 3
  02d21	01		 DB	 1
  02d22	03		 DB	 3
  02d23	03		 DB	 3
  02d24	03		 DB	 3
  02d25	01		 DB	 1
  02d26	03		 DB	 3
  02d27	03		 DB	 3
  02d28	02		 DB	 2
  02d29	03		 DB	 3
  02d2a	03		 DB	 3
  02d2b	03		 DB	 3
  02d2c	02		 DB	 2
  02d2d	03		 DB	 3
  02d2e	03		 DB	 3
  02d2f	03		 DB	 3
  02d30	03		 DB	 3
  02d31	03		 DB	 3
  02d32	03		 DB	 3
  02d33	03		 DB	 3
  02d34	02		 DB	 2
?cpuTick@@YAXPEAUcpu@@@Z ENDP				; cpuTick
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Value$ = 0
Address$ = 8
StackPointer$ = 32
MemoryOffset$ = 40
?popStack@@YAEPEAE_K@Z PROC				; popStack

; 377  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 378  :     *StackPointer += 1;    

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR StackPointer$[rsp]
  00013	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00016	ff c0		 inc	 eax
  00018	48 8b 4c 24 20	 mov	 rcx, QWORD PTR StackPointer$[rsp]
  0001d	88 01		 mov	 BYTE PTR [rcx], al

; 379  :     uint8 *Address = (uint8 *)((*StackPointer + STACK_ADRS) + MemoryOffset);

  0001f	48 8b 44 24 20	 mov	 rax, QWORD PTR StackPointer$[rsp]
  00024	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00027	05 00 01 00 00	 add	 eax, 256		; 00000100H
  0002c	48 98		 cdqe
  0002e	48 03 44 24 28	 add	 rax, QWORD PTR MemoryOffset$[rsp]
  00033	48 89 44 24 08	 mov	 QWORD PTR Address$[rsp], rax

; 380  :     uint8 Value = *Address;

  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR Address$[rsp]
  0003d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00040	88 04 24	 mov	 BYTE PTR Value$[rsp], al

; 381  :     *Address = 0;

  00043	48 8b 44 24 08	 mov	 rax, QWORD PTR Address$[rsp]
  00048	c6 00 00	 mov	 BYTE PTR [rax], 0

; 382  :     return(Value);

  0004b	0f b6 04 24	 movzx	 eax, BYTE PTR Value$[rsp]

; 383  : }

  0004f	48 83 c4 18	 add	 rsp, 24
  00053	c3		 ret	 0
?popStack@@YAEPEAE_K@Z ENDP				; popStack
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Address$ = 0
Byte$ = 32
StackPointer$ = 40
MemoryOffset$ = 48
?pushStack@@YAXEPEAE_K@Z PROC				; pushStack

; 371  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	48 83 ec 18	 sub	 rsp, 24

; 372  :     uint8 *Address = (uint8 *)((*StackPointer + STACK_ADRS) + MemoryOffset);

  00012	48 8b 44 24 28	 mov	 rax, QWORD PTR StackPointer$[rsp]
  00017	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001a	05 00 01 00 00	 add	 eax, 256		; 00000100H
  0001f	48 98		 cdqe
  00021	48 03 44 24 30	 add	 rax, QWORD PTR MemoryOffset$[rsp]
  00026	48 89 04 24	 mov	 QWORD PTR Address$[rsp], rax

; 373  :     *Address = Byte;

  0002a	48 8b 04 24	 mov	 rax, QWORD PTR Address$[rsp]
  0002e	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Byte$[rsp]
  00033	88 08		 mov	 BYTE PTR [rax], cl

; 374  :     *StackPointer -= 1;  

  00035	48 8b 44 24 28	 mov	 rax, QWORD PTR StackPointer$[rsp]
  0003a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003d	ff c8		 dec	 eax
  0003f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR StackPointer$[rsp]
  00044	88 01		 mov	 BYTE PTR [rcx], al

; 375  : }

  00046	48 83 c4 18	 add	 rsp, 24
  0004a	c3		 ret	 0
?pushStack@@YAXEPEAE_K@Z ENDP				; pushStack
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?relative@@YACPEAUcpuRegisters@@_K@Z
_TEXT	SEGMENT
Value$ = 32
Registers$ = 64
MemoryOffset$ = 72
?relative@@YACPEAUcpuRegisters@@_K@Z PROC		; relative, COMDAT

; 358  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 359  :     int8 Value = (int8)readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00013	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00017	ff c0		 inc	 eax
  00019	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0001e	0f b7 c8	 movzx	 ecx, ax
  00021	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 360  : 
; 361  :     Log.InstrValue1 = Value;

  0002a	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  0002f	88 05 03 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+3, al

; 362  :     Log.InstrAddress = Value;

  00035	66 0f be 44 24
	20		 movsx	 ax, BYTE PTR Value$[rsp]
  0003b	66 89 05 10 00
	00 00		 mov	 WORD PTR ?Log@@3UcpuLog@@A+16, ax

; 363  :     
; 364  :     return(Value);

  00042	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]

; 365  : }

  00047	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004b	c3		 ret	 0
?relative@@YACPEAUcpuRegisters@@_K@Z ENDP		; relative
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?indirectY@@YAEPEAUcpuRegisters@@_K@Z
_TEXT	SEGMENT
ZeroAddress$ = 32
Value$ = 33
FinalAddress$ = 36
IndirectAddress$ = 40
Registers$ = 64
MemoryOffset$ = 72
?indirectY@@YAEPEAUcpuRegisters@@_K@Z PROC		; indirectY, COMDAT

; 345  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 346  :     uint8 ZeroAddress = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset); 

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00013	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00017	ff c0		 inc	 eax
  00019	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0001e	0f b7 c8	 movzx	 ecx, ax
  00021	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00026	88 44 24 20	 mov	 BYTE PTR ZeroAddress$[rsp], al

; 347  :     uint16 IndirectAddress = readCpuMemory16(ZeroAddress, MemoryOffset);

  0002a	0f b6 44 24 20	 movzx	 eax, BYTE PTR ZeroAddress$[rsp]
  0002f	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00034	0f b7 c8	 movzx	 ecx, ax
  00037	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  0003c	66 89 44 24 28	 mov	 WORD PTR IndirectAddress$[rsp], ax

; 348  :     uint16 FinalAddress = IndirectAddress + Registers->Y;

  00041	0f b7 44 24 28	 movzx	 eax, WORD PTR IndirectAddress$[rsp]
  00046	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Registers$[rsp]
  0004b	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  0004f	03 c1		 add	 eax, ecx
  00051	66 89 44 24 24	 mov	 WORD PTR FinalAddress$[rsp], ax

; 349  :     uint8 Value = readCpuMemory8(FinalAddress, MemoryOffset);

  00056	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0005b	0f b7 4c 24 24	 movzx	 ecx, WORD PTR FinalAddress$[rsp]
  00060	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00065	88 44 24 21	 mov	 BYTE PTR Value$[rsp], al

; 350  :    
; 351  :     Log.InstrValue1 = ZeroAddress;

  00069	0f b6 44 24 20	 movzx	 eax, BYTE PTR ZeroAddress$[rsp]
  0006e	88 05 03 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+3, al

; 352  :     Log.InstrAddress = FinalAddress;

  00074	0f b7 44 24 24	 movzx	 eax, WORD PTR FinalAddress$[rsp]
  00079	66 89 05 10 00
	00 00		 mov	 WORD PTR ?Log@@3UcpuLog@@A+16, ax

; 353  :     Log.AddressValue = Value;

  00080	0f b6 44 24 21	 movzx	 eax, BYTE PTR Value$[rsp]
  00085	88 05 12 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+18, al

; 354  :     
; 355  :     return(Value);

  0008b	0f b6 44 24 21	 movzx	 eax, BYTE PTR Value$[rsp]

; 356  : }

  00090	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00094	c3		 ret	 0
?indirectY@@YAEPEAUcpuRegisters@@_K@Z ENDP		; indirectY
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?indirectX@@YAEPEAUcpuRegisters@@_K@Z
_TEXT	SEGMENT
ZeroAddress$ = 32
Value$ = 33
NewAddress$ = 34
IndirectAddress$ = 36
Registers$ = 64
MemoryOffset$ = 72
?indirectX@@YAEPEAUcpuRegisters@@_K@Z PROC		; indirectX, COMDAT

; 332  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 333  :     uint8 ZeroAddress = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00013	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00017	ff c0		 inc	 eax
  00019	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0001e	0f b7 c8	 movzx	 ecx, ax
  00021	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00026	88 44 24 20	 mov	 BYTE PTR ZeroAddress$[rsp], al

; 334  :     uint8 NewAddress = ZeroAddress + Registers->X;

  0002a	0f b6 44 24 20	 movzx	 eax, BYTE PTR ZeroAddress$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Registers$[rsp]
  00034	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00038	03 c1		 add	 eax, ecx
  0003a	88 44 24 22	 mov	 BYTE PTR NewAddress$[rsp], al

; 335  :     uint16 IndirectAddress = readCpuMemory16(NewAddress, MemoryOffset);

  0003e	0f b6 44 24 22	 movzx	 eax, BYTE PTR NewAddress$[rsp]
  00043	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00048	0f b7 c8	 movzx	 ecx, ax
  0004b	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  00050	66 89 44 24 24	 mov	 WORD PTR IndirectAddress$[rsp], ax

; 336  :     uint8 Value = readCpuMemory8(IndirectAddress, MemoryOffset);

  00055	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0005a	0f b7 4c 24 24	 movzx	 ecx, WORD PTR IndirectAddress$[rsp]
  0005f	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00064	88 44 24 21	 mov	 BYTE PTR Value$[rsp], al

; 337  : 
; 338  :     Log.InstrValue1 = ZeroAddress;

  00068	0f b6 44 24 20	 movzx	 eax, BYTE PTR ZeroAddress$[rsp]
  0006d	88 05 03 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+3, al

; 339  :     Log.InstrAddress = IndirectAddress;

  00073	0f b7 44 24 24	 movzx	 eax, WORD PTR IndirectAddress$[rsp]
  00078	66 89 05 10 00
	00 00		 mov	 WORD PTR ?Log@@3UcpuLog@@A+16, ax

; 340  :     Log.AddressValue = Value;

  0007f	0f b6 44 24 21	 movzx	 eax, BYTE PTR Value$[rsp]
  00084	88 05 12 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+18, al

; 341  :     
; 342  :     return(Value);

  0008a	0f b6 44 24 21	 movzx	 eax, BYTE PTR Value$[rsp]

; 343  : }

  0008f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00093	c3		 ret	 0
?indirectX@@YAEPEAUcpuRegisters@@_K@Z ENDP		; indirectX
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?absY@@YAEPEAUcpuRegisters@@_K@Z
_TEXT	SEGMENT
Value$ = 32
Address$ = 36
NewAdrs$ = 40
Registers$ = 64
MemoryOffset$ = 72
?absY@@YAEPEAUcpuRegisters@@_K@Z PROC			; absY, COMDAT

; 318  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 319  :     uint16 Address = readCpuMemory16(Registers->PrgCounter + 1, MemoryOffset);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00013	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00017	ff c0		 inc	 eax
  00019	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0001e	0f b7 c8	 movzx	 ecx, ax
  00021	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  00026	66 89 44 24 24	 mov	 WORD PTR Address$[rsp], ax

; 320  :     uint16 NewAdrs = Address + Registers->Y;

  0002b	0f b7 44 24 24	 movzx	 eax, WORD PTR Address$[rsp]
  00030	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Registers$[rsp]
  00035	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  00039	03 c1		 add	 eax, ecx
  0003b	66 89 44 24 28	 mov	 WORD PTR NewAdrs$[rsp], ax

; 321  :     uint8 Value = readCpuMemory8(NewAdrs, MemoryOffset);

  00040	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00045	0f b7 4c 24 28	 movzx	 ecx, WORD PTR NewAdrs$[rsp]
  0004a	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  0004f	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 322  : 
; 323  :     
; 324  :     Log.InstrValue1 = Address;

  00053	0f b6 44 24 24	 movzx	 eax, BYTE PTR Address$[rsp]
  00058	88 05 03 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+3, al

; 325  :     Log.InstrValue2 = Address >> 8;

  0005e	0f b7 44 24 24	 movzx	 eax, WORD PTR Address$[rsp]
  00063	c1 f8 08	 sar	 eax, 8
  00066	88 05 04 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+4, al

; 326  :     Log.InstrAddress = NewAdrs;

  0006c	0f b7 44 24 28	 movzx	 eax, WORD PTR NewAdrs$[rsp]
  00071	66 89 05 10 00
	00 00		 mov	 WORD PTR ?Log@@3UcpuLog@@A+16, ax

; 327  :     Log.AddressValue = Value;

  00078	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  0007d	88 05 12 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+18, al

; 328  :     
; 329  :     return(Value);

  00083	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]

; 330  : }

  00088	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008c	c3		 ret	 0
?absY@@YAEPEAUcpuRegisters@@_K@Z ENDP			; absY
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?absX@@YAEPEAUcpuRegisters@@_K@Z
_TEXT	SEGMENT
Value$ = 32
Address$ = 36
NewAdrs$ = 40
Registers$ = 64
MemoryOffset$ = 72
?absX@@YAEPEAUcpuRegisters@@_K@Z PROC			; absX, COMDAT

; 304  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 305  :     uint16 Address = readCpuMemory16(Registers->PrgCounter + 1, MemoryOffset);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00013	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00017	ff c0		 inc	 eax
  00019	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0001e	0f b7 c8	 movzx	 ecx, ax
  00021	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  00026	66 89 44 24 24	 mov	 WORD PTR Address$[rsp], ax

; 306  :     uint16 NewAdrs = Address + Registers->X;

  0002b	0f b7 44 24 24	 movzx	 eax, WORD PTR Address$[rsp]
  00030	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Registers$[rsp]
  00035	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00039	03 c1		 add	 eax, ecx
  0003b	66 89 44 24 28	 mov	 WORD PTR NewAdrs$[rsp], ax

; 307  :     uint8 Value = readCpuMemory8(NewAdrs, MemoryOffset);

  00040	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00045	0f b7 4c 24 28	 movzx	 ecx, WORD PTR NewAdrs$[rsp]
  0004a	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  0004f	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 308  : 
; 309  :     
; 310  :     Log.InstrValue1 = Address;

  00053	0f b6 44 24 24	 movzx	 eax, BYTE PTR Address$[rsp]
  00058	88 05 03 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+3, al

; 311  :     Log.InstrValue2 = Address >> 8;

  0005e	0f b7 44 24 24	 movzx	 eax, WORD PTR Address$[rsp]
  00063	c1 f8 08	 sar	 eax, 8
  00066	88 05 04 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+4, al

; 312  :     Log.InstrAddress = NewAdrs;

  0006c	0f b7 44 24 28	 movzx	 eax, WORD PTR NewAdrs$[rsp]
  00071	66 89 05 10 00
	00 00		 mov	 WORD PTR ?Log@@3UcpuLog@@A+16, ax

; 313  :     Log.AddressValue = Value;

  00078	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  0007d	88 05 12 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+18, al

; 314  :     
; 315  :     return(Value);

  00083	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]

; 316  : }

  00088	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008c	c3		 ret	 0
?absX@@YAEPEAUcpuRegisters@@_K@Z ENDP			; absX
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?abs@@YAEPEAUcpuRegisters@@_K@Z
_TEXT	SEGMENT
Value$ = 32
Address$ = 36
Registers$ = 64
MemoryOffset$ = 72
?abs@@YAEPEAUcpuRegisters@@_K@Z PROC			; abs, COMDAT

; 292  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 293  :     uint16 Address = readCpuMemory16(Registers->PrgCounter + 1, MemoryOffset);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00013	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00017	ff c0		 inc	 eax
  00019	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0001e	0f b7 c8	 movzx	 ecx, ax
  00021	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  00026	66 89 44 24 24	 mov	 WORD PTR Address$[rsp], ax

; 294  :     uint8 Value = readCpuMemory8(Address, MemoryOffset);

  0002b	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00030	0f b7 4c 24 24	 movzx	 ecx, WORD PTR Address$[rsp]
  00035	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  0003a	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 295  : 
; 296  :     Log.InstrValue1 = Address;

  0003e	0f b6 44 24 24	 movzx	 eax, BYTE PTR Address$[rsp]
  00043	88 05 03 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+3, al

; 297  :     Log.InstrValue2 = Address >> 8;

  00049	0f b7 44 24 24	 movzx	 eax, WORD PTR Address$[rsp]
  0004e	c1 f8 08	 sar	 eax, 8
  00051	88 05 04 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+4, al

; 298  :     Log.InstrAddress = Address;

  00057	0f b7 44 24 24	 movzx	 eax, WORD PTR Address$[rsp]
  0005c	66 89 05 10 00
	00 00		 mov	 WORD PTR ?Log@@3UcpuLog@@A+16, ax

; 299  :     Log.AddressValue = Value;

  00063	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  00068	88 05 12 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+18, al

; 300  :     
; 301  :     return(Value);

  0006e	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]

; 302  : }

  00073	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00077	c3		 ret	 0
?abs@@YAEPEAUcpuRegisters@@_K@Z ENDP			; abs
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?zeroPageY@@YAEPEAUcpuRegisters@@_K@Z
_TEXT	SEGMENT
Address$ = 32
Value$ = 33
AddressBefore$ = 34
Registers$ = 64
MemoryOffset$ = 72
?zeroPageY@@YAEPEAUcpuRegisters@@_K@Z PROC		; zeroPageY, COMDAT

; 279  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 280  :     uint8 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00013	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00017	ff c0		 inc	 eax
  00019	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0001e	0f b7 c8	 movzx	 ecx, ax
  00021	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00026	88 44 24 20	 mov	 BYTE PTR Address$[rsp], al

; 281  :     uint8 AddressBefore = Address;

  0002a	0f b6 44 24 20	 movzx	 eax, BYTE PTR Address$[rsp]
  0002f	88 44 24 22	 mov	 BYTE PTR AddressBefore$[rsp], al

; 282  :     Address += Registers->Y;

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00038	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0003c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Address$[rsp]
  00041	03 c8		 add	 ecx, eax
  00043	8b c1		 mov	 eax, ecx
  00045	88 44 24 20	 mov	 BYTE PTR Address$[rsp], al

; 283  :     uint8 Value = readCpuMemory8(Address, MemoryOffset);

  00049	0f b6 44 24 20	 movzx	 eax, BYTE PTR Address$[rsp]
  0004e	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00053	0f b7 c8	 movzx	 ecx, ax
  00056	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  0005b	88 44 24 21	 mov	 BYTE PTR Value$[rsp], al

; 284  : 
; 285  :     Log.InstrValue1 = AddressBefore;

  0005f	0f b6 44 24 22	 movzx	 eax, BYTE PTR AddressBefore$[rsp]
  00064	88 05 03 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+3, al

; 286  :     Log.InstrAddress = Address;

  0006a	0f b6 44 24 20	 movzx	 eax, BYTE PTR Address$[rsp]
  0006f	66 89 05 10 00
	00 00		 mov	 WORD PTR ?Log@@3UcpuLog@@A+16, ax

; 287  :     Log.AddressValue = Value;

  00076	0f b6 44 24 21	 movzx	 eax, BYTE PTR Value$[rsp]
  0007b	88 05 12 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+18, al

; 288  :     
; 289  :     return(Value);

  00081	0f b6 44 24 21	 movzx	 eax, BYTE PTR Value$[rsp]

; 290  : }

  00086	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008a	c3		 ret	 0
?zeroPageY@@YAEPEAUcpuRegisters@@_K@Z ENDP		; zeroPageY
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?zeroPageX@@YAEPEAUcpuRegisters@@_K@Z
_TEXT	SEGMENT
Address$ = 32
Value$ = 33
AddressBefore$ = 34
Registers$ = 64
MemoryOffset$ = 72
?zeroPageX@@YAEPEAUcpuRegisters@@_K@Z PROC		; zeroPageX, COMDAT

; 266  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 267  :     uint8 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00013	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00017	ff c0		 inc	 eax
  00019	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0001e	0f b7 c8	 movzx	 ecx, ax
  00021	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00026	88 44 24 20	 mov	 BYTE PTR Address$[rsp], al

; 268  :     uint8 AddressBefore = Address;

  0002a	0f b6 44 24 20	 movzx	 eax, BYTE PTR Address$[rsp]
  0002f	88 44 24 22	 mov	 BYTE PTR AddressBefore$[rsp], al

; 269  :     Address += Registers->X;

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00038	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0003c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Address$[rsp]
  00041	03 c8		 add	 ecx, eax
  00043	8b c1		 mov	 eax, ecx
  00045	88 44 24 20	 mov	 BYTE PTR Address$[rsp], al

; 270  :     uint8 Value = readCpuMemory8(Address, MemoryOffset);

  00049	0f b6 44 24 20	 movzx	 eax, BYTE PTR Address$[rsp]
  0004e	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00053	0f b7 c8	 movzx	 ecx, ax
  00056	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  0005b	88 44 24 21	 mov	 BYTE PTR Value$[rsp], al

; 271  : 
; 272  :     Log.InstrValue1 = AddressBefore;

  0005f	0f b6 44 24 22	 movzx	 eax, BYTE PTR AddressBefore$[rsp]
  00064	88 05 03 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+3, al

; 273  :     Log.InstrAddress = Address;

  0006a	0f b6 44 24 20	 movzx	 eax, BYTE PTR Address$[rsp]
  0006f	66 89 05 10 00
	00 00		 mov	 WORD PTR ?Log@@3UcpuLog@@A+16, ax

; 274  :     Log.AddressValue = Value;

  00076	0f b6 44 24 21	 movzx	 eax, BYTE PTR Value$[rsp]
  0007b	88 05 12 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+18, al

; 275  :     
; 276  :     return(Value);

  00081	0f b6 44 24 21	 movzx	 eax, BYTE PTR Value$[rsp]

; 277  : }

  00086	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008a	c3		 ret	 0
?zeroPageX@@YAEPEAUcpuRegisters@@_K@Z ENDP		; zeroPageX
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?zeroPage@@YAEPEAUcpuRegisters@@_K@Z
_TEXT	SEGMENT
Address$ = 32
Value$ = 33
Registers$ = 64
MemoryOffset$ = 72
?zeroPage@@YAEPEAUcpuRegisters@@_K@Z PROC		; zeroPage, COMDAT

; 256  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 257  :     uint8 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00013	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00017	ff c0		 inc	 eax
  00019	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0001e	0f b7 c8	 movzx	 ecx, ax
  00021	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00026	88 44 24 20	 mov	 BYTE PTR Address$[rsp], al

; 258  :     uint8 Value = readCpuMemory8(Address, MemoryOffset);

  0002a	0f b6 44 24 20	 movzx	 eax, BYTE PTR Address$[rsp]
  0002f	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00034	0f b7 c8	 movzx	 ecx, ax
  00037	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  0003c	88 44 24 21	 mov	 BYTE PTR Value$[rsp], al

; 259  : 
; 260  :     Log.InstrAddress = Log.InstrValue1 = Address;

  00040	0f b6 44 24 20	 movzx	 eax, BYTE PTR Address$[rsp]
  00045	88 05 03 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+3, al
  0004b	0f b6 05 03 00
	00 00		 movzx	 eax, BYTE PTR ?Log@@3UcpuLog@@A+3
  00052	66 89 05 10 00
	00 00		 mov	 WORD PTR ?Log@@3UcpuLog@@A+16, ax

; 261  :     Log.AddressValue = Value;

  00059	0f b6 44 24 21	 movzx	 eax, BYTE PTR Value$[rsp]
  0005e	88 05 12 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+18, al

; 262  :     
; 263  :     return(Value);

  00064	0f b6 44 24 21	 movzx	 eax, BYTE PTR Value$[rsp]

; 264  : }

  00069	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006d	c3		 ret	 0
?zeroPage@@YAEPEAUcpuRegisters@@_K@Z ENDP		; zeroPage
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?immediate@@YAEPEAUcpuRegisters@@_K@Z
_TEXT	SEGMENT
Value$ = 32
Registers$ = 64
MemoryOffset$ = 72
?immediate@@YAEPEAUcpuRegisters@@_K@Z PROC		; immediate, COMDAT

; 247  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 248  :     uint8 Value = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00013	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00017	ff c0		 inc	 eax
  00019	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0001e	0f b7 c8	 movzx	 ecx, ax
  00021	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 249  : 
; 250  :     Log.InstrValue1 = Value;

  0002a	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  0002f	88 05 03 00 00
	00		 mov	 BYTE PTR ?Log@@3UcpuLog@@A+3, al

; 251  :     Log.InstrAddress = Value;

  00035	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  0003a	66 89 05 10 00
	00 00		 mov	 WORD PTR ?Log@@3UcpuLog@@A+16, ax

; 252  :     
; 253  :     return(Value);

  00041	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]

; 254  : }

  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
?immediate@@YAEPEAUcpuRegisters@@_K@Z ENDP		; immediate
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
CmpValue$ = 32
Value$ = 64
Register$ = 72
Flags$ = 80
?cmp@@YAXEEPEAE@Z PROC					; cmp

; 232  : {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000d	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 233  :     uint8 CmpValue = Register - Value;

  00011	0f b6 44 24 48	 movzx	 eax, BYTE PTR Register$[rsp]
  00016	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR Value$[rsp]
  0001b	2b c1		 sub	 eax, ecx
  0001d	88 44 24 20	 mov	 BYTE PTR CmpValue$[rsp], al

; 234  :                         
; 235  :     setNegative(CmpValue, Flags);

  00021	48 8b 54 24 50	 mov	 rdx, QWORD PTR Flags$[rsp]
  00026	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  0002b	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 236  :     setZero(CmpValue, Flags);

  00030	48 8b 54 24 50	 mov	 rdx, QWORD PTR Flags$[rsp]
  00035	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  0003a	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 237  :                         
; 238  :     if(Register < Value)

  0003f	0f b6 44 24 48	 movzx	 eax, BYTE PTR Register$[rsp]
  00044	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR Value$[rsp]
  00049	3b c1		 cmp	 eax, ecx
  0004b	7d 0c		 jge	 SHORT $LN2@cmp

; 239  :     {
; 240  :         clearCarry(Flags);

  0004d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Flags$[rsp]
  00052	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry

; 241  :     }
; 242  :     else

  00057	eb 0a		 jmp	 SHORT $LN3@cmp
$LN2@cmp:

; 243  :         setCarry(Flags);

  00059	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Flags$[rsp]
  0005e	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry
$LN3@cmp:

; 244  : }

  00063	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00067	c3		 ret	 0
?cmp@@YAXEEPEAE@Z ENDP					; cmp
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Value$ = 48
Registers$ = 56
?sbc@@YAXEPEAUcpuRegisters@@@Z PROC			; sbc

; 227  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 228  :     adc(~Value, Registers);

  0000d	0f b6 44 24 30	 movzx	 eax, BYTE PTR Value$[rsp]
  00012	f7 d0		 not	 eax
  00014	48 8b 54 24 38	 mov	 rdx, QWORD PTR Registers$[rsp]
  00019	0f b6 c8	 movzx	 ecx, al
  0001c	e8 00 00 00 00	 call	 ?adc@@YAXEPEAUcpuRegisters@@@Z ; adc

; 229  : }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
?sbc@@YAXEPEAUcpuRegisters@@@Z ENDP			; sbc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
AddedValue$ = 32
CarryIn$ = 33
ValueBit7$ = 36
RegABit7$ = 40
ResultBit6$ = 44
Value$ = 64
Registers$ = 72
?adc@@YAXEPEAUcpuRegisters@@@Z PROC			; adc

; 204  : {    

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 205  :     uint8 CarryIn = (Registers->Flags & 1);            

  0000d	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  00012	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00016	83 e0 01	 and	 eax, 1
  00019	88 44 24 21	 mov	 BYTE PTR CarryIn$[rsp], al

; 206  :     uint8 AddedValue = Registers->A + Value + CarryIn;

  0001d	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  00022	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00025	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR Value$[rsp]
  0002a	03 c1		 add	 eax, ecx
  0002c	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CarryIn$[rsp]
  00031	03 c1		 add	 eax, ecx
  00033	88 44 24 20	 mov	 BYTE PTR AddedValue$[rsp], al

; 207  : 
; 208  :     bool32 ValueBit7 = Value & (1 << 7);

  00037	0f b6 44 24 40	 movzx	 eax, BYTE PTR Value$[rsp]
  0003c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00041	89 44 24 24	 mov	 DWORD PTR ValueBit7$[rsp], eax

; 209  :     bool32 RegABit7 = Registers->A & (1 << 7);

  00045	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  0004a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00052	89 44 24 28	 mov	 DWORD PTR RegABit7$[rsp], eax

; 210  :     bool32 ResultBit6 = AddedValue & (1 << 6);

  00056	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddedValue$[rsp]
  0005b	83 e0 40	 and	 eax, 64			; 00000040H
  0005e	89 44 24 2c	 mov	 DWORD PTR ResultBit6$[rsp], eax

; 211  : 
; 212  :     if((!ValueBit7 && !RegABit7 && ResultBit6) || (ValueBit7 && RegABit7 && !ResultBit6))

  00062	83 7c 24 24 00	 cmp	 DWORD PTR ValueBit7$[rsp], 0
  00067	75 0e		 jne	 SHORT $LN5@adc
  00069	83 7c 24 28 00	 cmp	 DWORD PTR RegABit7$[rsp], 0
  0006e	75 07		 jne	 SHORT $LN5@adc
  00070	83 7c 24 2c 00	 cmp	 DWORD PTR ResultBit6$[rsp], 0
  00075	75 15		 jne	 SHORT $LN4@adc
$LN5@adc:
  00077	83 7c 24 24 00	 cmp	 DWORD PTR ValueBit7$[rsp], 0
  0007c	74 21		 je	 SHORT $LN2@adc
  0007e	83 7c 24 28 00	 cmp	 DWORD PTR RegABit7$[rsp], 0
  00083	74 1a		 je	 SHORT $LN2@adc
  00085	83 7c 24 2c 00	 cmp	 DWORD PTR ResultBit6$[rsp], 0
  0008a	75 13		 jne	 SHORT $LN2@adc
$LN4@adc:

; 213  :         setOverflow(&Registers->Flags);

  0008c	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  00091	48 83 c0 03	 add	 rax, 3
  00095	48 8b c8	 mov	 rcx, rax
  00098	e8 00 00 00 00	 call	 ?setOverflow@@YAXPEAE@Z	; setOverflow

; 214  :     else

  0009d	eb 11		 jmp	 SHORT $LN3@adc
$LN2@adc:

; 215  :         clearOverflow(&Registers->Flags);

  0009f	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  000a4	48 83 c0 03	 add	 rax, 3
  000a8	48 8b c8	 mov	 rcx, rax
  000ab	e8 00 00 00 00	 call	 ?clearOverflow@@YAXPEAE@Z ; clearOverflow
$LN3@adc:

; 216  : 
; 217  :     if((!ValueBit7 && RegABit7 && ResultBit6)  || (ValueBit7 && !RegABit7 && ResultBit6) ||
; 218  :        (ValueBit7 &&  RegABit7 && !ResultBit6) || (ValueBit7 &&  RegABit7 && ResultBit6))

  000b0	83 7c 24 24 00	 cmp	 DWORD PTR ValueBit7$[rsp], 0
  000b5	75 0e		 jne	 SHORT $LN9@adc
  000b7	83 7c 24 28 00	 cmp	 DWORD PTR RegABit7$[rsp], 0
  000bc	74 07		 je	 SHORT $LN9@adc
  000be	83 7c 24 2c 00	 cmp	 DWORD PTR ResultBit6$[rsp], 0
  000c3	75 3f		 jne	 SHORT $LN8@adc
$LN9@adc:
  000c5	83 7c 24 24 00	 cmp	 DWORD PTR ValueBit7$[rsp], 0
  000ca	74 0e		 je	 SHORT $LN10@adc
  000cc	83 7c 24 28 00	 cmp	 DWORD PTR RegABit7$[rsp], 0
  000d1	75 07		 jne	 SHORT $LN10@adc
  000d3	83 7c 24 2c 00	 cmp	 DWORD PTR ResultBit6$[rsp], 0
  000d8	75 2a		 jne	 SHORT $LN8@adc
$LN10@adc:
  000da	83 7c 24 24 00	 cmp	 DWORD PTR ValueBit7$[rsp], 0
  000df	74 0e		 je	 SHORT $LN11@adc
  000e1	83 7c 24 28 00	 cmp	 DWORD PTR RegABit7$[rsp], 0
  000e6	74 07		 je	 SHORT $LN11@adc
  000e8	83 7c 24 2c 00	 cmp	 DWORD PTR ResultBit6$[rsp], 0
  000ed	74 15		 je	 SHORT $LN8@adc
$LN11@adc:
  000ef	83 7c 24 24 00	 cmp	 DWORD PTR ValueBit7$[rsp], 0
  000f4	74 21		 je	 SHORT $LN6@adc
  000f6	83 7c 24 28 00	 cmp	 DWORD PTR RegABit7$[rsp], 0
  000fb	74 1a		 je	 SHORT $LN6@adc
  000fd	83 7c 24 2c 00	 cmp	 DWORD PTR ResultBit6$[rsp], 0
  00102	74 13		 je	 SHORT $LN6@adc
$LN8@adc:

; 219  :         setCarry(&Registers->Flags);

  00104	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  00109	48 83 c0 03	 add	 rax, 3
  0010d	48 8b c8	 mov	 rcx, rax
  00110	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 220  :     else

  00115	eb 11		 jmp	 SHORT $LN7@adc
$LN6@adc:

; 221  :         clearCarry(&Registers->Flags);

  00117	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  0011c	48 83 c0 03	 add	 rax, 3
  00120	48 8b c8	 mov	 rcx, rax
  00123	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN7@adc:

; 222  :     
; 223  :     setNegative(AddedValue, &Registers->Flags);

  00128	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  0012d	48 83 c0 03	 add	 rax, 3
  00131	48 8b d0	 mov	 rdx, rax
  00134	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR AddedValue$[rsp]
  00139	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 224  :     setZero(AddedValue, &Registers->Flags);

  0013e	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  00143	48 83 c0 03	 add	 rax, 3
  00147	48 8b d0	 mov	 rdx, rax
  0014a	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR AddedValue$[rsp]
  0014f	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 225  : }

  00154	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00158	c3		 ret	 0
?adc@@YAXEPEAUcpuRegisters@@@Z ENDP			; adc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Byte$ = 48
Address$ = 56
MemoryOffset$ = 64
?writeCpuMemory8@@YAXEG_K@Z PROC			; writeCpuMemory8

; 175  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 176  :     // NOTE: Mirrors the address for the 2kb ram 
; 177  :     if(0x800 <= Address && Address < 0x2000)

  00012	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00017	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  0001c	7c 26		 jl	 SHORT $LN2@writeCpuMe
  0001e	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00023	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  00028	7d 1a		 jge	 SHORT $LN2@writeCpuMe

; 178  :         Address = (Address % 0x800);

  0002a	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  0002f	99		 cdq
  00030	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  00036	03 c2		 add	 eax, edx
  00038	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0003d	2b c2		 sub	 eax, edx
  0003f	66 89 44 24 38	 mov	 WORD PTR Address$[rsp], ax
$LN2@writeCpuMe:

; 179  :     // NOTE: Mirror for PPU Registers
; 180  :     if(0x2008 <= Address && Address < 0x4000)

  00044	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00049	3d 08 20 00 00	 cmp	 eax, 8200		; 00002008H
  0004e	7c 26		 jl	 SHORT $LN3@writeCpuMe
  00050	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00055	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  0005a	7d 1a		 jge	 SHORT $LN3@writeCpuMe

; 181  :         Address = (Address % (0x2008 - 0x2000)) + 0x2000;

  0005c	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00061	99		 cdq
  00062	83 e2 07	 and	 edx, 7
  00065	03 c2		 add	 eax, edx
  00067	83 e0 07	 and	 eax, 7
  0006a	2b c2		 sub	 eax, edx
  0006c	05 00 20 00 00	 add	 eax, 8192		; 00002000H
  00071	66 89 44 24 38	 mov	 WORD PTR Address$[rsp], ax
$LN3@writeCpuMe:

; 182  :     if(0x8000 < Address || Address == 0x2002)

  00076	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  0007b	3d 00 80 00 00	 cmp	 eax, 32768		; 00008000H
  00080	7f 0c		 jg	 SHORT $LN5@writeCpuMe
  00082	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00087	3d 02 20 00 00	 cmp	 eax, 8194		; 00002002H
  0008c	75 12		 jne	 SHORT $LN4@writeCpuMe
$LN5@writeCpuMe:

; 183  :         Assert(0); // Writing to Program ROM, bank switching?     

  0008e	33 c0		 xor	 eax, eax
  00090	83 f8 01	 cmp	 eax, 1
  00093	74 0b		 je	 SHORT $LN6@writeCpuMe
  00095	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN6@writeCpuMe:
$LN4@writeCpuMe:

; 184  : 
; 185  :     
; 186  :     writeMemory8(Byte, Address, MemoryOffset);

  000a0	4c 8b 44 24 40	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  000a5	0f b7 54 24 38	 movzx	 edx, WORD PTR Address$[rsp]
  000aa	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR Byte$[rsp]
  000af	e8 00 00 00 00	 call	 ?writeMemory8@@YAXEG_K@Z ; writeMemory8

; 187  :     
; 188  :     if(Address == 0x2005) // Scroll address

  000b4	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]

; 189  :     {
; 190  : //        Assert(0);
; 191  :     }
; 192  :     
; 193  :     if(Address == 0x2006) // Writing to ppu io address register

  000b9	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  000be	3d 06 20 00 00	 cmp	 eax, 8198		; 00002006H
  000c3	75 0f		 jne	 SHORT $LN8@writeCpuMe

; 194  :     {
; 195  :         VRamIOAdrsCount++;

  000c5	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?VRamIOAdrsCount@@3EA ; VRamIOAdrsCount
  000cc	fe c0		 inc	 al
  000ce	88 05 00 00 00
	00		 mov	 BYTE PTR ?VRamIOAdrsCount@@3EA, al ; VRamIOAdrsCount
$LN8@writeCpuMe:

; 196  :     }
; 197  :     if(Address == 0x2007) // Write to IO for ppu. Happens after two writes to 0x2006

  000d4	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  000d9	3d 07 20 00 00	 cmp	 eax, 8199		; 00002007H
  000de	75 0f		 jne	 SHORT $LN9@writeCpuMe

; 198  :     {
; 199  :         VRamIOWriteCount++; 

  000e0	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?VRamIOWriteCount@@3EA ; VRamIOWriteCount
  000e7	fe c0		 inc	 al
  000e9	88 05 00 00 00
	00		 mov	 BYTE PTR ?VRamIOWriteCount@@3EA, al ; VRamIOWriteCount
$LN9@writeCpuMe:

; 200  :     }
; 201  : }

  000ef	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000f3	c3		 ret	 0
?writeCpuMemory8@@YAXEG_K@Z ENDP			; writeCpuMemory8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
NewAddress$ = 36
Address$ = 64
MemoryOffset$ = 72
?readCpuMemory16@@YAGG_K@Z PROC				; readCpuMemory16

; 164  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 165  :     // NOTE: Little Endian
; 166  :     uint8 LowByte = readCpuMemory8(Address, MemoryOffset);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00013	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00018	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  0001d	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 167  :     uint8 HighByte = readCpuMemory8(Address+1, MemoryOffset);

  00021	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00026	ff c0		 inc	 eax
  00028	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0002d	0f b7 c8	 movzx	 ecx, ax
  00030	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00035	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 168  :         
; 169  :     uint16 NewAddress = (HighByte << 8) | LowByte;

  00039	0f b6 44 24 20	 movzx	 eax, BYTE PTR HighByte$[rsp]
  0003e	c1 e0 08	 shl	 eax, 8
  00041	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  00046	0b c1		 or	 eax, ecx
  00048	66 89 44 24 24	 mov	 WORD PTR NewAddress$[rsp], ax

; 170  :     return(NewAddress);

  0004d	0f b7 44 24 24	 movzx	 eax, WORD PTR NewAddress$[rsp]

; 171  : }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
?readCpuMemory16@@YAGG_K@Z ENDP				; readCpuMemory16
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Value$ = 32
ResetValue$1 = 33
temp$2 = 34
Address$ = 64
MemoryOffset$ = 72
?readCpuMemory8@@YAEG_K@Z PROC				; readCpuMemory8

; 132  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 133  :     // NOTE: Mirrors the address for the 2kb ram 
; 134  :     if(0x800 <= Address && Address < 0x2000)

  0000e	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00013	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  00018	7c 26		 jl	 SHORT $LN2@readCpuMem
  0001a	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0001f	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  00024	7d 1a		 jge	 SHORT $LN2@readCpuMem

; 135  :         Address = (Address % 0x800);

  00026	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0002b	99		 cdq
  0002c	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  00032	03 c2		 add	 eax, edx
  00034	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00039	2b c2		 sub	 eax, edx
  0003b	66 89 44 24 40	 mov	 WORD PTR Address$[rsp], ax
$LN2@readCpuMem:

; 136  :     // NOTE: Mirror for PPU Registers
; 137  :     if(0x2008 <= Address && Address < 0x4000)

  00040	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00045	3d 08 20 00 00	 cmp	 eax, 8200		; 00002008H
  0004a	7c 26		 jl	 SHORT $LN3@readCpuMem
  0004c	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00051	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  00056	7d 1a		 jge	 SHORT $LN3@readCpuMem

; 138  :         Address = (Address % (0x2008 - 0x2000)) + 0x2000;

  00058	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0005d	99		 cdq
  0005e	83 e2 07	 and	 edx, 7
  00061	03 c2		 add	 eax, edx
  00063	83 e0 07	 and	 eax, 7
  00066	2b c2		 sub	 eax, edx
  00068	05 00 20 00 00	 add	 eax, 8192		; 00002000H
  0006d	66 89 44 24 40	 mov	 WORD PTR Address$[rsp], ax
$LN3@readCpuMem:

; 139  :     
; 140  :     if(Address == 0x2007) // Reading from the IO of ppu. First read is junk, unless its the colour palette

  00072	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00077	3d 07 20 00 00	 cmp	 eax, 8199		; 00002007H
  0007c	75 05		 jne	 SHORT $LN4@readCpuMem

; 141  :     {
; 142  :         // 0x0000 - 0x3EFF    First read will be junk, second read will return actual value
; 143  :         // 0x3F00 - 0x3FFF    This read will always return straight away.
; 144  :         uint8 temp= 1;

  0007e	c6 44 24 22 01	 mov	 BYTE PTR temp$2[rsp], 1
$LN4@readCpuMem:

; 145  :     }
; 146  :         
; 147  :     uint8 Value = readMemory8(Address, MemoryOffset);

  00083	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00088	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0008d	e8 00 00 00 00	 call	 ?readMemory8@@YAEG_K@Z	; readMemory8
  00092	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 148  :             
; 149  :     if(Address == 0x2002) // Read status will reset the IO registers

  00096	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0009b	3d 02 20 00 00	 cmp	 eax, 8194		; 00002002H
  000a0	75 35		 jne	 SHORT $LN5@readCpuMem

; 150  :     {
; 151  :         // Will reset 2005 and 2006 registers, and turn off bit 7 of 0x2002
; 152  :         ResetScrollIOAdrs = true;

  000a2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?ResetScrollIOAdrs@@3HA, 1 ; ResetScrollIOAdrs

; 153  :         ResetVRamIOAdrs = true;

  000ac	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?ResetVRamIOAdrs@@3HA, 1 ; ResetVRamIOAdrs

; 154  :         
; 155  :         uint8 ResetValue = Value & ~(1 << 7);

  000b6	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000bb	0f ba f0 07	 btr	 eax, 7
  000bf	88 44 24 21	 mov	 BYTE PTR ResetValue$1[rsp], al

; 156  :         writeMemory8(ResetValue, Address, MemoryOffset);

  000c3	4c 8b 44 24 48	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  000c8	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  000cd	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ResetValue$1[rsp]
  000d2	e8 00 00 00 00	 call	 ?writeMemory8@@YAXEG_K@Z ; writeMemory8
$LN5@readCpuMem:

; 157  :     }
; 158  :     
; 159  :     return(Value);

  000d7	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]

; 160  : }

  000dc	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e0	c3		 ret	 0
?readCpuMemory8@@YAEG_K@Z ENDP				; readCpuMemory8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Bit$ = 8
Flags$ = 16
?isBitSet@@YAHW4STATUS_BITS@@E@Z PROC			; isBitSet

; 108  : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 109  :     if(Bit == CARRY_BIT)

  00008	83 7c 24 08 00	 cmp	 DWORD PTR Bit$[rsp], 0
  0000d	75 0d		 jne	 SHORT $LN2@isBitSet

; 110  :         return(Flags & 1);

  0000f	0f b6 44 24 10	 movzx	 eax, BYTE PTR Flags$[rsp]
  00014	83 e0 01	 and	 eax, 1
  00017	e9 8d 00 00 00	 jmp	 $LN1@isBitSet
$LN2@isBitSet:

; 111  :     if(Bit == ZERO_BIT)

  0001c	83 7c 24 08 01	 cmp	 DWORD PTR Bit$[rsp], 1
  00021	75 0a		 jne	 SHORT $LN3@isBitSet

; 112  :         return(Flags & (1 << 1));

  00023	0f b6 44 24 10	 movzx	 eax, BYTE PTR Flags$[rsp]
  00028	83 e0 02	 and	 eax, 2
  0002b	eb 7c		 jmp	 SHORT $LN1@isBitSet
$LN3@isBitSet:

; 113  :     if(Bit == INTERRUPT_BIT)

  0002d	83 7c 24 08 02	 cmp	 DWORD PTR Bit$[rsp], 2
  00032	75 0a		 jne	 SHORT $LN4@isBitSet

; 114  :         return(Flags & (1 << 2));

  00034	0f b6 44 24 10	 movzx	 eax, BYTE PTR Flags$[rsp]
  00039	83 e0 04	 and	 eax, 4
  0003c	eb 6b		 jmp	 SHORT $LN1@isBitSet
$LN4@isBitSet:

; 115  :     if(Bit == DECIMAL_BIT)

  0003e	83 7c 24 08 03	 cmp	 DWORD PTR Bit$[rsp], 3
  00043	75 0a		 jne	 SHORT $LN5@isBitSet

; 116  :         return(Flags & (1 << 3));

  00045	0f b6 44 24 10	 movzx	 eax, BYTE PTR Flags$[rsp]
  0004a	83 e0 08	 and	 eax, 8
  0004d	eb 5a		 jmp	 SHORT $LN1@isBitSet
$LN5@isBitSet:

; 117  :     if(Bit == BREAK_BIT)

  0004f	83 7c 24 08 04	 cmp	 DWORD PTR Bit$[rsp], 4
  00054	75 0a		 jne	 SHORT $LN6@isBitSet

; 118  :         return(Flags & (1 << 4));

  00056	0f b6 44 24 10	 movzx	 eax, BYTE PTR Flags$[rsp]
  0005b	83 e0 10	 and	 eax, 16
  0005e	eb 49		 jmp	 SHORT $LN1@isBitSet
$LN6@isBitSet:

; 119  :     if(Bit == BLANK_BIT)

  00060	83 7c 24 08 05	 cmp	 DWORD PTR Bit$[rsp], 5
  00065	75 0a		 jne	 SHORT $LN7@isBitSet

; 120  :         return(Flags & (1 << 5));

  00067	0f b6 44 24 10	 movzx	 eax, BYTE PTR Flags$[rsp]
  0006c	83 e0 20	 and	 eax, 32			; 00000020H
  0006f	eb 38		 jmp	 SHORT $LN1@isBitSet
$LN7@isBitSet:

; 121  :     if(Bit == OVERFLOW_BIT)

  00071	83 7c 24 08 06	 cmp	 DWORD PTR Bit$[rsp], 6
  00076	75 0a		 jne	 SHORT $LN8@isBitSet

; 122  :         return(Flags & (1 << 6));

  00078	0f b6 44 24 10	 movzx	 eax, BYTE PTR Flags$[rsp]
  0007d	83 e0 40	 and	 eax, 64			; 00000040H
  00080	eb 27		 jmp	 SHORT $LN1@isBitSet
$LN8@isBitSet:

; 123  :     if(Bit == NEGATIVE_BIT)

  00082	83 7c 24 08 07	 cmp	 DWORD PTR Bit$[rsp], 7
  00087	75 0c		 jne	 SHORT $LN9@isBitSet

; 124  :         return(Flags & (1 << 7));

  00089	0f b6 44 24 10	 movzx	 eax, BYTE PTR Flags$[rsp]
  0008e	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00093	eb 14		 jmp	 SHORT $LN1@isBitSet
$LN9@isBitSet:

; 125  : 
; 126  :     Assert(0);

  00095	33 c0		 xor	 eax, eax
  00097	83 f8 01	 cmp	 eax, 1
  0009a	74 0b		 je	 SHORT $LN10@isBitSet
  0009c	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN10@isBitSet:

; 127  :     return(0);

  000a7	33 c0		 xor	 eax, eax
$LN1@isBitSet:

; 128  : }

  000a9	c3		 ret	 0
?isBitSet@@YAHW4STATUS_BITS@@E@Z ENDP			; isBitSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setNegative@@YAXEPEAE@Z
_TEXT	SEGMENT
Value$ = 8
Flags$ = 16
?setNegative@@YAXEPEAE@Z PROC				; setNegative, COMDAT

; 87   : {  

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 88   :     if(Value >= 0x00 && Value <= 0x7F)

  00009	0f b6 44 24 08	 movzx	 eax, BYTE PTR Value$[rsp]
  0000e	85 c0		 test	 eax, eax
  00010	7c 1f		 jl	 SHORT $LN2@setNegativ
  00012	0f b6 44 24 08	 movzx	 eax, BYTE PTR Value$[rsp]
  00017	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  0001a	7f 15		 jg	 SHORT $LN2@setNegativ

; 89   :         *Flags = *Flags & ~(1 << 7); // clear negative flag

  0001c	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  00021	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00024	0f ba f0 07	 btr	 eax, 7
  00028	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  0002d	88 01		 mov	 BYTE PTR [rcx], al

; 90   :     else

  0002f	eb 13		 jmp	 SHORT $LN3@setNegativ
$LN2@setNegativ:

; 91   :         *Flags = *Flags | (1 << 7); // set negative flag

  00031	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  00036	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00039	0f ba e8 07	 bts	 eax, 7
  0003d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  00042	88 01		 mov	 BYTE PTR [rcx], al
$LN3@setNegativ:

; 92   : }

  00044	c3		 ret	 0
?setNegative@@YAXEPEAE@Z ENDP				; setNegative
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearOverflow@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearOverflow@@YAXPEAE@Z PROC				; clearOverflow, COMDAT

; 83   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 84   :     *Flags = *Flags & ~(1 << 6);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 bf	 and	 eax, -65		; ffffffffffffffbfH
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al

; 85   : }

  00017	c3		 ret	 0
?clearOverflow@@YAXPEAE@Z ENDP				; clearOverflow
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setOverflow@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setOverflow@@YAXPEAE@Z PROC				; setOverflow, COMDAT

; 79   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 80   :     *Flags = *Flags | (1 << 6);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 40	 or	 eax, 64			; 00000040H
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al

; 81   : }

  00017	c3		 ret	 0
?setOverflow@@YAXPEAE@Z ENDP				; setOverflow
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setBreak@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setBreak@@YAXPEAE@Z PROC				; setBreak, COMDAT

; 71   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 72   :     *Flags = *Flags | (1 << 4);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 10	 or	 eax, 16
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al

; 73   : }

  00017	c3		 ret	 0
?setBreak@@YAXPEAE@Z ENDP				; setBreak
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearDecimal@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearDecimal@@YAXPEAE@Z PROC				; clearDecimal, COMDAT

; 67   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 68   :     *Flags = *Flags & ~(1 << 3);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 f7	 and	 eax, -9
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al

; 69   : }

  00017	c3		 ret	 0
?clearDecimal@@YAXPEAE@Z ENDP				; clearDecimal
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearInterrupt@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearInterrupt@@YAXPEAE@Z PROC				; clearInterrupt, COMDAT

; 63   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 64   :     *Flags = *Flags & ~(1 << 2);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 fb	 and	 eax, -5
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al

; 65   : }

  00017	c3		 ret	 0
?clearInterrupt@@YAXPEAE@Z ENDP				; clearInterrupt
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setInterrupt@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setInterrupt@@YAXPEAE@Z PROC				; setInterrupt, COMDAT

; 59   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 60   :     *Flags = *Flags | (1 << 2);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 04	 or	 eax, 4
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al

; 61   : }

  00017	c3		 ret	 0
?setInterrupt@@YAXPEAE@Z ENDP				; setInterrupt
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setZero@@YAXEPEAE@Z
_TEXT	SEGMENT
Value$ = 8
Flags$ = 16
?setZero@@YAXEPEAE@Z PROC				; setZero, COMDAT

; 52   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 53   :     if(Value == 0x00)

  00009	0f b6 44 24 08	 movzx	 eax, BYTE PTR Value$[rsp]
  0000e	85 c0		 test	 eax, eax
  00010	75 14		 jne	 SHORT $LN2@setZero

; 54   :         *Flags = *Flags | (1 << 1); // Set zero flag

  00012	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  00017	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001a	83 c8 02	 or	 eax, 2
  0001d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  00022	88 01		 mov	 BYTE PTR [rcx], al

; 55   :     else

  00024	eb 12		 jmp	 SHORT $LN3@setZero
$LN2@setZero:

; 56   :         *Flags = *Flags & ~(1 << 1);

  00026	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  0002b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002e	83 e0 fd	 and	 eax, -3
  00031	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  00036	88 01		 mov	 BYTE PTR [rcx], al
$LN3@setZero:

; 57   : }

  00038	c3		 ret	 0
?setZero@@YAXEPEAE@Z ENDP				; setZero
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearCarry@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearCarry@@YAXPEAE@Z PROC				; clearCarry, COMDAT

; 48   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 49   :     *Flags = *Flags & ~1;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 fe	 and	 eax, -2
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al

; 50   : }

  00017	c3		 ret	 0
?clearCarry@@YAXPEAE@Z ENDP				; clearCarry
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setCarry@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setCarry@@YAXPEAE@Z PROC				; setCarry, COMDAT

; 44   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 45   :     *Flags = *Flags | 1;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 01	 or	 eax, 1
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al

; 46   : }

  00017	c3		 ret	 0
?setCarry@@YAXPEAE@Z ENDP				; setCarry
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Value$ = 0
NewAddress$ = 8
Address$ = 32
MemoryOffset$ = 40
?readMemory8@@YAEG_K@Z PROC				; readMemory8

; 248  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 249  :     uint8 *NewAddress = (uint8 *)(Address + MemoryOffset);

  0000e	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  00013	48 03 44 24 28	 add	 rax, QWORD PTR MemoryOffset$[rsp]
  00018	48 89 44 24 08	 mov	 QWORD PTR NewAddress$[rsp], rax

; 250  :     uint8 Value = *NewAddress;

  0001d	48 8b 44 24 08	 mov	 rax, QWORD PTR NewAddress$[rsp]
  00022	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00025	88 04 24	 mov	 BYTE PTR Value$[rsp], al

; 251  :     return(Value);

  00028	0f b6 04 24	 movzx	 eax, BYTE PTR Value$[rsp]

; 252  : }

  0002c	48 83 c4 18	 add	 rsp, 24
  00030	c3		 ret	 0
?readMemory8@@YAEG_K@Z ENDP				; readMemory8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
NewAddress$ = 0
Byte$ = 32
Address$ = 40
MemoryOffset$ = 48
?writeMemory8@@YAXEG_K@Z PROC				; writeMemory8

; 242  : {   

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	48 83 ec 18	 sub	 rsp, 24

; 243  :     uint8 *NewAddress = (uint8 *)(Address + MemoryOffset);

  00012	0f b7 44 24 28	 movzx	 eax, WORD PTR Address$[rsp]
  00017	48 03 44 24 30	 add	 rax, QWORD PTR MemoryOffset$[rsp]
  0001c	48 89 04 24	 mov	 QWORD PTR NewAddress$[rsp], rax

; 244  :     *NewAddress = Byte;

  00020	48 8b 04 24	 mov	 rax, QWORD PTR NewAddress$[rsp]
  00024	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Byte$[rsp]
  00029	88 08		 mov	 BYTE PTR [rax], cl

; 245  : }

  0002b	48 83 c4 18	 add	 rsp, 24
  0002f	c3		 ret	 0
?writeMemory8@@YAXEG_K@Z ENDP				; writeMemory8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Byte$1 = 0
Dest$ = 32
Src$ = 40
Size$ = 48
?cpyMemory@@YAXPEAE0G@Z PROC				; cpyMemory

; 235  : {

  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	48 83 ec 18	 sub	 rsp, 24

; 236  :     // NOTE: Very basic copy. Not bounds protection
; 237  :     for(uint16 Byte = 0; Byte < Size; ++Byte)

  00014	33 c0		 xor	 eax, eax
  00016	66 89 04 24	 mov	 WORD PTR Byte$1[rsp], ax
  0001a	eb 0b		 jmp	 SHORT $LN4@cpyMemory
$LN2@cpyMemory:
  0001c	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  00020	66 ff c0	 inc	 ax
  00023	66 89 04 24	 mov	 WORD PTR Byte$1[rsp], ax
$LN4@cpyMemory:
  00027	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  0002b	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Size$[rsp]
  00030	3b c1		 cmp	 eax, ecx
  00032	7d 1c		 jge	 SHORT $LN3@cpyMemory

; 238  :         Dest[Byte] = Src[Byte];

  00034	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  00038	0f b7 0c 24	 movzx	 ecx, WORD PTR Byte$1[rsp]
  0003c	48 8b 54 24 20	 mov	 rdx, QWORD PTR Dest$[rsp]
  00041	4c 8b 44 24 28	 mov	 r8, QWORD PTR Src$[rsp]
  00046	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0004b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0004e	eb cc		 jmp	 SHORT $LN2@cpyMemory
$LN3@cpyMemory:

; 239  : }

  00050	48 83 c4 18	 add	 rsp, 24
  00054	c3		 ret	 0
?cpyMemory@@YAXPEAE0G@Z ENDP				; cpyMemory
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
BytesRead$1 = 64
FileData$ = 72
FileHandle$ = 80
Filesize$2 = 88
Filename$ = 112
Size$ = 120
?LoadFile@@YAPEAXPEADPEAI@Z PROC			; LoadFile

; 194  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 195  :     void *FileData = 0;

  0000e	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR FileData$[rsp], 0

; 196  :     
; 197  :     HANDLE FileHandle = CreateFileA(Filename, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);

  00017	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00020	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00028	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  00030	45 33 c9	 xor	 r9d, r9d
  00033	41 b8 01 00 00
	00		 mov	 r8d, 1
  00039	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  0003e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Filename$[rsp]
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileA
  00049	48 89 44 24 50	 mov	 QWORD PTR FileHandle$[rsp], rax

; 198  :     if(FileHandle != INVALID_HANDLE_VALUE)

  0004e	48 83 7c 24 50
	ff		 cmp	 QWORD PTR FileHandle$[rsp], -1
  00054	0f 84 8d 00 00
	00		 je	 $LN2@LoadFile

; 199  :     {
; 200  :         LARGE_INTEGER Filesize;
; 201  :         if(GetFileSizeEx(FileHandle, &Filesize))

  0005a	48 8d 54 24 58	 lea	 rdx, QWORD PTR Filesize$2[rsp]
  0005f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR FileHandle$[rsp]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileSizeEx
  0006a	85 c0		 test	 eax, eax
  0006c	74 77		 je	 SHORT $LN4@LoadFile

; 202  :         {
; 203  :             FileData = VirtualAlloc(0, Filesize.LowPart, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);

  0006e	8b 44 24 58	 mov	 eax, DWORD PTR Filesize$2[rsp]
  00072	41 b9 04 00 00
	00		 mov	 r9d, 4
  00078	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  0007e	8b d0		 mov	 edx, eax
  00080	33 c9		 xor	 ecx, ecx
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  00088	48 89 44 24 48	 mov	 QWORD PTR FileData$[rsp], rax

; 204  :             if(FileData)

  0008d	48 83 7c 24 48
	00		 cmp	 QWORD PTR FileData$[rsp], 0
  00093	74 50		 je	 SHORT $LN6@LoadFile

; 205  :             {
; 206  :                 DWORD BytesRead;
; 207  :                 if(ReadFile(FileHandle, FileData, Filesize.LowPart, &BytesRead, 0) &&

  00095	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0009e	4c 8d 4c 24 40	 lea	 r9, QWORD PTR BytesRead$1[rsp]
  000a3	44 8b 44 24 58	 mov	 r8d, DWORD PTR Filesize$2[rsp]
  000a8	48 8b 54 24 48	 mov	 rdx, QWORD PTR FileData$[rsp]
  000ad	48 8b 4c 24 50	 mov	 rcx, QWORD PTR FileHandle$[rsp]
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReadFile
  000b8	85 c0		 test	 eax, eax
  000ba	74 17		 je	 SHORT $LN8@LoadFile
  000bc	8b 44 24 40	 mov	 eax, DWORD PTR BytesRead$1[rsp]
  000c0	39 44 24 58	 cmp	 DWORD PTR Filesize$2[rsp], eax
  000c4	75 0d		 jne	 SHORT $LN8@LoadFile

; 208  :                    (Filesize.LowPart == BytesRead))
; 209  :                 {
; 210  :                     *Size = (uint32)BytesRead;

  000c6	48 8b 44 24 78	 mov	 rax, QWORD PTR Size$[rsp]
  000cb	8b 4c 24 40	 mov	 ecx, DWORD PTR BytesRead$1[rsp]
  000cf	89 08		 mov	 DWORD PTR [rax], ecx

; 211  :                     // It worked!
; 212  :                 }
; 213  :                 else

  000d1	eb 12		 jmp	 SHORT $LN9@LoadFile
$LN8@LoadFile:

; 214  :                 {
; 215  :                     Assert(0);

  000d3	33 c0		 xor	 eax, eax
  000d5	83 f8 01	 cmp	 eax, 1
  000d8	74 0b		 je	 SHORT $LN10@LoadFile
  000da	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN10@LoadFile:
$LN9@LoadFile:
$LN6@LoadFile:
$LN4@LoadFile:

; 216  :                 }
; 217  :             }
; 218  :             else
; 219  :             {
; 220  :             }   
; 221  :         }
; 222  :         else
; 223  :         {
; 224  :         }
; 225  :     }
; 226  :     else

  000e5	eb 12		 jmp	 SHORT $LN3@LoadFile
$LN2@LoadFile:

; 227  :     {
; 228  :         Assert(0);

  000e7	33 c0		 xor	 eax, eax
  000e9	83 f8 01	 cmp	 eax, 1
  000ec	74 0b		 je	 SHORT $LN11@LoadFile
  000ee	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN11@LoadFile:
$LN3@LoadFile:

; 229  :     }
; 230  :     return(FileData);

  000f9	48 8b 44 24 48	 mov	 rax, QWORD PTR FileData$[rsp]

; 231  : }

  000fe	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00102	c3		 ret	 0
?LoadFile@@YAPEAXPEADPEAI@Z ENDP			; LoadFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
tv64 = 32
tv67 = 36
tv70 = 40
tv73 = 44
tv81 = 48
tv87 = 52
tv93 = 56
tv131 = 60
tv137 = 64
tv143 = 68
tv149 = 72
tv155 = 76
tv75 = 80
WasDown$1 = 88
IsDown$2 = 92
AltPressed$3 = 96
Result$ = 104
WindowHandle$ = 128
Message$ = 136
wParam$ = 144
lParam$ = 152
?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z PROC		; WinInputCallback

; 82   : {

$LN51:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 83   :     LRESULT Result = 0;

  00017	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR Result$[rsp], 0

; 84   :     
; 85   :     switch(Message) 

  00020	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR Message$[rsp]
  00027	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  0002b	83 7c 24 20 10	 cmp	 DWORD PTR tv64[rsp], 16
  00030	77 21		 ja	 SHORT $LN48@WinInputCa
  00032	83 7c 24 20 10	 cmp	 DWORD PTR tv64[rsp], 16
  00037	74 59		 je	 SHORT $LN8@WinInputCa
  00039	83 7c 24 20 01	 cmp	 DWORD PTR tv64[rsp], 1
  0003e	74 48		 je	 SHORT $LN6@WinInputCa
  00040	83 7c 24 20 02	 cmp	 DWORD PTR tv64[rsp], 2
  00045	74 5a		 je	 SHORT $LN9@WinInputCa
  00047	83 7c 24 20 05	 cmp	 DWORD PTR tv64[rsp], 5
  0004c	74 3f		 je	 SHORT $LN7@WinInputCa
  0004e	e9 6a 03 00 00	 jmp	 $LN24@WinInputCa
$LN48@WinInputCa:
  00053	81 7c 24 20 00
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 256 ; 00000100H
  0005b	0f 82 5c 03 00
	00		 jb	 $LN24@WinInputCa
  00061	81 7c 24 20 01
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 257 ; 00000101H
  00069	76 3b		 jbe	 SHORT $LN10@WinInputCa
  0006b	81 7c 24 20 03
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 259 ; 00000103H
  00073	0f 86 44 03 00
	00		 jbe	 $LN24@WinInputCa
  00079	81 7c 24 20 05
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 261 ; 00000105H
  00081	76 23		 jbe	 SHORT $LN10@WinInputCa
  00083	e9 35 03 00 00	 jmp	 $LN24@WinInputCa
$LN6@WinInputCa:

; 86   :     { 
; 87   :         case WM_CREATE:
; 88   :         {
; 89   :             // Initialize the window. 
; 90   :             break; 

  00088	e9 5a 03 00 00	 jmp	 $LN2@WinInputCa
$LN7@WinInputCa:

; 91   :         }
; 92   :         
; 93   :         case WM_SIZE:
; 94   :         {
; 95   :             // Set the size and position of the window. 
; 96   :             break;

  0008d	e9 55 03 00 00	 jmp	 $LN2@WinInputCa
$LN8@WinInputCa:

; 97   :         }
; 98   :         case WM_CLOSE:
; 99   :         {
; 100  :             GlobalRunning = false;

  00092	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0

; 101  :             break;

  0009c	e9 46 03 00 00	 jmp	 $LN2@WinInputCa
$LN9@WinInputCa:

; 102  :         }
; 103  :         case WM_DESTROY:
; 104  :         {
; 105  :             break;

  000a1	e9 41 03 00 00	 jmp	 $LN2@WinInputCa
$LN10@WinInputCa:

; 106  :         }
; 107  :         case WM_SYSKEYDOWN:
; 108  :         case WM_SYSKEYUP:
; 109  :         case WM_KEYDOWN:
; 110  :         case WM_KEYUP:
; 111  :         {
; 112  :             bool32 IsDown = ((lParam & (1<<31)) == 0);

  000a6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR lParam$[rsp]
  000ae	48 25 00 00 00
	80		 and	 rax, -2147483648	; ffffffff80000000H
  000b4	48 85 c0	 test	 rax, rax
  000b7	75 0a		 jne	 SHORT $LN26@WinInputCa
  000b9	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  000c1	eb 08		 jmp	 SHORT $LN27@WinInputCa
$LN26@WinInputCa:
  000c3	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN27@WinInputCa:
  000cb	8b 44 24 24	 mov	 eax, DWORD PTR tv67[rsp]
  000cf	89 44 24 5c	 mov	 DWORD PTR IsDown$2[rsp], eax

; 113  :             bool32 WasDown = ((lParam & (1<<30)) != 0);

  000d3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR lParam$[rsp]
  000db	48 25 00 00 00
	40		 and	 rax, 1073741824		; 40000000H
  000e1	48 85 c0	 test	 rax, rax
  000e4	74 0a		 je	 SHORT $LN28@WinInputCa
  000e6	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  000ee	eb 08		 jmp	 SHORT $LN29@WinInputCa
$LN28@WinInputCa:
  000f0	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN29@WinInputCa:
  000f8	8b 44 24 28	 mov	 eax, DWORD PTR tv70[rsp]
  000fc	89 44 24 58	 mov	 DWORD PTR WasDown$1[rsp], eax

; 114  : 
; 115  :             // NOTE: Alt only on SYSDOWN messages
; 116  :             bool32 AltPressed = ((lParam & (1<<29)) != 0);

  00100	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR lParam$[rsp]
  00108	48 25 00 00 00
	20		 and	 rax, 536870912		; 20000000H
  0010e	48 85 c0	 test	 rax, rax
  00111	74 0a		 je	 SHORT $LN30@WinInputCa
  00113	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  0011b	eb 08		 jmp	 SHORT $LN31@WinInputCa
$LN30@WinInputCa:
  0011d	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN31@WinInputCa:
  00125	8b 44 24 2c	 mov	 eax, DWORD PTR tv73[rsp]
  00129	89 44 24 60	 mov	 DWORD PTR AltPressed$3[rsp], eax

; 117  :               
; 118  :             if(IsDown != WasDown)

  0012d	8b 44 24 58	 mov	 eax, DWORD PTR WasDown$1[rsp]
  00131	39 44 24 5c	 cmp	 DWORD PTR IsDown$2[rsp], eax
  00135	0f 84 80 02 00
	00		 je	 $LN11@WinInputCa

; 119  :             {               
; 120  :                 switch(wParam)

  0013b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR wParam$[rsp]
  00143	48 89 44 24 50	 mov	 QWORD PTR tv75[rsp], rax
  00148	48 8b 44 24 50	 mov	 rax, QWORD PTR tv75[rsp]
  0014d	48 83 e8 0d	 sub	 rax, 13
  00151	48 89 44 24 50	 mov	 QWORD PTR tv75[rsp], rax
  00156	48 83 7c 24 50
	66		 cmp	 QWORD PTR tv75[rsp], 102 ; 00000066H
  0015c	0f 87 59 02 00
	00		 ja	 $LN4@WinInputCa
  00162	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:__ImageBase
  00169	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv75[rsp]
  0016e	0f b6 8c 08 00
	00 00 00	 movzx	 ecx, BYTE PTR $LN49@WinInputCa[rax+rcx]
  00176	8b 8c 88 00 00
	00 00		 mov	 ecx, DWORD PTR $LN50@WinInputCa[rax+rcx*4]
  0017d	48 03 c8	 add	 rcx, rax
  00180	ff e1		 jmp	 rcx
$LN12@WinInputCa:

; 121  :                 {
; 122  :                     // NOTE: Up and down changes the octave the keys are in
; 123  :                     case VK_UP:
; 124  :                     {
; 125  :                         WinInput.buttons[input::B_UP] = !WinInput.buttons[input::B_UP];

  00182	b8 04 00 00 00	 mov	 eax, 4
  00187	48 6b c0 04	 imul	 rax, rax, 4
  0018b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00192	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  00196	75 0a		 jne	 SHORT $LN32@WinInputCa
  00198	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  001a0	eb 08		 jmp	 SHORT $LN33@WinInputCa
$LN32@WinInputCa:
  001a2	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN33@WinInputCa:
  001aa	b8 04 00 00 00	 mov	 eax, 4
  001af	48 6b c0 04	 imul	 rax, rax, 4
  001b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  001ba	8b 54 24 30	 mov	 edx, DWORD PTR tv81[rsp]
  001be	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 126  :                         break;

  001c1	e9 f5 01 00 00	 jmp	 $LN4@WinInputCa
$LN13@WinInputCa:

; 127  :                     }
; 128  :                     case VK_DOWN:
; 129  :                     {
; 130  :                         WinInput.buttons[input::B_DOWN] = !WinInput.buttons[input::B_DOWN];

  001c6	b8 04 00 00 00	 mov	 eax, 4
  001cb	48 6b c0 05	 imul	 rax, rax, 5
  001cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  001d6	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  001da	75 0a		 jne	 SHORT $LN34@WinInputCa
  001dc	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv87[rsp], 1
  001e4	eb 08		 jmp	 SHORT $LN35@WinInputCa
$LN34@WinInputCa:
  001e6	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
$LN35@WinInputCa:
  001ee	b8 04 00 00 00	 mov	 eax, 4
  001f3	48 6b c0 05	 imul	 rax, rax, 5
  001f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  001fe	8b 54 24 34	 mov	 edx, DWORD PTR tv87[rsp]
  00202	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 131  :                         break;

  00205	e9 b1 01 00 00	 jmp	 $LN4@WinInputCa
$LN14@WinInputCa:

; 132  :                     }
; 133  :                     case VK_LEFT:
; 134  :                     {
; 135  :                         WinInput.buttons[input::B_LEFT] = !WinInput.buttons[input::B_LEFT];

  0020a	b8 04 00 00 00	 mov	 eax, 4
  0020f	48 6b c0 06	 imul	 rax, rax, 6
  00213	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0021a	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  0021e	75 0a		 jne	 SHORT $LN36@WinInputCa
  00220	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  00228	eb 08		 jmp	 SHORT $LN37@WinInputCa
$LN36@WinInputCa:
  0022a	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN37@WinInputCa:
  00232	b8 04 00 00 00	 mov	 eax, 4
  00237	48 6b c0 06	 imul	 rax, rax, 6
  0023b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00242	8b 54 24 38	 mov	 edx, DWORD PTR tv93[rsp]
  00246	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 136  :                         break;

  00249	e9 6d 01 00 00	 jmp	 $LN4@WinInputCa
$LN15@WinInputCa:

; 137  :                     }
; 138  :                     case VK_RIGHT:
; 139  :                     {
; 140  :                         WinInput.buttons[input::B_RIGHT] = !WinInput.buttons[input::B_RIGHT];

  0024e	b8 04 00 00 00	 mov	 eax, 4
  00253	48 6b c0 07	 imul	 rax, rax, 7
  00257	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0025e	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  00262	75 0a		 jne	 SHORT $LN38@WinInputCa
  00264	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  0026c	eb 08		 jmp	 SHORT $LN39@WinInputCa
$LN38@WinInputCa:
  0026e	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN39@WinInputCa:
  00276	b8 04 00 00 00	 mov	 eax, 4
  0027b	48 6b c0 07	 imul	 rax, rax, 7
  0027f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00286	8b 54 24 3c	 mov	 edx, DWORD PTR tv131[rsp]
  0028a	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 141  :                         break;

  0028d	e9 29 01 00 00	 jmp	 $LN4@WinInputCa
$LN16@WinInputCa:

; 142  :                     }
; 143  :                     case 'Z':
; 144  :                     {
; 145  :                         WinInput.buttons[input::B_A] = !WinInput.buttons[input::B_A];

  00292	b8 04 00 00 00	 mov	 eax, 4
  00297	48 6b c0 00	 imul	 rax, rax, 0
  0029b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  002a2	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  002a6	75 0a		 jne	 SHORT $LN40@WinInputCa
  002a8	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv137[rsp], 1
  002b0	eb 08		 jmp	 SHORT $LN41@WinInputCa
$LN40@WinInputCa:
  002b2	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN41@WinInputCa:
  002ba	b8 04 00 00 00	 mov	 eax, 4
  002bf	48 6b c0 00	 imul	 rax, rax, 0
  002c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  002ca	8b 54 24 40	 mov	 edx, DWORD PTR tv137[rsp]
  002ce	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 146  :                         break;

  002d1	e9 e5 00 00 00	 jmp	 $LN4@WinInputCa
$LN17@WinInputCa:

; 147  :                     }
; 148  :                     case 'X':
; 149  :                     {
; 150  :                         WinInput.buttons[input::B_B] = !WinInput.buttons[input::B_B];

  002d6	b8 04 00 00 00	 mov	 eax, 4
  002db	48 6b c0 01	 imul	 rax, rax, 1
  002df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  002e6	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  002ea	75 0a		 jne	 SHORT $LN42@WinInputCa
  002ec	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv143[rsp], 1
  002f4	eb 08		 jmp	 SHORT $LN43@WinInputCa
$LN42@WinInputCa:
  002f6	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv143[rsp], 0
$LN43@WinInputCa:
  002fe	b8 04 00 00 00	 mov	 eax, 4
  00303	48 6b c0 01	 imul	 rax, rax, 1
  00307	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0030e	8b 54 24 44	 mov	 edx, DWORD PTR tv143[rsp]
  00312	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 151  :                         break;

  00315	e9 a1 00 00 00	 jmp	 $LN4@WinInputCa
$LN18@WinInputCa:

; 152  :                     }
; 153  :                     case VK_RETURN:
; 154  :                     {
; 155  :                         WinInput.buttons[input::B_START] = !WinInput.buttons[input::B_START];

  0031a	b8 04 00 00 00	 mov	 eax, 4
  0031f	48 6b c0 03	 imul	 rax, rax, 3
  00323	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0032a	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  0032e	75 0a		 jne	 SHORT $LN44@WinInputCa
  00330	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv149[rsp], 1
  00338	eb 08		 jmp	 SHORT $LN45@WinInputCa
$LN44@WinInputCa:
  0033a	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
$LN45@WinInputCa:
  00342	b8 04 00 00 00	 mov	 eax, 4
  00347	48 6b c0 03	 imul	 rax, rax, 3
  0034b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00352	8b 54 24 48	 mov	 edx, DWORD PTR tv149[rsp]
  00356	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 156  :                         break;

  00359	eb 60		 jmp	 SHORT $LN4@WinInputCa
$LN19@WinInputCa:

; 157  :                     }
; 158  :                     case VK_SHIFT:
; 159  :                     {
; 160  :                         WinInput.buttons[input::B_SELECT] = !WinInput.buttons[input::B_SELECT];

  0035b	b8 04 00 00 00	 mov	 eax, 4
  00360	48 6b c0 02	 imul	 rax, rax, 2
  00364	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0036b	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  0036f	75 0a		 jne	 SHORT $LN46@WinInputCa
  00371	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv155[rsp], 1
  00379	eb 08		 jmp	 SHORT $LN47@WinInputCa
$LN46@WinInputCa:
  0037b	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv155[rsp], 0
$LN47@WinInputCa:
  00383	b8 04 00 00 00	 mov	 eax, 4
  00388	48 6b c0 02	 imul	 rax, rax, 2
  0038c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00393	8b 54 24 4c	 mov	 edx, DWORD PTR tv155[rsp]
  00397	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 161  :                         break;

  0039a	eb 1f		 jmp	 SHORT $LN4@WinInputCa

; 162  :                     }
; 163  :                     case VK_SPACE:
; 164  :                     {
; 165  :                         
; 166  :                         break;

  0039c	eb 1d		 jmp	 SHORT $LN4@WinInputCa
$LN21@WinInputCa:

; 167  :                     }
; 168  :                     case VK_ESCAPE:
; 169  :                     {
; 170  :                         GlobalRunning = false;

  0039e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0

; 171  :                         break;

  003a8	eb 11		 jmp	 SHORT $LN4@WinInputCa
$LN22@WinInputCa:

; 172  :                     }
; 173  :                     case VK_F4:
; 174  :                     {
; 175  :                         if(AltPressed)

  003aa	83 7c 24 60 00	 cmp	 DWORD PTR AltPressed$3[rsp], 0
  003af	74 0a		 je	 SHORT $LN23@WinInputCa

; 176  :                         {
; 177  :                             GlobalRunning = false;

  003b1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0
$LN23@WinInputCa:
$LN4@WinInputCa:
$LN11@WinInputCa:

; 178  :                         }
; 179  :                         break;
; 180  :                     }
; 181  :                 }
; 182  :             }
; 183  :             break;

  003bb	eb 2a		 jmp	 SHORT $LN2@WinInputCa
$LN24@WinInputCa:

; 184  :         }            
; 185  :         default:
; 186  :         {
; 187  :             Result = DefWindowProc(WindowHandle, Message, wParam, lParam); 

  003bd	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR lParam$[rsp]
  003c5	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR wParam$[rsp]
  003cd	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR Message$[rsp]
  003d4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR WindowHandle$[rsp]
  003dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DefWindowProcA
  003e2	48 89 44 24 68	 mov	 QWORD PTR Result$[rsp], rax
$LN2@WinInputCa:

; 188  :         }
; 189  :     }
; 190  :     return Result;

  003e7	48 8b 44 24 68	 mov	 rax, QWORD PTR Result$[rsp]

; 191  : }

  003ec	48 83 c4 78	 add	 rsp, 120		; 00000078H
  003f0	c3		 ret	 0
  003f1	0f 1f 00	 npad	 3
$LN50@WinInputCa:
  003f4	00 00 00 00	 DD	 $LN18@WinInputCa
  003f8	00 00 00 00	 DD	 $LN19@WinInputCa
  003fc	00 00 00 00	 DD	 $LN21@WinInputCa
  00400	00 00 00 00	 DD	 $LN14@WinInputCa
  00404	00 00 00 00	 DD	 $LN12@WinInputCa
  00408	00 00 00 00	 DD	 $LN15@WinInputCa
  0040c	00 00 00 00	 DD	 $LN13@WinInputCa
  00410	00 00 00 00	 DD	 $LN17@WinInputCa
  00414	00 00 00 00	 DD	 $LN16@WinInputCa
  00418	00 00 00 00	 DD	 $LN22@WinInputCa
  0041c	00 00 00 00	 DD	 $LN4@WinInputCa
$LN49@WinInputCa:
  00420	00		 DB	 0
  00421	0a		 DB	 10
  00422	0a		 DB	 10
  00423	01		 DB	 1
  00424	0a		 DB	 10
  00425	0a		 DB	 10
  00426	0a		 DB	 10
  00427	0a		 DB	 10
  00428	0a		 DB	 10
  00429	0a		 DB	 10
  0042a	0a		 DB	 10
  0042b	0a		 DB	 10
  0042c	0a		 DB	 10
  0042d	0a		 DB	 10
  0042e	02		 DB	 2
  0042f	0a		 DB	 10
  00430	0a		 DB	 10
  00431	0a		 DB	 10
  00432	0a		 DB	 10
  00433	0a		 DB	 10
  00434	0a		 DB	 10
  00435	0a		 DB	 10
  00436	0a		 DB	 10
  00437	0a		 DB	 10
  00438	03		 DB	 3
  00439	04		 DB	 4
  0043a	05		 DB	 5
  0043b	06		 DB	 6
  0043c	0a		 DB	 10
  0043d	0a		 DB	 10
  0043e	0a		 DB	 10
  0043f	0a		 DB	 10
  00440	0a		 DB	 10
  00441	0a		 DB	 10
  00442	0a		 DB	 10
  00443	0a		 DB	 10
  00444	0a		 DB	 10
  00445	0a		 DB	 10
  00446	0a		 DB	 10
  00447	0a		 DB	 10
  00448	0a		 DB	 10
  00449	0a		 DB	 10
  0044a	0a		 DB	 10
  0044b	0a		 DB	 10
  0044c	0a		 DB	 10
  0044d	0a		 DB	 10
  0044e	0a		 DB	 10
  0044f	0a		 DB	 10
  00450	0a		 DB	 10
  00451	0a		 DB	 10
  00452	0a		 DB	 10
  00453	0a		 DB	 10
  00454	0a		 DB	 10
  00455	0a		 DB	 10
  00456	0a		 DB	 10
  00457	0a		 DB	 10
  00458	0a		 DB	 10
  00459	0a		 DB	 10
  0045a	0a		 DB	 10
  0045b	0a		 DB	 10
  0045c	0a		 DB	 10
  0045d	0a		 DB	 10
  0045e	0a		 DB	 10
  0045f	0a		 DB	 10
  00460	0a		 DB	 10
  00461	0a		 DB	 10
  00462	0a		 DB	 10
  00463	0a		 DB	 10
  00464	0a		 DB	 10
  00465	0a		 DB	 10
  00466	0a		 DB	 10
  00467	0a		 DB	 10
  00468	0a		 DB	 10
  00469	0a		 DB	 10
  0046a	0a		 DB	 10
  0046b	07		 DB	 7
  0046c	0a		 DB	 10
  0046d	08		 DB	 8
  0046e	0a		 DB	 10
  0046f	0a		 DB	 10
  00470	0a		 DB	 10
  00471	0a		 DB	 10
  00472	0a		 DB	 10
  00473	0a		 DB	 10
  00474	0a		 DB	 10
  00475	0a		 DB	 10
  00476	0a		 DB	 10
  00477	0a		 DB	 10
  00478	0a		 DB	 10
  00479	0a		 DB	 10
  0047a	0a		 DB	 10
  0047b	0a		 DB	 10
  0047c	0a		 DB	 10
  0047d	0a		 DB	 10
  0047e	0a		 DB	 10
  0047f	0a		 DB	 10
  00480	0a		 DB	 10
  00481	0a		 DB	 10
  00482	0a		 DB	 10
  00483	0a		 DB	 10
  00484	0a		 DB	 10
  00485	0a		 DB	 10
  00486	09		 DB	 9
?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z ENDP		; WinInputCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
MSElapsed$ = 32
Counter$ = 40
CounterElapsed$ = 48
PerfCountFrequency$ = 80
?getMilliSeconds@@YAM_K@Z PROC				; getMilliSeconds

; 69   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 70   :     LARGE_INTEGER Counter;
; 71   :     QueryPerformanceCounter(&Counter);

  00009	48 8d 4c 24 28	 lea	 rcx, QWORD PTR Counter$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_QueryPerformanceCounter

; 72   :     
; 73   :     uint64 CounterElapsed = Counter.QuadPart;

  00014	48 8b 44 24 28	 mov	 rax, QWORD PTR Counter$[rsp]
  00019	48 89 44 24 30	 mov	 QWORD PTR CounterElapsed$[rsp], rax

; 74   :     real32 MSElapsed = ((1000.0f * (real32)CounterElapsed) / (real32)PerfCountFrequency);

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR CounterElapsed$[rsp]
  00023	f3 48 0f 2a c0	 cvtsi2ss xmm0, rax
  00028	48 85 c0	 test	 rax, rax
  0002b	7d 08		 jge	 SHORT $LN4@getMilliSe
  0002d	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@5f800000
$LN4@getMilliSe:
  00035	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@447a0000
  0003d	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00041	0f 28 c1	 movaps	 xmm0, xmm1
  00044	48 8b 44 24 50	 mov	 rax, QWORD PTR PerfCountFrequency$[rsp]
  00049	f3 48 0f 2a c8	 cvtsi2ss xmm1, rax
  0004e	48 85 c0	 test	 rax, rax
  00051	7d 08		 jge	 SHORT $LN3@getMilliSe
  00053	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@5f800000
$LN3@getMilliSe:
  0005b	f3 0f 5e c1	 divss	 xmm0, xmm1
  0005f	f3 0f 11 44 24
	20		 movss	 DWORD PTR MSElapsed$[rsp], xmm0

; 75   : 
; 76   :     return(MSElapsed);

  00065	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR MSElapsed$[rsp]

; 77   : }

  0006b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006f	c3		 ret	 0
?getMilliSeconds@@YAM_K@Z ENDP				; getMilliSeconds
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  00018	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  0001d	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00022	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00027	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0002c	45 33 c0	 xor	 r8d, r8d
  0002f	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00039	e8 00 00 00 00	 call	 _vsprintf_l
  0003e	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

  00042	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

  0004b	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1788 : }

  0004f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00053	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00027	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  0002c	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00038	e8 00 00 00 00	 call	 _vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 83 c8 01	 or	 rax, 1
  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00029	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00033	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00038	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003d	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00047	48 8b c8	 mov	 rcx, rax
  0004a	e8 00 00 00 00	 call	 __stdio_common_vsprintf
  0004f	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00053	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00058	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005a	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00062	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00064	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  00068	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006c	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1391 : }

  00070	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00074	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File u:\programs\visual studio\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 81   :     static unsigned __int64 _OptionsStorage;
; 82   :     return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 83   : }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
i$1 = 96
Flags6$ = 97
RomPrgBankCount$ = 98
MapperNumber$ = 99
ResScale$ = 100
Flags7$ = 101
WindowHeight$ = 104
WindowWidth$ = 108
RenderScaleHeight$ = 112
RenderScaleWidth$ = 116
RomData$ = 120
RomChrBankCount$ = 128
RomPrgRamSize$ = 129
Flags9$ = 130
Flags10$ = 131
MemPrgBank1$ = 132
MemPrgBank2$ = 136
CurrentMS$2 = 140
PrevMS$3 = 144
Window$4 = 152
TotalMemorySize$ = 160
tv193 = 164
ElapsedMS$5 = 168
PpuMemorySize$ = 172
CpuMemorySize$ = 176
RomPrgData$ = 184
Memory$ = 192
DeviceContext$6 = 200
PerfCountFrequency$ = 208
FileSize$ = 216
Filename$ = 224
WinPerfCountFrequency$ = 232
RomChrData$ = 240
LastCounter$7 = 248
LastCycles$8 = 256
PpuData$ = 264
WindowClass$ = 320
Message$9 = 400
CpuData$ = 448
ScreenBackBuffer$ = 480
Buffer$10 = 560
__$ArrayPad$ = 568
WindowInstance$ = 592
PrevWindowInstance$ = 600
CommandLine$ = 608
CommandShow$ = 616
WinMain	PROC

; 317  : {

$LN30:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 40 02
	00 00		 sub	 rsp, 576		; 00000240H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 38
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 318  :     // TODO: I could reduce the memory usage as the nes does not actually use 64 kbs,
; 319  :     //       the nes mirrors certain sections of address space
; 320  :     uint32 CpuMemorySize = Kilobytes(64);

  0002e	c7 84 24 b0 00
	00 00 00 00 01
	00		 mov	 DWORD PTR CpuMemorySize$[rsp], 65536 ; 00010000H

; 321  :     uint32 PpuMemorySize = Kilobytes(64);

  00039	c7 84 24 ac 00
	00 00 00 00 01
	00		 mov	 DWORD PTR PpuMemorySize$[rsp], 65536 ; 00010000H

; 322  :     uint32 TotalMemorySize = CpuMemorySize + PpuMemorySize;

  00044	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR PpuMemorySize$[rsp]
  0004b	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR CpuMemorySize$[rsp]
  00052	03 c8		 add	 ecx, eax
  00054	8b c1		 mov	 eax, ecx
  00056	89 84 24 a0 00
	00 00		 mov	 DWORD PTR TotalMemorySize$[rsp], eax

; 323  : 
; 324  :     // NOTE: Aiming to have one memory allocation for the whole program.
; 325  :     // TODO: Loading the cartridge also creates memory. Figure out to include in this call.
; 326  :     uint8 * Memory = (uint8 *)VirtualAlloc(0, (size_t)TotalMemorySize, MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);

  0005d	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR TotalMemorySize$[rsp]
  00064	41 b9 04 00 00
	00		 mov	 r9d, 4
  0006a	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  00070	8b d0		 mov	 edx, eax
  00072	33 c9		 xor	 ecx, ecx
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  0007a	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR Memory$[rsp], rax

; 327  : 
; 328  :     cpu CpuData = {};

  00082	48 8d 84 24 c0
	01 00 00	 lea	 rax, QWORD PTR CpuData$[rsp]
  0008a	48 8b f8	 mov	 rdi, rax
  0008d	33 c0		 xor	 eax, eax
  0008f	b9 18 00 00 00	 mov	 ecx, 24
  00094	f3 aa		 rep stosb

; 329  :     CpuData.MemoryOffset = (uint64)Memory; 

  00096	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR Memory$[rsp]
  0009e	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR CpuData$[rsp+8], rax

; 330  :     CpuData.Registers.StackPtr = 0xFF;

  000a6	c6 84 24 c4 01
	00 00 ff	 mov	 BYTE PTR CpuData$[rsp+4], 255 ; 000000ffH

; 331  :     
; 332  :     ppu PpuData = {};    

  000ae	48 8d 84 24 08
	01 00 00	 lea	 rax, QWORD PTR PpuData$[rsp]
  000b6	48 8b f8	 mov	 rdi, rax
  000b9	33 c0		 xor	 eax, eax
  000bb	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  000c0	f3 aa		 rep stosb

; 333  :     PpuData.MemoryOffset = (uint64)Memory + Kilobytes(64);

  000c2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR Memory$[rsp]
  000ca	48 05 00 00 01
	00		 add	 rax, 65536		; 00010000H
  000d0	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR PpuData$[rsp+8], rax

; 334  :       
; 335  : #define PPU_REG_ADRS 0x2000    
; 336  :     PpuData.Registers = (ppu_registers *)(CpuData.MemoryOffset + PPU_REG_ADRS);

  000d8	48 8b 84 24 c8
	01 00 00	 mov	 rax, QWORD PTR CpuData$[rsp+8]
  000e0	48 05 00 20 00
	00		 add	 rax, 8192		; 00002000H
  000e6	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR PpuData$[rsp], rax

; 337  :     PpuData.Registers->Status = (1 << 7) | (1 << 5); 

  000ee	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  000f6	c6 40 02 a0	 mov	 BYTE PTR [rax+2], 160	; 000000a0H

; 338  :     
; 339  :     
; 340  :     // Reading rom file
; 341  :     char * Filename = "Baseball.nes";

  000fa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88611
  00101	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR Filename$[rsp], rax

; 342  :     uint32 FileSize;
; 343  :     uint8 *RomData = (uint8 *)LoadFile(Filename, &FileSize);

  00109	48 8d 94 24 d8
	00 00 00	 lea	 rdx, QWORD PTR FileSize$[rsp]
  00111	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR Filename$[rsp]
  00119	e8 00 00 00 00	 call	 ?LoadFile@@YAPEAXPEADPEAI@Z ; LoadFile
  0011e	48 89 44 24 78	 mov	 QWORD PTR RomData$[rsp], rax

; 344  : 
; 345  :     // NOTE: Check for correct header
; 346  :     if(RomData[0] != 'N' || RomData[1] != 'E' || RomData[2] != 'S')

  00123	b8 01 00 00 00	 mov	 eax, 1
  00128	48 6b c0 00	 imul	 rax, rax, 0
  0012c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR RomData$[rsp]
  00131	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00135	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  00138	75 2e		 jne	 SHORT $LN12@WinMain
  0013a	b8 01 00 00 00	 mov	 eax, 1
  0013f	48 6b c0 01	 imul	 rax, rax, 1
  00143	48 8b 4c 24 78	 mov	 rcx, QWORD PTR RomData$[rsp]
  00148	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0014c	83 f8 45	 cmp	 eax, 69			; 00000045H
  0014f	75 17		 jne	 SHORT $LN12@WinMain
  00151	b8 01 00 00 00	 mov	 eax, 1
  00156	48 6b c0 02	 imul	 rax, rax, 2
  0015a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR RomData$[rsp]
  0015f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00163	83 f8 53	 cmp	 eax, 83			; 00000053H
  00166	74 12		 je	 SHORT $LN11@WinMain
$LN12@WinMain:

; 347  :     {
; 348  :         Assert(0);   

  00168	33 c0		 xor	 eax, eax
  0016a	83 f8 01	 cmp	 eax, 1
  0016d	74 0b		 je	 SHORT $LN13@WinMain
  0016f	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN13@WinMain:
$LN11@WinMain:

; 349  :     }
; 350  : 
; 351  :     // NOTE: Read header
; 352  :     uint8 RomPrgBankCount = RomData[4];

  0017a	b8 01 00 00 00	 mov	 eax, 1
  0017f	48 6b c0 04	 imul	 rax, rax, 4
  00183	48 8b 4c 24 78	 mov	 rcx, QWORD PTR RomData$[rsp]
  00188	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018c	88 44 24 62	 mov	 BYTE PTR RomPrgBankCount$[rsp], al

; 353  :     uint8 RomChrBankCount = RomData[5];

  00190	b8 01 00 00 00	 mov	 eax, 1
  00195	48 6b c0 05	 imul	 rax, rax, 5
  00199	48 8b 4c 24 78	 mov	 rcx, QWORD PTR RomData$[rsp]
  0019e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001a2	88 84 24 80 00
	00 00		 mov	 BYTE PTR RomChrBankCount$[rsp], al

; 354  : 
; 355  :     uint8 Flags6 = RomData[6];

  001a9	b8 01 00 00 00	 mov	 eax, 1
  001ae	48 6b c0 06	 imul	 rax, rax, 6
  001b2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR RomData$[rsp]
  001b7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001bb	88 44 24 61	 mov	 BYTE PTR Flags6$[rsp], al

; 356  :     uint8 Flags7 = RomData[7];

  001bf	b8 01 00 00 00	 mov	 eax, 1
  001c4	48 6b c0 07	 imul	 rax, rax, 7
  001c8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR RomData$[rsp]
  001cd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001d1	88 44 24 65	 mov	 BYTE PTR Flags7$[rsp], al

; 357  : 
; 358  :     uint8 RomPrgRamSize = RomData[8];

  001d5	b8 01 00 00 00	 mov	 eax, 1
  001da	48 6b c0 08	 imul	 rax, rax, 8
  001de	48 8b 4c 24 78	 mov	 rcx, QWORD PTR RomData$[rsp]
  001e3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001e7	88 84 24 81 00
	00 00		 mov	 BYTE PTR RomPrgRamSize$[rsp], al

; 359  :     uint8 Flags9 = RomData[9];

  001ee	b8 01 00 00 00	 mov	 eax, 1
  001f3	48 6b c0 09	 imul	 rax, rax, 9
  001f7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR RomData$[rsp]
  001fc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00200	88 84 24 82 00
	00 00		 mov	 BYTE PTR Flags9$[rsp], al

; 360  :     uint8 Flags10 = RomData[10];

  00207	b8 01 00 00 00	 mov	 eax, 1
  0020c	48 6b c0 0a	 imul	 rax, rax, 10
  00210	48 8b 4c 24 78	 mov	 rcx, QWORD PTR RomData$[rsp]
  00215	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00219	88 84 24 83 00
	00 00		 mov	 BYTE PTR Flags10$[rsp], al

; 361  : 
; 362  :     uint8 *RomPrgData;
; 363  :     // NOTE: If trainer present. Data after header and before program data
; 364  :     if(Flags6 & (1 << 2))

  00220	0f b6 44 24 61	 movzx	 eax, BYTE PTR Flags6$[rsp]
  00225	83 e0 04	 and	 eax, 4
  00228	85 c0		 test	 eax, eax
  0022a	74 13		 je	 SHORT $LN14@WinMain

; 365  :     {
; 366  :         Assert(1); 

  0022c	33 c0		 xor	 eax, eax
  0022e	85 c0		 test	 eax, eax
  00230	74 0b		 je	 SHORT $LN16@WinMain
  00232	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN16@WinMain:

; 367  :     }
; 368  :     else

  0023d	eb 11		 jmp	 SHORT $LN15@WinMain
$LN14@WinMain:

; 369  :     {
; 370  :         RomPrgData = RomData + 16;

  0023f	48 8b 44 24 78	 mov	 rax, QWORD PTR RomData$[rsp]
  00244	48 83 c0 10	 add	 rax, 16
  00248	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR RomPrgData$[rsp], rax
$LN15@WinMain:

; 371  :     }
; 372  : 
; 373  :     uint8 *RomChrData = RomPrgData + (RomPrgBankCount * Kilobytes(16));

  00250	0f b6 44 24 62	 movzx	 eax, BYTE PTR RomPrgBankCount$[rsp]
  00255	48 69 c0 00 40
	00 00		 imul	 rax, rax, 16384		; 00004000H
  0025c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR RomPrgData$[rsp]
  00264	48 03 c8	 add	 rcx, rax
  00267	48 8b c1	 mov	 rax, rcx
  0026a	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR RomChrData$[rsp], rax

; 374  :     // TODO: Implement Playchoice roms 
; 375  : 
; 376  : 
; 377  : 
; 378  : // NOTE: This is the two banks of memory that are currently loaded
; 379  : //       The mapper number will specify which initial banks are loaded
; 380  : //       Program will then change these banks while running.
; 381  : //       These pointers reference the rom memory.
; 382  : //       Offset is required to make relative to memory mapped address    
; 383  : 
; 384  :     
; 385  :     // TODO: Mappers
; 386  :     // NOTE: MY UNDERSTANDING OF HOW BANK REGISTERS WORK (SO FAR)
; 387  :     //
; 388  :     //       This is for M001. 
; 389  :     //       On the catridge, 4 registers are stored, each is 5 bits wide
; 390  :     //       These registers cannot be accessed directly, but can be set.
; 391  :     //       To set, writing to the prg rom 5 times will save the value.
; 392  :     //       To select the register to write too, the fifth write will be
; 393  :     //       to one of the prg banks. Only the fifth write will write to the specified
; 394  :     //       bank. If you write to 0x8000 4 times, then 0xE000 the fifth, only
; 395  :     //       0xE000 register will be written too. 0xE004 counts as 0xE000, and 0x8001
; 396  :     //       counts as 0x8000
; 397  :     //       There is a temporary port too
; 398  :     //       This is a byte with a reset bit and the bit just entered.
; 399  :     //       If reset is hit, then bit entered, plus temporary reg is cleared.
; 400  :     //       If 5 bits enter through port, then reg is saved
; 401  : 
; 402  :     // TODO: This will change as I add program mappers 
; 403  :     uint16 MemPrgBank1 = 0x8000;

  00272	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00277	66 89 84 24 84
	00 00 00	 mov	 WORD PTR MemPrgBank1$[rsp], ax

; 404  :     uint16 MemPrgBank2 = 0xC000;

  0027f	b8 00 c0 00 00	 mov	 eax, 49152		; 0000c000H
  00284	66 89 84 24 88
	00 00 00	 mov	 WORD PTR MemPrgBank2$[rsp], ax

; 405  :     
; 406  :     uint8 MapperNumber = (Flags7 & 0xF0) | (Flags6 >> 4);

  0028c	0f b6 44 24 65	 movzx	 eax, BYTE PTR Flags7$[rsp]
  00291	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00296	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR Flags6$[rsp]
  0029b	c1 f9 04	 sar	 ecx, 4
  0029e	0b c1		 or	 eax, ecx
  002a0	88 44 24 63	 mov	 BYTE PTR MapperNumber$[rsp], al

; 407  :     switch(MapperNumber)

  002a4	0f b6 44 24 63	 movzx	 eax, BYTE PTR MapperNumber$[rsp]
  002a9	88 84 24 a4 00
	00 00		 mov	 BYTE PTR tv193[rsp], al
  002b0	80 bc 24 a4 00
	00 00 00	 cmp	 BYTE PTR tv193[rsp], 0
  002b8	74 02		 je	 SHORT $LN17@WinMain
  002ba	eb 6a		 jmp	 SHORT $LN21@WinMain
$LN17@WinMain:

; 408  :     {
; 409  :         case 0:
; 410  :         {
; 411  :             if(RomPrgBankCount == 1) {

  002bc	0f b6 44 24 62	 movzx	 eax, BYTE PTR RomPrgBankCount$[rsp]
  002c1	83 f8 01	 cmp	 eax, 1
  002c4	75 4c		 jne	 SHORT $LN18@WinMain

; 412  :                 cpyMemory((uint8 *)MemPrgBank1 + CpuData.MemoryOffset, RomPrgData, Kilobytes(16));

  002c6	0f b7 84 24 84
	00 00 00	 movzx	 eax, WORD PTR MemPrgBank1$[rsp]
  002ce	48 03 84 24 c8
	01 00 00	 add	 rax, QWORD PTR CpuData$[rsp+8]
  002d6	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  002db	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR RomPrgData$[rsp]
  002e3	48 8b c8	 mov	 rcx, rax
  002e6	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 413  :                 cpyMemory((uint8 *)MemPrgBank2 + CpuData.MemoryOffset, RomPrgData, Kilobytes(16));

  002eb	0f b7 84 24 88
	00 00 00	 movzx	 eax, WORD PTR MemPrgBank2$[rsp]
  002f3	48 03 84 24 c8
	01 00 00	 add	 rax, QWORD PTR CpuData$[rsp+8]
  002fb	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  00300	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR RomPrgData$[rsp]
  00308	48 8b c8	 mov	 rcx, rax
  0030b	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 414  :             }
; 415  :             else

  00310	eb 12		 jmp	 SHORT $LN19@WinMain
$LN18@WinMain:

; 416  :                 Assert(0);

  00312	33 c0		 xor	 eax, eax
  00314	83 f8 01	 cmp	 eax, 1
  00317	74 0b		 je	 SHORT $LN20@WinMain
  00319	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN20@WinMain:
$LN19@WinMain:

; 417  :             break;

  00324	eb 3c		 jmp	 SHORT $LN2@WinMain
$LN21@WinMain:

; 418  :         }
; 419  :         
; 420  :         default:
; 421  :         {
; 422  :             char Buffer[8];
; 423  :             sprintf(Buffer, "Error: Unknown mapper number = %d\n", MapperNumber);

  00326	0f b6 44 24 63	 movzx	 eax, BYTE PTR MapperNumber$[rsp]
  0032b	44 8b c0	 mov	 r8d, eax
  0032e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG88623
  00335	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR Buffer$10[rsp]
  0033d	e8 00 00 00 00	 call	 sprintf

; 424  :             OutputDebugString(Buffer);

  00342	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR Buffer$10[rsp]
  0034a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 425  :             Assert(0);

  00350	33 c0		 xor	 eax, eax
  00352	83 f8 01	 cmp	 eax, 1
  00355	74 0b		 je	 SHORT $LN22@WinMain
  00357	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN22@WinMain:
$LN2@WinMain:

; 426  :             break;
; 427  :         }
; 428  :     }
; 429  :     
; 430  :     // NOTE: Load the program counter with the reset vector
; 431  :     CpuData.Registers.PrgCounter = readCpuMemory16(RESET_VEC, CpuData.MemoryOffset);

  00362	48 8b 94 24 c8
	01 00 00	 mov	 rdx, QWORD PTR CpuData$[rsp+8]
  0036a	66 b9 fc ff	 mov	 cx, 65532		; 0000fffcH
  0036e	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  00373	66 89 84 24 c6
	01 00 00	 mov	 WORD PTR CpuData$[rsp+6], ax

; 432  : 
; 433  :     
; 434  :     // Screen back buffer creation
; 435  :     uint16 RenderScaleWidth = 256, RenderScaleHeight = 240;

  0037b	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00380	66 89 44 24 74	 mov	 WORD PTR RenderScaleWidth$[rsp], ax
  00385	b8 f0 00 00 00	 mov	 eax, 240		; 000000f0H
  0038a	66 89 44 24 70	 mov	 WORD PTR RenderScaleHeight$[rsp], ax

; 436  :     uint8 ResScale = 5;

  0038f	c6 44 24 64 05	 mov	 BYTE PTR ResScale$[rsp], 5

; 437  :     uint16 WindowWidth = RenderScaleWidth * ResScale, WindowHeight = RenderScaleHeight * ResScale;

  00394	0f b7 44 24 74	 movzx	 eax, WORD PTR RenderScaleWidth$[rsp]
  00399	0f b6 4c 24 64	 movzx	 ecx, BYTE PTR ResScale$[rsp]
  0039e	0f af c1	 imul	 eax, ecx
  003a1	66 89 44 24 6c	 mov	 WORD PTR WindowWidth$[rsp], ax
  003a6	0f b7 44 24 70	 movzx	 eax, WORD PTR RenderScaleHeight$[rsp]
  003ab	0f b6 4c 24 64	 movzx	 ecx, BYTE PTR ResScale$[rsp]
  003b0	0f af c1	 imul	 eax, ecx
  003b3	66 89 44 24 68	 mov	 WORD PTR WindowHeight$[rsp], ax

; 438  :     screen_buffer ScreenBackBuffer = {};

  003b8	48 8d 84 24 e0
	01 00 00	 lea	 rax, QWORD PTR ScreenBackBuffer$[rsp]
  003c0	48 8b f8	 mov	 rdi, rax
  003c3	33 c0		 xor	 eax, eax
  003c5	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  003ca	f3 aa		 rep stosb

; 439  :     createBackBuffer(&ScreenBackBuffer, RenderScaleWidth, RenderScaleHeight);

  003cc	44 0f b7 44 24
	70		 movzx	 r8d, WORD PTR RenderScaleHeight$[rsp]
  003d2	0f b7 54 24 74	 movzx	 edx, WORD PTR RenderScaleWidth$[rsp]
  003d7	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR ScreenBackBuffer$[rsp]
  003df	e8 00 00 00 00	 call	 ?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z ; createBackBuffer

; 440  : 
; 441  :     PpuData.ZeroPixel = (uint32 *)ScreenBackBuffer.Memory;

  003e4	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR ScreenBackBuffer$[rsp+48]
  003ec	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR PpuData$[rsp+24], rax

; 442  : 
; 443  : 
; 444  :     
; 445  :     // Window Creation
; 446  :     WNDCLASSA WindowClass = {};

  003f4	48 8d 84 24 40
	01 00 00	 lea	 rax, QWORD PTR WindowClass$[rsp]
  003fc	48 8b f8	 mov	 rdi, rax
  003ff	33 c0		 xor	 eax, eax
  00401	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00406	f3 aa		 rep stosb

; 447  :     WindowClass.style = CS_HREDRAW | CS_VREDRAW;

  00408	c7 84 24 40 01
	00 00 03 00 00
	00		 mov	 DWORD PTR WindowClass$[rsp], 3

; 448  :     WindowClass.lpfnWndProc = WinInputCallback;

  00413	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z ; WinInputCallback
  0041a	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR WindowClass$[rsp+8], rax

; 449  :     WindowClass.hInstance = WindowInstance;

  00422	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR WindowInstance$[rsp]
  0042a	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR WindowClass$[rsp+24], rax

; 450  :     WindowClass.lpszClassName = "NesEmu";

  00432	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88625
  00439	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR WindowClass$[rsp+64], rax

; 451  : 
; 452  :     LARGE_INTEGER WinPerfCountFrequency;
; 453  :     QueryPerformanceFrequency(&WinPerfCountFrequency); 

  00441	48 8d 8c 24 e8
	00 00 00	 lea	 rcx, QWORD PTR WinPerfCountFrequency$[rsp]
  00449	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_QueryPerformanceFrequency

; 454  :     uint64 PerfCountFrequency = WinPerfCountFrequency.QuadPart;            

  0044f	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR WinPerfCountFrequency$[rsp]
  00457	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR PerfCountFrequency$[rsp], rax

; 455  : 
; 456  :     
; 457  :     if(RegisterClassA(&WindowClass))

  0045f	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR WindowClass$[rsp]
  00467	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegisterClassA
  0046d	0f b7 c0	 movzx	 eax, ax
  00470	85 c0		 test	 eax, eax
  00472	0f 84 32 02 00
	00		 je	 $LN23@WinMain

; 458  :     {
; 459  :         HWND Window = CreateWindowExA(0, WindowClass.lpszClassName, "NesEmu",

  00478	0f b7 44 24 68	 movzx	 eax, WORD PTR WindowHeight$[rsp]
  0047d	0f b7 4c 24 6c	 movzx	 ecx, WORD PTR WindowWidth$[rsp]
  00482	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR [rsp+88], 0
  0048b	48 8b 94 24 50
	02 00 00	 mov	 rdx, QWORD PTR WindowInstance$[rsp]
  00493	48 89 54 24 50	 mov	 QWORD PTR [rsp+80], rdx
  00498	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  004a1	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  004aa	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  004ae	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  004b2	c7 44 24 28 00
	00 00 80	 mov	 DWORD PTR [rsp+40], -2147483648 ; ffffffff80000000H
  004ba	c7 44 24 20 00
	00 00 80	 mov	 DWORD PTR [rsp+32], -2147483648 ; ffffffff80000000H
  004c2	41 b9 00 00 cf
	10		 mov	 r9d, 282001408		; 10cf0000H
  004c8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG88628
  004cf	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR WindowClass$[rsp+64]
  004d7	33 c9		 xor	 ecx, ecx
  004d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateWindowExA
  004df	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR Window$4[rsp], rax

; 460  :                                       WS_OVERLAPPEDWINDOW|WS_VISIBLE,
; 461  :                                       CW_USEDEFAULT, CW_USEDEFAULT,
; 462  :                                       WindowWidth, WindowHeight,
; 463  :                                       0, 0, WindowInstance, 0);
; 464  :         if(Window) // If window was created successfully

  004e7	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR Window$4[rsp], 0
  004f0	0f 84 a0 01 00
	00		 je	 $LN25@WinMain

; 465  :         {
; 466  :             LARGE_INTEGER LastCounter;
; 467  :             QueryPerformanceCounter(&LastCounter);                        

  004f6	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR LastCounter$7[rsp]
  004fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_QueryPerformanceCounter

; 468  :             uint64 LastCycles = __rdtsc();

  00504	0f 31		 rdtsc
  00506	48 c1 e2 20	 shl	 rdx, 32			; 00000020H
  0050a	48 0b c2	 or	 rax, rdx
  0050d	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR LastCycles$8[rsp], rax

; 469  :             
; 470  :             // TODO: Must run the emulation at the same speed as the nes would.
; 471  :             GlobalRunning = true;

  00515	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 1

; 472  :             
; 473  :                         
; 474  :             real32 CurrentMS, PrevMS = getMilliSeconds(PerfCountFrequency);

  0051f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR PerfCountFrequency$[rsp]
  00527	e8 00 00 00 00	 call	 ?getMilliSeconds@@YAM_K@Z ; getMilliSeconds
  0052c	f3 0f 11 84 24
	90 00 00 00	 movss	 DWORD PTR PrevMS$3[rsp], xmm0

; 475  :             real32 ElapsedMS = 0;

  00535	0f 57 c0	 xorps	 xmm0, xmm0
  00538	f3 0f 11 84 24
	a8 00 00 00	 movss	 DWORD PTR ElapsedMS$5[rsp], xmm0
$LN4@WinMain:

; 476  :             while(GlobalRunning)

  00541	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?GlobalRunning@@3HA, 0
  00548	0f 84 46 01 00
	00		 je	 $LN5@WinMain

; 477  :             {
; 478  :                 MSG Message = {}; 

  0054e	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR Message$9[rsp]
  00556	48 8b f8	 mov	 rdi, rax
  00559	33 c0		 xor	 eax, eax
  0055b	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00560	f3 aa		 rep stosb
$LN6@WinMain:

; 479  :                 while (PeekMessage(&Message, Window, 0, 0, PM_REMOVE))

  00562	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0056a	45 33 c9	 xor	 r9d, r9d
  0056d	45 33 c0	 xor	 r8d, r8d
  00570	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR Window$4[rsp]
  00578	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR Message$9[rsp]
  00580	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PeekMessageA
  00586	85 c0		 test	 eax, eax
  00588	74 1e		 je	 SHORT $LN7@WinMain

; 480  :                 {
; 481  :                     TranslateMessage(&Message);

  0058a	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR Message$9[rsp]
  00592	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TranslateMessage

; 482  :                     DispatchMessage(&Message);

  00598	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR Message$9[rsp]
  005a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DispatchMessageA

; 483  :                 }

  005a6	eb ba		 jmp	 SHORT $LN6@WinMain
$LN7@WinMain:

; 484  : 
; 485  :                 cpuTick(&CpuData);

  005a8	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR CpuData$[rsp]
  005b0	e8 00 00 00 00	 call	 ?cpuTick@@YAXPEAUcpu@@@Z ; cpuTick

; 486  :                 // TODO: Timing is not complete
; 487  :                 //       Cpu opcodes execute in a different number of cycles
; 488  :                 //       Must multiply pputicks to stay synched.
; 489  :                 for(uint8 i = 0; i < 3; ++i)

  005b5	c6 44 24 60 00	 mov	 BYTE PTR i$1[rsp], 0
  005ba	eb 0b		 jmp	 SHORT $LN10@WinMain
$LN8@WinMain:
  005bc	0f b6 44 24 60	 movzx	 eax, BYTE PTR i$1[rsp]
  005c1	fe c0		 inc	 al
  005c3	88 44 24 60	 mov	 BYTE PTR i$1[rsp], al
$LN10@WinMain:
  005c7	0f b6 44 24 60	 movzx	 eax, BYTE PTR i$1[rsp]
  005cc	83 f8 03	 cmp	 eax, 3
  005cf	7d 17		 jge	 SHORT $LN9@WinMain

; 490  :                 {
; 491  :                     ppuTick(&ScreenBackBuffer, &PpuData);

  005d1	48 8d 94 24 08
	01 00 00	 lea	 rdx, QWORD PTR PpuData$[rsp]
  005d9	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR ScreenBackBuffer$[rsp]
  005e1	e8 00 00 00 00	 call	 ?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z ; ppuTick

; 492  :                 }

  005e6	eb d4		 jmp	 SHORT $LN8@WinMain
$LN9@WinMain:

; 493  :           
; 494  :                 getWindowSize(Window, &WindowWidth, &WindowHeight);

  005e8	4c 8d 44 24 68	 lea	 r8, QWORD PTR WindowHeight$[rsp]
  005ed	48 8d 54 24 6c	 lea	 rdx, QWORD PTR WindowWidth$[rsp]
  005f2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Window$4[rsp]
  005fa	e8 00 00 00 00	 call	 ?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z ; getWindowSize

; 495  :                 
; 496  :                 // NOTE: Drawing the backbuffer to the window 
; 497  :                 HDC DeviceContext = GetDC(Window);

  005ff	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Window$4[rsp]
  00607	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetDC
  0060d	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR DeviceContext$6[rsp], rax

; 498  :                 drawScreenBuffer(&ScreenBackBuffer, DeviceContext,

  00615	44 0f b7 4c 24
	68		 movzx	 r9d, WORD PTR WindowHeight$[rsp]
  0061b	44 0f b7 44 24
	6c		 movzx	 r8d, WORD PTR WindowWidth$[rsp]
  00621	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR DeviceContext$6[rsp]
  00629	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR ScreenBackBuffer$[rsp]
  00631	e8 00 00 00 00	 call	 ?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z ; drawScreenBuffer

; 499  :                                  WindowWidth, WindowHeight);
; 500  :                 ReleaseDC(Window, DeviceContext);

  00636	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR DeviceContext$6[rsp]
  0063e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Window$4[rsp]
  00646	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReleaseDC

; 501  : 
; 502  :                 CurrentMS = getMilliSeconds(PerfCountFrequency);

  0064c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR PerfCountFrequency$[rsp]
  00654	e8 00 00 00 00	 call	 ?getMilliSeconds@@YAM_K@Z ; getMilliSeconds
  00659	f3 0f 11 84 24
	8c 00 00 00	 movss	 DWORD PTR CurrentMS$2[rsp], xmm0

; 503  :                 ElapsedMS = CurrentMS - PrevMS;

  00662	f3 0f 10 84 24
	8c 00 00 00	 movss	 xmm0, DWORD PTR CurrentMS$2[rsp]
  0066b	f3 0f 5c 84 24
	90 00 00 00	 subss	 xmm0, DWORD PTR PrevMS$3[rsp]
  00674	f3 0f 11 84 24
	a8 00 00 00	 movss	 DWORD PTR ElapsedMS$5[rsp], xmm0

; 504  :                 PrevMS = CurrentMS;

  0067d	f3 0f 10 84 24
	8c 00 00 00	 movss	 xmm0, DWORD PTR CurrentMS$2[rsp]
  00686	f3 0f 11 84 24
	90 00 00 00	 movss	 DWORD PTR PrevMS$3[rsp], xmm0

; 505  :             }

  0068f	e9 ad fe ff ff	 jmp	 $LN4@WinMain
$LN5@WinMain:

; 506  :         }
; 507  :         else

  00694	eb 12		 jmp	 SHORT $LN26@WinMain
$LN25@WinMain:

; 508  :         {
; 509  :             Assert(0);

  00696	33 c0		 xor	 eax, eax
  00698	83 f8 01	 cmp	 eax, 1
  0069b	74 0b		 je	 SHORT $LN27@WinMain
  0069d	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN27@WinMain:
$LN26@WinMain:

; 510  :         }
; 511  :     }
; 512  :     else

  006a8	eb 12		 jmp	 SHORT $LN24@WinMain
$LN23@WinMain:

; 513  :     {
; 514  :         Assert(0);

  006aa	33 c0		 xor	 eax, eax
  006ac	83 f8 01	 cmp	 eax, 1
  006af	74 0b		 je	 SHORT $LN28@WinMain
  006b1	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN28@WinMain:
$LN24@WinMain:

; 515  :     }
; 516  :     return(0);

  006bc	33 c0		 xor	 eax, eax

; 517  : } 

  006be	48 8b 8c 24 38
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  006c6	48 33 cc	 xor	 rcx, rsp
  006c9	e8 00 00 00 00	 call	 __security_check_cookie
  006ce	48 81 c4 40 02
	00 00		 add	 rsp, 576		; 00000240H
  006d5	5f		 pop	 rdi
  006d6	c3		 ret	 0
WinMain	ENDP
_TEXT	ENDS
END
