; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
?WinInput@@3Uinput@@A DB 020H DUP (?)			; WinInput
_BSS	ENDS
CONST	SEGMENT
$SG87591 DB	'Up', 00H
	ORG $+1
$SG87593 DB	'Up', 00H
	ORG $+1
$SG87595 DB	'Up', 00H
	ORG $+1
$SG87597 DB	'Up', 00H
	ORG $+1
$SG87599 DB	'Up', 00H
	ORG $+1
$SG87601 DB	'Up', 00H
	ORG $+1
$SG87603 DB	'Up', 00H
	ORG $+1
$SG87605 DB	'Up', 00H
	ORG $+1
$SG87765 DB	'ZeldaT.nes', 00H
	ORG $+5
$SG87775 DB	'Error: Unknown mapper number = %d', 0aH, 00H
	ORG $+1
$SG87777 DB	'NesEmu', 00H
	ORG $+1
$SG87780 DB	'NesEmu', 00H
CONST	ENDS
PUBLIC	WinMain
PUBLIC	__local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z	; WinInputCallback
PUBLIC	?LoadRomData@@YAPEAXPEADPEAI@Z			; LoadRomData
PUBLIC	?PushByte@@YAXEPEAE0@Z				; PushByte
PUBLIC	?PopByte@@YAEPEAE0@Z				; PopByte
PUBLIC	?writeMemByte@@YAXGE@Z				; writeMemByte
PUBLIC	?readMemory@@YAEG@Z				; readMemory
PUBLIC	?readMemory16@@YAGG@Z				; readMemory16
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
EXTRN	__imp_CreateFileA:PROC
EXTRN	__imp_GetFileSizeEx:PROC
EXTRN	__imp_ReadFile:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_QueryPerformanceCounter:PROC
EXTRN	__imp_VirtualAlloc:PROC
EXTRN	__imp_TranslateMessage:PROC
EXTRN	__imp_DispatchMessageA:PROC
EXTRN	__imp_PeekMessageA:PROC
EXTRN	__imp_DefWindowProcA:PROC
EXTRN	__imp_RegisterClassA:PROC
EXTRN	__imp_CreateWindowExA:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?GlobalRunning@@3HA DD 01H DUP (?)			; GlobalRunning
	ALIGN	8

?MemoryStartOffset@@3_KA DQ 01H DUP (?)			; MemoryStartOffset
_BSS	ENDS
pdata	SEGMENT
$pdata$WinMain DD imagerel $LN25
	DD	imagerel $LN25+1173
	DD	imagerel $unwind$WinMain
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z DD imagerel $LN51
	DD	imagerel $LN51+1251
	DD	imagerel $unwind$?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z
$pdata$?LoadRomData@@YAPEAXPEADPEAI@Z DD imagerel $LN13
	DD	imagerel $LN13+259
	DD	imagerel $unwind$?LoadRomData@@YAPEAXPEADPEAI@Z
$pdata$?PushByte@@YAXEPEAE0@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?PushByte@@YAXEPEAE0@Z
$pdata$?PopByte@@YAEPEAE0@Z DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$?PopByte@@YAEPEAE0@Z
$pdata$?writeMemByte@@YAXGE@Z DD imagerel $LN5
	DD	imagerel $LN5+122
	DD	imagerel $unwind$?writeMemByte@@YAXGE@Z
$pdata$?readMemory@@YAEG@Z DD imagerel $LN5
	DD	imagerel $LN5+114
	DD	imagerel $unwind$?readMemory@@YAEG@Z
$pdata$?readMemory16@@YAGG@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$?readMemory16@@YAGG@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
xdata	SEGMENT
$unwind$WinMain DD 032e19H
	DD	030011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0178H
$unwind$?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z DD 011701H
	DD	0e217H
$unwind$?LoadRomData@@YAPEAXPEADPEAI@Z DD 010e01H
	DD	0c20eH
$unwind$?PushByte@@YAXEPEAE0@Z DD 011201H
	DD	02212H
$unwind$?PopByte@@YAEPEAE0@Z DD 010e01H
	DD	0220eH
$unwind$?writeMemByte@@YAXGE@Z DD 010d01H
	DD	0220dH
$unwind$?readMemory@@YAEG@Z DD 010901H
	DD	02209H
$unwind$?readMemory16@@YAGG@Z DD 010901H
	DD	06209H
xdata	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0registers@?1??WinMain@@YAHPEAUHINSTANCE__@@0PEADH@Z@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0registers@?1??WinMain@@YAHPEAUHINSTANCE__@@0PEADH@Z@QEAA@XZ PROC ; `WinMain'::`2'::registers::registers, COMDAT
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c6 40 03 00	 mov	 BYTE PTR [rax+3], 0
  0000e	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00013	c3		 ret	 0
??0registers@?1??WinMain@@YAHPEAUHINSTANCE__@@0PEADH@Z@QEAA@XZ ENDP ; `WinMain'::`2'::registers::registers
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemu\code\nesemu.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
NewAddress$ = 36
Address$ = 64
?readMemory16@@YAGG@Z PROC				; readMemory16

; 293  : {

$LN3:
  00000	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 294  :     // NOTE: Little Endian
; 295  :     uint8 LowByte = readMemory(Address);

  00009	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0000e	e8 00 00 00 00	 call	 ?readMemory@@YAEG@Z	; readMemory
  00013	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 296  :     uint8 HighByte = readMemory(Address+1);

  00017	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0001c	ff c0		 inc	 eax
  0001e	0f b7 c8	 movzx	 ecx, ax
  00021	e8 00 00 00 00	 call	 ?readMemory@@YAEG@Z	; readMemory
  00026	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 297  :         
; 298  :     uint16 NewAddress = (HighByte << 8) | LowByte;

  0002a	0f b6 44 24 20	 movzx	 eax, BYTE PTR HighByte$[rsp]
  0002f	c1 e0 08	 shl	 eax, 8
  00032	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  00037	0b c1		 or	 eax, ecx
  00039	66 89 44 24 24	 mov	 WORD PTR NewAddress$[rsp], ax

; 299  :     return(NewAddress);

  0003e	0f b7 44 24 24	 movzx	 eax, WORD PTR NewAddress$[rsp]

; 300  : }

  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	c3		 ret	 0
?readMemory16@@YAGG@Z ENDP				; readMemory16
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemu\code\nesemu.cpp
_TEXT	SEGMENT
NewAddress$ = 0
Address$ = 32
?readMemory@@YAEG@Z PROC				; readMemory

; 279  : {

$LN5:
  00000	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00005	48 83 ec 18	 sub	 rsp, 24

; 280  :     // NOTE: Mirrors the address for the 2kb ram 
; 281  :     if(0x800 <= Address && Address < 0x2000)

  00009	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  0000e	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  00013	7c 1c		 jl	 SHORT $LN2@readMemory
  00015	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  0001a	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  0001f	7d 10		 jge	 SHORT $LN2@readMemory

; 282  :         Address = Address & (Kilobytes(2) - 1);  // Modulus for values power of 2

  00021	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  00026	48 25 ff 07 00
	00		 and	 rax, 2047		; 000007ffH
  0002c	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax
$LN2@readMemory:

; 283  :     // NOTE: Mirror for PPU Registers
; 284  :     if(0x2008 <= Address && Address < 0x4000)

  00031	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  00036	3d 08 20 00 00	 cmp	 eax, 8200		; 00002008H
  0003b	7c 19		 jl	 SHORT $LN3@readMemory
  0003d	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  00042	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  00047	7d 0d		 jge	 SHORT $LN3@readMemory

; 285  :         Address = Address & 7; // Modulus, repeates every 8 bytes

  00049	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  0004e	83 e0 07	 and	 eax, 7
  00051	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax
$LN3@readMemory:

; 286  : 
; 287  :     uint8 *NewAddress = (uint8 *)(Address + MemoryStartOffset);

  00056	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  0005b	48 03 05 00 00
	00 00		 add	 rax, QWORD PTR ?MemoryStartOffset@@3_KA
  00062	48 89 04 24	 mov	 QWORD PTR NewAddress$[rsp], rax

; 288  :     return(*NewAddress);

  00066	48 8b 04 24	 mov	 rax, QWORD PTR NewAddress$[rsp]
  0006a	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 289  : }

  0006d	48 83 c4 18	 add	 rsp, 24
  00071	c3		 ret	 0
?readMemory@@YAEG@Z ENDP				; readMemory
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemu\code\nesemu.cpp
_TEXT	SEGMENT
NewAddress$ = 0
Address$ = 32
Byte$ = 40
?writeMemByte@@YAXGE@Z PROC				; writeMemByte

; 265  : {

$LN5:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00009	48 83 ec 18	 sub	 rsp, 24

; 266  :     // NOTE: Mirrors the address for the 2kb ram 
; 267  :     if(0x800 <= Address && Address < 0x2000)

  0000d	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  00012	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  00017	7c 1c		 jl	 SHORT $LN2@writeMemBy
  00019	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  0001e	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  00023	7d 10		 jge	 SHORT $LN2@writeMemBy

; 268  :         Address = Address & (Kilobytes(2) - 1);  // Modulus for values power of 2

  00025	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  0002a	48 25 ff 07 00
	00		 and	 rax, 2047		; 000007ffH
  00030	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax
$LN2@writeMemBy:

; 269  :     // NOTE: Mirror for PPU Registers
; 270  :     if(0x2008 <= Address && Address < 0x4000)

  00035	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  0003a	3d 08 20 00 00	 cmp	 eax, 8200		; 00002008H
  0003f	7c 19		 jl	 SHORT $LN3@writeMemBy
  00041	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  00046	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  0004b	7d 0d		 jge	 SHORT $LN3@writeMemBy

; 271  :         Address = Address & 7; // Modulus, repeates every 8 bytes

  0004d	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  00052	83 e0 07	 and	 eax, 7
  00055	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax
$LN3@writeMemBy:

; 272  : 
; 273  :     
; 274  :     uint8 *NewAddress = (uint8 *)(Address + MemoryStartOffset);

  0005a	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  0005f	48 03 05 00 00
	00 00		 add	 rax, QWORD PTR ?MemoryStartOffset@@3_KA
  00066	48 89 04 24	 mov	 QWORD PTR NewAddress$[rsp], rax

; 275  :     *NewAddress = Byte;

  0006a	48 8b 04 24	 mov	 rax, QWORD PTR NewAddress$[rsp]
  0006e	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR Byte$[rsp]
  00073	88 08		 mov	 BYTE PTR [rax], cl

; 276  : }

  00075	48 83 c4 18	 add	 rsp, 24
  00079	c3		 ret	 0
?writeMemByte@@YAXGE@Z ENDP				; writeMemByte
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemu\code\nesemu.cpp
_TEXT	SEGMENT
Value$ = 0
Address$ = 8
StackPointer$ = 32
StackLocation$ = 40
?PopByte@@YAEPEAE0@Z PROC				; PopByte

; 255  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 256  :     uint8 *Address = (uint8 *)(*StackPointer + (uint64) StackLocation);

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR StackPointer$[rsp]
  00013	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00016	48 03 44 24 28	 add	 rax, QWORD PTR StackLocation$[rsp]
  0001b	48 89 44 24 08	 mov	 QWORD PTR Address$[rsp], rax

; 257  :     uint8 Value = *Address;

  00020	48 8b 44 24 08	 mov	 rax, QWORD PTR Address$[rsp]
  00025	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00028	88 04 24	 mov	 BYTE PTR Value$[rsp], al

; 258  : 
; 259  :     ++(*StackPointer);

  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR StackPointer$[rsp]
  00030	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00033	fe c0		 inc	 al
  00035	48 8b 4c 24 20	 mov	 rcx, QWORD PTR StackPointer$[rsp]
  0003a	88 01		 mov	 BYTE PTR [rcx], al

; 260  :     
; 261  :     return(Value);

  0003c	0f b6 04 24	 movzx	 eax, BYTE PTR Value$[rsp]

; 262  : }

  00040	48 83 c4 18	 add	 rsp, 24
  00044	c3		 ret	 0
?PopByte@@YAEPEAE0@Z ENDP				; PopByte
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemu\code\nesemu.cpp
_TEXT	SEGMENT
Address$ = 0
Byte$ = 32
StackPointer$ = 40
StackLocation$ = 48
?PushByte@@YAXEPEAE0@Z PROC				; PushByte

; 242  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	48 83 ec 18	 sub	 rsp, 24

; 243  :     // NOTE:
; 244  :     // Stack pointer is commonly initialised to 0xFF.
; 245  :     // Adding a byte will decrease the pointer.
; 246  :     // Poping increases the pointer.
; 247  :     // The pointer does wrap if under 0x100
; 248  : 
; 249  :     uint8 *Address = (uint8 *)(*StackPointer + (uint64) StackLocation);

  00012	48 8b 44 24 28	 mov	 rax, QWORD PTR StackPointer$[rsp]
  00017	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001a	48 03 44 24 30	 add	 rax, QWORD PTR StackLocation$[rsp]
  0001f	48 89 04 24	 mov	 QWORD PTR Address$[rsp], rax

; 250  :     *Address = Byte;

  00023	48 8b 04 24	 mov	 rax, QWORD PTR Address$[rsp]
  00027	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Byte$[rsp]
  0002c	88 08		 mov	 BYTE PTR [rax], cl

; 251  : 
; 252  :     --(*StackPointer);  

  0002e	48 8b 44 24 28	 mov	 rax, QWORD PTR StackPointer$[rsp]
  00033	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00036	fe c8		 dec	 al
  00038	48 8b 4c 24 28	 mov	 rcx, QWORD PTR StackPointer$[rsp]
  0003d	88 01		 mov	 BYTE PTR [rcx], al

; 253  : }

  0003f	48 83 c4 18	 add	 rsp, 24
  00043	c3		 ret	 0
?PushByte@@YAXEPEAE0@Z ENDP				; PushByte
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemu\code\nesemu.cpp
_TEXT	SEGMENT
BytesRead$1 = 64
RomData$ = 72
RomHandle$ = 80
Filesize$2 = 88
Filename$ = 112
Size$ = 120
?LoadRomData@@YAPEAXPEADPEAI@Z PROC			; LoadRomData

; 179  : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 180  :     void *RomData = 0;

  0000e	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR RomData$[rsp], 0

; 181  :     
; 182  :     HANDLE RomHandle = CreateFileA(Filename, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);

  00017	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00020	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00028	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  00030	45 33 c9	 xor	 r9d, r9d
  00033	41 b8 01 00 00
	00		 mov	 r8d, 1
  00039	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  0003e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Filename$[rsp]
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileA
  00049	48 89 44 24 50	 mov	 QWORD PTR RomHandle$[rsp], rax

; 183  :     if(RomHandle != INVALID_HANDLE_VALUE)

  0004e	48 83 7c 24 50
	ff		 cmp	 QWORD PTR RomHandle$[rsp], -1
  00054	0f 84 8d 00 00
	00		 je	 $LN2@LoadRomDat

; 184  :     {
; 185  :         LARGE_INTEGER Filesize;
; 186  :         if(GetFileSizeEx(RomHandle, &Filesize))

  0005a	48 8d 54 24 58	 lea	 rdx, QWORD PTR Filesize$2[rsp]
  0005f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR RomHandle$[rsp]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileSizeEx
  0006a	85 c0		 test	 eax, eax
  0006c	74 77		 je	 SHORT $LN4@LoadRomDat

; 187  :         {
; 188  :             RomData = VirtualAlloc(0, Filesize.LowPart, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);

  0006e	8b 44 24 58	 mov	 eax, DWORD PTR Filesize$2[rsp]
  00072	41 b9 04 00 00
	00		 mov	 r9d, 4
  00078	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  0007e	8b d0		 mov	 edx, eax
  00080	33 c9		 xor	 ecx, ecx
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  00088	48 89 44 24 48	 mov	 QWORD PTR RomData$[rsp], rax

; 189  :             if(RomData)

  0008d	48 83 7c 24 48
	00		 cmp	 QWORD PTR RomData$[rsp], 0
  00093	74 50		 je	 SHORT $LN6@LoadRomDat

; 190  :             {
; 191  :                 DWORD BytesRead;
; 192  :                 if(ReadFile(RomHandle, RomData, Filesize.LowPart, &BytesRead, 0) &&

  00095	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0009e	4c 8d 4c 24 40	 lea	 r9, QWORD PTR BytesRead$1[rsp]
  000a3	44 8b 44 24 58	 mov	 r8d, DWORD PTR Filesize$2[rsp]
  000a8	48 8b 54 24 48	 mov	 rdx, QWORD PTR RomData$[rsp]
  000ad	48 8b 4c 24 50	 mov	 rcx, QWORD PTR RomHandle$[rsp]
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReadFile
  000b8	85 c0		 test	 eax, eax
  000ba	74 17		 je	 SHORT $LN8@LoadRomDat
  000bc	8b 44 24 40	 mov	 eax, DWORD PTR BytesRead$1[rsp]
  000c0	39 44 24 58	 cmp	 DWORD PTR Filesize$2[rsp], eax
  000c4	75 0d		 jne	 SHORT $LN8@LoadRomDat

; 193  :                    (Filesize.LowPart == BytesRead))
; 194  :                 {
; 195  :                     *Size = (uint32)BytesRead;

  000c6	48 8b 44 24 78	 mov	 rax, QWORD PTR Size$[rsp]
  000cb	8b 4c 24 40	 mov	 ecx, DWORD PTR BytesRead$1[rsp]
  000cf	89 08		 mov	 DWORD PTR [rax], ecx

; 196  :                     // It worked!
; 197  :                 }
; 198  :                 else

  000d1	eb 12		 jmp	 SHORT $LN9@LoadRomDat
$LN8@LoadRomDat:

; 199  :                 {
; 200  :                     Assert(0);

  000d3	33 c0		 xor	 eax, eax
  000d5	83 f8 01	 cmp	 eax, 1
  000d8	74 0b		 je	 SHORT $LN10@LoadRomDat
  000da	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN10@LoadRomDat:
$LN9@LoadRomDat:
$LN6@LoadRomDat:
$LN4@LoadRomDat:

; 201  :                 }
; 202  :             }
; 203  :             else
; 204  :             {
; 205  :             }   
; 206  :         }
; 207  :         else
; 208  :         {
; 209  :         }
; 210  :     }
; 211  :     else

  000e5	eb 12		 jmp	 SHORT $LN3@LoadRomDat
$LN2@LoadRomDat:

; 212  :     {
; 213  :         Assert(0);

  000e7	33 c0		 xor	 eax, eax
  000e9	83 f8 01	 cmp	 eax, 1
  000ec	74 0b		 je	 SHORT $LN11@LoadRomDat
  000ee	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN11@LoadRomDat:
$LN3@LoadRomDat:

; 214  :     }
; 215  :     return(RomData);

  000f9	48 8b 44 24 48	 mov	 rax, QWORD PTR RomData$[rsp]

; 216  : }

  000fe	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00102	c3		 ret	 0
?LoadRomData@@YAPEAXPEADPEAI@Z ENDP			; LoadRomData
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemu\code\nesemu.cpp
_TEXT	SEGMENT
tv64 = 32
tv67 = 36
tv70 = 40
tv73 = 44
tv82 = 48
tv89 = 52
tv128 = 56
tv135 = 60
tv142 = 64
tv149 = 68
tv156 = 72
tv163 = 76
tv75 = 80
WasDown$1 = 88
IsDown$2 = 92
AltPressed$3 = 96
Result$ = 104
WindowHandle$ = 128
Message$ = 136
wParam$ = 144
lParam$ = 152
?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z PROC		; WinInputCallback

; 60   : {

$LN51:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 61   :     LRESULT Result = 0;

  00017	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR Result$[rsp], 0

; 62   :     
; 63   :     switch(Message) 

  00020	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR Message$[rsp]
  00027	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  0002b	83 7c 24 20 10	 cmp	 DWORD PTR tv64[rsp], 16
  00030	77 21		 ja	 SHORT $LN48@WinInputCa
  00032	83 7c 24 20 10	 cmp	 DWORD PTR tv64[rsp], 16
  00037	74 59		 je	 SHORT $LN8@WinInputCa
  00039	83 7c 24 20 01	 cmp	 DWORD PTR tv64[rsp], 1
  0003e	74 48		 je	 SHORT $LN6@WinInputCa
  00040	83 7c 24 20 02	 cmp	 DWORD PTR tv64[rsp], 2
  00045	74 50		 je	 SHORT $LN9@WinInputCa
  00047	83 7c 24 20 05	 cmp	 DWORD PTR tv64[rsp], 5
  0004c	74 3f		 je	 SHORT $LN7@WinInputCa
  0004e	e9 c8 03 00 00	 jmp	 $LN24@WinInputCa
$LN48@WinInputCa:
  00053	81 7c 24 20 00
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 256 ; 00000100H
  0005b	0f 82 ba 03 00
	00		 jb	 $LN24@WinInputCa
  00061	81 7c 24 20 01
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 257 ; 00000101H
  00069	76 31		 jbe	 SHORT $LN10@WinInputCa
  0006b	81 7c 24 20 03
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 259 ; 00000103H
  00073	0f 86 a2 03 00
	00		 jbe	 $LN24@WinInputCa
  00079	81 7c 24 20 05
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 261 ; 00000105H
  00081	76 19		 jbe	 SHORT $LN10@WinInputCa
  00083	e9 93 03 00 00	 jmp	 $LN24@WinInputCa
$LN6@WinInputCa:

; 64   :     { 
; 65   :         case WM_CREATE:
; 66   :         {
; 67   :             // Initialize the window. 
; 68   :             break; 

  00088	e9 b8 03 00 00	 jmp	 $LN2@WinInputCa
$LN7@WinInputCa:

; 69   :         }
; 70   :         
; 71   :         case WM_SIZE:
; 72   :         {
; 73   :             // Set the size and position of the window. 
; 74   :             break;

  0008d	e9 b3 03 00 00	 jmp	 $LN2@WinInputCa
$LN8@WinInputCa:

; 75   :         }
; 76   :         case WM_CLOSE:
; 77   :         {
; 78   :             break;

  00092	e9 ae 03 00 00	 jmp	 $LN2@WinInputCa
$LN9@WinInputCa:

; 79   :         }
; 80   :         case WM_DESTROY:
; 81   :         {
; 82   :             break;

  00097	e9 a9 03 00 00	 jmp	 $LN2@WinInputCa
$LN10@WinInputCa:

; 83   :         }
; 84   :         case WM_SYSKEYDOWN:
; 85   :         case WM_SYSKEYUP:
; 86   :         case WM_KEYDOWN:
; 87   :         case WM_KEYUP:
; 88   :         {
; 89   :             bool32 IsDown = ((lParam & (1<<31)) == 0);

  0009c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR lParam$[rsp]
  000a4	48 25 00 00 00
	80		 and	 rax, -2147483648	; ffffffff80000000H
  000aa	48 85 c0	 test	 rax, rax
  000ad	75 0a		 jne	 SHORT $LN26@WinInputCa
  000af	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  000b7	eb 08		 jmp	 SHORT $LN27@WinInputCa
$LN26@WinInputCa:
  000b9	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN27@WinInputCa:
  000c1	8b 44 24 24	 mov	 eax, DWORD PTR tv67[rsp]
  000c5	89 44 24 5c	 mov	 DWORD PTR IsDown$2[rsp], eax

; 90   :             bool32 WasDown = ((lParam & (1<<30)) != 0);

  000c9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR lParam$[rsp]
  000d1	48 25 00 00 00
	40		 and	 rax, 1073741824		; 40000000H
  000d7	48 85 c0	 test	 rax, rax
  000da	74 0a		 je	 SHORT $LN28@WinInputCa
  000dc	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  000e4	eb 08		 jmp	 SHORT $LN29@WinInputCa
$LN28@WinInputCa:
  000e6	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN29@WinInputCa:
  000ee	8b 44 24 28	 mov	 eax, DWORD PTR tv70[rsp]
  000f2	89 44 24 58	 mov	 DWORD PTR WasDown$1[rsp], eax

; 91   : 
; 92   :             // NOTE: Alt only on SYSDOWN messages
; 93   :             bool32 AltPressed = ((lParam & (1<<29)) != 0);

  000f6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR lParam$[rsp]
  000fe	48 25 00 00 00
	20		 and	 rax, 536870912		; 20000000H
  00104	48 85 c0	 test	 rax, rax
  00107	74 0a		 je	 SHORT $LN30@WinInputCa
  00109	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  00111	eb 08		 jmp	 SHORT $LN31@WinInputCa
$LN30@WinInputCa:
  00113	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN31@WinInputCa:
  0011b	8b 44 24 2c	 mov	 eax, DWORD PTR tv73[rsp]
  0011f	89 44 24 60	 mov	 DWORD PTR AltPressed$3[rsp], eax

; 94   :               
; 95   :             if(IsDown != WasDown)

  00123	8b 44 24 58	 mov	 eax, DWORD PTR WasDown$1[rsp]
  00127	39 44 24 5c	 cmp	 DWORD PTR IsDown$2[rsp], eax
  0012b	0f 84 e8 02 00
	00		 je	 $LN11@WinInputCa

; 96   :             {               
; 97   :                 switch(wParam)

  00131	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR wParam$[rsp]
  00139	48 89 44 24 50	 mov	 QWORD PTR tv75[rsp], rax
  0013e	48 8b 44 24 50	 mov	 rax, QWORD PTR tv75[rsp]
  00143	48 83 e8 0d	 sub	 rax, 13
  00147	48 89 44 24 50	 mov	 QWORD PTR tv75[rsp], rax
  0014c	48 83 7c 24 50
	66		 cmp	 QWORD PTR tv75[rsp], 102 ; 00000066H
  00152	0f 87 c1 02 00
	00		 ja	 $LN4@WinInputCa
  00158	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:__ImageBase
  0015f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv75[rsp]
  00164	0f b6 8c 08 00
	00 00 00	 movzx	 ecx, BYTE PTR $LN49@WinInputCa[rax+rcx]
  0016c	8b 8c 88 00 00
	00 00		 mov	 ecx, DWORD PTR $LN50@WinInputCa[rax+rcx*4]
  00173	48 03 c8	 add	 rcx, rax
  00176	ff e1		 jmp	 rcx
$LN12@WinInputCa:

; 98   :                 {
; 99   :                     // NOTE: Up and down changes the octave the keys are in
; 100  :                     case VK_UP:
; 101  :                     {
; 102  :                         OutputDebugString("Up");

  00178	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG87591
  0017f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 103  :                         WinInput.buttons[input::B_UP] = !WinInput.buttons[input::B_UP];

  00185	b8 04 00 00 00	 mov	 eax, 4
  0018a	48 6b c0 00	 imul	 rax, rax, 0
  0018e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00195	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  00199	75 0a		 jne	 SHORT $LN32@WinInputCa
  0019b	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  001a3	eb 08		 jmp	 SHORT $LN33@WinInputCa
$LN32@WinInputCa:
  001a5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN33@WinInputCa:
  001ad	b8 04 00 00 00	 mov	 eax, 4
  001b2	48 6b c0 00	 imul	 rax, rax, 0
  001b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  001bd	8b 54 24 30	 mov	 edx, DWORD PTR tv82[rsp]
  001c1	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 104  :                         break;

  001c4	e9 50 02 00 00	 jmp	 $LN4@WinInputCa
$LN13@WinInputCa:

; 105  :                     }
; 106  :                     case VK_DOWN:
; 107  :                     {
; 108  :                         OutputDebugString("Up");

  001c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG87593
  001d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :                         WinInput.buttons[input::B_DOWN] = !WinInput.buttons[input::B_DOWN];

  001d6	b8 04 00 00 00	 mov	 eax, 4
  001db	48 6b c0 01	 imul	 rax, rax, 1
  001df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  001e6	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  001ea	75 0a		 jne	 SHORT $LN34@WinInputCa
  001ec	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv89[rsp], 1
  001f4	eb 08		 jmp	 SHORT $LN35@WinInputCa
$LN34@WinInputCa:
  001f6	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv89[rsp], 0
$LN35@WinInputCa:
  001fe	b8 04 00 00 00	 mov	 eax, 4
  00203	48 6b c0 01	 imul	 rax, rax, 1
  00207	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0020e	8b 54 24 34	 mov	 edx, DWORD PTR tv89[rsp]
  00212	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 110  :                         break;

  00215	e9 ff 01 00 00	 jmp	 $LN4@WinInputCa
$LN14@WinInputCa:

; 111  :                     }
; 112  :                     case VK_LEFT:
; 113  :                     {
; 114  :                         OutputDebugString("Up");

  0021a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG87595
  00221	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 115  :                         WinInput.buttons[input::B_LEFT] = !WinInput.buttons[input::B_LEFT];

  00227	b8 04 00 00 00	 mov	 eax, 4
  0022c	48 6b c0 02	 imul	 rax, rax, 2
  00230	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00237	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  0023b	75 0a		 jne	 SHORT $LN36@WinInputCa
  0023d	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv128[rsp], 1
  00245	eb 08		 jmp	 SHORT $LN37@WinInputCa
$LN36@WinInputCa:
  00247	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN37@WinInputCa:
  0024f	b8 04 00 00 00	 mov	 eax, 4
  00254	48 6b c0 02	 imul	 rax, rax, 2
  00258	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0025f	8b 54 24 38	 mov	 edx, DWORD PTR tv128[rsp]
  00263	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 116  :                         break;

  00266	e9 ae 01 00 00	 jmp	 $LN4@WinInputCa
$LN15@WinInputCa:

; 117  :                     }
; 118  :                     case VK_RIGHT:
; 119  :                     {
; 120  :                         OutputDebugString("Up");

  0026b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG87597
  00272	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 121  :                         WinInput.buttons[input::B_RIGHT] = !WinInput.buttons[input::B_RIGHT];

  00278	b8 04 00 00 00	 mov	 eax, 4
  0027d	48 6b c0 03	 imul	 rax, rax, 3
  00281	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00288	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  0028c	75 0a		 jne	 SHORT $LN38@WinInputCa
  0028e	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv135[rsp], 1
  00296	eb 08		 jmp	 SHORT $LN39@WinInputCa
$LN38@WinInputCa:
  00298	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN39@WinInputCa:
  002a0	b8 04 00 00 00	 mov	 eax, 4
  002a5	48 6b c0 03	 imul	 rax, rax, 3
  002a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  002b0	8b 54 24 3c	 mov	 edx, DWORD PTR tv135[rsp]
  002b4	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 122  :                         break;

  002b7	e9 5d 01 00 00	 jmp	 $LN4@WinInputCa
$LN16@WinInputCa:

; 123  :                     }
; 124  :                     case 'Z':
; 125  :                     {
; 126  :                         OutputDebugString("Up");

  002bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG87599
  002c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 127  :                         WinInput.buttons[input::B_A] = !WinInput.buttons[input::B_A];

  002c9	b8 04 00 00 00	 mov	 eax, 4
  002ce	48 6b c0 04	 imul	 rax, rax, 4
  002d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  002d9	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  002dd	75 0a		 jne	 SHORT $LN40@WinInputCa
  002df	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv142[rsp], 1
  002e7	eb 08		 jmp	 SHORT $LN41@WinInputCa
$LN40@WinInputCa:
  002e9	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN41@WinInputCa:
  002f1	b8 04 00 00 00	 mov	 eax, 4
  002f6	48 6b c0 04	 imul	 rax, rax, 4
  002fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00301	8b 54 24 40	 mov	 edx, DWORD PTR tv142[rsp]
  00305	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 128  :                         break;

  00308	e9 0c 01 00 00	 jmp	 $LN4@WinInputCa
$LN17@WinInputCa:

; 129  :                     }
; 130  :                     case 'X':
; 131  :                     {
; 132  :                         OutputDebugString("Up");

  0030d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG87601
  00314	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 133  :                         WinInput.buttons[input::B_B] = !WinInput.buttons[input::B_B];

  0031a	b8 04 00 00 00	 mov	 eax, 4
  0031f	48 6b c0 05	 imul	 rax, rax, 5
  00323	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0032a	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  0032e	75 0a		 jne	 SHORT $LN42@WinInputCa
  00330	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv149[rsp], 1
  00338	eb 08		 jmp	 SHORT $LN43@WinInputCa
$LN42@WinInputCa:
  0033a	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
$LN43@WinInputCa:
  00342	b8 04 00 00 00	 mov	 eax, 4
  00347	48 6b c0 05	 imul	 rax, rax, 5
  0034b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00352	8b 54 24 44	 mov	 edx, DWORD PTR tv149[rsp]
  00356	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 134  :                         break;

  00359	e9 bb 00 00 00	 jmp	 $LN4@WinInputCa
$LN18@WinInputCa:

; 135  :                     }
; 136  :                     case VK_RETURN:
; 137  :                     {
; 138  :                         OutputDebugString("Up");

  0035e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG87603
  00365	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 139  :                         WinInput.buttons[input::B_START] = !WinInput.buttons[input::B_START];

  0036b	b8 04 00 00 00	 mov	 eax, 4
  00370	48 6b c0 06	 imul	 rax, rax, 6
  00374	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0037b	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  0037f	75 0a		 jne	 SHORT $LN44@WinInputCa
  00381	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv156[rsp], 1
  00389	eb 08		 jmp	 SHORT $LN45@WinInputCa
$LN44@WinInputCa:
  0038b	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
$LN45@WinInputCa:
  00393	b8 04 00 00 00	 mov	 eax, 4
  00398	48 6b c0 06	 imul	 rax, rax, 6
  0039c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  003a3	8b 54 24 48	 mov	 edx, DWORD PTR tv156[rsp]
  003a7	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 140  :                         break;

  003aa	eb 6d		 jmp	 SHORT $LN4@WinInputCa
$LN19@WinInputCa:

; 141  :                     }
; 142  :                     case VK_SHIFT:
; 143  :                     {
; 144  :                         OutputDebugString("Up");

  003ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG87605
  003b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 145  :                         WinInput.buttons[input::B_SELECT] = !WinInput.buttons[input::B_SELECT];

  003b9	b8 04 00 00 00	 mov	 eax, 4
  003be	48 6b c0 07	 imul	 rax, rax, 7
  003c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  003c9	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  003cd	75 0a		 jne	 SHORT $LN46@WinInputCa
  003cf	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv163[rsp], 1
  003d7	eb 08		 jmp	 SHORT $LN47@WinInputCa
$LN46@WinInputCa:
  003d9	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv163[rsp], 0
$LN47@WinInputCa:
  003e1	b8 04 00 00 00	 mov	 eax, 4
  003e6	48 6b c0 07	 imul	 rax, rax, 7
  003ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  003f1	8b 54 24 4c	 mov	 edx, DWORD PTR tv163[rsp]
  003f5	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 146  :                         break;

  003f8	eb 1f		 jmp	 SHORT $LN4@WinInputCa

; 147  :                     }
; 148  :                     case VK_SPACE:
; 149  :                     {
; 150  :                         
; 151  :                         break;

  003fa	eb 1d		 jmp	 SHORT $LN4@WinInputCa
$LN21@WinInputCa:

; 152  :                     }
; 153  :                     case VK_ESCAPE:
; 154  :                     {
; 155  :                         GlobalRunning = false;

  003fc	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0

; 156  :                         break;

  00406	eb 11		 jmp	 SHORT $LN4@WinInputCa
$LN22@WinInputCa:

; 157  :                     }
; 158  :                     case VK_F4:
; 159  :                     {
; 160  :                         if(AltPressed)

  00408	83 7c 24 60 00	 cmp	 DWORD PTR AltPressed$3[rsp], 0
  0040d	74 0a		 je	 SHORT $LN23@WinInputCa

; 161  :                         {
; 162  :                             GlobalRunning = false;

  0040f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0
$LN23@WinInputCa:
$LN4@WinInputCa:
$LN11@WinInputCa:

; 163  :                         }
; 164  :                         break;
; 165  :                     }
; 166  :                 }
; 167  :             }
; 168  :             break;

  00419	eb 2a		 jmp	 SHORT $LN2@WinInputCa
$LN24@WinInputCa:

; 169  :         }            
; 170  :         default:
; 171  :         {
; 172  :             Result = DefWindowProc(WindowHandle, Message, wParam, lParam); 

  0041b	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR lParam$[rsp]
  00423	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR wParam$[rsp]
  0042b	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR Message$[rsp]
  00432	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR WindowHandle$[rsp]
  0043a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DefWindowProcA
  00440	48 89 44 24 68	 mov	 QWORD PTR Result$[rsp], rax
$LN2@WinInputCa:

; 173  :         }
; 174  :     }
; 175  :     return Result;

  00445	48 8b 44 24 68	 mov	 rax, QWORD PTR Result$[rsp]

; 176  : }

  0044a	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0044e	c3		 ret	 0
  0044f	90		 npad	 1
$LN50@WinInputCa:
  00450	00 00 00 00	 DD	 $LN18@WinInputCa
  00454	00 00 00 00	 DD	 $LN19@WinInputCa
  00458	00 00 00 00	 DD	 $LN21@WinInputCa
  0045c	00 00 00 00	 DD	 $LN14@WinInputCa
  00460	00 00 00 00	 DD	 $LN12@WinInputCa
  00464	00 00 00 00	 DD	 $LN15@WinInputCa
  00468	00 00 00 00	 DD	 $LN13@WinInputCa
  0046c	00 00 00 00	 DD	 $LN17@WinInputCa
  00470	00 00 00 00	 DD	 $LN16@WinInputCa
  00474	00 00 00 00	 DD	 $LN22@WinInputCa
  00478	00 00 00 00	 DD	 $LN4@WinInputCa
$LN49@WinInputCa:
  0047c	00		 DB	 0
  0047d	0a		 DB	 10
  0047e	0a		 DB	 10
  0047f	01		 DB	 1
  00480	0a		 DB	 10
  00481	0a		 DB	 10
  00482	0a		 DB	 10
  00483	0a		 DB	 10
  00484	0a		 DB	 10
  00485	0a		 DB	 10
  00486	0a		 DB	 10
  00487	0a		 DB	 10
  00488	0a		 DB	 10
  00489	0a		 DB	 10
  0048a	02		 DB	 2
  0048b	0a		 DB	 10
  0048c	0a		 DB	 10
  0048d	0a		 DB	 10
  0048e	0a		 DB	 10
  0048f	0a		 DB	 10
  00490	0a		 DB	 10
  00491	0a		 DB	 10
  00492	0a		 DB	 10
  00493	0a		 DB	 10
  00494	03		 DB	 3
  00495	04		 DB	 4
  00496	05		 DB	 5
  00497	06		 DB	 6
  00498	0a		 DB	 10
  00499	0a		 DB	 10
  0049a	0a		 DB	 10
  0049b	0a		 DB	 10
  0049c	0a		 DB	 10
  0049d	0a		 DB	 10
  0049e	0a		 DB	 10
  0049f	0a		 DB	 10
  004a0	0a		 DB	 10
  004a1	0a		 DB	 10
  004a2	0a		 DB	 10
  004a3	0a		 DB	 10
  004a4	0a		 DB	 10
  004a5	0a		 DB	 10
  004a6	0a		 DB	 10
  004a7	0a		 DB	 10
  004a8	0a		 DB	 10
  004a9	0a		 DB	 10
  004aa	0a		 DB	 10
  004ab	0a		 DB	 10
  004ac	0a		 DB	 10
  004ad	0a		 DB	 10
  004ae	0a		 DB	 10
  004af	0a		 DB	 10
  004b0	0a		 DB	 10
  004b1	0a		 DB	 10
  004b2	0a		 DB	 10
  004b3	0a		 DB	 10
  004b4	0a		 DB	 10
  004b5	0a		 DB	 10
  004b6	0a		 DB	 10
  004b7	0a		 DB	 10
  004b8	0a		 DB	 10
  004b9	0a		 DB	 10
  004ba	0a		 DB	 10
  004bb	0a		 DB	 10
  004bc	0a		 DB	 10
  004bd	0a		 DB	 10
  004be	0a		 DB	 10
  004bf	0a		 DB	 10
  004c0	0a		 DB	 10
  004c1	0a		 DB	 10
  004c2	0a		 DB	 10
  004c3	0a		 DB	 10
  004c4	0a		 DB	 10
  004c5	0a		 DB	 10
  004c6	0a		 DB	 10
  004c7	07		 DB	 7
  004c8	0a		 DB	 10
  004c9	08		 DB	 8
  004ca	0a		 DB	 10
  004cb	0a		 DB	 10
  004cc	0a		 DB	 10
  004cd	0a		 DB	 10
  004ce	0a		 DB	 10
  004cf	0a		 DB	 10
  004d0	0a		 DB	 10
  004d1	0a		 DB	 10
  004d2	0a		 DB	 10
  004d3	0a		 DB	 10
  004d4	0a		 DB	 10
  004d5	0a		 DB	 10
  004d6	0a		 DB	 10
  004d7	0a		 DB	 10
  004d8	0a		 DB	 10
  004d9	0a		 DB	 10
  004da	0a		 DB	 10
  004db	0a		 DB	 10
  004dc	0a		 DB	 10
  004dd	0a		 DB	 10
  004de	0a		 DB	 10
  004df	0a		 DB	 10
  004e0	0a		 DB	 10
  004e1	0a		 DB	 10
  004e2	09		 DB	 9
?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z ENDP		; WinInputCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  00018	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  0001d	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00022	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00027	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0002c	45 33 c0	 xor	 r8d, r8d
  0002f	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00039	e8 00 00 00 00	 call	 _vsprintf_l
  0003e	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

  00042	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

  0004b	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1788 : }

  0004f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00053	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00027	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  0002c	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00038	e8 00 00 00 00	 call	 _vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 83 c8 01	 or	 rax, 1
  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00029	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00033	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00038	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003d	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00047	48 8b c8	 mov	 rcx, rax
  0004a	e8 00 00 00 00	 call	 __stdio_common_vsprintf
  0004f	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00053	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00058	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005a	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00062	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00064	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  00068	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006c	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1391 : }

  00070	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00074	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File u:\programs\visual studio\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 81   :     static unsigned __int64 _OptionsStorage;
; 82   :     return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 83   : }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemu\code\nesemu.cpp
_TEXT	SEGMENT
Flags6$ = 96
MapperNumber$ = 97
RomPrgBankCount$ = 98
Flags7$ = 99
RomData$ = 104
MemPrgBank1$ = 112
MemPrgBank2$ = 113
RomChrBankCount$ = 114
RomPrgRamSize$ = 115
Flags9$ = 116
Flags10$ = 117
BytesRead$1 = 118
ResetVec$ = 120
tv153 = 124
RAMAdrs$ = 128
ZeroPageAdrs$ = 132
StackAdrs$ = 136
NMIVec$ = 140
IRQnBRKVec$ = 144
RomPrgData$ = 152
Registers$ = 160
Window$2 = 168
FileSize$ = 176
Memory$ = 184
Filename$ = 192
RomChrData$ = 200
loadedPrgBank1$ = 208
loadedPrgBank2$ = 216
LastCounter$3 = 224
LastCycles$4 = 232
WindowClass$ = 240
Message$5 = 320
Buffer$6 = 368
__$ArrayPad$ = 376
WindowInstance$ = 400
PrevWindowInstance$ = 408
CommandLine$ = 416
CommandShow$ = 424
WinMain	PROC

; 305  : {

$LN25:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 80 01
	00 00		 sub	 rsp, 384		; 00000180H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 306  :     struct registers {
; 307  :         uint8 A;
; 308  :         uint8 X;
; 309  :         uint8 Y; 
; 310  :         uint8 Flags = 0;
; 311  :         uint8 StackPtr;
; 312  :         uint16 PrgCounter; // not yet used
; 313  :     };
; 314  :     
; 315  :     registers Registers = {};

  0002e	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR Registers$[rsp]
  00036	48 8b f8	 mov	 rdi, rax
  00039	33 c0		 xor	 eax, eax
  0003b	b9 08 00 00 00	 mov	 ecx, 8
  00040	f3 aa		 rep stosb
  00042	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR Registers$[rsp]
  0004a	e8 00 00 00 00	 call	 ??0registers@?1??WinMain@@YAHPEAUHINSTANCE__@@0PEADH@Z@QEAA@XZ

; 316  : 
; 317  :     // Program will have these
; 318  :     uint16 NMIVec = 0xFFFA;

  0004f	b8 fa ff 00 00	 mov	 eax, 65530		; 0000fffaH
  00054	66 89 84 24 8c
	00 00 00	 mov	 WORD PTR NMIVec$[rsp], ax

; 319  :     uint16 ResetVec = 0xFFFC;

  0005c	b8 fc ff 00 00	 mov	 eax, 65532		; 0000fffcH
  00061	66 89 44 24 78	 mov	 WORD PTR ResetVec$[rsp], ax

; 320  :     uint16 IRQnBRKVec = 0xFFFE; 

  00066	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  0006b	66 89 84 24 90
	00 00 00	 mov	 WORD PTR IRQnBRKVec$[rsp], ax

; 321  :     
; 322  :     /*
; 323  :       CPU Memory Map - taken from nesdev.com
; 324  :       $0000-$07FF   $0800   2KB internal RAM
; 325  :       $0800-$0FFF   $0800   Mirrors of $0000-$07FF
; 326  :       $1000-$17FF   $0800
; 327  :       $1800-$1FFF   $0800
; 328  :       $2000-$2007   $0008   NES PPU registers
; 329  :       $2008-$3FFF   $1FF8   Mirrors of $2000-2007 (repeats every 8 bytes)
; 330  :       $4000-$4017   $0018   NES APU and I/O registers
; 331  :       $4018-$401F   $0008   APU and I/O functionality that is normally disabled. See CPU Test Mode.
; 332  :       $4020-$FFFF   $BFE0   Cartridge space: PRG ROM, PRG RAM, and mapper registers (See Note)
; 333  :      */
; 334  : 
; 335  :     /*
; 336  :       2KB RAM Rough Layout
; 337  :       0x0000-0x00FF  Zero Page
; 338  :       0x0100-0x01FF  Stack
; 339  :       0x0200-0x07FF  Unassigned Memory(free for program to use)
; 340  :      */
; 341  : 
; 342  :     uint8 * Memory = (uint8 *)VirtualAlloc(0, Kilobytes(64), MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);

  00073	41 b9 04 00 00
	00		 mov	 r9d, 4
  00079	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  0007f	ba 00 00 01 00	 mov	 edx, 65536		; 00010000H
  00084	33 c9		 xor	 ecx, ecx
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  0008c	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR Memory$[rsp], rax

; 343  :     MemoryStartOffset = (uint64)Memory; // TODO: Remove from gobal scope?

  00094	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR Memory$[rsp]
  0009c	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?MemoryStartOffset@@3_KA, rax

; 344  :     
; 345  :     // Ram Memory
; 346  :     uint16 RAMAdrs = 0x0;

  000a3	33 c0		 xor	 eax, eax
  000a5	66 89 84 24 80
	00 00 00	 mov	 WORD PTR RAMAdrs$[rsp], ax

; 347  :     uint16 ZeroPageAdrs = 0x0;

  000ad	33 c0		 xor	 eax, eax
  000af	66 89 84 24 84
	00 00 00	 mov	 WORD PTR ZeroPageAdrs$[rsp], ax

; 348  :     uint16 StackAdrs = 0x100;

  000b7	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  000bc	66 89 84 24 88
	00 00 00	 mov	 WORD PTR StackAdrs$[rsp], ax

; 349  : 
; 350  :         
; 351  :     uint8 MemPrgBank1 = 0x8000;

  000c4	c6 44 24 70 00	 mov	 BYTE PTR MemPrgBank1$[rsp], 0

; 352  :     uint8 MemPrgBank2 = 0xC000;

  000c9	c6 44 24 71 00	 mov	 BYTE PTR MemPrgBank2$[rsp], 0

; 353  : 
; 354  : 
; 355  :     // NOTE: Not sure if needed yet.
; 356  :     //uint16 PPURegAdrs = 0x2000;
; 357  :     //uint16 IORegAdrs = 0x4000;
; 358  :     
; 359  :     // Reading rom file
; 360  :     char * Filename = "ZeldaT.nes";

  000ce	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG87765
  000d5	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR Filename$[rsp], rax

; 361  :     uint32 FileSize;
; 362  :     uint8 *RomData = (uint8 *)LoadRomData(Filename, &FileSize);

  000dd	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR FileSize$[rsp]
  000e5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR Filename$[rsp]
  000ed	e8 00 00 00 00	 call	 ?LoadRomData@@YAPEAXPEADPEAI@Z ; LoadRomData
  000f2	48 89 44 24 68	 mov	 QWORD PTR RomData$[rsp], rax

; 363  : 
; 364  :     // NOTE: Check for correct header
; 365  :     if(RomData[0] != 'N' || RomData[1] != 'E' || RomData[2] != 'S')

  000f7	b8 01 00 00 00	 mov	 eax, 1
  000fc	48 6b c0 00	 imul	 rax, rax, 0
  00100	48 8b 4c 24 68	 mov	 rcx, QWORD PTR RomData$[rsp]
  00105	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00109	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  0010c	75 2e		 jne	 SHORT $LN9@WinMain
  0010e	b8 01 00 00 00	 mov	 eax, 1
  00113	48 6b c0 01	 imul	 rax, rax, 1
  00117	48 8b 4c 24 68	 mov	 rcx, QWORD PTR RomData$[rsp]
  0011c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00120	83 f8 45	 cmp	 eax, 69			; 00000045H
  00123	75 17		 jne	 SHORT $LN9@WinMain
  00125	b8 01 00 00 00	 mov	 eax, 1
  0012a	48 6b c0 02	 imul	 rax, rax, 2
  0012e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR RomData$[rsp]
  00133	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00137	83 f8 53	 cmp	 eax, 83			; 00000053H
  0013a	74 12		 je	 SHORT $LN8@WinMain
$LN9@WinMain:

; 366  :     {
; 367  :         Assert(0);   

  0013c	33 c0		 xor	 eax, eax
  0013e	83 f8 01	 cmp	 eax, 1
  00141	74 0b		 je	 SHORT $LN10@WinMain
  00143	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN10@WinMain:
$LN8@WinMain:

; 368  :     }
; 369  : 
; 370  :     // NOTE: Read header
; 371  :     uint8 RomPrgBankCount = RomData[4];

  0014e	b8 01 00 00 00	 mov	 eax, 1
  00153	48 6b c0 04	 imul	 rax, rax, 4
  00157	48 8b 4c 24 68	 mov	 rcx, QWORD PTR RomData$[rsp]
  0015c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00160	88 44 24 62	 mov	 BYTE PTR RomPrgBankCount$[rsp], al

; 372  :     uint8 RomChrBankCount = RomData[5];

  00164	b8 01 00 00 00	 mov	 eax, 1
  00169	48 6b c0 05	 imul	 rax, rax, 5
  0016d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR RomData$[rsp]
  00172	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00176	88 44 24 72	 mov	 BYTE PTR RomChrBankCount$[rsp], al

; 373  : 
; 374  :     uint8 Flags6 = RomData[6];

  0017a	b8 01 00 00 00	 mov	 eax, 1
  0017f	48 6b c0 06	 imul	 rax, rax, 6
  00183	48 8b 4c 24 68	 mov	 rcx, QWORD PTR RomData$[rsp]
  00188	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018c	88 44 24 60	 mov	 BYTE PTR Flags6$[rsp], al

; 375  :     uint8 Flags7 = RomData[7];

  00190	b8 01 00 00 00	 mov	 eax, 1
  00195	48 6b c0 07	 imul	 rax, rax, 7
  00199	48 8b 4c 24 68	 mov	 rcx, QWORD PTR RomData$[rsp]
  0019e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001a2	88 44 24 63	 mov	 BYTE PTR Flags7$[rsp], al

; 376  : 
; 377  :     uint8 RomPrgRamSize = RomData[8];

  001a6	b8 01 00 00 00	 mov	 eax, 1
  001ab	48 6b c0 08	 imul	 rax, rax, 8
  001af	48 8b 4c 24 68	 mov	 rcx, QWORD PTR RomData$[rsp]
  001b4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001b8	88 44 24 73	 mov	 BYTE PTR RomPrgRamSize$[rsp], al

; 378  :     uint8 Flags9 = RomData[9];

  001bc	b8 01 00 00 00	 mov	 eax, 1
  001c1	48 6b c0 09	 imul	 rax, rax, 9
  001c5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR RomData$[rsp]
  001ca	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ce	88 44 24 74	 mov	 BYTE PTR Flags9$[rsp], al

; 379  :     uint8 Flags10 = RomData[10];

  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	48 6b c0 0a	 imul	 rax, rax, 10
  001db	48 8b 4c 24 68	 mov	 rcx, QWORD PTR RomData$[rsp]
  001e0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001e4	88 44 24 75	 mov	 BYTE PTR Flags10$[rsp], al

; 380  : 
; 381  :     uint8 *RomPrgData;
; 382  :     // NOTE: If trainer present. Data after header and before program data
; 383  :     if(Flags6 & (1 << 2))

  001e8	0f b6 44 24 60	 movzx	 eax, BYTE PTR Flags6$[rsp]
  001ed	83 e0 04	 and	 eax, 4
  001f0	85 c0		 test	 eax, eax
  001f2	74 13		 je	 SHORT $LN11@WinMain

; 384  :     {
; 385  :         Assert(1); 

  001f4	33 c0		 xor	 eax, eax
  001f6	85 c0		 test	 eax, eax
  001f8	74 0b		 je	 SHORT $LN13@WinMain
  001fa	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN13@WinMain:

; 386  :     }
; 387  :     else

  00205	eb 11		 jmp	 SHORT $LN12@WinMain
$LN11@WinMain:

; 388  :     {
; 389  :         RomPrgData = RomData + 16;

  00207	48 8b 44 24 68	 mov	 rax, QWORD PTR RomData$[rsp]
  0020c	48 83 c0 10	 add	 rax, 16
  00210	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR RomPrgData$[rsp], rax
$LN12@WinMain:

; 390  :     }
; 391  : 
; 392  :     uint8 *RomChrData = RomPrgData + (RomPrgBankCount * Kilobytes(16));

  00218	0f b6 44 24 62	 movzx	 eax, BYTE PTR RomPrgBankCount$[rsp]
  0021d	48 69 c0 00 40
	00 00		 imul	 rax, rax, 16384		; 00004000H
  00224	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR RomPrgData$[rsp]
  0022c	48 03 c8	 add	 rcx, rax
  0022f	48 8b c1	 mov	 rax, rcx
  00232	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR RomChrData$[rsp], rax

; 393  :     // TODO: Implement Playchoice roms 
; 394  : 
; 395  : 
; 396  :     // NOTE: This is the two banks of memory that are currently loaded
; 397  :     //       The mapper number will specify which initial banks are loaded
; 398  :     //       Program will then change these banks while running.
; 399  :     //       These pointers reference the rom memory.
; 400  :     //       Offset is required to make relative to memory mapped address    
; 401  :     uint8 *loadedPrgBank1;
; 402  :     uint8 *loadedPrgBank2;
; 403  : 
; 404  : 
; 405  :     
; 406  :     uint8 MapperNumber = (Flags7 & 0xF0) | (Flags6 >> 4);

  0023a	0f b6 44 24 63	 movzx	 eax, BYTE PTR Flags7$[rsp]
  0023f	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00244	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR Flags6$[rsp]
  00249	c1 f9 04	 sar	 ecx, 4
  0024c	0b c1		 or	 eax, ecx
  0024e	88 44 24 61	 mov	 BYTE PTR MapperNumber$[rsp], al

; 407  :     switch(MapperNumber)

  00252	0f b6 44 24 61	 movzx	 eax, BYTE PTR MapperNumber$[rsp]
  00257	88 44 24 7c	 mov	 BYTE PTR tv153[rsp], al
  0025b	80 7c 24 7c 00	 cmp	 BYTE PTR tv153[rsp], 0
  00260	74 09		 je	 SHORT $LN14@WinMain
  00262	80 7c 24 7c 01	 cmp	 BYTE PTR tv153[rsp], 1
  00267	74 24		 je	 SHORT $LN15@WinMain
  00269	eb 24		 jmp	 SHORT $LN16@WinMain
$LN14@WinMain:

; 408  :     {
; 409  :         case 0:
; 410  :         {
; 411  :             loadedPrgBank1 = RomPrgData;

  0026b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR RomPrgData$[rsp]
  00273	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR loadedPrgBank1$[rsp], rax

; 412  :             loadedPrgBank2 = RomPrgData;

  0027b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR RomPrgData$[rsp]
  00283	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR loadedPrgBank2$[rsp], rax

; 413  :             break;

  0028b	eb 3e		 jmp	 SHORT $LN2@WinMain
$LN15@WinMain:

; 414  :         }
; 415  :         case 1:
; 416  :         {
; 417  :             break;

  0028d	eb 3c		 jmp	 SHORT $LN2@WinMain
$LN16@WinMain:

; 418  :         }
; 419  :         default:
; 420  :         {
; 421  :             char Buffer[8];
; 422  :             sprintf(Buffer, "Error: Unknown mapper number = %d\n", MapperNumber);

  0028f	0f b6 44 24 61	 movzx	 eax, BYTE PTR MapperNumber$[rsp]
  00294	44 8b c0	 mov	 r8d, eax
  00297	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG87775
  0029e	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR Buffer$6[rsp]
  002a6	e8 00 00 00 00	 call	 sprintf

; 423  :             OutputDebugString(Buffer);

  002ab	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR Buffer$6[rsp]
  002b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 424  :             Assert(0);

  002b9	33 c0		 xor	 eax, eax
  002bb	83 f8 01	 cmp	 eax, 1
  002be	74 0b		 je	 SHORT $LN17@WinMain
  002c0	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN17@WinMain:
$LN2@WinMain:

; 425  :             break;
; 426  :         }
; 427  :     }
; 428  : 
; 429  :     
; 430  :     // NOTE: Load the program counter with the reset vector
; 431  :     Registers.PrgCounter = readMemory16(ResetVec);

  002cb	0f b7 4c 24 78	 movzx	 ecx, WORD PTR ResetVec$[rsp]
  002d0	e8 00 00 00 00	 call	 ?readMemory16@@YAGG@Z	; readMemory16
  002d5	66 89 84 24 a6
	00 00 00	 mov	 WORD PTR Registers$[rsp+6], ax

; 432  : 
; 433  : 
; 434  :     
; 435  :     WNDCLASSA WindowClass = {};

  002dd	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR WindowClass$[rsp]
  002e5	48 8b f8	 mov	 rdi, rax
  002e8	33 c0		 xor	 eax, eax
  002ea	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  002ef	f3 aa		 rep stosb

; 436  :     WindowClass.style = CS_HREDRAW | CS_VREDRAW;

  002f1	c7 84 24 f0 00
	00 00 03 00 00
	00		 mov	 DWORD PTR WindowClass$[rsp], 3

; 437  :     WindowClass.lpfnWndProc = WinInputCallback;

  002fc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z ; WinInputCallback
  00303	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR WindowClass$[rsp+8], rax

; 438  :     WindowClass.hInstance = WindowInstance;

  0030b	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR WindowInstance$[rsp]
  00313	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR WindowClass$[rsp+24], rax

; 439  :     WindowClass.lpszClassName = "NesEmu";

  0031b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG87777
  00322	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR WindowClass$[rsp+64], rax

; 440  :     
; 441  :     if(RegisterClassA(&WindowClass))

  0032a	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR WindowClass$[rsp]
  00332	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegisterClassA
  00338	0f b7 c0	 movzx	 eax, ax
  0033b	85 c0		 test	 eax, eax
  0033d	0f 84 25 01 00
	00		 je	 $LN18@WinMain

; 442  :     {
; 443  :         HWND Window = CreateWindowExA(0, WindowClass.lpszClassName, "NesEmu",

  00343	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR [rsp+88], 0
  0034c	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR WindowInstance$[rsp]
  00354	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00359	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  00362	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  0036b	c7 44 24 38 00
	00 00 80	 mov	 DWORD PTR [rsp+56], -2147483648 ; ffffffff80000000H
  00373	c7 44 24 30 00
	00 00 80	 mov	 DWORD PTR [rsp+48], -2147483648 ; ffffffff80000000H
  0037b	c7 44 24 28 00
	00 00 80	 mov	 DWORD PTR [rsp+40], -2147483648 ; ffffffff80000000H
  00383	c7 44 24 20 00
	00 00 80	 mov	 DWORD PTR [rsp+32], -2147483648 ; ffffffff80000000H
  0038b	41 b9 00 00 cf
	10		 mov	 r9d, 282001408		; 10cf0000H
  00391	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG87780
  00398	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR WindowClass$[rsp+64]
  003a0	33 c9		 xor	 ecx, ecx
  003a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateWindowExA
  003a8	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR Window$2[rsp], rax

; 444  :                                       WS_OVERLAPPEDWINDOW|WS_VISIBLE,
; 445  :                                       CW_USEDEFAULT, CW_USEDEFAULT,
; 446  :                                       CW_USEDEFAULT,CW_USEDEFAULT,
; 447  :                                       0, 0, WindowInstance, 0);
; 448  :         if(Window)

  003b0	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR Window$2[rsp], 0
  003b9	0f 84 95 00 00
	00		 je	 $LN20@WinMain

; 449  :         {            
; 450  :             LARGE_INTEGER LastCounter;
; 451  :             QueryPerformanceCounter(&LastCounter);                        

  003bf	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR LastCounter$3[rsp]
  003c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_QueryPerformanceCounter

; 452  :             uint64 LastCycles = __rdtsc();

  003cd	0f 31		 rdtsc
  003cf	48 c1 e2 20	 shl	 rdx, 32			; 00000020H
  003d3	48 0b c2	 or	 rax, rdx
  003d6	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR LastCycles$4[rsp], rax

; 453  : 
; 454  :             
; 455  :             uint8 BytesRead = 1;

  003de	c6 44 24 76 01	 mov	 BYTE PTR BytesRead$1[rsp], 1

; 456  :             
; 457  :             GlobalRunning = true;            

  003e3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 1
$LN4@WinMain:

; 458  :             while(GlobalRunning)

  003ed	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?GlobalRunning@@3HA, 0
  003f4	74 5c		 je	 SHORT $LN5@WinMain

; 459  :             {
; 460  :                 MSG Message = {}; 

  003f6	48 8d 84 24 40
	01 00 00	 lea	 rax, QWORD PTR Message$5[rsp]
  003fe	48 8b f8	 mov	 rdi, rax
  00401	33 c0		 xor	 eax, eax
  00403	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00408	f3 aa		 rep stosb
$LN6@WinMain:

; 461  :                 while (PeekMessage(&Message, Window, 0, 0, PM_REMOVE))

  0040a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00412	45 33 c9	 xor	 r9d, r9d
  00415	45 33 c0	 xor	 r8d, r8d
  00418	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR Window$2[rsp]
  00420	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR Message$5[rsp]
  00428	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PeekMessageA
  0042e	85 c0		 test	 eax, eax
  00430	74 1e		 je	 SHORT $LN7@WinMain

; 462  :                 {
; 463  :                     TranslateMessage(&Message);

  00432	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR Message$5[rsp]
  0043a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TranslateMessage

; 464  :                     DispatchMessage(&Message);

  00440	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR Message$5[rsp]
  00448	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DispatchMessageA

; 465  :                 }

  0044e	eb ba		 jmp	 SHORT $LN6@WinMain
$LN7@WinMain:

; 466  :                 /*
; 467  :                 switch(*CurrentInstr)
; 468  :                 {
; 469  :                     case 0x10: // BPL - Branch if plus.
; 470  :                     {
; 471  :                         int8 RelAddress = readNextByte(CurrentInstr, &BytesRead);
; 472  :                         // NOTE: Will change program counter if negative flag is clear.
; 473  :                         if(!(Registers.Flags & (1 << 7)))
; 474  :                         {
; 475  :                             Registers.PrgCounter += (RelAddress + 2); // Plus two to next instruction
; 476  :                             CurrentInstr = (uint8 *)((uint64)PrgStart + Registers.PrgCounter);
; 477  :                             BytesRead = 0;
; 478  :                         }
; 479  :                         break;
; 480  :                     }
; 481  :                     case 0x20: // JSR - Jump to subroutine
; 482  :                     {
; 483  :                         // last byte of jrs (next instruction minus 1) is pushed onto stack
; 484  :                         // program counter jumps to address
; 485  : 
; 486  :                         // TODO: Is absolute addressing from cartridge 0x00, or where program bank starts?
; 487  :                         uint16 NewAddress = readNextUInt16(CurrentInstr, &BytesRead);
; 488  :                         
; 489  :                         uint16 PrevAdrs = ((uint64)(CurrentInstr + 2) - (uint64)PrgStart);                              
; 490  :                         uint8 HighByte = (uint8)(PrevAdrs >> 8);
; 491  :                         uint8 LowByte = (uint8)PrevAdrs;
; 492  :       
; 493  :                         // Push onto stack, little endian
; 494  :                         PushByte(HighByte, &Registers.StackPtr, Stack);
; 495  :                         PushByte(LowByte, &Registers.StackPtr, Stack);
; 496  : 
; 497  :                         Registers.PrgCounter = NewAddress;
; 498  :                         CurrentInstr = (uint8 *)((uint64)PrgStart + Registers.PrgCounter);
; 499  :                         BytesRead = 0; // set to zero so does move forward
; 500  : 
; 501  :                         break;
; 502  :                     }
; 503  :                     case 0x29: // AND(Immediate) - Logical AND with value and A, stores in A
; 504  :                     {
; 505  :                         uint8 ByteValue = readNextByte(CurrentInstr, &BytesRead);
; 506  : 
; 507  :                         uint8 ANDValue = Registers.A & ByteValue;
; 508  : 
; 509  :                         setNegative(ANDValue, &Registers.Flags);
; 510  :                         setZero(ANDValue, &Registers.Flags);
; 511  : 
; 512  :                         Registers.A = ANDValue;
; 513  :                         break;
; 514  :                     }
; 515  :                     case 0x4C: // JMP(Absolute) - Jump
; 516  :                     {
; 517  :                         uint16 NewAddress = readNextUInt16(CurrentInstr, &BytesRead);
; 518  :                         Registers.PrgCounter = NewAddress;
; 519  :                         CurrentInstr = (uint8 *)((uint64)PrgStart + Registers.PrgCounter);
; 520  :                         BytesRead = 0;
; 521  :                         break;
; 522  :                     }
; 523  :                     case 0x78: // Set Interrupt Disable Flag
; 524  :                     {
; 525  :                         Registers.Flags = Registers.Flags | (1 << 2); // Set interrupt flag
; 526  :                         break;
; 527  :                     }
; 528  :                     case 0x8D: // STA(Absolute) - Store Accumulator in Memory
; 529  :                     {
; 530  :                         uint16 Address = readNextUInt16(CurrentInstr, &BytesRead);
; 531  :                         
; 532  :                         writeMemByte(Registers.A, Address, MemStart);                        
; 533  :                         break;
; 534  :                     }
; 535  :                     case 0x9A: // TXS - Transfer X to Stack Pointer
; 536  :                     {
; 537  :                         uint8 Value = Registers.X;
; 538  :                         setNegative(Value, &Registers.Flags);
; 539  :                         setZero(Value, &Registers.Flags);
; 540  :                         Registers.StackPtr = Value;
; 541  :                         break;
; 542  :                     }
; 543  :                     case 0xA2: // LDX(Immediate) - Load X index with memory
; 544  :                     {
; 545  :                         uint8 Value = readNextByte(CurrentInstr, &BytesRead);
; 546  : 
; 547  :                         setNegative(Value, &Registers.Flags);
; 548  :                         setZero(Value, &Registers.Flags);
; 549  : 
; 550  :                         Registers.X = Value;
; 551  :                         break;
; 552  :                     }
; 553  :                     case 0xAD: // LDA(Absolute) - Load A with 16bit address
; 554  :                     {
; 555  :                         uint16 Address = readNextUInt16(CurrentInstr, &BytesRead);                                                
; 556  :                         uint8 Value = readMemByte(Address, MemStart);
; 557  :                         
; 558  :                         setNegative(Value, &Registers.Flags);
; 559  :                         setZero(Value, &Registers.Flags);
; 560  :                         Registers.A = Value;                    
; 561  :                         break;
; 562  :                     }
; 563  :                     case 0xA5: // LDA(Zero Page) - load A from zero page
; 564  :                     {
; 565  :                         uint8 Address = readNextByte(CurrentInstr, &BytesRead);
; 566  : 
; 567  :                         uint8 Value = readMemByte(Address, ZeroPage);
; 568  :                         
; 569  :                         setNegative(Value, &Registers.Flags);
; 570  :                         setZero(Value, &Registers.Flags);
; 571  :                         
; 572  :                         Registers.A = Value;
; 573  :                         break;
; 574  :                     }
; 575  :                     case 0xA9: // LDA(Immediate) - Load accumulator with memory
; 576  :                     {
; 577  :                         uint8 Value = readNextByte(CurrentInstr, &BytesRead);
; 578  :    
; 579  :                         setNegative(Value, &Registers.Flags);
; 580  :                         setZero(Value, &Registers.Flags);
; 581  :                         
; 582  :                         Registers.A = Value;          
; 583  :                         break;
; 584  :                     }
; 585  :                     case 0xB0: // BCS - Branch if Carry is set
; 586  :                     {
; 587  :                         uint8 RelAddress = readNextByte(CurrentInstr, &BytesRead);
; 588  :                         if(Registers.Flags & 1)
; 589  :                         {
; 590  :                             Registers.PrgCounter += (RelAddress + 2); // Plus two to next instruction
; 591  :                             CurrentInstr = (uint8 *)((uint64)PrgStart + Registers.PrgCounter);
; 592  :                             BytesRead = 0;
; 593  :                         }
; 594  :                         break;
; 595  :                     };
; 596  :                     case 0xC9: // CMP(Immediate) - Compare value against A
; 597  :                     {
; 598  :                         uint8 ByteValue = readNextByte(CurrentInstr, &BytesRead);
; 599  : 
; 600  :                         uint8 CmpValue = Registers.A - ByteValue;
; 601  :                         
; 602  :                         setNegative(ByteValue, &Registers.Flags);
; 603  :                         setZero(ByteValue, &Registers.Flags);
; 604  :                         
; 605  :                         if(Registers.A < ByteValue)
; 606  :                         {
; 607  :                             clearCarry(&Registers.Flags);
; 608  :                         }
; 609  :                         else
; 610  :                             setCarry(&Registers.Flags);
; 611  : 
; 612  :                         break;
; 613  :                     }
; 614  :                     case 0xD0: // BNE - Branch if not equal
; 615  :                     {
; 616  :                         // TODO: Might be wrong, where do we branch from, currentinstr or next??
; 617  :                         uint8 RelAddress = readNextByte(CurrentInstr, &BytesRead);
; 618  :                         if((Registers.Flags & (1 << 1)))
; 619  :                         {
; 620  :                             Registers.PrgCounter += (RelAddress); // Plus two to next instruction
; 621  :                             CurrentInstr = (uint8 *)((uint64)PrgStart + Registers.PrgCounter);
; 622  :                             BytesRead = 0;
; 623  :                         }
; 624  :                         break;
; 625  :                     }
; 626  :                     case 0xD8: // Clear decimal flag
; 627  :                     {
; 628  :                         Registers.Flags = Registers.Flags & ~(1 << 3); // clear decimal flag
; 629  :                         break;
; 630  :                     }
; 631  :                     case 0xF0: // BEQ - Brach if Equal
; 632  :                     {
; 633  :                         uint8 RelAddress = readNextByte(CurrentInstr, &BytesRead);
; 634  :                         if(Registers.Flags & (1 << 1))
; 635  :                         {
; 636  :                             Registers.PrgCounter += (RelAddress + 2); // Plus two to next instruction
; 637  :                             CurrentInstr = (uint8 *)((uint64)PrgStart + Registers.PrgCounter);
; 638  :                             BytesRead = 0;
; 639  :                         }
; 640  :                         break;    
; 641  :                     }
; 642  :                     default:
; 643  :                     {
; 644  :                         uint8 MissingValue = *CurrentInstr;
; 645  :                         char Buffer[8];
; 646  :                         sprintf(Buffer, "%X\n", MissingValue);
; 647  :                         OutputDebugString(Buffer);
; 648  :                         Assert(0);
; 649  :                         break;
; 650  :                     }
; 651  : 
; 652  :                 }
; 653  :                 
; 654  :                 // NOTE: When updating bytesRead, some instruction like branch do not want to advance the progcounter
; 655  :                 CurrentInstr = getnextInstruction(CurrentInstr, &Registers.PrgCounter, &BytesRead);
; 656  :                 BytesRead = 1;
; 657  :                 */
; 658  :                 
; 659  : #if 0
; 660  :                 uint64 EndCycles = __rdtsc();
; 661  :                 
; 662  :                 LARGE_INTEGER EndCounter;
; 663  :                 QueryPerformanceCounter(&EndCounter);
; 664  :                 
; 665  :                 uint64 CounterElapsed = EndCounter.QuadPart - LastCounter.QuadPart; 
; 666  :                 uint64 CyclesElapsed = EndCycles - LastCycles;
; 667  :                 
; 668  :                 real32 MSElapsed = ((1000.0f * (real32)CounterElapsed) / (real32)PerfCountFrequency);
; 669  :                 real32 FPSElapsed = (real32)PerfCountFrequency / (real32)CounterElapsed;
; 670  :                 real32 MCElapsed = (real32)CyclesElapsed / (1000.0f*1000.0f);                 
; 671  :                 
; 672  :                 char TextBuffer[256];
; 673  :                 _snprintf(TextBuffer, 256, "Cycles: %f, FPS: %f, DeltaTime: %f\n", MCElapsed, FPSElapsed, MSElapsed);
; 674  :                 OutputDebugString(TextBuffer);
; 675  :                 
; 676  :                 LastCounter = EndCounter;
; 677  :                 LastCycles = EndCycles;
; 678  : #endif
; 679  :             }   

  00450	eb 9b		 jmp	 SHORT $LN4@WinMain
$LN5@WinMain:

; 680  :         }
; 681  :         else

  00452	eb 12		 jmp	 SHORT $LN21@WinMain
$LN20@WinMain:

; 682  :         {
; 683  :             Assert(0);

  00454	33 c0		 xor	 eax, eax
  00456	83 f8 01	 cmp	 eax, 1
  00459	74 0b		 je	 SHORT $LN22@WinMain
  0045b	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN22@WinMain:
$LN21@WinMain:

; 684  :         }
; 685  :     }
; 686  :     else

  00466	eb 12		 jmp	 SHORT $LN19@WinMain
$LN18@WinMain:

; 687  :     {
; 688  :         Assert(0);

  00468	33 c0		 xor	 eax, eax
  0046a	83 f8 01	 cmp	 eax, 1
  0046d	74 0b		 je	 SHORT $LN23@WinMain
  0046f	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN23@WinMain:
$LN19@WinMain:

; 689  :     }
; 690  : 
; 691  :     return(0);

  0047a	33 c0		 xor	 eax, eax

; 692  : } 

  0047c	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00484	48 33 cc	 xor	 rcx, rsp
  00487	e8 00 00 00 00	 call	 __security_check_cookie
  0048c	48 81 c4 80 01
	00 00		 add	 rsp, 384		; 00000180H
  00493	5f		 pop	 rdi
  00494	c3		 ret	 0
WinMain	ENDP
_TEXT	ENDS
END
