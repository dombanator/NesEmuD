; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?VRamAdrsWriteCount@@3EA			; VRamAdrsWriteCount
PUBLIC	?VRamDataWriteCount@@3EA			; VRamDataWriteCount
PUBLIC	?InputReadCount@@3EA				; InputReadCount
PUBLIC	?InputReadMax@@3EA				; InputReadMax
PUBLIC	?NMICalled@@3HA					; NMICalled
PUBLIC	?Palette@@3PAY02EA				; Palette
_BSS	SEGMENT
?WinInput@@3Uinput@@A DB 020H DUP (?)			; WinInput
?VRamAdrsWriteCount@@3EA DB 01H DUP (?)			; VRamAdrsWriteCount
	ALIGN	4

?VRamDataWriteCount@@3EA DB 01H DUP (?)			; VRamDataWriteCount
	ALIGN	4

?InputReadCount@@3EA DB 01H DUP (?)			; InputReadCount
	ALIGN	4

?NMICalled@@3HA DD 01H DUP (?)				; NMICalled
_BSS	ENDS
_DATA	SEGMENT
?InputReadMax@@3EA DB 018H				; InputReadMax
	ORG $+15
?Palette@@3PAY02EA DB 075H				; Palette
	DB	075H
	DB	075H
	DB	027H
	DB	01bH
	DB	08fH
	DB	00H
	DB	00H
	DB	0abH
	DB	047H
	DB	00H
	DB	09fH
	DB	08fH
	DB	00H
	DB	077H
	DB	0abH
	DB	00H
	DB	013H
	DB	0a7H
	DB	00H
	DB	00H
	DB	07fH
	DB	0bH
	DB	00H
	DB	043H
	DB	02fH
	DB	00H
	DB	00H
	DB	047H
	DB	00H
	DB	00H
	DB	051H
	DB	00H
	DB	00H
	DB	03fH
	DB	017H
	DB	01bH
	DB	03fH
	DB	05fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0bcH
	DB	0bcH
	DB	0bcH
	DB	00H
	DB	073H
	DB	0efH
	DB	023H
	DB	03bH
	DB	0efH
	DB	083H
	DB	00H
	DB	0f3H
	DB	0bfH
	DB	00H
	DB	0bfH
	DB	0e7H
	DB	00H
	DB	05bH
	DB	0dbH
	DB	02bH
	DB	00H
	DB	0cbH
	DB	04fH
	DB	0fH
	DB	08bH
	DB	073H
	DB	00H
	DB	00H
	DB	097H
	DB	00H
	DB	00H
	DB	0abH
	DB	00H
	DB	00H
	DB	093H
	DB	03bH
	DB	00H
	DB	083H
	DB	08bH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	03fH
	DB	0bfH
	DB	0ffH
	DB	05fH
	DB	097H
	DB	0ffH
	DB	0a7H
	DB	08bH
	DB	0fdH
	DB	0f7H
	DB	07bH
	DB	0ffH
	DB	0ffH
	DB	077H
	DB	0b7H
	DB	0ffH
	DB	077H
	DB	063H
	DB	0ffH
	DB	09bH
	DB	03bH
	DB	0f3H
	DB	0bfH
	DB	03fH
	DB	083H
	DB	0d3H
	DB	013H
	DB	04fH
	DB	0dfH
	DB	04bH
	DB	058H
	DB	0f8H
	DB	098H
	DB	00H
	DB	0ebH
	DB	0dbH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0abH
	DB	0e7H
	DB	0ffH
	DB	0c7H
	DB	0d7H
	DB	0ffH
	DB	0d7H
	DB	0cbH
	DB	0ffH
	DB	0ffH
	DB	0c7H
	DB	0ffH
	DB	0ffH
	DB	0c7H
	DB	0dbH
	DB	0ffH
	DB	0bfH
	DB	0b3H
	DB	0ffH
	DB	0dbH
	DB	0abH
	DB	0ffH
	DB	0e7H
	DB	0a3H
	DB	0e3H
	DB	0ffH
	DB	0a3H
	DB	0abH
	DB	0f3H
	DB	0bfH
	DB	0b3H
	DB	0ffH
	DB	0cfH
	DB	09fH
	DB	0ffH
	DB	0f3H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_DATA	ENDS
CONST	SEGMENT
$SG88284 DB	'Pacman.nes', 00H
	ORG $+5
$SG88296 DB	'Error: Unknown mapper number = %d', 0aH, 00H
	ORG $+1
$SG88298 DB	'NesEmu', 00H
	ORG $+1
$SG88301 DB	'NesEmu', 00H
	ORG $+1
$SG87607 DB	'Up', 00H
	ORG $+1
$SG87609 DB	'Up', 00H
	ORG $+1
$SG87611 DB	'Up', 00H
	ORG $+1
$SG87613 DB	'Up', 00H
	ORG $+1
$SG87615 DB	'Up', 00H
	ORG $+1
$SG87617 DB	'Up', 00H
	ORG $+1
$SG87619 DB	'Up', 00H
	ORG $+1
$SG87621 DB	'Up', 00H
	ORG $+1
$SG88004 DB	'%X', 0aH, 00H
	ORG $+8
$SG88006 DB	'OpCode: %X Flags:%X A:%X  X:%X  Y:%X  P:%X  SP:%X  Bytes'
	DB	'Read:%d  Cycles:%d ', 0aH, 00H
CONST	ENDS
PUBLIC	WinMain
PUBLIC	__local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z	; WinInputCallback
PUBLIC	?setNegative@@YAXEPEAE@Z			; setNegative
PUBLIC	?setZero@@YAXEPEAE@Z				; setZero
PUBLIC	?setCarry@@YAXPEAE@Z				; setCarry
PUBLIC	?clearCarry@@YAXPEAE@Z				; clearCarry
PUBLIC	?setOverflow@@YAXPEAE@Z				; setOverflow
PUBLIC	?clearOverflow@@YAXPEAE@Z			; clearOverflow
PUBLIC	?adc@@YAXEPEAUcpuRegisters@@@Z			; adc
PUBLIC	?sbc@@YAXEPEAUcpuRegisters@@@Z			; sbc
PUBLIC	?cmp@@YAXEEPEAE@Z				; cmp
PUBLIC	?PushStack@@YAXEPEAE_K@Z			; PushStack
PUBLIC	?PopStack@@YAEPEAE_K@Z				; PopStack
PUBLIC	?cpuTick@@YAXPEAUcpu@@@Z			; cpuTick
PUBLIC	?getPaletteValue@@YAXEPEAE00@Z			; getPaletteValue
PUBLIC	?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z	; ppuTick
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
EXTRN	__imp_CreateFileA:PROC
EXTRN	__imp_GetFileSizeEx:PROC
EXTRN	__imp_ReadFile:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_QueryPerformanceCounter:PROC
EXTRN	__imp_VirtualAlloc:PROC
EXTRN	__imp_VirtualFree:PROC
EXTRN	__imp_StretchDIBits:PROC
EXTRN	__imp_TranslateMessage:PROC
EXTRN	__imp_DispatchMessageA:PROC
EXTRN	__imp_PeekMessageA:PROC
EXTRN	__imp_DefWindowProcA:PROC
EXTRN	__imp_RegisterClassA:PROC
EXTRN	__imp_CreateWindowExA:PROC
EXTRN	__imp_GetDC:PROC
EXTRN	__imp_ReleaseDC:PROC
EXTRN	__imp_GetClientRect:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?GlobalRunning@@3HA DD 01H DUP (?)			; GlobalRunning
_BSS	ENDS
pdata	SEGMENT
$pdata$WinMain DD imagerel $LN31
	DD	imagerel $LN31+1674
	DD	imagerel $unwind$WinMain
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z DD imagerel $LN51
	DD	imagerel $LN51+1263
	DD	imagerel $unwind$?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z
$pdata$?LoadFile@@YAPEAXPEADPEAI@Z DD imagerel ?LoadFile@@YAPEAXPEADPEAI@Z
	DD	imagerel ?LoadFile@@YAPEAXPEADPEAI@Z+259
	DD	imagerel $unwind$?LoadFile@@YAPEAXPEADPEAI@Z
$pdata$?cpyMemory@@YAXPEAE0G@Z DD imagerel ?cpyMemory@@YAXPEAE0G@Z
	DD	imagerel ?cpyMemory@@YAXPEAE0G@Z+85
	DD	imagerel $unwind$?cpyMemory@@YAXPEAE0G@Z
$pdata$?writeMemory8@@YAXEG_K@Z DD imagerel ?writeMemory8@@YAXEG_K@Z
	DD	imagerel ?writeMemory8@@YAXEG_K@Z+48
	DD	imagerel $unwind$?writeMemory8@@YAXEG_K@Z
$pdata$?writeCpuMemory8@@YAXEG_K@Z DD imagerel ?writeCpuMemory8@@YAXEG_K@Z
	DD	imagerel ?writeCpuMemory8@@YAXEG_K@Z+258
	DD	imagerel $unwind$?writeCpuMemory8@@YAXEG_K@Z
$pdata$?readMemory8@@YAEG_K@Z DD imagerel ?readMemory8@@YAEG_K@Z
	DD	imagerel ?readMemory8@@YAEG_K@Z+49
	DD	imagerel $unwind$?readMemory8@@YAEG_K@Z
$pdata$?readCpuMemory8@@YAEG_K@Z DD imagerel ?readCpuMemory8@@YAEG_K@Z
	DD	imagerel ?readCpuMemory8@@YAEG_K@Z+186
	DD	imagerel $unwind$?readCpuMemory8@@YAEG_K@Z
$pdata$?readCpuMemory16@@YAGG_K@Z DD imagerel ?readCpuMemory16@@YAGG_K@Z
	DD	imagerel ?readCpuMemory16@@YAGG_K@Z+87
	DD	imagerel $unwind$?readCpuMemory16@@YAGG_K@Z
$pdata$?adc@@YAXEPEAUcpuRegisters@@@Z DD imagerel $LN8
	DD	imagerel $LN8+226
	DD	imagerel $unwind$?adc@@YAXEPEAUcpuRegisters@@@Z
$pdata$?sbc@@YAXEPEAUcpuRegisters@@@Z DD imagerel $LN8
	DD	imagerel $LN8+235
	DD	imagerel $unwind$?sbc@@YAXEPEAUcpuRegisters@@@Z
$pdata$?cmp@@YAXEEPEAE@Z DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$?cmp@@YAXEEPEAE@Z
$pdata$?PushStack@@YAXEPEAE_K@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$?PushStack@@YAXEPEAE_K@Z
$pdata$?PopStack@@YAEPEAE_K@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$?PopStack@@YAEPEAE_K@Z
$pdata$?cpuTick@@YAXPEAUcpu@@@Z DD imagerel $LN97
	DD	imagerel $LN97+7702
	DD	imagerel $unwind$?cpuTick@@YAXPEAUcpu@@@Z
$pdata$?getAttribute@@YAEPEAUppu@@EE@Z DD imagerel ?getAttribute@@YAEPEAUppu@@EE@Z
	DD	imagerel ?getAttribute@@YAEPEAUppu@@EE@Z+296
	DD	imagerel $unwind$?getAttribute@@YAEPEAUppu@@EE@Z
$pdata$?getBkgrdPattern@@YA?AUbkgrd_pattern@@PEAUppu@@E@Z DD imagerel ?getBkgrdPattern@@YA?AUbkgrd_pattern@@PEAUppu@@E@Z
	DD	imagerel ?getBkgrdPattern@@YA?AUbkgrd_pattern@@PEAUppu@@E@Z+140
	DD	imagerel $unwind$?getBkgrdPattern@@YA?AUbkgrd_pattern@@PEAUppu@@E@Z
$pdata$?getNametableValue@@YAEPEAUppu@@EE@Z DD imagerel ?getNametableValue@@YAEPEAUppu@@EE@Z
	DD	imagerel ?getNametableValue@@YAEPEAUppu@@EE@Z+86
	DD	imagerel $unwind$?getNametableValue@@YAEPEAUppu@@EE@Z
$pdata$?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z DD imagerel $LN29
	DD	imagerel $LN29+1626
	DD	imagerel $unwind$?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z
$pdata$?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z DD imagerel ?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z
	DD	imagerel ?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z+108
	DD	imagerel $unwind$?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z
$pdata$?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z DD imagerel ?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z
	DD	imagerel ?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z+262
	DD	imagerel $unwind$?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z
$pdata$?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z DD imagerel ?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z
	DD	imagerel ?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z+165
	DD	imagerel $unwind$?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
xdata	SEGMENT
$unwind$WinMain DD 032e19H
	DD	044011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0218H
$unwind$?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z DD 011701H
	DD	0e217H
$unwind$?LoadFile@@YAPEAXPEADPEAI@Z DD 010e01H
	DD	0c20eH
$unwind$?cpyMemory@@YAXPEAE0G@Z DD 011401H
	DD	02214H
$unwind$?writeMemory8@@YAXEG_K@Z DD 011201H
	DD	02212H
$unwind$?writeCpuMemory8@@YAXEG_K@Z DD 011201H
	DD	04212H
$unwind$?readMemory8@@YAEG_K@Z DD 010e01H
	DD	0220eH
$unwind$?readCpuMemory8@@YAEG_K@Z DD 010e01H
	DD	0620eH
$unwind$?readCpuMemory16@@YAGG_K@Z DD 010e01H
	DD	0620eH
$unwind$?adc@@YAXEPEAUcpuRegisters@@@Z DD 010d01H
	DD	0620dH
$unwind$?sbc@@YAXEPEAUcpuRegisters@@@Z DD 010d01H
	DD	0620dH
$unwind$?cmp@@YAXEEPEAE@Z DD 011101H
	DD	06211H
$unwind$?PushStack@@YAXEPEAE_K@Z DD 011201H
	DD	02212H
$unwind$?PopStack@@YAEPEAE_K@Z DD 010e01H
	DD	0220eH
$unwind$?cpuTick@@YAXPEAUcpu@@@Z DD 042019H
	DD	069010eH
	DD	030067007H
	DD	imagerel __GSHandlerCheck
	DD	0330H
$unwind$?getAttribute@@YAEPEAUppu@@EE@Z DD 011201H
	DD	04212H
$unwind$?getBkgrdPattern@@YA?AUbkgrd_pattern@@PEAUppu@@E@Z DD 031501H
	DD	070114215H
	DD	06010H
$unwind$?getNametableValue@@YAEPEAUppu@@EE@Z DD 011201H
	DD	02212H
$unwind$?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z DD 042519H
	DD	0190113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z DD 012219H
	DD	08213H
	DD	imagerel __GSHandlerCheck
	DD	030H
$unwind$?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z DD 011401H
	DD	06214H
$unwind$?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z DD 011a01H
	DD	0e21aH
xdata	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
BackBuffer$ = 128
DeviceContext$ = 136
WindowWidth$ = 144
WindowHeight$ = 152
?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z PROC ; drawScreenBuffer

; 357  : {                

  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000c	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00011	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00016	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 358  :     StretchDIBits(DeviceContext,

  0001a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  00022	0f b7 8c 24 98
	00 00 00	 movzx	 ecx, WORD PTR WindowHeight$[rsp]
  0002a	0f b7 94 24 90
	00 00 00	 movzx	 edx, WORD PTR WindowWidth$[rsp]
  00032	c7 44 24 60 20
	00 cc 00	 mov	 DWORD PTR [rsp+96], 13369376 ; 00cc0020H
  0003a	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR [rsp+88], 0
  00042	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00047	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  0004f	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00053	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00058	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  00060	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00063	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00067	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  0006f	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00072	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00076	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  0007e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00086	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0008a	44 8b ca	 mov	 r9d, edx
  0008d	45 33 c0	 xor	 r8d, r8d
  00090	33 d2		 xor	 edx, edx
  00092	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR DeviceContext$[rsp]
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_StretchDIBits

; 359  :                   0, 0, WindowWidth, WindowHeight,
; 360  :                   0, 0, BackBuffer->Width, BackBuffer->Height,
; 361  :                   BackBuffer->Memory,
; 362  :                   &BackBuffer->Info,
; 363  :                   DIB_RGB_COLORS, SRCCOPY);
; 364  : }

  000a0	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000a4	c3		 ret	 0
?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z ENDP ; drawScreenBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
MemorySize$ = 32
Buffer$ = 64
Width$ = 72
Height$ = 80
?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z PROC	; createBackBuffer

; 331  : {

  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 332  :     // TODO: This is based on Handmade Hero code. Will need to reference and look at licences later on
; 333  :     //       website: handmadehero.org
; 334  :     if(Buffer->Memory)

  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  00019	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  0001e	74 17		 je	 SHORT $LN2@createBack

; 335  :     {
; 336  :         VirtualFree(Buffer->Memory, 0, MEM_RELEASE);

  00020	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00026	33 d2		 xor	 edx, edx
  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  0002d	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualFree
$LN2@createBack:

; 337  :     }
; 338  : 
; 339  :     Buffer->Width = Width;

  00037	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  00041	89 41 38	 mov	 DWORD PTR [rcx+56], eax

; 340  :     Buffer->Height = Height;

  00044	0f b7 44 24 50	 movzx	 eax, WORD PTR Height$[rsp]
  00049	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  0004e	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 341  :     Buffer->BytesPerPixel = 4;

  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  00056	c7 40 44 04 00
	00 00		 mov	 DWORD PTR [rax+68], 4

; 342  : 
; 343  :     Buffer->Info.bmiHeader.biSize = sizeof(Buffer->Info.bmiHeader);

  0005d	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  00062	c7 00 28 00 00
	00		 mov	 DWORD PTR [rax], 40	; 00000028H

; 344  :     Buffer->Info.bmiHeader.biWidth = Width;

  00068	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  0006d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  00072	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 345  :     Buffer->Info.bmiHeader.biHeight = -Height; // Negative tells windows that we raster top to bottom

  00075	0f b7 44 24 50	 movzx	 eax, WORD PTR Height$[rsp]
  0007a	f7 d8		 neg	 eax
  0007c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  00081	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 346  :     Buffer->Info.bmiHeader.biPlanes = 1;

  00084	b8 01 00 00 00	 mov	 eax, 1
  00089	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  0008e	66 89 41 0c	 mov	 WORD PTR [rcx+12], ax

; 347  :     Buffer->Info.bmiHeader.biBitCount = 32;

  00092	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  0009c	66 89 41 0e	 mov	 WORD PTR [rcx+14], ax

; 348  :     Buffer->Info.bmiHeader.biCompression = BI_RGB;

  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  000a5	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 349  : 
; 350  :     int MemorySize = Width * Height * Buffer->BytesPerPixel;

  000ac	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  000b1	0f b7 4c 24 50	 movzx	 ecx, WORD PTR Height$[rsp]
  000b6	0f af c1	 imul	 eax, ecx
  000b9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000be	0f af 41 44	 imul	 eax, DWORD PTR [rcx+68]
  000c2	89 44 24 20	 mov	 DWORD PTR MemorySize$[rsp], eax

; 351  :     Buffer->Memory = VirtualAlloc(0, MemorySize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);

  000c6	48 63 44 24 20	 movsxd	 rax, DWORD PTR MemorySize$[rsp]
  000cb	41 b9 04 00 00
	00		 mov	 r9d, 4
  000d1	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  000d7	48 8b d0	 mov	 rdx, rax
  000da	33 c9		 xor	 ecx, ecx
  000dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  000e2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000e7	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 352  :     Buffer->Pitch = Width * Buffer->BytesPerPixel;

  000eb	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  000f0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000f5	0f af 41 44	 imul	 eax, DWORD PTR [rcx+68]
  000f9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000fe	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 353  : }

  00101	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00105	c3		 ret	 0
?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z ENDP	; createBackBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
ClientRect$ = 32
__$ArrayPad$ = 48
Window$ = 80
Width$ = 88
Height$ = 96
?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z PROC		; getWindowSize

; 320  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 321  :     RECT ClientRect;
; 322  :     GetClientRect(Window, &ClientRect);

  00022	48 8d 54 24 20	 lea	 rdx, QWORD PTR ClientRect$[rsp]
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Window$[rsp]
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetClientRect

; 323  :     *Width = ClientRect.right - ClientRect.left;

  00032	8b 44 24 20	 mov	 eax, DWORD PTR ClientRect$[rsp]
  00036	8b 4c 24 28	 mov	 ecx, DWORD PTR ClientRect$[rsp+8]
  0003a	2b c8		 sub	 ecx, eax
  0003c	8b c1		 mov	 eax, ecx
  0003e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Width$[rsp]
  00043	66 89 01	 mov	 WORD PTR [rcx], ax

; 324  :     *Height = ClientRect.bottom - ClientRect.top;

  00046	8b 44 24 24	 mov	 eax, DWORD PTR ClientRect$[rsp+4]
  0004a	8b 4c 24 2c	 mov	 ecx, DWORD PTR ClientRect$[rsp+12]
  0004e	2b c8		 sub	 ecx, eax
  00050	8b c1		 mov	 eax, ecx
  00052	48 8b 4c 24 60	 mov	 rcx, QWORD PTR Height$[rsp]
  00057	66 89 01	 mov	 WORD PTR [rcx], ax

; 325  : }

  0005a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0005f	48 33 cc	 xor	 rcx, rsp
  00062	e8 00 00 00 00	 call	 __security_check_cookie
  00067	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006b	c3		 ret	 0
?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z ENDP		; getWindowSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
BlockX$ = 32
TileX$ = 33
TileY$ = 34
PatternIndex$ = 35
PrevTileX$ = 36
PrevTileY$ = 37
PrevPatternIndex$ = 38
PrevBlockX$ = 39
BlockY$ = 40
PrevBlockY$ = 41
TilePixelY$ = 42
TilePixelX$ = 43
CombinedBits$ = 44
NameTableFlag$ = 45
AddressIncrement$ = 46
Group2Bit$ = 47
Group1Bit$ = 48
Attribute$ = 49
ColourIndex$ = 50
Blue$ = 51
Green$ = 52
Red$ = 53
Registers$ = 56
tv137 = 64
ColourIntensity$ = 68
FullAttribute$ = 69
SpritesAre8x16$ = 72
NmiOnVBlank$ = 76
ColourMode$ = 80
ClipBackground$ = 84
ClipSprites$ = 88
HideBackground$ = 92
HideSprites$ = 96
CurrentPixel$ = 104
Pattern$ = 112
$T1 = 128
$T2 = 144
CurrentPalette$ = 160
__$ArrayPad$ = 176
BackBuffer$ = 224
PpuData$ = 232
?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z PROC	; ppuTick

; 155  : {

$LN29:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 156  :     ppu_registers *Registers = PpuData->Registers; 

  00025	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	48 89 44 24 38	 mov	 QWORD PTR Registers$[rsp], rax

; 157  :     
; 158  :     if(VRamAdrsWriteCount != PpuData->PrevAdrsWriteCount && VRamAdrsWriteCount > 0)

  00035	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?VRamAdrsWriteCount@@3EA ; VRamAdrsWriteCount
  0003c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  00044	0f b6 49 28	 movzx	 ecx, BYTE PTR [rcx+40]
  00048	3b c1		 cmp	 eax, ecx
  0004a	74 31		 je	 SHORT $LN4@ppuTick
  0004c	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?VRamAdrsWriteCount@@3EA ; VRamAdrsWriteCount
  00053	85 c0		 test	 eax, eax
  00055	7e 26		 jle	 SHORT $LN4@ppuTick

; 159  :         PpuData->FullVRamAdrsIO = (PpuData->FullVRamAdrsIO << 8) | Registers->VRamAddress;

  00057	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  0005f	0f b7 40 26	 movzx	 eax, WORD PTR [rax+38]
  00063	c1 e0 08	 shl	 eax, 8
  00066	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Registers$[rsp]
  0006b	0f b6 49 06	 movzx	 ecx, BYTE PTR [rcx+6]
  0006f	0b c1		 or	 eax, ecx
  00071	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  00079	66 89 41 26	 mov	 WORD PTR [rcx+38], ax
$LN4@ppuTick:

; 160  : 
; 161  :     if((VRamDataWriteCount != PpuData->PrevDataWriteCount) && (VRamDataWriteCount > 0) &&

  0007d	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?VRamDataWriteCount@@3EA ; VRamDataWriteCount
  00084	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  0008c	0f b6 49 29	 movzx	 ecx, BYTE PTR [rcx+41]
  00090	3b c1		 cmp	 eax, ecx
  00092	74 5f		 je	 SHORT $LN5@ppuTick
  00094	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?VRamDataWriteCount@@3EA ; VRamDataWriteCount
  0009b	85 c0		 test	 eax, eax
  0009d	7e 54		 jle	 SHORT $LN5@ppuTick
  0009f	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?VRamAdrsWriteCount@@3EA ; VRamAdrsWriteCount
  000a6	99		 cdq
  000a7	83 e0 01	 and	 eax, 1
  000aa	33 c2		 xor	 eax, edx
  000ac	2b c2		 sub	 eax, edx
  000ae	85 c0		 test	 eax, eax
  000b0	75 41		 jne	 SHORT $LN5@ppuTick

; 162  :        (VRamAdrsWriteCount % 2 == 0))
; 163  :     {
; 164  :         writeMemory8(Registers->VRamIO, PpuData->FullVRamAdrsIO, PpuData->MemoryOffset);

  000b2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  000ba	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  000be	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  000c6	0f b7 50 26	 movzx	 edx, WORD PTR [rax+38]
  000ca	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  000cf	0f b6 48 07	 movzx	 ecx, BYTE PTR [rax+7]
  000d3	e8 00 00 00 00	 call	 ?writeMemory8@@YAXEG_K@Z ; writeMemory8

; 165  :         PpuData->FullVRamAdrsIO++;

  000d8	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  000e0	0f b7 40 26	 movzx	 eax, WORD PTR [rax+38]
  000e4	66 ff c0	 inc	 ax
  000e7	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  000ef	66 89 41 26	 mov	 WORD PTR [rcx+38], ax
$LN5@ppuTick:

; 166  :     }
; 167  :     
; 168  :     PpuData->PrevAdrsWriteCount = VRamAdrsWriteCount;

  000f3	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  000fb	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?VRamAdrsWriteCount@@3EA ; VRamAdrsWriteCount
  00102	88 48 28	 mov	 BYTE PTR [rax+40], cl

; 169  :     PpuData->PrevDataWriteCount = VRamDataWriteCount;

  00105	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  0010d	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?VRamDataWriteCount@@3EA ; VRamDataWriteCount
  00114	88 48 29	 mov	 BYTE PTR [rax+41], cl

; 170  :     
; 171  :     uint8 NameTableFlag = Registers->Ctrl1 & 0x03;

  00117	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  0011c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0011f	83 e0 03	 and	 eax, 3
  00122	88 44 24 2d	 mov	 BYTE PTR NameTableFlag$[rsp], al

; 172  :     switch(NameTableFlag)

  00126	0f b6 44 24 2d	 movzx	 eax, BYTE PTR NameTableFlag$[rsp]
  0012b	88 44 24 40	 mov	 BYTE PTR tv137[rsp], al
  0012f	80 7c 24 40 00	 cmp	 BYTE PTR tv137[rsp], 0
  00134	74 17		 je	 SHORT $LN6@ppuTick
  00136	80 7c 24 40 01	 cmp	 BYTE PTR tv137[rsp], 1
  0013b	74 23		 je	 SHORT $LN7@ppuTick
  0013d	80 7c 24 40 02	 cmp	 BYTE PTR tv137[rsp], 2
  00142	74 2f		 je	 SHORT $LN8@ppuTick
  00144	80 7c 24 40 03	 cmp	 BYTE PTR tv137[rsp], 3
  00149	74 3b		 je	 SHORT $LN9@ppuTick
  0014b	eb 4a		 jmp	 SHORT $LN2@ppuTick
$LN6@ppuTick:

; 173  :     {
; 174  :         case 0:
; 175  :         {
; 176  :             PpuData->NameTableAddress = 0x2000;

  0014d	b8 00 20 00 00	 mov	 eax, 8192		; 00002000H
  00152	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  0015a	66 89 41 20	 mov	 WORD PTR [rcx+32], ax

; 177  :             break;

  0015e	eb 37		 jmp	 SHORT $LN2@ppuTick
$LN7@ppuTick:

; 178  :         }
; 179  :         case 1:
; 180  :         {
; 181  :             PpuData->NameTableAddress = 0x2400;

  00160	b8 00 24 00 00	 mov	 eax, 9216		; 00002400H
  00165	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  0016d	66 89 41 20	 mov	 WORD PTR [rcx+32], ax

; 182  :             break;

  00171	eb 24		 jmp	 SHORT $LN2@ppuTick
$LN8@ppuTick:

; 183  :         }
; 184  :         case 2:
; 185  :         {
; 186  :             PpuData->NameTableAddress = 0x2800;

  00173	b8 00 28 00 00	 mov	 eax, 10240		; 00002800H
  00178	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  00180	66 89 41 20	 mov	 WORD PTR [rcx+32], ax

; 187  :             break;

  00184	eb 11		 jmp	 SHORT $LN2@ppuTick
$LN9@ppuTick:

; 188  :         }
; 189  :         case 3:
; 190  :         {
; 191  :             PpuData->NameTableAddress = 0x2C00;

  00186	b8 00 2c 00 00	 mov	 eax, 11264		; 00002c00H
  0018b	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  00193	66 89 41 20	 mov	 WORD PTR [rcx+32], ax
$LN2@ppuTick:

; 192  :             break;
; 193  :         }
; 194  :     }
; 195  :     
; 196  :     uint8 AddressIncrement = 1;

  00197	c6 44 24 2e 01	 mov	 BYTE PTR AddressIncrement$[rsp], 1

; 197  :     if(Registers->Ctrl1 & (1 << 2))

  0019c	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  001a1	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a4	83 e0 04	 and	 eax, 4
  001a7	85 c0		 test	 eax, eax
  001a9	74 05		 je	 SHORT $LN10@ppuTick

; 198  :         AddressIncrement = 32;

  001ab	c6 44 24 2e 20	 mov	 BYTE PTR AddressIncrement$[rsp], 32 ; 00000020H
$LN10@ppuTick:

; 199  : 
; 200  :     
; 201  :     if(Registers->Ctrl1 & (1 << 3))

  001b0	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  001b5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001b8	83 e0 08	 and	 eax, 8
  001bb	85 c0		 test	 eax, eax
  001bd	74 13		 je	 SHORT $LN11@ppuTick

; 202  :         PpuData->SprtPatAddress = 0x1000;

  001bf	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  001c4	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  001cc	66 89 41 24	 mov	 WORD PTR [rcx+36], ax

; 203  :     else

  001d0	eb 0e		 jmp	 SHORT $LN12@ppuTick
$LN11@ppuTick:

; 204  :         PpuData->SprtPatAddress = 0x0000;

  001d2	33 c0		 xor	 eax, eax
  001d4	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  001dc	66 89 41 24	 mov	 WORD PTR [rcx+36], ax
$LN12@ppuTick:

; 205  :     
; 206  :     if(Registers->Ctrl1 & (1 << 4))

  001e0	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  001e5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001e8	83 e0 10	 and	 eax, 16
  001eb	85 c0		 test	 eax, eax
  001ed	74 13		 je	 SHORT $LN13@ppuTick

; 207  :         PpuData->BkgrdPatAddress = 0x1000;

  001ef	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  001f4	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  001fc	66 89 41 22	 mov	 WORD PTR [rcx+34], ax

; 208  :     else

  00200	eb 0e		 jmp	 SHORT $LN14@ppuTick
$LN13@ppuTick:

; 209  :         PpuData->BkgrdPatAddress = 0x0000;

  00202	33 c0		 xor	 eax, eax
  00204	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  0020c	66 89 41 22	 mov	 WORD PTR [rcx+34], ax
$LN14@ppuTick:

; 210  : 
; 211  :     
; 212  :     bool32 SpritesAre8x16 = false;

  00210	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR SpritesAre8x16$[rsp], 0

; 213  :     if(Registers->Ctrl1 & (1 << 5))

  00218	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  0021d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00220	83 e0 20	 and	 eax, 32			; 00000020H
  00223	85 c0		 test	 eax, eax
  00225	74 08		 je	 SHORT $LN15@ppuTick

; 214  :         SpritesAre8x16 = true;

  00227	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR SpritesAre8x16$[rsp], 1
$LN15@ppuTick:

; 215  : 
; 216  :     bool32 NmiOnVBlank = false;

  0022f	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR NmiOnVBlank$[rsp], 0

; 217  :     if(Registers->Ctrl1 & (1 << 7))

  00237	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  0023c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0023f	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00244	85 c0		 test	 eax, eax
  00246	74 08		 je	 SHORT $LN16@ppuTick

; 218  :         NmiOnVBlank = true;

  00248	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR NmiOnVBlank$[rsp], 1
$LN16@ppuTick:

; 219  : 
; 220  : 
; 221  :     bool32 ColourMode = true;

  00250	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR ColourMode$[rsp], 1

; 222  :     if(Registers->Ctrl2 & 1)

  00258	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  0025d	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00261	83 e0 01	 and	 eax, 1
  00264	85 c0		 test	 eax, eax
  00266	74 08		 je	 SHORT $LN17@ppuTick

; 223  :         ColourMode = false;

  00268	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR ColourMode$[rsp], 0
$LN17@ppuTick:

; 224  : 
; 225  :     bool32 ClipBackground = false;

  00270	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR ClipBackground$[rsp], 0

; 226  :     if(Registers->Ctrl2 & (1 << 1))

  00278	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  0027d	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00281	83 e0 02	 and	 eax, 2
  00284	85 c0		 test	 eax, eax
  00286	74 08		 je	 SHORT $LN18@ppuTick

; 227  :         ClipBackground = true;

  00288	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR ClipBackground$[rsp], 1
$LN18@ppuTick:

; 228  : 
; 229  :     bool32 ClipSprites = false;

  00290	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR ClipSprites$[rsp], 0

; 230  :     if(Registers->Ctrl2 & (1 << 2))

  00298	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  0029d	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  002a1	83 e0 04	 and	 eax, 4
  002a4	85 c0		 test	 eax, eax
  002a6	74 08		 je	 SHORT $LN19@ppuTick

; 231  :         ClipSprites = true;

  002a8	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR ClipSprites$[rsp], 1
$LN19@ppuTick:

; 232  : 
; 233  :     bool32 HideBackground = true;

  002b0	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR HideBackground$[rsp], 1

; 234  :     if(Registers->Ctrl2 & (1 << 3))

  002b8	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  002bd	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  002c1	83 e0 08	 and	 eax, 8
  002c4	85 c0		 test	 eax, eax
  002c6	74 08		 je	 SHORT $LN20@ppuTick

; 235  :         HideBackground = false;

  002c8	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR HideBackground$[rsp], 0
$LN20@ppuTick:

; 236  : 
; 237  :     bool32 HideSprites = true;

  002d0	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR HideSprites$[rsp], 1

; 238  :     if(Registers->Ctrl2 & (1 << 4))

  002d8	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  002dd	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  002e1	83 e0 10	 and	 eax, 16
  002e4	85 c0		 test	 eax, eax
  002e6	74 08		 je	 SHORT $LN21@ppuTick

; 239  :         HideSprites = false;

  002e8	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR HideSprites$[rsp], 0
$LN21@ppuTick:

; 240  : 
; 241  :     uint8 ColourIntensity = Registers->Ctrl2 >> 5;    

  002f0	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  002f5	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  002f9	c1 f8 05	 sar	 eax, 5
  002fc	88 44 24 44	 mov	 BYTE PTR ColourIntensity$[rsp], al

; 242  : 
; 243  :     
; 244  :     
; 245  :     
; 246  :     /*
; 247  :       Palette is stored at 0x3F00 to 0x3F20
; 248  :       0x3F00 - 0x3F0F is Image Palette
; 249  :       0x3F10 - 0x3F1F is Sprie Palette
; 250  : 
; 251  :       This is mirrored from 0x3F20 to 0x4000
; 252  : 
; 253  :       A palette is 16 indexes to colours stored
; 254  :       in the colour palette. This does not mean 16
; 255  :       seperate colours however as a shared colour is
; 256  :       found every 4 bytes. So 0x3F00 = 0x3F04 = 0x3F08 = 0x3F0C
; 257  : 
; 258  :       Each group of palette is 4 colours.
; 259  :       There are 4 groups.
; 260  :       Attribute tables will name one of the four groups
; 261  :       This is the 4 colours used by a 2x2 tile section
; 262  :       Tiles are 8x8 pixels.
; 263  :       Pattern Tables hold the 8x8 pixel data. Each pattern is
; 264  :       16 bytes.
; 265  :       The nametable points to which pattern is used for a 8x8 pixeled
; 266  :       section.
; 267  :       
; 268  :      */
; 269  :     
; 270  :     PpuData->ZeroPixel = (uint32 *)BackBuffer->Memory;

  00300	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  00308	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR BackBuffer$[rsp]
  00310	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00314	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 271  :     
; 272  :     uint8 Red, Green, Blue;
; 273  :     uint8 TileX, TileY, PrevTileX = 255, PrevTileY = 255;

  00318	c6 44 24 24 ff	 mov	 BYTE PTR PrevTileX$[rsp], 255 ; 000000ffH
  0031d	c6 44 24 25 ff	 mov	 BYTE PTR PrevTileY$[rsp], 255 ; 000000ffH

; 274  :     uint8 BlockX, BlockY, PrevBlockX = 255, PrevBlockY = 255;

  00322	c6 44 24 27 ff	 mov	 BYTE PTR PrevBlockX$[rsp], 255 ; 000000ffH
  00327	c6 44 24 29 ff	 mov	 BYTE PTR PrevBlockY$[rsp], 255 ; 000000ffH

; 275  : 
; 276  :     bkgrd_pattern Pattern = {};

  0032c	48 8d 44 24 70	 lea	 rax, QWORD PTR Pattern$[rsp]
  00331	48 8b f8	 mov	 rdi, rax
  00334	33 c0		 xor	 eax, eax
  00336	b9 10 00 00 00	 mov	 ecx, 16
  0033b	f3 aa		 rep stosb

; 277  : 
; 278  :     palette CurrentPalette = {};

  0033d	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR CurrentPalette$[rsp]
  00345	48 8b f8	 mov	 rdi, rax
  00348	33 c0		 xor	 eax, eax
  0034a	b9 0c 00 00 00	 mov	 ecx, 12
  0034f	f3 aa		 rep stosb

; 279  : 
; 280  :     TileX = PpuData->CurrentXPixel / 8;

  00351	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  00359	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  0035d	99		 cdq
  0035e	83 e2 07	 and	 edx, 7
  00361	03 c2		 add	 eax, edx
  00363	c1 f8 03	 sar	 eax, 3
  00366	88 44 24 21	 mov	 BYTE PTR TileX$[rsp], al

; 281  :     TileY = PpuData->CurrentYPixel / 8;

  0036a	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  00372	0f b7 40 12	 movzx	 eax, WORD PTR [rax+18]
  00376	99		 cdq
  00377	83 e2 07	 and	 edx, 7
  0037a	03 c2		 add	 eax, edx
  0037c	c1 f8 03	 sar	 eax, 3
  0037f	88 44 24 22	 mov	 BYTE PTR TileY$[rsp], al

; 282  : 
; 283  :     uint8 PatternIndex, PrevPatternIndex = 255;

  00383	c6 44 24 26 ff	 mov	 BYTE PTR PrevPatternIndex$[rsp], 255 ; 000000ffH

; 284  :     
; 285  :     if((TileX != PrevTileX) || (TileY != PrevTileY))

  00388	0f b6 44 24 21	 movzx	 eax, BYTE PTR TileX$[rsp]
  0038d	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR PrevTileX$[rsp]
  00392	3b c1		 cmp	 eax, ecx
  00394	75 0e		 jne	 SHORT $LN23@ppuTick
  00396	0f b6 44 24 22	 movzx	 eax, BYTE PTR TileY$[rsp]
  0039b	0f b6 4c 24 25	 movzx	 ecx, BYTE PTR PrevTileY$[rsp]
  003a0	3b c1		 cmp	 eax, ecx
  003a2	74 1c		 je	 SHORT $LN22@ppuTick
$LN23@ppuTick:

; 286  :         PatternIndex = getNametableValue(PpuData, TileX, TileY);

  003a4	44 0f b6 44 24
	22		 movzx	 r8d, BYTE PTR TileY$[rsp]
  003aa	0f b6 54 24 21	 movzx	 edx, BYTE PTR TileX$[rsp]
  003af	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  003b7	e8 00 00 00 00	 call	 ?getNametableValue@@YAEPEAUppu@@EE@Z ; getNametableValue
  003bc	88 44 24 23	 mov	 BYTE PTR PatternIndex$[rsp], al
$LN22@ppuTick:

; 287  :     if(PatternIndex != PrevPatternIndex)

  003c0	0f b6 44 24 23	 movzx	 eax, BYTE PTR PatternIndex$[rsp]
  003c5	0f b6 4c 24 26	 movzx	 ecx, BYTE PTR PrevPatternIndex$[rsp]
  003ca	3b c1		 cmp	 eax, ecx
  003cc	74 4a		 je	 SHORT $LN24@ppuTick

; 288  :         Pattern = getBkgrdPattern(PpuData, PatternIndex);

  003ce	44 0f b6 44 24
	23		 movzx	 r8d, BYTE PTR PatternIndex$[rsp]
  003d4	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR PpuData$[rsp]
  003dc	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR $T2[rsp]
  003e4	e8 00 00 00 00	 call	 ?getBkgrdPattern@@YA?AUbkgrd_pattern@@PEAUppu@@E@Z ; getBkgrdPattern
  003e9	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T1[rsp]
  003f1	48 8b f9	 mov	 rdi, rcx
  003f4	48 8b f0	 mov	 rsi, rax
  003f7	b9 10 00 00 00	 mov	 ecx, 16
  003fc	f3 a4		 rep movsb
  003fe	48 8d 44 24 70	 lea	 rax, QWORD PTR Pattern$[rsp]
  00403	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T1[rsp]
  0040b	48 8b f8	 mov	 rdi, rax
  0040e	48 8b f1	 mov	 rsi, rcx
  00411	b9 10 00 00 00	 mov	 ecx, 16
  00416	f3 a4		 rep movsb
$LN24@ppuTick:

; 289  :     
; 290  :     // NOTE: Pixel relative to a tile
; 291  :     uint8 TilePixelX = PpuData->CurrentXPixel % 8;

  00418	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  00420	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00424	99		 cdq
  00425	83 e2 07	 and	 edx, 7
  00428	03 c2		 add	 eax, edx
  0042a	83 e0 07	 and	 eax, 7
  0042d	2b c2		 sub	 eax, edx
  0042f	88 44 24 2b	 mov	 BYTE PTR TilePixelX$[rsp], al

; 292  :     uint8 TilePixelY = PpuData->CurrentYPixel % 8; 

  00433	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  0043b	0f b7 40 12	 movzx	 eax, WORD PTR [rax+18]
  0043f	99		 cdq
  00440	83 e2 07	 and	 edx, 7
  00443	03 c2		 add	 eax, edx
  00445	83 e0 07	 and	 eax, 7
  00448	2b c2		 sub	 eax, edx
  0044a	88 44 24 2a	 mov	 BYTE PTR TilePixelY$[rsp], al

; 293  :     
; 294  :     PrevTileX = TileX;

  0044e	0f b6 44 24 21	 movzx	 eax, BYTE PTR TileX$[rsp]
  00453	88 44 24 24	 mov	 BYTE PTR PrevTileX$[rsp], al

; 295  :     PrevTileY = TileY;

  00457	0f b6 44 24 22	 movzx	 eax, BYTE PTR TileY$[rsp]
  0045c	88 44 24 25	 mov	 BYTE PTR PrevTileY$[rsp], al

; 296  :     PrevPatternIndex = PatternIndex;

  00460	0f b6 44 24 23	 movzx	 eax, BYTE PTR PatternIndex$[rsp]
  00465	88 44 24 26	 mov	 BYTE PTR PrevPatternIndex$[rsp], al

; 297  : 
; 298  :   
; 299  :     BlockX = PpuData->CurrentXPixel / 16; 

  00469	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  00471	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00475	99		 cdq
  00476	83 e2 0f	 and	 edx, 15
  00479	03 c2		 add	 eax, edx
  0047b	c1 f8 04	 sar	 eax, 4
  0047e	88 44 24 20	 mov	 BYTE PTR BlockX$[rsp], al

; 300  :     BlockY = PpuData->CurrentYPixel / 16;    

  00482	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  0048a	0f b7 40 12	 movzx	 eax, WORD PTR [rax+18]
  0048e	99		 cdq
  0048f	83 e2 0f	 and	 edx, 15
  00492	03 c2		 add	 eax, edx
  00494	c1 f8 04	 sar	 eax, 4
  00497	88 44 24 28	 mov	 BYTE PTR BlockY$[rsp], al

; 301  : 
; 302  : 
; 303  :     uint8 Attribute;
; 304  :     if((BlockX != PrevBlockX) || (BlockX != PrevBlockY))

  0049b	0f b6 44 24 20	 movzx	 eax, BYTE PTR BlockX$[rsp]
  004a0	0f b6 4c 24 27	 movzx	 ecx, BYTE PTR PrevBlockX$[rsp]
  004a5	3b c1		 cmp	 eax, ecx
  004a7	75 0e		 jne	 SHORT $LN26@ppuTick
  004a9	0f b6 44 24 20	 movzx	 eax, BYTE PTR BlockX$[rsp]
  004ae	0f b6 4c 24 29	 movzx	 ecx, BYTE PTR PrevBlockY$[rsp]
  004b3	3b c1		 cmp	 eax, ecx
  004b5	74 1c		 je	 SHORT $LN25@ppuTick
$LN26@ppuTick:

; 305  :          Attribute = getAttribute(PpuData, BlockX, BlockY);

  004b7	44 0f b6 44 24
	28		 movzx	 r8d, BYTE PTR BlockY$[rsp]
  004bd	0f b6 54 24 20	 movzx	 edx, BYTE PTR BlockX$[rsp]
  004c2	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  004ca	e8 00 00 00 00	 call	 ?getAttribute@@YAEPEAUppu@@EE@Z ; getAttribute
  004cf	88 44 24 31	 mov	 BYTE PTR Attribute$[rsp], al
$LN25@ppuTick:

; 306  :   
; 307  :     PrevBlockX = BlockX;

  004d3	0f b6 44 24 20	 movzx	 eax, BYTE PTR BlockX$[rsp]
  004d8	88 44 24 27	 mov	 BYTE PTR PrevBlockX$[rsp], al

; 308  :     PrevBlockY = BlockY;

  004dc	0f b6 44 24 28	 movzx	 eax, BYTE PTR BlockY$[rsp]
  004e1	88 44 24 29	 mov	 BYTE PTR PrevBlockY$[rsp], al

; 309  : 
; 310  :     
; 311  :     // NOTE: Each pixel for a pattern has 2 bits for colour. The other 3 bits
; 312  :     //       for colour are stored in the attribute table. Each bit is stored
; 313  :     //       seperately in two seperate groups. This calculation will retrieve the
; 314  :     //       required bit for a specific pixel and combine them to make a 2 bits
; 315  :     uint8 Group1Bit = (Pattern.Group1[TilePixelY] >> (7 - TilePixelX)) & 1;

  004e5	0f b6 44 24 2a	 movzx	 eax, BYTE PTR TilePixelY$[rsp]
  004ea	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Pattern$[rsp]
  004ef	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004f3	0f b6 4c 24 2b	 movzx	 ecx, BYTE PTR TilePixelX$[rsp]
  004f8	ba 07 00 00 00	 mov	 edx, 7
  004fd	2b d1		 sub	 edx, ecx
  004ff	8b ca		 mov	 ecx, edx
  00501	d3 f8		 sar	 eax, cl
  00503	83 e0 01	 and	 eax, 1
  00506	88 44 24 30	 mov	 BYTE PTR Group1Bit$[rsp], al

; 316  :     uint8 Group2Bit = (Pattern.Group2[TilePixelY] >> (7 - TilePixelX)) & 1;

  0050a	0f b6 44 24 2a	 movzx	 eax, BYTE PTR TilePixelY$[rsp]
  0050f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Pattern$[rsp+8]
  00514	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00518	0f b6 4c 24 2b	 movzx	 ecx, BYTE PTR TilePixelX$[rsp]
  0051d	ba 07 00 00 00	 mov	 edx, 7
  00522	2b d1		 sub	 edx, ecx
  00524	8b ca		 mov	 ecx, edx
  00526	d3 f8		 sar	 eax, cl
  00528	83 e0 01	 and	 eax, 1
  0052b	88 44 24 2f	 mov	 BYTE PTR Group2Bit$[rsp], al

; 317  :     uint8 CombinedBits = Group2Bit << 1 | Group1Bit;

  0052f	0f b6 44 24 2f	 movzx	 eax, BYTE PTR Group2Bit$[rsp]
  00534	d1 e0		 shl	 eax, 1
  00536	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR Group1Bit$[rsp]
  0053b	0b c1		 or	 eax, ecx
  0053d	88 44 24 2c	 mov	 BYTE PTR CombinedBits$[rsp], al

; 318  : 
; 319  :     uint8 FullAttribute = (Attribute << 2) & CombinedBits;

  00541	0f b6 44 24 31	 movzx	 eax, BYTE PTR Attribute$[rsp]
  00546	c1 e0 02	 shl	 eax, 2
  00549	0f b6 4c 24 2c	 movzx	 ecx, BYTE PTR CombinedBits$[rsp]
  0054e	23 c1		 and	 eax, ecx
  00550	88 44 24 45	 mov	 BYTE PTR FullAttribute$[rsp], al

; 320  : 
; 321  :     // TODO: This should fetch the Colour index from the image palette at 0x3F00
; 322  :     uint8 ColourIndex = CombinedBits;

  00554	0f b6 44 24 2c	 movzx	 eax, BYTE PTR CombinedBits$[rsp]
  00559	88 44 24 32	 mov	 BYTE PTR ColourIndex$[rsp], al

; 323  : 
; 324  :     getPaletteValue(ColourIndex, &Red, &Green, &Blue);

  0055d	4c 8d 4c 24 33	 lea	 r9, QWORD PTR Blue$[rsp]
  00562	4c 8d 44 24 34	 lea	 r8, QWORD PTR Green$[rsp]
  00567	48 8d 54 24 35	 lea	 rdx, QWORD PTR Red$[rsp]
  0056c	0f b6 4c 24 32	 movzx	 ecx, BYTE PTR ColourIndex$[rsp]
  00571	e8 00 00 00 00	 call	 ?getPaletteValue@@YAXEPEAE00@Z ; getPaletteValue

; 325  :     uint32 *CurrentPixel = (PpuData->ZeroPixel + (PpuData->CurrentYPixel * BackBuffer->Width)) + PpuData->CurrentXPixel;

  00576	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  0057e	0f b7 40 12	 movzx	 eax, WORD PTR [rax+18]
  00582	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR BackBuffer$[rsp]
  0058a	0f af 41 38	 imul	 eax, DWORD PTR [rcx+56]
  0058e	48 98		 cdqe
  00590	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  00598	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0059c	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  005a0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  005a8	0f b7 49 10	 movzx	 ecx, WORD PTR [rcx+16]
  005ac	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  005b0	48 89 44 24 68	 mov	 QWORD PTR CurrentPixel$[rsp], rax

; 326  :          
; 327  :     *CurrentPixel  = ((Blue << 16) | (Green << 8) | Red);

  005b5	0f b6 44 24 33	 movzx	 eax, BYTE PTR Blue$[rsp]
  005ba	c1 e0 10	 shl	 eax, 16
  005bd	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR Green$[rsp]
  005c2	c1 e1 08	 shl	 ecx, 8
  005c5	0b c1		 or	 eax, ecx
  005c7	0f b6 4c 24 35	 movzx	 ecx, BYTE PTR Red$[rsp]
  005cc	0b c1		 or	 eax, ecx
  005ce	48 8b 4c 24 68	 mov	 rcx, QWORD PTR CurrentPixel$[rsp]
  005d3	89 01		 mov	 DWORD PTR [rcx], eax

; 328  : 
; 329  :     // Advance to the next pixel,
; 330  :     // TODO: Make this a loop that updates once before vblank?
; 331  :     if((PpuData->CurrentXPixel + 1) >= BackBuffer->Width)

  005d5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  005dd	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  005e1	ff c0		 inc	 eax
  005e3	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR BackBuffer$[rsp]
  005eb	3b 41 38	 cmp	 eax, DWORD PTR [rcx+56]
  005ee	7c 28		 jl	 SHORT $LN27@ppuTick

; 332  :         PpuData->CurrentYPixel = (PpuData->CurrentYPixel + 1) % BackBuffer->Height;

  005f0	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  005f8	0f b7 40 12	 movzx	 eax, WORD PTR [rax+18]
  005fc	ff c0		 inc	 eax
  005fe	99		 cdq
  005ff	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR BackBuffer$[rsp]
  00607	f7 79 3c	 idiv	 DWORD PTR [rcx+60]
  0060a	8b c2		 mov	 eax, edx
  0060c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  00614	66 89 41 12	 mov	 WORD PTR [rcx+18], ax
$LN27@ppuTick:

; 333  :     PpuData->CurrentXPixel = (PpuData->CurrentXPixel + 1) % BackBuffer->Width;

  00618	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  00620	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00624	ff c0		 inc	 eax
  00626	99		 cdq
  00627	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR BackBuffer$[rsp]
  0062f	f7 79 38	 idiv	 DWORD PTR [rcx+56]
  00632	8b c2		 mov	 eax, edx
  00634	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR PpuData$[rsp]
  0063c	66 89 41 10	 mov	 WORD PTR [rcx+16], ax

; 334  :     
; 335  : }

  00640	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00648	48 33 cc	 xor	 rcx, rsp
  0064b	e8 00 00 00 00	 call	 __security_check_cookie
  00650	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00657	5f		 pop	 rdi
  00658	5e		 pop	 rsi
  00659	c3		 ret	 0
?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z ENDP	; ppuTick
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
NameTableAddress$ = 0
Value$ = 8
PpuData$ = 32
TileX$ = 40
TileY$ = 48
?getNametableValue@@YAEPEAUppu@@EE@Z PROC		; getNametableValue

; 148  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 149  :     uint64 NameTableAddress = PpuData->NameTableAddress + PpuData->MemoryOffset;

  00012	48 8b 44 24 20	 mov	 rax, QWORD PTR PpuData$[rsp]
  00017	0f b7 40 20	 movzx	 eax, WORD PTR [rax+32]
  0001b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR PpuData$[rsp]
  00020	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00024	48 89 04 24	 mov	 QWORD PTR NameTableAddress$[rsp], rax

; 150  :     uint8 *Value = (uint8 *)(NameTableAddress + (TileY * TILE_COUNT_X) + TileX);    

  00028	0f b6 44 24 30	 movzx	 eax, BYTE PTR TileY$[rsp]
  0002d	6b c0 20	 imul	 eax, eax, 32		; 00000020H
  00030	48 98		 cdqe
  00032	48 8b 0c 24	 mov	 rcx, QWORD PTR NameTableAddress$[rsp]
  00036	48 03 c8	 add	 rcx, rax
  00039	48 8b c1	 mov	 rax, rcx
  0003c	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR TileX$[rsp]
  00041	48 03 c1	 add	 rax, rcx
  00044	48 89 44 24 08	 mov	 QWORD PTR Value$[rsp], rax

; 151  :     return(*Value);

  00049	48 8b 44 24 08	 mov	 rax, QWORD PTR Value$[rsp]
  0004e	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 152  : }

  00051	48 83 c4 18	 add	 rsp, 24
  00055	c3		 ret	 0
?getNametableValue@@YAEPEAUppu@@EE@Z ENDP		; getNametableValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
PatAddress$ = 0
PatTableAddress$ = 8
Result$ = 16
$T1 = 64
PpuData$ = 72
PatternIndex$ = 80
?getBkgrdPattern@@YA?AUbkgrd_pattern@@PEAUppu@@E@Z PROC	; getBkgrdPattern

; 134  : {   

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 135  :     bkgrd_pattern Result = {};

  00015	48 8d 44 24 10	 lea	 rax, QWORD PTR Result$[rsp]
  0001a	48 8b f8	 mov	 rdi, rax
  0001d	33 c0		 xor	 eax, eax
  0001f	b9 10 00 00 00	 mov	 ecx, 16
  00024	f3 aa		 rep stosb

; 136  :     
; 137  :     uint64 PatTableAddress = PpuData->BkgrdPatAddress + PpuData->MemoryOffset;

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR PpuData$[rsp]
  0002b	0f b7 40 22	 movzx	 eax, WORD PTR [rax+34]
  0002f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR PpuData$[rsp]
  00034	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00038	48 89 44 24 08	 mov	 QWORD PTR PatTableAddress$[rsp], rax

; 138  : 
; 139  :     uint8 *PatAddress = (uint8 *)(PatTableAddress + (PatternIndex * BYTES_PER_PATTERN));

  0003d	0f b6 44 24 50	 movzx	 eax, BYTE PTR PatternIndex$[rsp]
  00042	6b c0 10	 imul	 eax, eax, 16
  00045	48 98		 cdqe
  00047	48 8b 4c 24 08	 mov	 rcx, QWORD PTR PatTableAddress$[rsp]
  0004c	48 03 c8	 add	 rcx, rax
  0004f	48 8b c1	 mov	 rax, rcx
  00052	48 89 04 24	 mov	 QWORD PTR PatAddress$[rsp], rax

; 140  : 
; 141  :     Result.Group1 = PatAddress;

  00056	48 8b 04 24	 mov	 rax, QWORD PTR PatAddress$[rsp]
  0005a	48 89 44 24 10	 mov	 QWORD PTR Result$[rsp], rax

; 142  :     Result.Group2 = PatAddress + (BYTES_PER_PATTERN / 2);

  0005f	48 8b 04 24	 mov	 rax, QWORD PTR PatAddress$[rsp]
  00063	48 83 c0 08	 add	 rax, 8
  00067	48 89 44 24 18	 mov	 QWORD PTR Result$[rsp+8], rax

; 143  :     
; 144  :     return(Result);

  0006c	48 8d 44 24 10	 lea	 rax, QWORD PTR Result$[rsp]
  00071	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  00076	48 8b f0	 mov	 rsi, rax
  00079	b9 10 00 00 00	 mov	 ecx, 16
  0007e	f3 a4		 rep movsb
  00080	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 145  : }

  00085	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00089	5f		 pop	 rdi
  0008a	5e		 pop	 rsi
  0008b	c3		 ret	 0
?getBkgrdPattern@@YA?AUbkgrd_pattern@@PEAUppu@@E@Z ENDP	; getBkgrdPattern
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
Result$ = 0
TileNumY$ = 1
AtrbByte$ = 2
TileNumX$ = 3
Tile4x4Y$ = 4
Tile4x4Width$ = 5
Tile4x4X$ = 6
AttributeAddress$ = 8
Attribute$ = 16
PpuData$ = 48
BlockX$ = 56
BlockY$ = 64
?getAttribute@@YAEPEAUppu@@EE@Z PROC			; getAttribute

; 79   : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 80   :     uint8 Result = {};

  00012	c6 04 24 00	 mov	 BYTE PTR Result$[rsp], 0

; 81   :     
; 82   :     uint64 AttributeAddress = PpuData->NameTableAddress + PpuData->MemoryOffset + NAMETABLE_BYTE_COUNT;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR PpuData$[rsp]
  0001b	0f b7 40 20	 movzx	 eax, WORD PTR [rax+32]
  0001f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR PpuData$[rsp]
  00024	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00028	48 8d 84 08 c0
	03 00 00	 lea	 rax, QWORD PTR [rax+rcx+960]
  00030	48 89 44 24 08	 mov	 QWORD PTR AttributeAddress$[rsp], rax

; 83   : 
; 84   :     // NOTE: Attribute data is condensed into one byte per 4x4 tiles.
; 85   :     //       I have the blockX and Y which is a 2x2 Tile, Dividing this by 2 will give 4x4
; 86   :     //       One byte is 0011 2233 where the attribute data is layout as following
; 87   :     //       00 11         Each 2 bits represents a block
; 88   :     //       22 33
; 89   : 
; 90   :     uint8 Tile4x4Width = TILE_COUNT_X / 4;

  00035	c6 44 24 05 08	 mov	 BYTE PTR Tile4x4Width$[rsp], 8

; 91   :     
; 92   :     uint8 Tile4x4X = BlockX / 2;

  0003a	0f b6 44 24 38	 movzx	 eax, BYTE PTR BlockX$[rsp]
  0003f	99		 cdq
  00040	2b c2		 sub	 eax, edx
  00042	d1 f8		 sar	 eax, 1
  00044	88 44 24 06	 mov	 BYTE PTR Tile4x4X$[rsp], al

; 93   :     uint8 Tile4x4Y = BlockY / 2;

  00048	0f b6 44 24 40	 movzx	 eax, BYTE PTR BlockY$[rsp]
  0004d	99		 cdq
  0004e	2b c2		 sub	 eax, edx
  00050	d1 f8		 sar	 eax, 1
  00052	88 44 24 04	 mov	 BYTE PTR Tile4x4Y$[rsp], al

; 94   : 
; 95   :     uint8 *Attribute = (uint8 *)(AttributeAddress + (Tile4x4Y * Tile4x4Width) + Tile4x4X);

  00056	0f b6 44 24 04	 movzx	 eax, BYTE PTR Tile4x4Y$[rsp]
  0005b	0f b6 4c 24 05	 movzx	 ecx, BYTE PTR Tile4x4Width$[rsp]
  00060	0f af c1	 imul	 eax, ecx
  00063	48 98		 cdqe
  00065	48 8b 4c 24 08	 mov	 rcx, QWORD PTR AttributeAddress$[rsp]
  0006a	48 03 c8	 add	 rcx, rax
  0006d	48 8b c1	 mov	 rax, rcx
  00070	0f b6 4c 24 06	 movzx	 ecx, BYTE PTR Tile4x4X$[rsp]
  00075	48 03 c1	 add	 rax, rcx
  00078	48 89 44 24 10	 mov	 QWORD PTR Attribute$[rsp], rax

; 96   :     uint8 AtrbByte = *Attribute;

  0007d	48 8b 44 24 10	 mov	 rax, QWORD PTR Attribute$[rsp]
  00082	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00085	88 44 24 02	 mov	 BYTE PTR AtrbByte$[rsp], al

; 97   : 
; 98   :     uint8 TileNumX = BlockX % 2;

  00089	0f b6 44 24 38	 movzx	 eax, BYTE PTR BlockX$[rsp]
  0008e	99		 cdq
  0008f	83 e0 01	 and	 eax, 1
  00092	33 c2		 xor	 eax, edx
  00094	2b c2		 sub	 eax, edx
  00096	88 44 24 03	 mov	 BYTE PTR TileNumX$[rsp], al

; 99   :     uint8 TileNumY = BlockY % 2;

  0009a	0f b6 44 24 40	 movzx	 eax, BYTE PTR BlockY$[rsp]
  0009f	99		 cdq
  000a0	83 e0 01	 and	 eax, 1
  000a3	33 c2		 xor	 eax, edx
  000a5	2b c2		 sub	 eax, edx
  000a7	88 44 24 01	 mov	 BYTE PTR TileNumY$[rsp], al

; 100  : 
; 101  :     if(TileNumX == 0)

  000ab	0f b6 44 24 03	 movzx	 eax, BYTE PTR TileNumX$[rsp]
  000b0	85 c0		 test	 eax, eax
  000b2	75 33		 jne	 SHORT $LN2@getAttribu

; 102  :     {
; 103  :         if(TileNumY == 0)

  000b4	0f b6 44 24 01	 movzx	 eax, BYTE PTR TileNumY$[rsp]
  000b9	85 c0		 test	 eax, eax
  000bb	75 10		 jne	 SHORT $LN4@getAttribu

; 104  :         {
; 105  :             Result = (AtrbByte << 6) & 3;

  000bd	0f b6 44 24 02	 movzx	 eax, BYTE PTR AtrbByte$[rsp]
  000c2	c1 e0 06	 shl	 eax, 6
  000c5	83 e0 03	 and	 eax, 3
  000c8	88 04 24	 mov	 BYTE PTR Result$[rsp], al
  000cb	eb 18		 jmp	 SHORT $LN5@getAttribu
$LN4@getAttribu:

; 106  :         }
; 107  :         else if(TileNumY == 1)

  000cd	0f b6 44 24 01	 movzx	 eax, BYTE PTR TileNumY$[rsp]
  000d2	83 f8 01	 cmp	 eax, 1
  000d5	75 0e		 jne	 SHORT $LN6@getAttribu

; 108  :         {
; 109  :             Result = (AtrbByte << 2) & 3;

  000d7	0f b6 44 24 02	 movzx	 eax, BYTE PTR AtrbByte$[rsp]
  000dc	c1 e0 02	 shl	 eax, 2
  000df	83 e0 03	 and	 eax, 3
  000e2	88 04 24	 mov	 BYTE PTR Result$[rsp], al
$LN6@getAttribu:
$LN5@getAttribu:

; 110  :         }
; 111  :     }

  000e5	eb 38		 jmp	 SHORT $LN3@getAttribu
$LN2@getAttribu:

; 112  :     else if(TileNumX == 1)

  000e7	0f b6 44 24 03	 movzx	 eax, BYTE PTR TileNumX$[rsp]
  000ec	83 f8 01	 cmp	 eax, 1
  000ef	75 2e		 jne	 SHORT $LN7@getAttribu

; 113  :     {
; 114  :         if(TileNumY == 0)

  000f1	0f b6 44 24 01	 movzx	 eax, BYTE PTR TileNumY$[rsp]
  000f6	85 c0		 test	 eax, eax
  000f8	75 10		 jne	 SHORT $LN8@getAttribu

; 115  :         {
; 116  :             Result = (AtrbByte << 4) & 3;

  000fa	0f b6 44 24 02	 movzx	 eax, BYTE PTR AtrbByte$[rsp]
  000ff	c1 e0 04	 shl	 eax, 4
  00102	83 e0 03	 and	 eax, 3
  00105	88 04 24	 mov	 BYTE PTR Result$[rsp], al
  00108	eb 15		 jmp	 SHORT $LN9@getAttribu
$LN8@getAttribu:

; 117  :         }
; 118  :         else if(TileNumY == 1)

  0010a	0f b6 44 24 01	 movzx	 eax, BYTE PTR TileNumY$[rsp]
  0010f	83 f8 01	 cmp	 eax, 1
  00112	75 0b		 jne	 SHORT $LN10@getAttribu

; 119  :         {
; 120  :             Result = AtrbByte & 3;

  00114	0f b6 44 24 02	 movzx	 eax, BYTE PTR AtrbByte$[rsp]
  00119	83 e0 03	 and	 eax, 3
  0011c	88 04 24	 mov	 BYTE PTR Result$[rsp], al
$LN10@getAttribu:
$LN9@getAttribu:
$LN7@getAttribu:
$LN3@getAttribu:

; 121  :         }
; 122  :     }
; 123  :     
; 124  :     return(Result);

  0011f	0f b6 04 24	 movzx	 eax, BYTE PTR Result$[rsp]

; 125  : }

  00123	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00127	c3		 ret	 0
?getAttribute@@YAEPEAUppu@@EE@Z ENDP			; getAttribute
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\palette.cpp
_TEXT	SEGMENT
Entry$ = 8
Red$ = 16
Green$ = 24
Blue$ = 32
?getPaletteValue@@YAXEPEAE00@Z PROC			; getPaletteValue

; 31   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 32   :     *Red   = Palette[Entry][0];

  00013	0f b6 44 24 08	 movzx	 eax, BYTE PTR Entry$[rsp]
  00018	48 6b c0 03	 imul	 rax, rax, 3
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Palette@@3PAY02EA ; Palette
  00023	48 03 c8	 add	 rcx, rax
  00026	48 8b c1	 mov	 rax, rcx
  00029	b9 01 00 00 00	 mov	 ecx, 1
  0002e	48 6b c9 00	 imul	 rcx, rcx, 0
  00032	48 8b 54 24 10	 mov	 rdx, QWORD PTR Red$[rsp]
  00037	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0003b	88 02		 mov	 BYTE PTR [rdx], al

; 33   :     *Green = Palette[Entry][1];

  0003d	0f b6 44 24 08	 movzx	 eax, BYTE PTR Entry$[rsp]
  00042	48 6b c0 03	 imul	 rax, rax, 3
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Palette@@3PAY02EA ; Palette
  0004d	48 03 c8	 add	 rcx, rax
  00050	48 8b c1	 mov	 rax, rcx
  00053	b9 01 00 00 00	 mov	 ecx, 1
  00058	48 6b c9 01	 imul	 rcx, rcx, 1
  0005c	48 8b 54 24 18	 mov	 rdx, QWORD PTR Green$[rsp]
  00061	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00065	88 02		 mov	 BYTE PTR [rdx], al

; 34   :     *Blue  = Palette[Entry][2];

  00067	0f b6 44 24 08	 movzx	 eax, BYTE PTR Entry$[rsp]
  0006c	48 6b c0 03	 imul	 rax, rax, 3
  00070	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Palette@@3PAY02EA ; Palette
  00077	48 03 c8	 add	 rcx, rax
  0007a	48 8b c1	 mov	 rax, rcx
  0007d	b9 01 00 00 00	 mov	 ecx, 1
  00082	48 6b c9 02	 imul	 rcx, rcx, 2
  00086	48 8b 54 24 20	 mov	 rdx, QWORD PTR Blue$[rsp]
  0008b	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0008f	88 02		 mov	 BYTE PTR [rdx], al

; 35   : }

  00091	c3		 ret	 0
?getPaletteValue@@YAXEPEAE00@Z ENDP			; getPaletteValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
BytesRead$ = 96
Registers$ = 104
CurrentInstr$ = 112
MemoryOffset$ = 120
Value$1 = 128
Value$2 = 129
Value$3 = 130
CyclesElapsed$ = 136
Value$4 = 144
Value$5 = 145
Value$6 = 146
Value$7 = 147
Value$8 = 148
Value$9 = 149
Value$10 = 150
ANDValue$11 = 151
ANDValue$12 = 152
Value$13 = 153
Value$14 = 154
Value$15 = 155
Value$16 = 156
Address$17 = 160
Address$18 = 164
Address$19 = 165
Address$20 = 166
Address$21 = 168
Address$22 = 172
ZeroAddress$23 = 173
HighByte$24 = 174
LowByte$25 = 175
HighByte$26 = 176
LowByte$27 = 177
ByteValue$28 = 178
Address$29 = 179
ByteValue$30 = 180
ZeroAddress$31 = 181
Address$32 = 182
Address$33 = 183
Address$34 = 184
Address$35 = 185
Value$36 = 186
Address$37 = 187
Value$38 = 188
Value$39 = 189
Value$40 = 190
Address$41 = 191
Value$42 = 192
ZeroAddress$43 = 193
Value$44 = 194
ZeroAddress$45 = 195
Value$46 = 196
MissingValue$47 = 197
HighByte$48 = 198
LowByte$49 = 199
HighByte$50 = 200
LowByte$51 = 201
Address$52 = 204
HighBytes$53 = 208
LowBytes$54 = 209
RelAddress$55 = 210
Address$56 = 212
PrevAdrs$57 = 216
Address$58 = 220
IndirectAddress$59 = 224
FinalAddress$60 = 228
Address$61 = 232
NewAdrs$62 = 236
Address$63 = 240
NewAdrs$64 = 244
Address$65 = 248
NewAddress$66 = 252
NewAddress$67 = 256
IndirectAddress$68 = 260
Address$69 = 264
IndirectAddress$70 = 268
IndirectAddress$71 = 272
FinalAddress$72 = 276
Address$73 = 280
tv72 = 284
CarryIsSet$74 = 288
CarryIsSet$75 = 292
Buffer$76 = 296
LogBuffer$ = 304
__$ArrayPad$ = 816
CpuData$ = 864
?cpuTick@@YAXPEAUcpu@@@Z PROC				; cpuTick

; 165  : {

$LN97:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	57		 push	 rdi
  00007	48 81 ec 48 03
	00 00		 sub	 rsp, 840		; 00000348H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 30
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 166  :     cpuRegisters *Registers = &CpuData->Registers;

  00020	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR CpuData$[rsp]
  00028	48 89 44 24 68	 mov	 QWORD PTR Registers$[rsp], rax

; 167  :     uint8 *CyclesElapsed = &CpuData->LastTickCycles;

  0002d	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR CpuData$[rsp]
  00035	48 83 c0 10	 add	 rax, 16
  00039	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR CyclesElapsed$[rsp], rax

; 168  :     uint64 MemoryOffset = CpuData->MemoryOffset; 

  00041	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR CpuData$[rsp]
  00049	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004d	48 89 44 24 78	 mov	 QWORD PTR MemoryOffset$[rsp], rax

; 169  : 
; 170  :     uint8 BytesRead = 0;

  00052	c6 44 24 60 00	 mov	 BYTE PTR BytesRead$[rsp], 0

; 171  :     
; 172  :     uint8 CurrentInstr = readMemory8(Registers->PrgCounter, MemoryOffset);                

  00057	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0005c	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00061	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00065	e8 00 00 00 00	 call	 ?readMemory8@@YAEG_K@Z	; readMemory8
  0006a	88 44 24 70	 mov	 BYTE PTR CurrentInstr$[rsp], al

; 173  :                 
; 174  :     switch(CurrentInstr)

  0006e	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00073	89 84 24 1c 01
	00 00		 mov	 DWORD PTR tv72[rsp], eax
  0007a	81 bc 24 1c 01
	00 00 f1 00 00
	00		 cmp	 DWORD PTR tv72[rsp], 241 ; 000000f1H
  00085	0f 87 e8 19 00
	00		 ja	 $LN91@cpuTick
  0008b	48 63 84 24 1c
	01 00 00	 movsxd	 rax, DWORD PTR tv72[rsp]
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0009a	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN95@cpuTick[rcx+rax]
  000a2	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN96@cpuTick[rcx+rax*4]
  000a9	48 03 c1	 add	 rax, rcx
  000ac	ff e0		 jmp	 rax
$LN4@cpuTick:

; 175  :     {
; 176  :         case 0x00: // BRK - Break
; 177  :         {
; 178  :             Registers->PrgCounter += 2;

  000ae	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  000b3	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  000b7	83 c0 02	 add	 eax, 2
  000ba	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  000bf	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 179  :             uint8 HighByte = (uint8)(Registers->PrgCounter >> 8);

  000c3	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  000c8	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  000cc	c1 f8 08	 sar	 eax, 8
  000cf	88 84 24 c8 00
	00 00		 mov	 BYTE PTR HighByte$50[rsp], al

; 180  :             uint8 LowByte = (uint8)Registers->PrgCounter;

  000d6	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  000db	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  000df	88 84 24 c9 00
	00 00		 mov	 BYTE PTR LowByte$51[rsp], al

; 181  :                         
; 182  :             PushStack(HighByte, &Registers->StackPtr, MemoryOffset);

  000e6	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  000eb	48 83 c0 04	 add	 rax, 4
  000ef	4c 8b 44 24 78	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  000f4	48 8b d0	 mov	 rdx, rax
  000f7	0f b6 8c 24 c8
	00 00 00	 movzx	 ecx, BYTE PTR HighByte$50[rsp]
  000ff	e8 00 00 00 00	 call	 ?PushStack@@YAXEPEAE_K@Z ; PushStack

; 183  :             PushStack(LowByte, &Registers->StackPtr, MemoryOffset);

  00104	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00109	48 83 c0 04	 add	 rax, 4
  0010d	4c 8b 44 24 78	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  00112	48 8b d0	 mov	 rdx, rax
  00115	0f b6 8c 24 c9
	00 00 00	 movzx	 ecx, BYTE PTR LowByte$51[rsp]
  0011d	e8 00 00 00 00	 call	 ?PushStack@@YAXEPEAE_K@Z ; PushStack

; 184  :             PushStack(Registers->Flags, &Registers->StackPtr, MemoryOffset);

  00122	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00127	48 83 c0 04	 add	 rax, 4
  0012b	4c 8b 44 24 78	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  00130	48 8b d0	 mov	 rdx, rax
  00133	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00138	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  0013c	e8 00 00 00 00	 call	 ?PushStack@@YAXEPEAE_K@Z ; PushStack

; 185  : 
; 186  :             Registers->Flags = Registers->Flags | (1 << 2);

  00141	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00146	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0014a	83 c8 04	 or	 eax, 4
  0014d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  00152	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 187  :             
; 188  :             // Read the break location from the IRQ/BRK Vector
; 189  : #define IRQ_VEC 0xFFFE
; 190  :             Registers->PrgCounter = readCpuMemory16(IRQ_VEC, MemoryOffset);

  00155	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0015a	66 b9 fe ff	 mov	 cx, 65534		; 0000fffeH
  0015e	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  00163	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  00168	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 191  :            
; 192  :             BytesRead = 0; // TODO: Check this

  0016c	c6 44 24 60 00	 mov	 BYTE PTR BytesRead$[rsp], 0

; 193  :             *CyclesElapsed = 7;

  00171	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00179	c6 00 07	 mov	 BYTE PTR [rax], 7

; 194  :             break;

  0017c	e9 3d 19 00 00	 jmp	 $LN2@cpuTick
$LN5@cpuTick:

; 195  :         }
; 196  :         case 0x40: // RTI - Return from Interrupt
; 197  :         {
; 198  :             Registers->Flags = PopStack(&Registers->StackPtr, MemoryOffset);

  00181	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00186	48 83 c0 04	 add	 rax, 4
  0018a	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0018f	48 8b c8	 mov	 rcx, rax
  00192	e8 00 00 00 00	 call	 ?PopStack@@YAEPEAE_K@Z	; PopStack
  00197	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  0019c	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 199  :             uint8 LowBytes = PopStack(&Registers->StackPtr, MemoryOffset);

  0019f	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  001a4	48 83 c0 04	 add	 rax, 4
  001a8	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  001ad	48 8b c8	 mov	 rcx, rax
  001b0	e8 00 00 00 00	 call	 ?PopStack@@YAEPEAE_K@Z	; PopStack
  001b5	88 84 24 d1 00
	00 00		 mov	 BYTE PTR LowBytes$54[rsp], al

; 200  :             uint8 HighBytes = PopStack(&Registers->StackPtr, MemoryOffset);

  001bc	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  001c1	48 83 c0 04	 add	 rax, 4
  001c5	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  001ca	48 8b c8	 mov	 rcx, rax
  001cd	e8 00 00 00 00	 call	 ?PopStack@@YAEPEAE_K@Z	; PopStack
  001d2	88 84 24 d0 00
	00 00		 mov	 BYTE PTR HighBytes$53[rsp], al

; 201  :             Registers->PrgCounter = (HighBytes << 8) | LowBytes;

  001d9	0f b6 84 24 d0
	00 00 00	 movzx	 eax, BYTE PTR HighBytes$53[rsp]
  001e1	c1 e0 08	 shl	 eax, 8
  001e4	0f b6 8c 24 d1
	00 00 00	 movzx	 ecx, BYTE PTR LowBytes$54[rsp]
  001ec	0b c1		 or	 eax, ecx
  001ee	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  001f3	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 202  :             
; 203  :             BytesRead = 0;

  001f7	c6 44 24 60 00	 mov	 BYTE PTR BytesRead$[rsp], 0

; 204  :             *CyclesElapsed = 6;

  001fc	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00204	c6 00 06	 mov	 BYTE PTR [rax], 6

; 205  :             break;

  00207	e9 b2 18 00 00	 jmp	 $LN2@cpuTick
$LN6@cpuTick:

; 206  :         }
; 207  :         
; 208  :         // Branch Instructions 
; 209  :         case 0x10: case 0x90: case 0xB0: case 0xD0: case 0xF0:
; 210  :         {
; 211  :             BytesRead = 2;

  0020c	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 212  :             *CyclesElapsed = 2;

  00211	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00219	c6 00 02	 mov	 BYTE PTR [rax], 2

; 213  :                         
; 214  :             int8 RelAddress = readMemory8(Registers->PrgCounter + 1, MemoryOffset);

  0021c	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00221	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00225	ff c0		 inc	 eax
  00227	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0022c	0f b7 c8	 movzx	 ecx, ax
  0022f	e8 00 00 00 00	 call	 ?readMemory8@@YAEG_K@Z	; readMemory8
  00234	88 84 24 d2 00
	00 00		 mov	 BYTE PTR RelAddress$55[rsp], al

; 215  :                         
; 216  :             if( (CurrentInstr == 0x10 && !(Registers->Flags & (1 << 7))) ||  // BPL - Branch if plus.
; 217  :                 (CurrentInstr == 0xB0 && !(Registers->Flags & (1)))      ||  // BCC - Branch on carry clear
; 218  :                 (CurrentInstr == 0xB0 &&   Registers->Flags & (1))       ||  // BCS - Branch if Carry is set
; 219  :                 (CurrentInstr == 0xD0 && !(Registers->Flags & (1 << 1))) ||  // BNE - Branch if not equal

  0023b	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00240	83 f8 10	 cmp	 eax, 16
  00243	75 12		 jne	 SHORT $LN9@cpuTick
  00245	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0024a	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0024e	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00253	85 c0		 test	 eax, eax
  00255	74 70		 je	 SHORT $LN8@cpuTick
$LN9@cpuTick:
  00257	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0025c	3d b0 00 00 00	 cmp	 eax, 176		; 000000b0H
  00261	75 10		 jne	 SHORT $LN10@cpuTick
  00263	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00268	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0026c	83 e0 01	 and	 eax, 1
  0026f	85 c0		 test	 eax, eax
  00271	74 54		 je	 SHORT $LN8@cpuTick
$LN10@cpuTick:
  00273	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00278	3d b0 00 00 00	 cmp	 eax, 176		; 000000b0H
  0027d	75 10		 jne	 SHORT $LN11@cpuTick
  0027f	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00284	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00288	83 e0 01	 and	 eax, 1
  0028b	85 c0		 test	 eax, eax
  0028d	75 38		 jne	 SHORT $LN8@cpuTick
$LN11@cpuTick:
  0028f	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00294	3d d0 00 00 00	 cmp	 eax, 208		; 000000d0H
  00299	75 10		 jne	 SHORT $LN12@cpuTick
  0029b	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  002a0	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  002a4	83 e0 02	 and	 eax, 2
  002a7	85 c0		 test	 eax, eax
  002a9	74 1c		 je	 SHORT $LN8@cpuTick
$LN12@cpuTick:
  002ab	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  002b0	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  002b5	75 4a		 jne	 SHORT $LN7@cpuTick
  002b7	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  002bc	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  002c0	83 e0 02	 and	 eax, 2
  002c3	85 c0		 test	 eax, eax
  002c5	74 3a		 je	 SHORT $LN7@cpuTick
$LN8@cpuTick:

; 220  :                 (CurrentInstr == 0xF0 &&   Registers->Flags & (1 << 1)))     // BEQ - Brach if Equal
; 221  :             {
; 222  :                 Registers->PrgCounter += (RelAddress + 2); // Plus two to next instruction

  002c7	0f be 84 24 d2
	00 00 00	 movsx	 eax, BYTE PTR RelAddress$55[rsp]
  002cf	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  002d4	0f b7 49 06	 movzx	 ecx, WORD PTR [rcx+6]
  002d8	8d 44 01 02	 lea	 eax, DWORD PTR [rcx+rax+2]
  002dc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  002e1	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 223  :                 BytesRead = 0;

  002e5	c6 44 24 60 00	 mov	 BYTE PTR BytesRead$[rsp], 0

; 224  :                 *CyclesElapsed += 1;

  002ea	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  002f2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002f5	ff c0		 inc	 eax
  002f7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR CyclesElapsed$[rsp]
  002ff	88 01		 mov	 BYTE PTR [rcx], al
$LN7@cpuTick:

; 225  :                 // TODO: Add cycles for crossings boundaries
; 226  :             }                       
; 227  :             break;

  00301	e9 b8 17 00 00	 jmp	 $LN2@cpuTick
$LN13@cpuTick:

; 228  :         }
; 229  : 
; 230  :         // LDA - Load Accumulator Register with value
; 231  :         case 0xA5: case 0xA9: case 0xAD: case 0xB1: case 0xBD: case 0xB9:
; 232  :         {
; 233  :             uint8 Value;
; 234  :                         
; 235  :             if(CurrentInstr == 0xA5) // Zero Page

  00306	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  0030b	3d a5 00 00 00	 cmp	 eax, 165		; 000000a5H
  00310	75 50		 jne	 SHORT $LN14@cpuTick

; 236  :             {
; 237  :                 uint8 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  00312	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00317	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0031b	ff c0		 inc	 eax
  0031d	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00322	0f b7 c8	 movzx	 ecx, ax
  00325	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  0032a	88 84 24 ac 00
	00 00		 mov	 BYTE PTR Address$22[rsp], al

; 238  :                 Value = readCpuMemory8(Address, MemoryOffset);

  00331	0f b6 84 24 ac
	00 00 00	 movzx	 eax, BYTE PTR Address$22[rsp]
  00339	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0033e	0f b7 c8	 movzx	 ecx, ax
  00341	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00346	88 84 24 80 00
	00 00		 mov	 BYTE PTR Value$1[rsp], al

; 239  :                 BytesRead = 2;

  0034d	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 240  :                 *CyclesElapsed = 3;

  00352	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  0035a	c6 00 03	 mov	 BYTE PTR [rax], 3
  0035d	e9 11 02 00 00	 jmp	 $LN15@cpuTick
$LN14@cpuTick:

; 241  :             }
; 242  :             else if(CurrentInstr == 0xA9) // Immediate

  00362	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00367	3d a9 00 00 00	 cmp	 eax, 169		; 000000a9H
  0036c	75 34		 jne	 SHORT $LN16@cpuTick

; 243  :             {
; 244  :                 Value = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  0036e	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00373	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00377	ff c0		 inc	 eax
  00379	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0037e	0f b7 c8	 movzx	 ecx, ax
  00381	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00386	88 84 24 80 00
	00 00		 mov	 BYTE PTR Value$1[rsp], al

; 245  :                 BytesRead = 2;

  0038d	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 246  :                 *CyclesElapsed = 2;

  00392	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  0039a	c6 00 02	 mov	 BYTE PTR [rax], 2
  0039d	e9 d1 01 00 00	 jmp	 $LN17@cpuTick
$LN16@cpuTick:

; 247  :             }
; 248  :             else if(CurrentInstr == 0xAD) // Absolute

  003a2	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  003a7	3d ad 00 00 00	 cmp	 eax, 173		; 000000adH
  003ac	75 4e		 jne	 SHORT $LN18@cpuTick

; 249  :             {
; 250  :                 uint16 Address = readCpuMemory16(Registers->PrgCounter + 1, MemoryOffset);

  003ae	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  003b3	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  003b7	ff c0		 inc	 eax
  003b9	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  003be	0f b7 c8	 movzx	 ecx, ax
  003c1	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  003c6	66 89 84 24 dc
	00 00 00	 mov	 WORD PTR Address$58[rsp], ax

; 251  :                 Value = readCpuMemory8(Address, MemoryOffset);

  003ce	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  003d3	0f b7 8c 24 dc
	00 00 00	 movzx	 ecx, WORD PTR Address$58[rsp]
  003db	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  003e0	88 84 24 80 00
	00 00		 mov	 BYTE PTR Value$1[rsp], al

; 252  :                 BytesRead = 3;

  003e7	c6 44 24 60 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 253  :                 *CyclesElapsed = 4;                        

  003ec	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  003f4	c6 00 04	 mov	 BYTE PTR [rax], 4
  003f7	e9 77 01 00 00	 jmp	 $LN19@cpuTick
$LN18@cpuTick:

; 254  :             }
; 255  :             else if(CurrentInstr == 0xB1) // (Indirect), Y

  003fc	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00401	3d b1 00 00 00	 cmp	 eax, 177		; 000000b1H
  00406	0f 85 85 00 00
	00		 jne	 $LN20@cpuTick

; 256  :             {
; 257  :                 uint8 ZeroAddress = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset); 

  0040c	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00411	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00415	ff c0		 inc	 eax
  00417	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0041c	0f b7 c8	 movzx	 ecx, ax
  0041f	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00424	88 84 24 ad 00
	00 00		 mov	 BYTE PTR ZeroAddress$23[rsp], al

; 258  :                 uint16 IndirectAddress = readCpuMemory16(ZeroAddress, MemoryOffset);

  0042b	0f b6 84 24 ad
	00 00 00	 movzx	 eax, BYTE PTR ZeroAddress$23[rsp]
  00433	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00438	0f b7 c8	 movzx	 ecx, ax
  0043b	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  00440	66 89 84 24 e0
	00 00 00	 mov	 WORD PTR IndirectAddress$59[rsp], ax

; 259  :                 uint16 FinalAddress = IndirectAddress + Registers->Y;

  00448	0f b7 84 24 e0
	00 00 00	 movzx	 eax, WORD PTR IndirectAddress$59[rsp]
  00450	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  00455	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  00459	03 c1		 add	 eax, ecx
  0045b	66 89 84 24 e4
	00 00 00	 mov	 WORD PTR FinalAddress$60[rsp], ax

; 260  :                 Value = readCpuMemory8(FinalAddress, MemoryOffset);

  00463	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00468	0f b7 8c 24 e4
	00 00 00	 movzx	 ecx, WORD PTR FinalAddress$60[rsp]
  00470	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00475	88 84 24 80 00
	00 00		 mov	 BYTE PTR Value$1[rsp], al

; 261  :                 BytesRead = 2;

  0047c	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 262  :                 *CyclesElapsed = 5;

  00481	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00489	c6 00 05	 mov	 BYTE PTR [rax], 5
  0048c	e9 e2 00 00 00	 jmp	 $LN21@cpuTick
$LN20@cpuTick:

; 263  :             }
; 264  :             else if(CurrentInstr == 0xBD) // Absolute, X

  00491	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00496	3d bd 00 00 00	 cmp	 eax, 189		; 000000bdH
  0049b	75 66		 jne	 SHORT $LN22@cpuTick

; 265  :             {
; 266  :                 uint16 Address = readCpuMemory16(Registers->PrgCounter + 1, MemoryOffset);

  0049d	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  004a2	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  004a6	ff c0		 inc	 eax
  004a8	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  004ad	0f b7 c8	 movzx	 ecx, ax
  004b0	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  004b5	66 89 84 24 e8
	00 00 00	 mov	 WORD PTR Address$61[rsp], ax

; 267  :                 uint16 NewAdrs = Address + Registers->X;

  004bd	0f b7 84 24 e8
	00 00 00	 movzx	 eax, WORD PTR Address$61[rsp]
  004c5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  004ca	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  004ce	03 c1		 add	 eax, ecx
  004d0	66 89 84 24 ec
	00 00 00	 mov	 WORD PTR NewAdrs$62[rsp], ax

; 268  :                 Value = readCpuMemory8(NewAdrs, MemoryOffset);

  004d8	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  004dd	0f b7 8c 24 ec
	00 00 00	 movzx	 ecx, WORD PTR NewAdrs$62[rsp]
  004e5	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  004ea	88 84 24 80 00
	00 00		 mov	 BYTE PTR Value$1[rsp], al

; 269  :                 BytesRead = 3;

  004f1	c6 44 24 60 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 270  :                 *CyclesElapsed = 4; // TODO: Boundary fix                         

  004f6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  004fe	c6 00 04	 mov	 BYTE PTR [rax], 4
  00501	eb 70		 jmp	 SHORT $LN23@cpuTick
$LN22@cpuTick:

; 271  :             }
; 272  :             else if(CurrentInstr == 0xB9) // Absolute, Y

  00503	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00508	3d b9 00 00 00	 cmp	 eax, 185		; 000000b9H
  0050d	75 64		 jne	 SHORT $LN24@cpuTick

; 273  :             {
; 274  :                 uint16 Address = readCpuMemory16(Registers->PrgCounter + 1, MemoryOffset);

  0050f	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00514	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00518	ff c0		 inc	 eax
  0051a	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0051f	0f b7 c8	 movzx	 ecx, ax
  00522	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  00527	66 89 84 24 f0
	00 00 00	 mov	 WORD PTR Address$63[rsp], ax

; 275  :                 uint16 NewAdrs = Address + Registers->Y;

  0052f	0f b7 84 24 f0
	00 00 00	 movzx	 eax, WORD PTR Address$63[rsp]
  00537	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  0053c	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  00540	03 c1		 add	 eax, ecx
  00542	66 89 84 24 f4
	00 00 00	 mov	 WORD PTR NewAdrs$64[rsp], ax

; 276  :                 Value = readCpuMemory8(NewAdrs, MemoryOffset);

  0054a	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0054f	0f b7 8c 24 f4
	00 00 00	 movzx	 ecx, WORD PTR NewAdrs$64[rsp]
  00557	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  0055c	88 84 24 80 00
	00 00		 mov	 BYTE PTR Value$1[rsp], al

; 277  :                 BytesRead = 3;

  00563	c6 44 24 60 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 278  :                 *CyclesElapsed = 4; // TODO: Boundary fix                         

  00568	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00570	c6 00 04	 mov	 BYTE PTR [rax], 4
$LN24@cpuTick:
$LN23@cpuTick:
$LN21@cpuTick:
$LN19@cpuTick:
$LN17@cpuTick:
$LN15@cpuTick:

; 279  :             }
; 280  :                         
; 281  :             setNegative(Value, &Registers->Flags);

  00573	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00578	48 83 c0 03	 add	 rax, 3
  0057c	48 8b d0	 mov	 rdx, rax
  0057f	0f b6 8c 24 80
	00 00 00	 movzx	 ecx, BYTE PTR Value$1[rsp]
  00587	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 282  :             setZero(Value, &Registers->Flags);                        

  0058c	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00591	48 83 c0 03	 add	 rax, 3
  00595	48 8b d0	 mov	 rdx, rax
  00598	0f b6 8c 24 80
	00 00 00	 movzx	 ecx, BYTE PTR Value$1[rsp]
  005a0	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 283  :             Registers->A = Value;

  005a5	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  005aa	0f b6 8c 24 80
	00 00 00	 movzx	 ecx, BYTE PTR Value$1[rsp]
  005b2	88 08		 mov	 BYTE PTR [rax], cl

; 284  :             break;

  005b4	e9 05 15 00 00	 jmp	 $LN2@cpuTick
$LN25@cpuTick:

; 285  :         }
; 286  : 
; 287  :         case 0x06: // ASL(ZeroPage) - Shift Mem Left 1 bit
; 288  :         {
; 289  :             uint8 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  005b9	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  005be	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  005c2	ff c0		 inc	 eax
  005c4	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  005c9	0f b7 c8	 movzx	 ecx, ax
  005cc	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  005d1	88 84 24 a4 00
	00 00		 mov	 BYTE PTR Address$18[rsp], al

; 290  :             uint8 Value = readCpuMemory8(Address, MemoryOffset);

  005d8	0f b6 84 24 a4
	00 00 00	 movzx	 eax, BYTE PTR Address$18[rsp]
  005e0	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  005e5	0f b7 c8	 movzx	 ecx, ax
  005e8	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  005ed	88 84 24 90 00
	00 00		 mov	 BYTE PTR Value$4[rsp], al

; 291  :             
; 292  :             if(Value & (1 << 7))

  005f4	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR Value$4[rsp]
  005fc	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00601	85 c0		 test	 eax, eax
  00603	74 13		 je	 SHORT $LN26@cpuTick

; 293  :                 setCarry(&Registers->Flags);

  00605	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0060a	48 83 c0 03	 add	 rax, 3
  0060e	48 8b c8	 mov	 rcx, rax
  00611	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 294  :             else

  00616	eb 11		 jmp	 SHORT $LN27@cpuTick
$LN26@cpuTick:

; 295  :                 clearCarry(&Registers->Flags);

  00618	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0061d	48 83 c0 03	 add	 rax, 3
  00621	48 8b c8	 mov	 rcx, rax
  00624	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN27@cpuTick:

; 296  :           
; 297  :             Value = Value << 1;

  00629	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR Value$4[rsp]
  00631	d1 e0		 shl	 eax, 1
  00633	88 84 24 90 00
	00 00		 mov	 BYTE PTR Value$4[rsp], al

; 298  :             writeCpuMemory8(Value, Address, MemoryOffset);

  0063a	0f b6 84 24 a4
	00 00 00	 movzx	 eax, BYTE PTR Address$18[rsp]
  00642	4c 8b 44 24 78	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  00647	0f b7 d0	 movzx	 edx, ax
  0064a	0f b6 8c 24 90
	00 00 00	 movzx	 ecx, BYTE PTR Value$4[rsp]
  00652	e8 00 00 00 00	 call	 ?writeCpuMemory8@@YAXEG_K@Z ; writeCpuMemory8

; 299  :                         
; 300  :             setNegative(Value, &Registers->Flags);

  00657	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0065c	48 83 c0 03	 add	 rax, 3
  00660	48 8b d0	 mov	 rdx, rax
  00663	0f b6 8c 24 90
	00 00 00	 movzx	 ecx, BYTE PTR Value$4[rsp]
  0066b	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 301  :             setZero(Value, &Registers->Flags);

  00670	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00675	48 83 c0 03	 add	 rax, 3
  00679	48 8b d0	 mov	 rdx, rax
  0067c	0f b6 8c 24 90
	00 00 00	 movzx	 ecx, BYTE PTR Value$4[rsp]
  00684	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 302  :             BytesRead = 2;

  00689	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 303  :             *CyclesElapsed = 5;

  0068e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00696	c6 00 05	 mov	 BYTE PTR [rax], 5

; 304  :             break;

  00699	e9 20 14 00 00	 jmp	 $LN2@cpuTick
$LN28@cpuTick:

; 305  :         }
; 306  :         case 0x0A: // ASL(Accumulator)
; 307  :         {
; 308  :             uint8 Value = Registers->A;

  0069e	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  006a3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  006a6	88 84 24 91 00
	00 00		 mov	 BYTE PTR Value$5[rsp], al

; 309  :             
; 310  :             if(Value & (1 << 7))

  006ad	0f b6 84 24 91
	00 00 00	 movzx	 eax, BYTE PTR Value$5[rsp]
  006b5	25 80 00 00 00	 and	 eax, 128		; 00000080H
  006ba	85 c0		 test	 eax, eax
  006bc	74 13		 je	 SHORT $LN29@cpuTick

; 311  :                 setCarry(&Registers->Flags);

  006be	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  006c3	48 83 c0 03	 add	 rax, 3
  006c7	48 8b c8	 mov	 rcx, rax
  006ca	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 312  :             else

  006cf	eb 11		 jmp	 SHORT $LN30@cpuTick
$LN29@cpuTick:

; 313  :                 clearCarry(&Registers->Flags);

  006d1	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  006d6	48 83 c0 03	 add	 rax, 3
  006da	48 8b c8	 mov	 rcx, rax
  006dd	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN30@cpuTick:

; 314  :           
; 315  :             Value = Value << 1;

  006e2	0f b6 84 24 91
	00 00 00	 movzx	 eax, BYTE PTR Value$5[rsp]
  006ea	d1 e0		 shl	 eax, 1
  006ec	88 84 24 91 00
	00 00		 mov	 BYTE PTR Value$5[rsp], al

; 316  : 
; 317  :             Registers->A = Value;

  006f3	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  006f8	0f b6 8c 24 91
	00 00 00	 movzx	 ecx, BYTE PTR Value$5[rsp]
  00700	88 08		 mov	 BYTE PTR [rax], cl

; 318  :                         
; 319  :             setNegative(Value, &Registers->Flags);

  00702	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00707	48 83 c0 03	 add	 rax, 3
  0070b	48 8b d0	 mov	 rdx, rax
  0070e	0f b6 8c 24 91
	00 00 00	 movzx	 ecx, BYTE PTR Value$5[rsp]
  00716	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 320  :             setZero(Value, &Registers->Flags);

  0071b	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00720	48 83 c0 03	 add	 rax, 3
  00724	48 8b d0	 mov	 rdx, rax
  00727	0f b6 8c 24 91
	00 00 00	 movzx	 ecx, BYTE PTR Value$5[rsp]
  0072f	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 321  :             BytesRead = 1;

  00734	c6 44 24 60 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 322  :             *CyclesElapsed = 2;

  00739	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00741	c6 00 02	 mov	 BYTE PTR [rax], 2

; 323  :             
; 324  :             break;

  00744	e9 75 13 00 00	 jmp	 $LN2@cpuTick
$LN31@cpuTick:

; 325  :         }
; 326  :         case 0x4A: // LSR(Accumulator) - logical shift right
; 327  :         {
; 328  :             if(Registers->A & 1)

  00749	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0074e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00751	83 e0 01	 and	 eax, 1
  00754	85 c0		 test	 eax, eax
  00756	74 13		 je	 SHORT $LN32@cpuTick

; 329  :                 setCarry(&Registers->Flags);

  00758	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0075d	48 83 c0 03	 add	 rax, 3
  00761	48 8b c8	 mov	 rcx, rax
  00764	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 330  :             else

  00769	eb 11		 jmp	 SHORT $LN33@cpuTick
$LN32@cpuTick:

; 331  :                 clearCarry(&Registers->Flags);

  0076b	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00770	48 83 c0 03	 add	 rax, 3
  00774	48 8b c8	 mov	 rcx, rax
  00777	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN33@cpuTick:

; 332  : 
; 333  :             Registers->A = Registers->A >> 1;

  0077c	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00781	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00784	d1 f8		 sar	 eax, 1
  00786	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  0078b	88 01		 mov	 BYTE PTR [rcx], al

; 334  :             BytesRead = 1;

  0078d	c6 44 24 60 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 335  :             *CyclesElapsed = 2;

  00792	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  0079a	c6 00 02	 mov	 BYTE PTR [rax], 2

; 336  :             break;

  0079d	e9 1c 13 00 00	 jmp	 $LN2@cpuTick
$LN34@cpuTick:

; 337  :         }
; 338  :         case 0x26: // ROL(Zeropage)
; 339  :         {
; 340  :             uint16 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  007a2	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  007a7	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  007ab	ff c0		 inc	 eax
  007ad	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  007b2	0f b7 c8	 movzx	 ecx, ax
  007b5	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  007ba	0f b6 c0	 movzx	 eax, al
  007bd	66 89 84 24 d4
	00 00 00	 mov	 WORD PTR Address$56[rsp], ax

; 341  :             uint8 Value = readCpuMemory8(Address, MemoryOffset);

  007c5	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  007ca	0f b7 8c 24 d4
	00 00 00	 movzx	 ecx, WORD PTR Address$56[rsp]
  007d2	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  007d7	88 84 24 81 00
	00 00		 mov	 BYTE PTR Value$2[rsp], al

; 342  : 
; 343  :             bool32 CarryIsSet = Registers->Flags & 1;

  007de	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  007e3	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  007e7	83 e0 01	 and	 eax, 1
  007ea	89 84 24 20 01
	00 00		 mov	 DWORD PTR CarryIsSet$74[rsp], eax

; 344  :             if(Registers->Flags & (1 << 7))

  007f1	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  007f6	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  007fa	25 80 00 00 00	 and	 eax, 128		; 00000080H
  007ff	85 c0		 test	 eax, eax
  00801	74 13		 je	 SHORT $LN35@cpuTick

; 345  :                 setCarry(&Registers->Flags);

  00803	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00808	48 83 c0 03	 add	 rax, 3
  0080c	48 8b c8	 mov	 rcx, rax
  0080f	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 346  :             else

  00814	eb 11		 jmp	 SHORT $LN36@cpuTick
$LN35@cpuTick:

; 347  :                 clearCarry(&Registers->Flags);

  00816	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0081b	48 83 c0 03	 add	 rax, 3
  0081f	48 8b c8	 mov	 rcx, rax
  00822	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN36@cpuTick:

; 348  : 
; 349  :             Value = Value << 1;

  00827	0f b6 84 24 81
	00 00 00	 movzx	 eax, BYTE PTR Value$2[rsp]
  0082f	d1 e0		 shl	 eax, 1
  00831	88 84 24 81 00
	00 00		 mov	 BYTE PTR Value$2[rsp], al

; 350  :             if(CarryIsSet)

  00838	83 bc 24 20 01
	00 00 00	 cmp	 DWORD PTR CarryIsSet$74[rsp], 0
  00840	74 12		 je	 SHORT $LN37@cpuTick

; 351  :                 Value = Value & 1;

  00842	0f b6 84 24 81
	00 00 00	 movzx	 eax, BYTE PTR Value$2[rsp]
  0084a	83 e0 01	 and	 eax, 1
  0084d	88 84 24 81 00
	00 00		 mov	 BYTE PTR Value$2[rsp], al
$LN37@cpuTick:

; 352  :             
; 353  :             setNegative(Value, &Registers->Flags);

  00854	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00859	48 83 c0 03	 add	 rax, 3
  0085d	48 8b d0	 mov	 rdx, rax
  00860	0f b6 8c 24 81
	00 00 00	 movzx	 ecx, BYTE PTR Value$2[rsp]
  00868	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 354  :             setZero(Value, &Registers->Flags);

  0086d	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00872	48 83 c0 03	 add	 rax, 3
  00876	48 8b d0	 mov	 rdx, rax
  00879	0f b6 8c 24 81
	00 00 00	 movzx	 ecx, BYTE PTR Value$2[rsp]
  00881	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 355  :             
; 356  :             writeCpuMemory8(Value, Address, MemoryOffset);

  00886	4c 8b 44 24 78	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  0088b	0f b7 94 24 d4
	00 00 00	 movzx	 edx, WORD PTR Address$56[rsp]
  00893	0f b6 8c 24 81
	00 00 00	 movzx	 ecx, BYTE PTR Value$2[rsp]
  0089b	e8 00 00 00 00	 call	 ?writeCpuMemory8@@YAXEG_K@Z ; writeCpuMemory8

; 357  :                                   
; 358  :             BytesRead = 2;

  008a0	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 359  :             *CyclesElapsed = 6;

  008a5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  008ad	c6 00 06	 mov	 BYTE PTR [rax], 6

; 360  :             break;

  008b0	e9 09 12 00 00	 jmp	 $LN2@cpuTick
$LN38@cpuTick:

; 361  :         }
; 362  :         case 0x36: // ROL(Zeropage, X) - Rotate left one bit
; 363  :         {
; 364  :             uint16 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  008b5	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  008ba	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  008be	ff c0		 inc	 eax
  008c0	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  008c5	0f b7 c8	 movzx	 ecx, ax
  008c8	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  008cd	0f b6 c0	 movzx	 eax, al
  008d0	66 89 84 24 a8
	00 00 00	 mov	 WORD PTR Address$21[rsp], ax

; 365  :             Address += Registers->X;

  008d8	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  008dd	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  008e1	0f b7 8c 24 a8
	00 00 00	 movzx	 ecx, WORD PTR Address$21[rsp]
  008e9	03 c8		 add	 ecx, eax
  008eb	8b c1		 mov	 eax, ecx
  008ed	66 89 84 24 a8
	00 00 00	 mov	 WORD PTR Address$21[rsp], ax

; 366  :             uint8 Value = readCpuMemory8(Address, MemoryOffset);

  008f5	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  008fa	0f b7 8c 24 a8
	00 00 00	 movzx	 ecx, WORD PTR Address$21[rsp]
  00902	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00907	88 84 24 82 00
	00 00		 mov	 BYTE PTR Value$3[rsp], al

; 367  : 
; 368  :             bool32 CarryIsSet = Registers->Flags & 1;

  0090e	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00913	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00917	83 e0 01	 and	 eax, 1
  0091a	89 84 24 24 01
	00 00		 mov	 DWORD PTR CarryIsSet$75[rsp], eax

; 369  :             if(Registers->Flags & (1 << 7))

  00921	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00926	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0092a	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0092f	85 c0		 test	 eax, eax
  00931	74 13		 je	 SHORT $LN39@cpuTick

; 370  :                 setCarry(&Registers->Flags);

  00933	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00938	48 83 c0 03	 add	 rax, 3
  0093c	48 8b c8	 mov	 rcx, rax
  0093f	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 371  :             else

  00944	eb 11		 jmp	 SHORT $LN40@cpuTick
$LN39@cpuTick:

; 372  :                 clearCarry(&Registers->Flags);

  00946	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0094b	48 83 c0 03	 add	 rax, 3
  0094f	48 8b c8	 mov	 rcx, rax
  00952	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN40@cpuTick:

; 373  : 
; 374  :             Value = Value << 1;

  00957	0f b6 84 24 82
	00 00 00	 movzx	 eax, BYTE PTR Value$3[rsp]
  0095f	d1 e0		 shl	 eax, 1
  00961	88 84 24 82 00
	00 00		 mov	 BYTE PTR Value$3[rsp], al

; 375  :             if(CarryIsSet)

  00968	83 bc 24 24 01
	00 00 00	 cmp	 DWORD PTR CarryIsSet$75[rsp], 0
  00970	74 12		 je	 SHORT $LN41@cpuTick

; 376  :                 Value = Value & 1;

  00972	0f b6 84 24 82
	00 00 00	 movzx	 eax, BYTE PTR Value$3[rsp]
  0097a	83 e0 01	 and	 eax, 1
  0097d	88 84 24 82 00
	00 00		 mov	 BYTE PTR Value$3[rsp], al
$LN41@cpuTick:

; 377  : 
; 378  :             setNegative(Value, &Registers->Flags);

  00984	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00989	48 83 c0 03	 add	 rax, 3
  0098d	48 8b d0	 mov	 rdx, rax
  00990	0f b6 8c 24 82
	00 00 00	 movzx	 ecx, BYTE PTR Value$3[rsp]
  00998	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 379  :             setZero(Value, &Registers->Flags);

  0099d	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  009a2	48 83 c0 03	 add	 rax, 3
  009a6	48 8b d0	 mov	 rdx, rax
  009a9	0f b6 8c 24 82
	00 00 00	 movzx	 ecx, BYTE PTR Value$3[rsp]
  009b1	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 380  :             writeCpuMemory8(Value, Address, MemoryOffset);

  009b6	4c 8b 44 24 78	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  009bb	0f b7 94 24 a8
	00 00 00	 movzx	 edx, WORD PTR Address$21[rsp]
  009c3	0f b6 8c 24 82
	00 00 00	 movzx	 ecx, BYTE PTR Value$3[rsp]
  009cb	e8 00 00 00 00	 call	 ?writeCpuMemory8@@YAXEG_K@Z ; writeCpuMemory8

; 381  :                                   
; 382  :             BytesRead = 2;

  009d0	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 383  :             *CyclesElapsed = 6;

  009d5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  009dd	c6 00 06	 mov	 BYTE PTR [rax], 6

; 384  :             
; 385  :             break;

  009e0	e9 d9 10 00 00	 jmp	 $LN2@cpuTick
$LN42@cpuTick:

; 386  :         }
; 387  :         case 0x0D: // ORA(Absolute) - OR memory with Accumlator
; 388  :         {
; 389  :             uint16 Address = readCpuMemory16(Registers->PrgCounter + 1, MemoryOffset);

  009e5	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  009ea	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  009ee	ff c0		 inc	 eax
  009f0	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  009f5	0f b7 c8	 movzx	 ecx, ax
  009f8	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  009fd	66 89 84 24 f8
	00 00 00	 mov	 WORD PTR Address$65[rsp], ax

; 390  :             uint8 Value = readCpuMemory8(Address, MemoryOffset);

  00a05	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00a0a	0f b7 8c 24 f8
	00 00 00	 movzx	 ecx, WORD PTR Address$65[rsp]
  00a12	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00a17	88 84 24 95 00
	00 00		 mov	 BYTE PTR Value$9[rsp], al

; 391  : 
; 392  :             Registers->A = Registers->A | Value;

  00a1e	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00a23	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00a26	0f b6 8c 24 95
	00 00 00	 movzx	 ecx, BYTE PTR Value$9[rsp]
  00a2e	0b c1		 or	 eax, ecx
  00a30	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  00a35	88 01		 mov	 BYTE PTR [rcx], al

; 393  :             
; 394  :             setNegative(Value, &Registers->Flags);

  00a37	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00a3c	48 83 c0 03	 add	 rax, 3
  00a40	48 8b d0	 mov	 rdx, rax
  00a43	0f b6 8c 24 95
	00 00 00	 movzx	 ecx, BYTE PTR Value$9[rsp]
  00a4b	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 395  :             setZero(Value, &Registers->Flags);

  00a50	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00a55	48 83 c0 03	 add	 rax, 3
  00a59	48 8b d0	 mov	 rdx, rax
  00a5c	0f b6 8c 24 95
	00 00 00	 movzx	 ecx, BYTE PTR Value$9[rsp]
  00a64	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 396  : 
; 397  :             BytesRead = 3;

  00a69	c6 44 24 60 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 398  :             *CyclesElapsed = 4;

  00a6e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00a76	c6 00 04	 mov	 BYTE PTR [rax], 4

; 399  :             break;

  00a79	e9 40 10 00 00	 jmp	 $LN2@cpuTick
$LN43@cpuTick:

; 400  :         }
; 401  :         
; 402  :         case 0xA2: // LDX(Immediate) - Load X index with memory
; 403  :         {
; 404  :             uint8 Value = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  00a7e	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00a83	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00a87	ff c0		 inc	 eax
  00a89	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00a8e	0f b7 c8	 movzx	 ecx, ax
  00a91	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00a96	88 84 24 96 00
	00 00		 mov	 BYTE PTR Value$10[rsp], al

; 405  : 
; 406  :             setNegative(Value, &Registers->Flags);

  00a9d	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00aa2	48 83 c0 03	 add	 rax, 3
  00aa6	48 8b d0	 mov	 rdx, rax
  00aa9	0f b6 8c 24 96
	00 00 00	 movzx	 ecx, BYTE PTR Value$10[rsp]
  00ab1	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 407  :             setZero(Value, &Registers->Flags);

  00ab6	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00abb	48 83 c0 03	 add	 rax, 3
  00abf	48 8b d0	 mov	 rdx, rax
  00ac2	0f b6 8c 24 96
	00 00 00	 movzx	 ecx, BYTE PTR Value$10[rsp]
  00aca	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 408  : 
; 409  :             Registers->X = Value;

  00acf	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00ad4	0f b6 8c 24 96
	00 00 00	 movzx	 ecx, BYTE PTR Value$10[rsp]
  00adc	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 410  :                         
; 411  :             BytesRead = 2;

  00adf	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 412  :             *CyclesElapsed = 2;

  00ae4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00aec	c6 00 02	 mov	 BYTE PTR [rax], 2

; 413  :             break;

  00aef	e9 ca 0f 00 00	 jmp	 $LN2@cpuTick
$LN44@cpuTick:

; 414  :         }
; 415  :                 
; 416  :                     
; 417  :         case 0x20: // JSR - Jump to subroutine
; 418  :         {
; 419  :             // last byte of jrs (next instruction minus 1) is pushed onto stack
; 420  :             // program counter jumps to address
; 421  : 
; 422  :             uint16 NewAddress = readCpuMemory16(Registers->PrgCounter + 1, MemoryOffset);

  00af4	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00af9	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00afd	ff c0		 inc	 eax
  00aff	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00b04	0f b7 c8	 movzx	 ecx, ax
  00b07	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  00b0c	66 89 84 24 fc
	00 00 00	 mov	 WORD PTR NewAddress$66[rsp], ax

; 423  :                         
; 424  :             uint16 PrevAdrs = Registers->PrgCounter + 2;                              

  00b14	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00b19	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00b1d	83 c0 02	 add	 eax, 2
  00b20	66 89 84 24 d8
	00 00 00	 mov	 WORD PTR PrevAdrs$57[rsp], ax

; 425  :             uint8 HighByte = (uint8)(PrevAdrs >> 8);

  00b28	0f b7 84 24 d8
	00 00 00	 movzx	 eax, WORD PTR PrevAdrs$57[rsp]
  00b30	c1 f8 08	 sar	 eax, 8
  00b33	88 84 24 ae 00
	00 00		 mov	 BYTE PTR HighByte$24[rsp], al

; 426  :             uint8 LowByte = (uint8)PrevAdrs;

  00b3a	0f b6 84 24 d8
	00 00 00	 movzx	 eax, BYTE PTR PrevAdrs$57[rsp]
  00b42	88 84 24 af 00
	00 00		 mov	 BYTE PTR LowByte$25[rsp], al

; 427  :       
; 428  :             // Push onto stack, little endian
; 429  :             PushStack(HighByte, &Registers->StackPtr, MemoryOffset);

  00b49	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00b4e	48 83 c0 04	 add	 rax, 4
  00b52	4c 8b 44 24 78	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  00b57	48 8b d0	 mov	 rdx, rax
  00b5a	0f b6 8c 24 ae
	00 00 00	 movzx	 ecx, BYTE PTR HighByte$24[rsp]
  00b62	e8 00 00 00 00	 call	 ?PushStack@@YAXEPEAE_K@Z ; PushStack

; 430  :             PushStack(LowByte, &Registers->StackPtr, MemoryOffset);

  00b67	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00b6c	48 83 c0 04	 add	 rax, 4
  00b70	4c 8b 44 24 78	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  00b75	48 8b d0	 mov	 rdx, rax
  00b78	0f b6 8c 24 af
	00 00 00	 movzx	 ecx, BYTE PTR LowByte$25[rsp]
  00b80	e8 00 00 00 00	 call	 ?PushStack@@YAXEPEAE_K@Z ; PushStack

; 431  : 
; 432  :             Registers->PrgCounter = NewAddress;

  00b85	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00b8a	0f b7 8c 24 fc
	00 00 00	 movzx	 ecx, WORD PTR NewAddress$66[rsp]
  00b92	66 89 48 06	 mov	 WORD PTR [rax+6], cx

; 433  : 
; 434  :             BytesRead = 0; // Moved to the next instruction already

  00b96	c6 44 24 60 00	 mov	 BYTE PTR BytesRead$[rsp], 0

; 435  :             *CyclesElapsed = 6;

  00b9b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00ba3	c6 00 06	 mov	 BYTE PTR [rax], 6

; 436  :             break;

  00ba6	e9 13 0f 00 00	 jmp	 $LN2@cpuTick
$LN45@cpuTick:

; 437  :         }
; 438  :         case 0x60: // RTS - Return from subroutine
; 439  :         {
; 440  :             uint8 LowByte = PopStack(&Registers->StackPtr, MemoryOffset);

  00bab	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00bb0	48 83 c0 04	 add	 rax, 4
  00bb4	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00bb9	48 8b c8	 mov	 rcx, rax
  00bbc	e8 00 00 00 00	 call	 ?PopStack@@YAEPEAE_K@Z	; PopStack
  00bc1	88 84 24 b1 00
	00 00		 mov	 BYTE PTR LowByte$27[rsp], al

; 441  :             uint8 HighByte = PopStack(&Registers->StackPtr, MemoryOffset);

  00bc8	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00bcd	48 83 c0 04	 add	 rax, 4
  00bd1	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00bd6	48 8b c8	 mov	 rcx, rax
  00bd9	e8 00 00 00 00	 call	 ?PopStack@@YAEPEAE_K@Z	; PopStack
  00bde	88 84 24 b0 00
	00 00		 mov	 BYTE PTR HighByte$26[rsp], al

; 442  :             Registers->PrgCounter = (HighByte << 8) | LowByte; 

  00be5	0f b6 84 24 b0
	00 00 00	 movzx	 eax, BYTE PTR HighByte$26[rsp]
  00bed	c1 e0 08	 shl	 eax, 8
  00bf0	0f b6 8c 24 b1
	00 00 00	 movzx	 ecx, BYTE PTR LowByte$27[rsp]
  00bf8	0b c1		 or	 eax, ecx
  00bfa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  00bff	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 443  : 
; 444  :             BytesRead = 1;

  00c03	c6 44 24 60 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 445  :             *CyclesElapsed = 6;

  00c08	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00c10	c6 00 06	 mov	 BYTE PTR [rax], 6

; 446  :             break;

  00c13	e9 a6 0e 00 00	 jmp	 $LN2@cpuTick
$LN46@cpuTick:

; 447  :         }
; 448  :                     
; 449  :         case 0x4C: // JMP(Absolute) - Jump
; 450  :         {
; 451  :             uint16 NewAddress = readCpuMemory16(Registers->PrgCounter + 1, MemoryOffset);

  00c18	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00c1d	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00c21	ff c0		 inc	 eax
  00c23	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00c28	0f b7 c8	 movzx	 ecx, ax
  00c2b	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  00c30	66 89 84 24 00
	01 00 00	 mov	 WORD PTR NewAddress$67[rsp], ax

; 452  :             Registers->PrgCounter = NewAddress;

  00c38	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00c3d	0f b7 8c 24 00
	01 00 00	 movzx	 ecx, WORD PTR NewAddress$67[rsp]
  00c45	66 89 48 06	 mov	 WORD PTR [rax+6], cx

; 453  :             BytesRead = 0;

  00c49	c6 44 24 60 00	 mov	 BYTE PTR BytesRead$[rsp], 0

; 454  :             *CyclesElapsed = 3;

  00c4e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00c56	c6 00 03	 mov	 BYTE PTR [rax], 3

; 455  :             break;

  00c59	e9 60 0e 00 00	 jmp	 $LN2@cpuTick
$LN47@cpuTick:

; 456  :         }
; 457  :                     
; 458  :         case 0x29: // AND(Immediate) - Logical AND with value and A, stores in A
; 459  :         {
; 460  :             uint8 ByteValue = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  00c5e	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00c63	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00c67	ff c0		 inc	 eax
  00c69	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00c6e	0f b7 c8	 movzx	 ecx, ax
  00c71	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00c76	88 84 24 b2 00
	00 00		 mov	 BYTE PTR ByteValue$28[rsp], al

; 461  : 
; 462  :             uint8 ANDValue = Registers->A & ByteValue;

  00c7d	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00c82	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00c85	0f b6 8c 24 b2
	00 00 00	 movzx	 ecx, BYTE PTR ByteValue$28[rsp]
  00c8d	23 c1		 and	 eax, ecx
  00c8f	88 84 24 97 00
	00 00		 mov	 BYTE PTR ANDValue$11[rsp], al

; 463  : 
; 464  :             setNegative(ANDValue, &Registers->Flags);

  00c96	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00c9b	48 83 c0 03	 add	 rax, 3
  00c9f	48 8b d0	 mov	 rdx, rax
  00ca2	0f b6 8c 24 97
	00 00 00	 movzx	 ecx, BYTE PTR ANDValue$11[rsp]
  00caa	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 465  :             setZero(ANDValue, &Registers->Flags);

  00caf	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00cb4	48 83 c0 03	 add	 rax, 3
  00cb8	48 8b d0	 mov	 rdx, rax
  00cbb	0f b6 8c 24 97
	00 00 00	 movzx	 ecx, BYTE PTR ANDValue$11[rsp]
  00cc3	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 466  : 
; 467  :             Registers->A = ANDValue;

  00cc8	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00ccd	0f b6 8c 24 97
	00 00 00	 movzx	 ecx, BYTE PTR ANDValue$11[rsp]
  00cd5	88 08		 mov	 BYTE PTR [rax], cl

; 468  : 
; 469  :             BytesRead = 2;

  00cd7	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 470  :             *CyclesElapsed = 2;

  00cdc	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00ce4	c6 00 02	 mov	 BYTE PTR [rax], 2

; 471  :             break;

  00ce7	e9 d2 0d 00 00	 jmp	 $LN2@cpuTick
$LN48@cpuTick:

; 472  :         }
; 473  :         case 0x25: // AND(Zeropage)
; 474  :         {
; 475  :             uint8 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  00cec	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00cf1	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00cf5	ff c0		 inc	 eax
  00cf7	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00cfc	0f b7 c8	 movzx	 ecx, ax
  00cff	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00d04	88 84 24 b3 00
	00 00		 mov	 BYTE PTR Address$29[rsp], al

; 476  :             uint8 ByteValue = readCpuMemory8(Address, MemoryOffset);

  00d0b	0f b6 84 24 b3
	00 00 00	 movzx	 eax, BYTE PTR Address$29[rsp]
  00d13	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00d18	0f b7 c8	 movzx	 ecx, ax
  00d1b	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00d20	88 84 24 b4 00
	00 00		 mov	 BYTE PTR ByteValue$30[rsp], al

; 477  :             uint8 ANDValue = Registers->A & ByteValue;

  00d27	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00d2c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00d2f	0f b6 8c 24 b4
	00 00 00	 movzx	 ecx, BYTE PTR ByteValue$30[rsp]
  00d37	23 c1		 and	 eax, ecx
  00d39	88 84 24 98 00
	00 00		 mov	 BYTE PTR ANDValue$12[rsp], al

; 478  : 
; 479  :             setNegative(ANDValue, &Registers->Flags);

  00d40	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00d45	48 83 c0 03	 add	 rax, 3
  00d49	48 8b d0	 mov	 rdx, rax
  00d4c	0f b6 8c 24 98
	00 00 00	 movzx	 ecx, BYTE PTR ANDValue$12[rsp]
  00d54	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 480  :             setZero(ANDValue, &Registers->Flags);

  00d59	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00d5e	48 83 c0 03	 add	 rax, 3
  00d62	48 8b d0	 mov	 rdx, rax
  00d65	0f b6 8c 24 98
	00 00 00	 movzx	 ecx, BYTE PTR ANDValue$12[rsp]
  00d6d	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 481  : 
; 482  :             Registers->A = ANDValue;

  00d72	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00d77	0f b6 8c 24 98
	00 00 00	 movzx	 ecx, BYTE PTR ANDValue$12[rsp]
  00d7f	88 08		 mov	 BYTE PTR [rax], cl

; 483  : 
; 484  :             BytesRead = 2;

  00d81	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 485  :             *CyclesElapsed = 3;

  00d86	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00d8e	c6 00 03	 mov	 BYTE PTR [rax], 3

; 486  :             break;

  00d91	e9 28 0d 00 00	 jmp	 $LN2@cpuTick
$LN49@cpuTick:

; 487  :         }
; 488  :                     
; 489  :         case 0xA8: // TAY - Transfer A to Y
; 490  :         {
; 491  :             Registers->Y = Registers->A;

  00d96	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00d9b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  00da0	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00da3	88 48 02	 mov	 BYTE PTR [rax+2], cl

; 492  :             
; 493  :             setNegative(Registers->A, &Registers->Flags);

  00da6	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00dab	48 83 c0 03	 add	 rax, 3
  00daf	48 8b d0	 mov	 rdx, rax
  00db2	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00db7	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00dba	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 494  :             setZero(Registers->A, &Registers->Flags);

  00dbf	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00dc4	48 83 c0 03	 add	 rax, 3
  00dc8	48 8b d0	 mov	 rdx, rax
  00dcb	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00dd0	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00dd3	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 495  :             
; 496  :             BytesRead = 1;

  00dd8	c6 44 24 60 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 497  :             *CyclesElapsed = 2;

  00ddd	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00de5	c6 00 02	 mov	 BYTE PTR [rax], 2

; 498  :             break;

  00de8	e9 d1 0c 00 00	 jmp	 $LN2@cpuTick
$LN50@cpuTick:

; 499  :         }
; 500  :         case 0x98: // TYA - Transfer Y to A
; 501  :         {
; 502  :             Registers->A = Registers->Y;

  00ded	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00df2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  00df7	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  00dfb	88 08		 mov	 BYTE PTR [rax], cl

; 503  :             
; 504  :             setNegative(Registers->A, &Registers->Flags);

  00dfd	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00e02	48 83 c0 03	 add	 rax, 3
  00e06	48 8b d0	 mov	 rdx, rax
  00e09	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00e0e	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00e11	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 505  :             setZero(Registers->A, &Registers->Flags);

  00e16	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00e1b	48 83 c0 03	 add	 rax, 3
  00e1f	48 8b d0	 mov	 rdx, rax
  00e22	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00e27	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00e2a	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 506  :             
; 507  :             BytesRead = 1;

  00e2f	c6 44 24 60 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 508  :             *CyclesElapsed = 2;

  00e34	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00e3c	c6 00 02	 mov	 BYTE PTR [rax], 2

; 509  :             break;

  00e3f	e9 7a 0c 00 00	 jmp	 $LN2@cpuTick
$LN51@cpuTick:

; 510  :         }
; 511  : 
; 512  :         case 0x8D: case 0x91: case 0x99: case 0x85: // STA - Store A in Memory
; 513  :         {
; 514  :             uint16 Address = {};

  00e44	33 c0		 xor	 eax, eax
  00e46	66 89 84 24 a0
	00 00 00	 mov	 WORD PTR Address$17[rsp], ax

; 515  :             if(CurrentInstr == 0x8D) // Absolute

  00e4e	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00e53	3d 8d 00 00 00	 cmp	 eax, 141		; 0000008dH
  00e58	75 35		 jne	 SHORT $LN52@cpuTick

; 516  :             {
; 517  :                 Address = readCpuMemory16(Registers->PrgCounter + 1, MemoryOffset);

  00e5a	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00e5f	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00e63	ff c0		 inc	 eax
  00e65	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00e6a	0f b7 c8	 movzx	 ecx, ax
  00e6d	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  00e72	66 89 84 24 a0
	00 00 00	 mov	 WORD PTR Address$17[rsp], ax

; 518  :                 BytesRead = 3;

  00e7a	c6 44 24 60 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 519  :                 *CyclesElapsed = 4;

  00e7f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00e87	c6 00 04	 mov	 BYTE PTR [rax], 4
  00e8a	e9 0e 01 00 00	 jmp	 $LN53@cpuTick
$LN52@cpuTick:

; 520  :             }
; 521  :             else if(CurrentInstr == 0x91) // (Indirect), Y

  00e8f	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00e94	3d 91 00 00 00	 cmp	 eax, 145		; 00000091H
  00e99	75 6c		 jne	 SHORT $LN54@cpuTick

; 522  :             {
; 523  :                 uint8 ZeroAddress = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset); 

  00e9b	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00ea0	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00ea4	ff c0		 inc	 eax
  00ea6	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00eab	0f b7 c8	 movzx	 ecx, ax
  00eae	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00eb3	88 84 24 b5 00
	00 00		 mov	 BYTE PTR ZeroAddress$31[rsp], al

; 524  :                 uint16 IndirectAddress = readCpuMemory16(ZeroAddress, MemoryOffset);

  00eba	0f b6 84 24 b5
	00 00 00	 movzx	 eax, BYTE PTR ZeroAddress$31[rsp]
  00ec2	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00ec7	0f b7 c8	 movzx	 ecx, ax
  00eca	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  00ecf	66 89 84 24 04
	01 00 00	 mov	 WORD PTR IndirectAddress$68[rsp], ax

; 525  :                 Address = IndirectAddress + Registers->Y;

  00ed7	0f b7 84 24 04
	01 00 00	 movzx	 eax, WORD PTR IndirectAddress$68[rsp]
  00edf	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  00ee4	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  00ee8	03 c1		 add	 eax, ecx
  00eea	66 89 84 24 a0
	00 00 00	 mov	 WORD PTR Address$17[rsp], ax

; 526  :                 BytesRead = 2;

  00ef2	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 527  :                 *CyclesElapsed = 6; // TODO: Check timing on this           

  00ef7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00eff	c6 00 06	 mov	 BYTE PTR [rax], 6
  00f02	e9 96 00 00 00	 jmp	 $LN55@cpuTick
$LN54@cpuTick:

; 528  :             }
; 529  :             else if(CurrentInstr == 0x99) // Absolute, Y

  00f07	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00f0c	3d 99 00 00 00	 cmp	 eax, 153		; 00000099H
  00f11	75 4f		 jne	 SHORT $LN56@cpuTick

; 530  :             {
; 531  :                 Address = readCpuMemory16(Registers->PrgCounter + 1, MemoryOffset); 

  00f13	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00f18	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00f1c	ff c0		 inc	 eax
  00f1e	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00f23	0f b7 c8	 movzx	 ecx, ax
  00f26	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  00f2b	66 89 84 24 a0
	00 00 00	 mov	 WORD PTR Address$17[rsp], ax

; 532  :                 Address += Registers->Y;

  00f33	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00f38	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00f3c	0f b7 8c 24 a0
	00 00 00	 movzx	 ecx, WORD PTR Address$17[rsp]
  00f44	03 c8		 add	 ecx, eax
  00f46	8b c1		 mov	 eax, ecx
  00f48	66 89 84 24 a0
	00 00 00	 mov	 WORD PTR Address$17[rsp], ax

; 533  :                 BytesRead = 3;

  00f50	c6 44 24 60 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 534  :                 *CyclesElapsed = 4; // TODO: Check timing on this

  00f55	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00f5d	c6 00 04	 mov	 BYTE PTR [rax], 4
  00f60	eb 3b		 jmp	 SHORT $LN57@cpuTick
$LN56@cpuTick:

; 535  :             }
; 536  :             else if(CurrentInstr == 0x85) // Zero Page

  00f62	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  00f67	3d 85 00 00 00	 cmp	 eax, 133		; 00000085H
  00f6c	75 2f		 jne	 SHORT $LN58@cpuTick

; 537  :             {
; 538  :                 uint8 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  00f6e	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00f73	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00f77	ff c0		 inc	 eax
  00f79	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00f7e	0f b7 c8	 movzx	 ecx, ax
  00f81	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00f86	88 84 24 18 01
	00 00		 mov	 BYTE PTR Address$73[rsp], al

; 539  :                 BytesRead = 2;

  00f8d	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 540  :                 *CyclesElapsed = 3;

  00f92	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  00f9a	c6 00 03	 mov	 BYTE PTR [rax], 3
$LN58@cpuTick:
$LN57@cpuTick:
$LN55@cpuTick:
$LN53@cpuTick:

; 541  :             }
; 542  :             writeCpuMemory8(Registers->A, Address, MemoryOffset);

  00f9d	4c 8b 44 24 78	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  00fa2	0f b7 94 24 a0
	00 00 00	 movzx	 edx, WORD PTR Address$17[rsp]
  00faa	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00faf	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00fb2	e8 00 00 00 00	 call	 ?writeCpuMemory8@@YAXEG_K@Z ; writeCpuMemory8

; 543  :             break;

  00fb7	e9 02 0b 00 00	 jmp	 $LN2@cpuTick
$LN59@cpuTick:

; 544  :         }
; 545  :       
; 546  :         
; 547  :         case 0x8E: // STX(Absolute) - store x in memory
; 548  :         {
; 549  :             uint16 Address = readCpuMemory16(Registers->PrgCounter + 1, MemoryOffset);

  00fbc	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00fc1	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00fc5	ff c0		 inc	 eax
  00fc7	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00fcc	0f b7 c8	 movzx	 ecx, ax
  00fcf	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  00fd4	66 89 84 24 08
	01 00 00	 mov	 WORD PTR Address$69[rsp], ax

; 550  :                         
; 551  :             writeCpuMemory8(Registers->X, Address, MemoryOffset);

  00fdc	4c 8b 44 24 78	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  00fe1	0f b7 94 24 08
	01 00 00	 movzx	 edx, WORD PTR Address$69[rsp]
  00fe9	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  00fee	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00ff2	e8 00 00 00 00	 call	 ?writeCpuMemory8@@YAXEG_K@Z ; writeCpuMemory8

; 552  :             BytesRead = 3;

  00ff7	c6 44 24 60 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 553  :             *CyclesElapsed = 4;

  00ffc	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01004	c6 00 04	 mov	 BYTE PTR [rax], 4

; 554  :             break;

  01007	e9 b2 0a 00 00	 jmp	 $LN2@cpuTick
$LN60@cpuTick:

; 555  :         }
; 556  : 
; 557  :         case 0x84: // STY(ZeroPage) - Store Y in memory
; 558  :         {
; 559  :             uint8 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  0100c	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01011	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  01015	ff c0		 inc	 eax
  01017	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0101c	0f b7 c8	 movzx	 ecx, ax
  0101f	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  01024	88 84 24 b6 00
	00 00		 mov	 BYTE PTR Address$32[rsp], al

; 560  :             writeCpuMemory8(Registers->Y, Address, MemoryOffset);

  0102b	0f b6 84 24 b6
	00 00 00	 movzx	 eax, BYTE PTR Address$32[rsp]
  01033	4c 8b 44 24 78	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  01038	0f b7 d0	 movzx	 edx, ax
  0103b	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01040	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  01044	e8 00 00 00 00	 call	 ?writeCpuMemory8@@YAXEG_K@Z ; writeCpuMemory8

; 561  :             BytesRead = 2;

  01049	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 562  :             *CyclesElapsed = 3;

  0104e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01056	c6 00 03	 mov	 BYTE PTR [rax], 3

; 563  :             break;

  01059	e9 60 0a 00 00	 jmp	 $LN2@cpuTick
$LN61@cpuTick:

; 564  :         }
; 565  :         
; 566  :         case 0xA0: // LDY(Immediate) - load y
; 567  :         {
; 568  :             uint8 Value = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  0105e	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01063	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  01067	ff c0		 inc	 eax
  01069	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0106e	0f b7 c8	 movzx	 ecx, ax
  01071	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  01076	88 84 24 99 00
	00 00		 mov	 BYTE PTR Value$13[rsp], al

; 569  :             Registers->Y = Value;

  0107d	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01082	0f b6 8c 24 99
	00 00 00	 movzx	 ecx, BYTE PTR Value$13[rsp]
  0108a	88 48 02	 mov	 BYTE PTR [rax+2], cl

; 570  : 
; 571  :             setNegative(Value, &Registers->Flags);

  0108d	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01092	48 83 c0 03	 add	 rax, 3
  01096	48 8b d0	 mov	 rdx, rax
  01099	0f b6 8c 24 99
	00 00 00	 movzx	 ecx, BYTE PTR Value$13[rsp]
  010a1	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 572  :             setZero(Value, &Registers->Flags);

  010a6	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  010ab	48 83 c0 03	 add	 rax, 3
  010af	48 8b d0	 mov	 rdx, rax
  010b2	0f b6 8c 24 99
	00 00 00	 movzx	 ecx, BYTE PTR Value$13[rsp]
  010ba	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 573  :             BytesRead = 2;

  010bf	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 574  :             *CyclesElapsed = 2;

  010c4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  010cc	c6 00 02	 mov	 BYTE PTR [rax], 2

; 575  :             
; 576  :             break;

  010cf	e9 ea 09 00 00	 jmp	 $LN2@cpuTick
$LN62@cpuTick:

; 577  :         }
; 578  :         case 0xA4: // LDY(ZeroPage)
; 579  :         {
; 580  :             uint8 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  010d4	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  010d9	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  010dd	ff c0		 inc	 eax
  010df	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  010e4	0f b7 c8	 movzx	 ecx, ax
  010e7	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  010ec	88 84 24 b7 00
	00 00		 mov	 BYTE PTR Address$33[rsp], al

; 581  :             uint8 Value = readCpuMemory8(Address, MemoryOffset);

  010f3	0f b6 84 24 b7
	00 00 00	 movzx	 eax, BYTE PTR Address$33[rsp]
  010fb	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01100	0f b7 c8	 movzx	 ecx, ax
  01103	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  01108	88 84 24 9a 00
	00 00		 mov	 BYTE PTR Value$14[rsp], al

; 582  :             Registers->Y = Value;

  0110f	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01114	0f b6 8c 24 9a
	00 00 00	 movzx	 ecx, BYTE PTR Value$14[rsp]
  0111c	88 48 02	 mov	 BYTE PTR [rax+2], cl

; 583  : 
; 584  :             setNegative(Value, &Registers->Flags);

  0111f	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01124	48 83 c0 03	 add	 rax, 3
  01128	48 8b d0	 mov	 rdx, rax
  0112b	0f b6 8c 24 9a
	00 00 00	 movzx	 ecx, BYTE PTR Value$14[rsp]
  01133	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 585  :             setZero(Value, &Registers->Flags);

  01138	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0113d	48 83 c0 03	 add	 rax, 3
  01141	48 8b d0	 mov	 rdx, rax
  01144	0f b6 8c 24 9a
	00 00 00	 movzx	 ecx, BYTE PTR Value$14[rsp]
  0114c	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 586  :             
; 587  :             BytesRead = 2;

  01151	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 588  :             *CyclesElapsed = 3;

  01156	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  0115e	c6 00 03	 mov	 BYTE PTR [rax], 3

; 589  :             break;

  01161	e9 58 09 00 00	 jmp	 $LN2@cpuTick
$LN63@cpuTick:

; 590  :         }
; 591  :         
; 592  :         case 0xA6: // LDX(ZeroPage)
; 593  :         {
; 594  :             uint8 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  01166	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0116b	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0116f	ff c0		 inc	 eax
  01171	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01176	0f b7 c8	 movzx	 ecx, ax
  01179	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  0117e	88 84 24 b8 00
	00 00		 mov	 BYTE PTR Address$34[rsp], al

; 595  :             uint8 Value = readCpuMemory8(Address, MemoryOffset);

  01185	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR Address$34[rsp]
  0118d	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01192	0f b7 c8	 movzx	 ecx, ax
  01195	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  0119a	88 84 24 9b 00
	00 00		 mov	 BYTE PTR Value$15[rsp], al

; 596  :             Registers->X = Value;

  011a1	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  011a6	0f b6 8c 24 9b
	00 00 00	 movzx	 ecx, BYTE PTR Value$15[rsp]
  011ae	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 597  : 
; 598  :             setNegative(Value, &Registers->Flags);

  011b1	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  011b6	48 83 c0 03	 add	 rax, 3
  011ba	48 8b d0	 mov	 rdx, rax
  011bd	0f b6 8c 24 9b
	00 00 00	 movzx	 ecx, BYTE PTR Value$15[rsp]
  011c5	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 599  :             setZero(Value, &Registers->Flags);

  011ca	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  011cf	48 83 c0 03	 add	 rax, 3
  011d3	48 8b d0	 mov	 rdx, rax
  011d6	0f b6 8c 24 9b
	00 00 00	 movzx	 ecx, BYTE PTR Value$15[rsp]
  011de	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 600  :             
; 601  :             BytesRead = 2;

  011e3	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 602  :             *CyclesElapsed = 3;

  011e8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  011f0	c6 00 03	 mov	 BYTE PTR [rax], 3

; 603  :             break;

  011f3	e9 c6 08 00 00	 jmp	 $LN2@cpuTick
$LN64@cpuTick:

; 604  :         }
; 605  :         
; 606  :         case 0x9A: // TXS - Transfer X to Stack Pointer
; 607  :         {
; 608  :             uint8 Value = Registers->X;

  011f8	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  011fd	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  01201	88 84 24 9c 00
	00 00		 mov	 BYTE PTR Value$16[rsp], al

; 609  :             setNegative(Value, &Registers->Flags);

  01208	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0120d	48 83 c0 03	 add	 rax, 3
  01211	48 8b d0	 mov	 rdx, rax
  01214	0f b6 8c 24 9c
	00 00 00	 movzx	 ecx, BYTE PTR Value$16[rsp]
  0121c	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 610  :             setZero(Value, &Registers->Flags);

  01221	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01226	48 83 c0 03	 add	 rax, 3
  0122a	48 8b d0	 mov	 rdx, rax
  0122d	0f b6 8c 24 9c
	00 00 00	 movzx	 ecx, BYTE PTR Value$16[rsp]
  01235	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 611  :             Registers->StackPtr = Value;

  0123a	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0123f	0f b6 8c 24 9c
	00 00 00	 movzx	 ecx, BYTE PTR Value$16[rsp]
  01247	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 612  :             BytesRead = 1;

  0124a	c6 44 24 60 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 613  :             *CyclesElapsed = 2;

  0124f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01257	c6 00 02	 mov	 BYTE PTR [rax], 2

; 614  :             break;

  0125a	e9 5f 08 00 00	 jmp	 $LN2@cpuTick
$LN65@cpuTick:

; 615  :         }
; 616  :         case 0x8A: // TXA - Transfer X to A
; 617  :         {
; 618  :             Registers->A = Registers->X;

  0125f	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01264	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  01269	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0126d	88 08		 mov	 BYTE PTR [rax], cl

; 619  :             BytesRead = 1;

  0126f	c6 44 24 60 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 620  :             *CyclesElapsed = 2;

  01274	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  0127c	c6 00 02	 mov	 BYTE PTR [rax], 2

; 621  :             break;

  0127f	e9 3a 08 00 00	 jmp	 $LN2@cpuTick
$LN66@cpuTick:

; 622  :         }
; 623  :         case 0xAA: // TAX - Transfer A to X
; 624  :         {
; 625  :             Registers->X = Registers->A;

  01284	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01289	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  0128e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01291	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 626  :             BytesRead = 1;

  01294	c6 44 24 60 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 627  :             *CyclesElapsed = 2;

  01299	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  012a1	c6 00 02	 mov	 BYTE PTR [rax], 2

; 628  :             break;

  012a4	e9 15 08 00 00	 jmp	 $LN2@cpuTick
$LN67@cpuTick:

; 629  :         }
; 630  : 
; 631  :         case 0x48: // PHA - Push accumulator on stack
; 632  :         {
; 633  :             PushStack(Registers->A, &Registers->StackPtr, MemoryOffset);

  012a9	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  012ae	48 83 c0 04	 add	 rax, 4
  012b2	4c 8b 44 24 78	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  012b7	48 8b d0	 mov	 rdx, rax
  012ba	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  012bf	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  012c2	e8 00 00 00 00	 call	 ?PushStack@@YAXEPEAE_K@Z ; PushStack

; 634  :             BytesRead = 1;

  012c7	c6 44 24 60 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 635  :             *CyclesElapsed = 3;

  012cc	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  012d4	c6 00 03	 mov	 BYTE PTR [rax], 3

; 636  :             break;

  012d7	e9 e2 07 00 00	 jmp	 $LN2@cpuTick
$LN68@cpuTick:

; 637  :         }
; 638  :         case 0x68: // PLA - Pop to accumulator
; 639  :         {
; 640  :             Registers->A = PopStack(&Registers->StackPtr, MemoryOffset);

  012dc	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  012e1	48 83 c0 04	 add	 rax, 4
  012e5	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  012ea	48 8b c8	 mov	 rcx, rax
  012ed	e8 00 00 00 00	 call	 ?PopStack@@YAEPEAE_K@Z	; PopStack
  012f2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  012f7	88 01		 mov	 BYTE PTR [rcx], al

; 641  :             BytesRead = 1;

  012f9	c6 44 24 60 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 642  :             *CyclesElapsed = 4;

  012fe	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01306	c6 00 04	 mov	 BYTE PTR [rax], 4

; 643  :             break;

  01309	e9 b0 07 00 00	 jmp	 $LN2@cpuTick
$LN69@cpuTick:

; 644  :         }
; 645  :         
; 646  :         case 0xCA: // DEX - Decrement X by one
; 647  :         {
; 648  :             Registers->X -= 1;

  0130e	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01313	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  01317	ff c8		 dec	 eax
  01319	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  0131e	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 649  :             setNegative(Registers->X, &Registers->Flags);

  01321	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01326	48 83 c0 03	 add	 rax, 3
  0132a	48 8b d0	 mov	 rdx, rax
  0132d	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01332	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  01336	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 650  :             setZero(Registers->X, &Registers->Flags);

  0133b	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01340	48 83 c0 03	 add	 rax, 3
  01344	48 8b d0	 mov	 rdx, rax
  01347	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0134c	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  01350	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 651  :             BytesRead = 1;

  01355	c6 44 24 60 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 652  :             *CyclesElapsed = 2;

  0135a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01362	c6 00 02	 mov	 BYTE PTR [rax], 2

; 653  :             break;

  01365	e9 54 07 00 00	 jmp	 $LN2@cpuTick
$LN70@cpuTick:

; 654  :         }
; 655  :         case 0x88: // DEY - Decrement Y
; 656  :         {
; 657  :             Registers->Y -= 1;

  0136a	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0136f	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  01373	ff c8		 dec	 eax
  01375	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  0137a	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 658  :             setNegative(Registers->Y, &Registers->Flags);

  0137d	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01382	48 83 c0 03	 add	 rax, 3
  01386	48 8b d0	 mov	 rdx, rax
  01389	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0138e	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  01392	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 659  :             setZero(Registers->Y, &Registers->Flags);

  01397	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0139c	48 83 c0 03	 add	 rax, 3
  013a0	48 8b d0	 mov	 rdx, rax
  013a3	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  013a8	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  013ac	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 660  :             BytesRead = 1;

  013b1	c6 44 24 60 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 661  :             *CyclesElapsed = 2;

  013b6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  013be	c6 00 02	 mov	 BYTE PTR [rax], 2

; 662  :             break;

  013c1	e9 f8 06 00 00	 jmp	 $LN2@cpuTick
$LN71@cpuTick:

; 663  :         }
; 664  :         case 0xE8: // INX - increment X
; 665  :         {
; 666  :             Registers->X += 1;

  013c6	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  013cb	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  013cf	ff c0		 inc	 eax
  013d1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  013d6	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 667  :             setNegative(Registers->X, &Registers->Flags);

  013d9	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  013de	48 83 c0 03	 add	 rax, 3
  013e2	48 8b d0	 mov	 rdx, rax
  013e5	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  013ea	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  013ee	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 668  :             setZero(Registers->X, &Registers->Flags);

  013f3	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  013f8	48 83 c0 03	 add	 rax, 3
  013fc	48 8b d0	 mov	 rdx, rax
  013ff	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01404	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  01408	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 669  :             BytesRead = 1;

  0140d	c6 44 24 60 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 670  :             *CyclesElapsed = 2;

  01412	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  0141a	c6 00 02	 mov	 BYTE PTR [rax], 2

; 671  :             break;

  0141d	e9 9c 06 00 00	 jmp	 $LN2@cpuTick
$LN72@cpuTick:

; 672  :         }
; 673  :         case 0xC8: // INX - increment X
; 674  :         {
; 675  :             Registers->Y += 1;

  01422	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01427	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0142b	ff c0		 inc	 eax
  0142d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  01432	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 676  :             setNegative(Registers->Y, &Registers->Flags);

  01435	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0143a	48 83 c0 03	 add	 rax, 3
  0143e	48 8b d0	 mov	 rdx, rax
  01441	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01446	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  0144a	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 677  :             setZero(Registers->Y, &Registers->Flags);

  0144f	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01454	48 83 c0 03	 add	 rax, 3
  01458	48 8b d0	 mov	 rdx, rax
  0145b	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01460	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  01464	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 678  :             BytesRead = 1;

  01469	c6 44 24 60 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 679  :             *CyclesElapsed = 2;

  0146e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01476	c6 00 02	 mov	 BYTE PTR [rax], 2

; 680  :             break;

  01479	e9 40 06 00 00	 jmp	 $LN2@cpuTick
$LN73@cpuTick:

; 681  :         }
; 682  :         case 0xE6: // INC(ZeroPage) - increment Memory
; 683  :         {
; 684  :             uint8 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  0147e	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01483	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  01487	ff c0		 inc	 eax
  01489	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0148e	0f b7 c8	 movzx	 ecx, ax
  01491	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  01496	88 84 24 a5 00
	00 00		 mov	 BYTE PTR Address$19[rsp], al

; 685  :             uint8 Value = readCpuMemory8(Address, MemoryOffset);

  0149d	0f b6 84 24 a5
	00 00 00	 movzx	 eax, BYTE PTR Address$19[rsp]
  014a5	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  014aa	0f b7 c8	 movzx	 ecx, ax
  014ad	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  014b2	88 84 24 92 00
	00 00		 mov	 BYTE PTR Value$6[rsp], al

; 686  :             Value++;

  014b9	0f b6 84 24 92
	00 00 00	 movzx	 eax, BYTE PTR Value$6[rsp]
  014c1	fe c0		 inc	 al
  014c3	88 84 24 92 00
	00 00		 mov	 BYTE PTR Value$6[rsp], al

; 687  :             writeCpuMemory8(Value, Address, MemoryOffset);

  014ca	0f b6 84 24 a5
	00 00 00	 movzx	 eax, BYTE PTR Address$19[rsp]
  014d2	4c 8b 44 24 78	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  014d7	0f b7 d0	 movzx	 edx, ax
  014da	0f b6 8c 24 92
	00 00 00	 movzx	 ecx, BYTE PTR Value$6[rsp]
  014e2	e8 00 00 00 00	 call	 ?writeCpuMemory8@@YAXEG_K@Z ; writeCpuMemory8

; 688  :             
; 689  :             setNegative(Value, &Registers->Flags);

  014e7	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  014ec	48 83 c0 03	 add	 rax, 3
  014f0	48 8b d0	 mov	 rdx, rax
  014f3	0f b6 8c 24 92
	00 00 00	 movzx	 ecx, BYTE PTR Value$6[rsp]
  014fb	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 690  :             setZero(Value, &Registers->Flags);

  01500	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01505	48 83 c0 03	 add	 rax, 3
  01509	48 8b d0	 mov	 rdx, rax
  0150c	0f b6 8c 24 92
	00 00 00	 movzx	 ecx, BYTE PTR Value$6[rsp]
  01514	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 691  :             BytesRead = 2;

  01519	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 692  :             *CyclesElapsed = 5;

  0151e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01526	c6 00 05	 mov	 BYTE PTR [rax], 5

; 693  :             
; 694  :             break;

  01529	e9 90 05 00 00	 jmp	 $LN2@cpuTick
$LN74@cpuTick:

; 695  :         }
; 696  :             
; 697  :         case 0xC6: // DEC(ZeroPage) - Decrement Memory
; 698  :         {
; 699  :             uint8 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  0152e	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01533	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  01537	ff c0		 inc	 eax
  01539	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0153e	0f b7 c8	 movzx	 ecx, ax
  01541	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  01546	88 84 24 a6 00
	00 00		 mov	 BYTE PTR Address$20[rsp], al

; 700  :             uint8 Value = readCpuMemory8(Address, MemoryOffset);

  0154d	0f b6 84 24 a6
	00 00 00	 movzx	 eax, BYTE PTR Address$20[rsp]
  01555	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0155a	0f b7 c8	 movzx	 ecx, ax
  0155d	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  01562	88 84 24 93 00
	00 00		 mov	 BYTE PTR Value$7[rsp], al

; 701  :             Value -= 1;

  01569	0f b6 84 24 93
	00 00 00	 movzx	 eax, BYTE PTR Value$7[rsp]
  01571	ff c8		 dec	 eax
  01573	88 84 24 93 00
	00 00		 mov	 BYTE PTR Value$7[rsp], al

; 702  :             writeCpuMemory8(Value, Address, MemoryOffset);

  0157a	0f b6 84 24 a6
	00 00 00	 movzx	 eax, BYTE PTR Address$20[rsp]
  01582	4c 8b 44 24 78	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  01587	0f b7 d0	 movzx	 edx, ax
  0158a	0f b6 8c 24 93
	00 00 00	 movzx	 ecx, BYTE PTR Value$7[rsp]
  01592	e8 00 00 00 00	 call	 ?writeCpuMemory8@@YAXEG_K@Z ; writeCpuMemory8

; 703  : 
; 704  :             setNegative(Value, &Registers->Flags);

  01597	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0159c	48 83 c0 03	 add	 rax, 3
  015a0	48 8b d0	 mov	 rdx, rax
  015a3	0f b6 8c 24 93
	00 00 00	 movzx	 ecx, BYTE PTR Value$7[rsp]
  015ab	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 705  :             setZero(Value, &Registers->Flags);

  015b0	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  015b5	48 83 c0 03	 add	 rax, 3
  015b9	48 8b d0	 mov	 rdx, rax
  015bc	0f b6 8c 24 93
	00 00 00	 movzx	 ecx, BYTE PTR Value$7[rsp]
  015c4	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 706  : 
; 707  :             BytesRead = 2;

  015c9	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 708  :             *CyclesElapsed = 5;

  015ce	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  015d6	c6 00 05	 mov	 BYTE PTR [rax], 5

; 709  :             break;

  015d9	e9 e0 04 00 00	 jmp	 $LN2@cpuTick
$LN75@cpuTick:

; 710  :         }
; 711  : 
; 712  :         case 0xC5: case 0xC9: case 0xD9:
; 713  :         {
; 714  :             uint8 Value = {};

  015de	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR Value$8[rsp], 0

; 715  :             if(CurrentInstr == 0xC5) // Zero Page

  015e6	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  015eb	3d c5 00 00 00	 cmp	 eax, 197		; 000000c5H
  015f0	75 50		 jne	 SHORT $LN76@cpuTick

; 716  :             {
; 717  :                 uint8 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  015f2	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  015f7	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  015fb	ff c0		 inc	 eax
  015fd	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01602	0f b7 c8	 movzx	 ecx, ax
  01605	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  0160a	88 84 24 b9 00
	00 00		 mov	 BYTE PTR Address$35[rsp], al

; 718  :                 Value = readCpuMemory8(Address, MemoryOffset);

  01611	0f b6 84 24 b9
	00 00 00	 movzx	 eax, BYTE PTR Address$35[rsp]
  01619	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0161e	0f b7 c8	 movzx	 ecx, ax
  01621	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  01626	88 84 24 94 00
	00 00		 mov	 BYTE PTR Value$8[rsp], al

; 719  :                 BytesRead = 2;

  0162d	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 720  :                 *CyclesElapsed = 3;

  01632	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  0163a	c6 00 03	 mov	 BYTE PTR [rax], 3
  0163d	e9 af 00 00 00	 jmp	 $LN77@cpuTick
$LN76@cpuTick:

; 721  :             }
; 722  :             else if(CurrentInstr == 0xC9) // Immediate

  01642	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01647	3d c9 00 00 00	 cmp	 eax, 201		; 000000c9H
  0164c	75 31		 jne	 SHORT $LN78@cpuTick

; 723  :             {
; 724  :                 Value = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  0164e	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01653	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  01657	ff c0		 inc	 eax
  01659	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0165e	0f b7 c8	 movzx	 ecx, ax
  01661	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  01666	88 84 24 94 00
	00 00		 mov	 BYTE PTR Value$8[rsp], al

; 725  :                 BytesRead = 2;

  0166d	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 726  :                 *CyclesElapsed = 2;

  01672	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  0167a	c6 00 02	 mov	 BYTE PTR [rax], 2
  0167d	eb 72		 jmp	 SHORT $LN79@cpuTick
$LN78@cpuTick:

; 727  :             }
; 728  :             else if(CurrentInstr == 0xD9) // Absolute, Y

  0167f	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01684	3d d9 00 00 00	 cmp	 eax, 217		; 000000d9H
  01689	75 66		 jne	 SHORT $LN80@cpuTick

; 729  :             {
; 730  :                 uint16 Address = readCpuMemory16(Registers->PrgCounter + 1, MemoryOffset);

  0168b	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01690	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  01694	ff c0		 inc	 eax
  01696	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0169b	0f b7 c8	 movzx	 ecx, ax
  0169e	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  016a3	66 89 84 24 cc
	00 00 00	 mov	 WORD PTR Address$52[rsp], ax

; 731  :                 Address += Registers->Y;

  016ab	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  016b0	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  016b4	0f b7 8c 24 cc
	00 00 00	 movzx	 ecx, WORD PTR Address$52[rsp]
  016bc	03 c8		 add	 ecx, eax
  016be	8b c1		 mov	 eax, ecx
  016c0	66 89 84 24 cc
	00 00 00	 mov	 WORD PTR Address$52[rsp], ax

; 732  :                 Value = readCpuMemory8(Address, MemoryOffset);

  016c8	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  016cd	0f b7 8c 24 cc
	00 00 00	 movzx	 ecx, WORD PTR Address$52[rsp]
  016d5	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  016da	88 84 24 94 00
	00 00		 mov	 BYTE PTR Value$8[rsp], al

; 733  :                 BytesRead = 3;

  016e1	c6 44 24 60 03	 mov	 BYTE PTR BytesRead$[rsp], 3

; 734  :                 *CyclesElapsed = 4; // TODO: **

  016e6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  016ee	c6 00 04	 mov	 BYTE PTR [rax], 4
$LN80@cpuTick:
$LN79@cpuTick:
$LN77@cpuTick:

; 735  :             }
; 736  : 
; 737  :             cmp(Value, Registers->A, &Registers->Flags);

  016f1	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  016f6	48 83 c0 03	 add	 rax, 3
  016fa	4c 8b c0	 mov	 r8, rax
  016fd	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01702	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  01705	0f b6 8c 24 94
	00 00 00	 movzx	 ecx, BYTE PTR Value$8[rsp]
  0170d	e8 00 00 00 00	 call	 ?cmp@@YAXEEPEAE@Z	; cmp

; 738  : 
; 739  :             break;

  01712	e9 a7 03 00 00	 jmp	 $LN2@cpuTick
$LN81@cpuTick:

; 740  :         }
; 741  : 
; 742  :         case 0xE0: // CPX(Immediate) - Compare against X
; 743  :         {
; 744  :             uint8 Value = readCpuMemory8(Registers->PrgCounter+1, MemoryOffset);

  01717	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0171c	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  01720	ff c0		 inc	 eax
  01722	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01727	0f b7 c8	 movzx	 ecx, ax
  0172a	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  0172f	88 84 24 ba 00
	00 00		 mov	 BYTE PTR Value$36[rsp], al

; 745  : 
; 746  :             cmp(Value, Registers->X, &Registers->Flags);

  01736	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0173b	48 83 c0 03	 add	 rax, 3
  0173f	4c 8b c0	 mov	 r8, rax
  01742	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01747	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  0174b	0f b6 8c 24 ba
	00 00 00	 movzx	 ecx, BYTE PTR Value$36[rsp]
  01753	e8 00 00 00 00	 call	 ?cmp@@YAXEEPEAE@Z	; cmp

; 747  :             
; 748  :             BytesRead = 2;

  01758	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 749  :             *CyclesElapsed = 2;

  0175d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01765	c6 00 02	 mov	 BYTE PTR [rax], 2

; 750  :             break;

  01768	e9 51 03 00 00	 jmp	 $LN2@cpuTick
$LN82@cpuTick:

; 751  :         }
; 752  :         case 0xE4: // CPX(ZeroPage) - Compare against X
; 753  :         {
; 754  :             uint8 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  0176d	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01772	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  01776	ff c0		 inc	 eax
  01778	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0177d	0f b7 c8	 movzx	 ecx, ax
  01780	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  01785	88 84 24 bb 00
	00 00		 mov	 BYTE PTR Address$37[rsp], al

; 755  :             uint8 Value = readCpuMemory8(Address, MemoryOffset);

  0178c	0f b6 84 24 bb
	00 00 00	 movzx	 eax, BYTE PTR Address$37[rsp]
  01794	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01799	0f b7 c8	 movzx	 ecx, ax
  0179c	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  017a1	88 84 24 bc 00
	00 00		 mov	 BYTE PTR Value$38[rsp], al

; 756  : 
; 757  :             cmp(Value, Registers->X, &Registers->Flags);

  017a8	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  017ad	48 83 c0 03	 add	 rax, 3
  017b1	4c 8b c0	 mov	 r8, rax
  017b4	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  017b9	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  017bd	0f b6 8c 24 bc
	00 00 00	 movzx	 ecx, BYTE PTR Value$38[rsp]
  017c5	e8 00 00 00 00	 call	 ?cmp@@YAXEEPEAE@Z	; cmp

; 758  :             
; 759  :             BytesRead = 2;

  017ca	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 760  :             *CyclesElapsed = 3;

  017cf	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  017d7	c6 00 03	 mov	 BYTE PTR [rax], 3

; 761  :                   
; 762  :             break;

  017da	e9 df 02 00 00	 jmp	 $LN2@cpuTick
$LN83@cpuTick:

; 763  :         }
; 764  :         case 0xC0: // CPY(Immediate) - Compare against Y
; 765  :         {
; 766  :             uint8 Value = readCpuMemory8(Registers->PrgCounter+1, MemoryOffset);

  017df	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  017e4	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  017e8	ff c0		 inc	 eax
  017ea	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  017ef	0f b7 c8	 movzx	 ecx, ax
  017f2	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  017f7	88 84 24 bd 00
	00 00		 mov	 BYTE PTR Value$39[rsp], al

; 767  : 
; 768  :             cmp(Value, Registers->Y, &Registers->Flags);

  017fe	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01803	48 83 c0 03	 add	 rax, 3
  01807	4c 8b c0	 mov	 r8, rax
  0180a	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0180f	0f b6 50 02	 movzx	 edx, BYTE PTR [rax+2]
  01813	0f b6 8c 24 bd
	00 00 00	 movzx	 ecx, BYTE PTR Value$39[rsp]
  0181b	e8 00 00 00 00	 call	 ?cmp@@YAXEEPEAE@Z	; cmp

; 769  :             
; 770  :             BytesRead = 2;

  01820	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 771  :             *CyclesElapsed = 2;

  01825	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  0182d	c6 00 02	 mov	 BYTE PTR [rax], 2

; 772  :             break;

  01830	e9 89 02 00 00	 jmp	 $LN2@cpuTick
$LN84@cpuTick:

; 773  :         }
; 774  :         
; 775  :         case 0x78: // Set Interrupt Disable Flag
; 776  :         {
; 777  :             Registers->Flags = Registers->Flags | (1 << 2); // Set interrupt flag

  01835	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0183a	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0183e	83 c8 04	 or	 eax, 4
  01841	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  01846	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 778  : 
; 779  :             BytesRead = 1;

  01849	c6 44 24 60 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 780  :             *CyclesElapsed = 2;

  0184e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01856	c6 00 02	 mov	 BYTE PTR [rax], 2

; 781  :             break;

  01859	e9 60 02 00 00	 jmp	 $LN2@cpuTick
$LN85@cpuTick:

; 782  :         }
; 783  :         case 0xD8: // Clear decimal flag
; 784  :         {
; 785  :             Registers->Flags = Registers->Flags & ~(1 << 3); // clear decimal flag

  0185e	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01863	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  01867	83 e0 f7	 and	 eax, -9
  0186a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  0186f	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 786  : 
; 787  :             BytesRead = 1;

  01872	c6 44 24 60 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 788  :             *CyclesElapsed = 2;

  01877	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  0187f	c6 00 02	 mov	 BYTE PTR [rax], 2

; 789  :             break;

  01882	e9 37 02 00 00	 jmp	 $LN2@cpuTick
$LN86@cpuTick:

; 790  :         }
; 791  :         case 0x18: // Clear carry flag
; 792  :         {
; 793  :             Registers->Flags = Registers->Flags & ~(1);

  01887	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0188c	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  01890	83 e0 fe	 and	 eax, -2
  01893	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  01898	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 794  :             BytesRead = 1;

  0189b	c6 44 24 60 01	 mov	 BYTE PTR BytesRead$[rsp], 1

; 795  :             *CyclesElapsed = 2;

  018a0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  018a8	c6 00 02	 mov	 BYTE PTR [rax], 2

; 796  :             break;            

  018ab	e9 0e 02 00 00	 jmp	 $LN2@cpuTick
$LN87@cpuTick:

; 797  :         }
; 798  :         case 0x69: // ADC(Immediate)
; 799  :         {
; 800  :             uint8 Value = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  018b0	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  018b5	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  018b9	ff c0		 inc	 eax
  018bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  018c0	0f b7 c8	 movzx	 ecx, ax
  018c3	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  018c8	88 84 24 be 00
	00 00		 mov	 BYTE PTR Value$40[rsp], al

; 801  :             adc(Value, Registers);

  018cf	48 8b 54 24 68	 mov	 rdx, QWORD PTR Registers$[rsp]
  018d4	0f b6 8c 24 be
	00 00 00	 movzx	 ecx, BYTE PTR Value$40[rsp]
  018dc	e8 00 00 00 00	 call	 ?adc@@YAXEPEAUcpuRegisters@@@Z ; adc

; 802  :             BytesRead = 2;

  018e1	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 803  :             *CyclesElapsed = 2;

  018e6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  018ee	c6 00 02	 mov	 BYTE PTR [rax], 2

; 804  :             break;

  018f1	e9 c8 01 00 00	 jmp	 $LN2@cpuTick
$LN88@cpuTick:

; 805  :         }
; 806  :         case 0x65: // ADC(zeropage)
; 807  :         {
; 808  :             uint8 Address = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset);

  018f6	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  018fb	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  018ff	ff c0		 inc	 eax
  01901	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01906	0f b7 c8	 movzx	 ecx, ax
  01909	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  0190e	88 84 24 bf 00
	00 00		 mov	 BYTE PTR Address$41[rsp], al

; 809  :             uint8 Value = readCpuMemory8(Address, MemoryOffset);

  01915	0f b6 84 24 bf
	00 00 00	 movzx	 eax, BYTE PTR Address$41[rsp]
  0191d	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01922	0f b7 c8	 movzx	 ecx, ax
  01925	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  0192a	88 84 24 c0 00
	00 00		 mov	 BYTE PTR Value$42[rsp], al

; 810  :             adc(Value, Registers);

  01931	48 8b 54 24 68	 mov	 rdx, QWORD PTR Registers$[rsp]
  01936	0f b6 8c 24 c0
	00 00 00	 movzx	 ecx, BYTE PTR Value$42[rsp]
  0193e	e8 00 00 00 00	 call	 ?adc@@YAXEPEAUcpuRegisters@@@Z ; adc

; 811  :             BytesRead = 2;

  01943	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 812  :             *CyclesElapsed = 3;

  01948	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01950	c6 00 03	 mov	 BYTE PTR [rax], 3

; 813  :             break;

  01953	e9 66 01 00 00	 jmp	 $LN2@cpuTick
$LN89@cpuTick:

; 814  :         }
; 815  :         case 0xE1: // SBC(Indirect, X)
; 816  :         {
; 817  :             uint8 ZeroAddress = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset); 

  01958	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  0195d	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  01961	ff c0		 inc	 eax
  01963	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01968	0f b7 c8	 movzx	 ecx, ax
  0196b	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  01970	88 84 24 c1 00
	00 00		 mov	 BYTE PTR ZeroAddress$43[rsp], al

; 818  :             uint16 IndirectAddress = readCpuMemory16(ZeroAddress + Registers->X, MemoryOffset);

  01977	0f b6 84 24 c1
	00 00 00	 movzx	 eax, BYTE PTR ZeroAddress$43[rsp]
  0197f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  01984	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  01988	03 c1		 add	 eax, ecx
  0198a	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0198f	0f b7 c8	 movzx	 ecx, ax
  01992	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  01997	66 89 84 24 0c
	01 00 00	 mov	 WORD PTR IndirectAddress$70[rsp], ax

; 819  :             uint8 Value = readCpuMemory8(IndirectAddress, MemoryOffset);

  0199f	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  019a4	0f b7 8c 24 0c
	01 00 00	 movzx	 ecx, WORD PTR IndirectAddress$70[rsp]
  019ac	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  019b1	88 84 24 c2 00
	00 00		 mov	 BYTE PTR Value$44[rsp], al

; 820  :             sbc(Value, Registers);

  019b8	48 8b 54 24 68	 mov	 rdx, QWORD PTR Registers$[rsp]
  019bd	0f b6 8c 24 c2
	00 00 00	 movzx	 ecx, BYTE PTR Value$44[rsp]
  019c5	e8 00 00 00 00	 call	 ?sbc@@YAXEPEAUcpuRegisters@@@Z ; sbc

; 821  :             BytesRead = 2;

  019ca	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 822  :             *CyclesElapsed = 6;

  019cf	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  019d7	c6 00 06	 mov	 BYTE PTR [rax], 6

; 823  :             break;

  019da	e9 df 00 00 00	 jmp	 $LN2@cpuTick
$LN90@cpuTick:

; 824  :         }
; 825  :         case 0xF1: // SBC(Indirect), Y - Subtract with carry
; 826  :         {
; 827  :             uint8 ZeroAddress = readCpuMemory8(Registers->PrgCounter + 1, MemoryOffset); 

  019df	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  019e4	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  019e8	ff c0		 inc	 eax
  019ea	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  019ef	0f b7 c8	 movzx	 ecx, ax
  019f2	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  019f7	88 84 24 c3 00
	00 00		 mov	 BYTE PTR ZeroAddress$45[rsp], al

; 828  :             uint16 IndirectAddress = readCpuMemory16(ZeroAddress, MemoryOffset);

  019fe	0f b6 84 24 c3
	00 00 00	 movzx	 eax, BYTE PTR ZeroAddress$45[rsp]
  01a06	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01a0b	0f b7 c8	 movzx	 ecx, ax
  01a0e	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  01a13	66 89 84 24 10
	01 00 00	 mov	 WORD PTR IndirectAddress$71[rsp], ax

; 829  :             uint16 FinalAddress = IndirectAddress + Registers->Y;

  01a1b	0f b7 84 24 10
	01 00 00	 movzx	 eax, WORD PTR IndirectAddress$71[rsp]
  01a23	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  01a28	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  01a2c	03 c1		 add	 eax, ecx
  01a2e	66 89 84 24 14
	01 00 00	 mov	 WORD PTR FinalAddress$72[rsp], ax

; 830  :             uint8 Value = readCpuMemory8(FinalAddress, MemoryOffset);

  01a36	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01a3b	0f b7 8c 24 14
	01 00 00	 movzx	 ecx, WORD PTR FinalAddress$72[rsp]
  01a43	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  01a48	88 84 24 c4 00
	00 00		 mov	 BYTE PTR Value$46[rsp], al

; 831  :             sbc(Value, Registers);

  01a4f	48 8b 54 24 68	 mov	 rdx, QWORD PTR Registers$[rsp]
  01a54	0f b6 8c 24 c4
	00 00 00	 movzx	 ecx, BYTE PTR Value$46[rsp]
  01a5c	e8 00 00 00 00	 call	 ?sbc@@YAXEPEAUcpuRegisters@@@Z ; sbc

; 832  :             BytesRead = 2;

  01a61	c6 44 24 60 02	 mov	 BYTE PTR BytesRead$[rsp], 2

; 833  :             *CyclesElapsed = 5; // TODO: Boundary cross is +1

  01a66	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01a6e	c6 00 05	 mov	 BYTE PTR [rax], 5

; 834  :             break;

  01a71	eb 4b		 jmp	 SHORT $LN2@cpuTick
$LN91@cpuTick:

; 835  :         }
; 836  :         default:
; 837  :         {
; 838  :             uint8 MissingValue = CurrentInstr;

  01a73	0f b6 44 24 70	 movzx	 eax, BYTE PTR CurrentInstr$[rsp]
  01a78	88 84 24 c5 00
	00 00		 mov	 BYTE PTR MissingValue$47[rsp], al

; 839  :             char Buffer[8];
; 840  :             sprintf(Buffer, "%X\n", MissingValue);

  01a7f	0f b6 84 24 c5
	00 00 00	 movzx	 eax, BYTE PTR MissingValue$47[rsp]
  01a87	44 8b c0	 mov	 r8d, eax
  01a8a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG88004
  01a91	48 8d 8c 24 28
	01 00 00	 lea	 rcx, QWORD PTR Buffer$76[rsp]
  01a99	e8 00 00 00 00	 call	 sprintf

; 841  :             OutputDebugString(Buffer);

  01a9e	48 8d 8c 24 28
	01 00 00	 lea	 rcx, QWORD PTR Buffer$76[rsp]
  01aa6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 842  :             Assert(0);

  01aac	33 c0		 xor	 eax, eax
  01aae	83 f8 01	 cmp	 eax, 1
  01ab1	74 0b		 je	 SHORT $LN92@cpuTick
  01ab3	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN92@cpuTick:
$LN2@cpuTick:

; 843  :             break;
; 844  :         }
; 845  :     }
; 846  : 
; 847  : #if 1
; 848  :     char LogBuffer[512];
; 849  :     //C000  4C F5 C5  JMP $C5F5                       A:00 X:00 Y:00 P:24 SP:FD CYC:  0
; 850  :     sprintf(LogBuffer, "OpCode: %X Flags:%X A:%X  X:%X  Y:%X  P:%X  SP:%X  BytesRead:%d  Cycles:%d \n",

  01abe	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01ac6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01ac9	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR BytesRead$[rsp]
  01ace	48 8b 54 24 68	 mov	 rdx, QWORD PTR Registers$[rsp]
  01ad3	0f b6 52 04	 movzx	 edx, BYTE PTR [rdx+4]
  01ad7	4c 8b 44 24 68	 mov	 r8, QWORD PTR Registers$[rsp]
  01adc	45 0f b7 40 06	 movzx	 r8d, WORD PTR [r8+6]
  01ae1	4c 8b 4c 24 68	 mov	 r9, QWORD PTR Registers$[rsp]
  01ae6	45 0f b6 49 02	 movzx	 r9d, BYTE PTR [r9+2]
  01aeb	4c 8b 54 24 68	 mov	 r10, QWORD PTR Registers$[rsp]
  01af0	45 0f b6 52 01	 movzx	 r10d, BYTE PTR [r10+1]
  01af5	4c 8b 5c 24 68	 mov	 r11, QWORD PTR Registers$[rsp]
  01afa	45 0f b6 1b	 movzx	 r11d, BYTE PTR [r11]
  01afe	48 8b 5c 24 68	 mov	 rbx, QWORD PTR Registers$[rsp]
  01b03	0f b6 5b 03	 movzx	 ebx, BYTE PTR [rbx+3]
  01b07	0f b6 7c 24 70	 movzx	 edi, BYTE PTR CurrentInstr$[rsp]
  01b0c	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  01b10	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01b14	89 54 24 40	 mov	 DWORD PTR [rsp+64], edx
  01b18	44 89 44 24 38	 mov	 DWORD PTR [rsp+56], r8d
  01b1d	44 89 4c 24 30	 mov	 DWORD PTR [rsp+48], r9d
  01b22	44 89 54 24 28	 mov	 DWORD PTR [rsp+40], r10d
  01b27	44 89 5c 24 20	 mov	 DWORD PTR [rsp+32], r11d
  01b2c	44 8b cb	 mov	 r9d, ebx
  01b2f	44 8b c7	 mov	 r8d, edi
  01b32	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG88006
  01b39	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR LogBuffer$[rsp]
  01b41	e8 00 00 00 00	 call	 sprintf

; 851  :             CurrentInstr, Registers->Flags, Registers->A, Registers->X, Registers->Y, Registers->PrgCounter,
; 852  :             Registers->StackPtr, BytesRead, *CyclesElapsed);
; 853  :     OutputDebugString(LogBuffer);

  01b46	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR LogBuffer$[rsp]
  01b4e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 854  :     
; 855  : #endif
; 856  : 
; 857  : 
; 858  :     
; 859  :     Registers->PrgCounter += BytesRead;

  01b54	0f b6 44 24 60	 movzx	 eax, BYTE PTR BytesRead$[rsp]
  01b59	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  01b5e	0f b7 49 06	 movzx	 ecx, WORD PTR [rcx+6]
  01b62	03 c8		 add	 ecx, eax
  01b64	8b c1		 mov	 eax, ecx
  01b66	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  01b6b	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 860  : 
; 861  :     
; 862  :     if(NMICalled)

  01b6f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?NMICalled@@3HA, 0 ; NMICalled
  01b76	0f 84 d0 00 00
	00		 je	 $LN93@cpuTick

; 863  :     {
; 864  :         uint8 HighByte = (uint8)(Registers->PrgCounter >> 8);

  01b7c	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01b81	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  01b85	c1 f8 08	 sar	 eax, 8
  01b88	88 84 24 c6 00
	00 00		 mov	 BYTE PTR HighByte$48[rsp], al

; 865  :         uint8 LowByte = (uint8)Registers->PrgCounter;

  01b8f	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01b94	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  01b98	88 84 24 c7 00
	00 00		 mov	 BYTE PTR LowByte$49[rsp], al

; 866  :                         
; 867  :         PushStack(HighByte, &Registers->StackPtr, MemoryOffset);

  01b9f	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01ba4	48 83 c0 04	 add	 rax, 4
  01ba8	4c 8b 44 24 78	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  01bad	48 8b d0	 mov	 rdx, rax
  01bb0	0f b6 8c 24 c6
	00 00 00	 movzx	 ecx, BYTE PTR HighByte$48[rsp]
  01bb8	e8 00 00 00 00	 call	 ?PushStack@@YAXEPEAE_K@Z ; PushStack

; 868  :         PushStack(LowByte, &Registers->StackPtr, MemoryOffset);

  01bbd	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01bc2	48 83 c0 04	 add	 rax, 4
  01bc6	4c 8b 44 24 78	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  01bcb	48 8b d0	 mov	 rdx, rax
  01bce	0f b6 8c 24 c7
	00 00 00	 movzx	 ecx, BYTE PTR LowByte$49[rsp]
  01bd6	e8 00 00 00 00	 call	 ?PushStack@@YAXEPEAE_K@Z ; PushStack

; 869  :         PushStack(Registers->Flags, &Registers->StackPtr, MemoryOffset);

  01bdb	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01be0	48 83 c0 04	 add	 rax, 4
  01be4	4c 8b 44 24 78	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  01be9	48 8b d0	 mov	 rdx, rax
  01bec	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01bf1	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  01bf5	e8 00 00 00 00	 call	 ?PushStack@@YAXEPEAE_K@Z ; PushStack

; 870  : 
; 871  :         Registers->Flags = Registers->Flags | (1 << 2);

  01bfa	48 8b 44 24 68	 mov	 rax, QWORD PTR Registers$[rsp]
  01bff	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  01c03	83 c8 04	 or	 eax, 4
  01c06	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  01c0b	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 872  :             
; 873  :         // Read the break location from the IRQ/BRK Vector
; 874  : #define NMI_VEC 0xFFFA
; 875  :         Registers->PrgCounter = readCpuMemory16(NMI_VEC, MemoryOffset);

  01c0e	48 8b 54 24 78	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  01c13	66 b9 fa ff	 mov	 cx, 65530		; 0000fffaH
  01c17	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  01c1c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Registers$[rsp]
  01c21	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 876  :            
; 877  :         BytesRead = 0; // TODO: Check this

  01c25	c6 44 24 60 00	 mov	 BYTE PTR BytesRead$[rsp], 0

; 878  :         *CyclesElapsed = *CyclesElapsed + 7;

  01c2a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR CyclesElapsed$[rsp]
  01c32	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01c35	83 c0 07	 add	 eax, 7
  01c38	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR CyclesElapsed$[rsp]
  01c40	88 01		 mov	 BYTE PTR [rcx], al

; 879  :         
; 880  :         NMICalled = false;

  01c42	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?NMICalled@@3HA, 0 ; NMICalled
$LN93@cpuTick:

; 881  :     }
; 882  : }

  01c4c	48 8b 8c 24 30
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01c54	48 33 cc	 xor	 rcx, rsp
  01c57	e8 00 00 00 00	 call	 __security_check_cookie
  01c5c	48 81 c4 48 03
	00 00		 add	 rsp, 840		; 00000348H
  01c63	5f		 pop	 rdi
  01c64	5b		 pop	 rbx
  01c65	c3		 ret	 0
  01c66	66 90		 npad	 2
$LN96@cpuTick:
  01c68	00 00 00 00	 DD	 $LN4@cpuTick
  01c6c	00 00 00 00	 DD	 $LN25@cpuTick
  01c70	00 00 00 00	 DD	 $LN28@cpuTick
  01c74	00 00 00 00	 DD	 $LN42@cpuTick
  01c78	00 00 00 00	 DD	 $LN6@cpuTick
  01c7c	00 00 00 00	 DD	 $LN86@cpuTick
  01c80	00 00 00 00	 DD	 $LN44@cpuTick
  01c84	00 00 00 00	 DD	 $LN48@cpuTick
  01c88	00 00 00 00	 DD	 $LN34@cpuTick
  01c8c	00 00 00 00	 DD	 $LN47@cpuTick
  01c90	00 00 00 00	 DD	 $LN38@cpuTick
  01c94	00 00 00 00	 DD	 $LN5@cpuTick
  01c98	00 00 00 00	 DD	 $LN67@cpuTick
  01c9c	00 00 00 00	 DD	 $LN31@cpuTick
  01ca0	00 00 00 00	 DD	 $LN46@cpuTick
  01ca4	00 00 00 00	 DD	 $LN45@cpuTick
  01ca8	00 00 00 00	 DD	 $LN88@cpuTick
  01cac	00 00 00 00	 DD	 $LN68@cpuTick
  01cb0	00 00 00 00	 DD	 $LN87@cpuTick
  01cb4	00 00 00 00	 DD	 $LN84@cpuTick
  01cb8	00 00 00 00	 DD	 $LN60@cpuTick
  01cbc	00 00 00 00	 DD	 $LN51@cpuTick
  01cc0	00 00 00 00	 DD	 $LN70@cpuTick
  01cc4	00 00 00 00	 DD	 $LN65@cpuTick
  01cc8	00 00 00 00	 DD	 $LN59@cpuTick
  01ccc	00 00 00 00	 DD	 $LN50@cpuTick
  01cd0	00 00 00 00	 DD	 $LN64@cpuTick
  01cd4	00 00 00 00	 DD	 $LN61@cpuTick
  01cd8	00 00 00 00	 DD	 $LN43@cpuTick
  01cdc	00 00 00 00	 DD	 $LN62@cpuTick
  01ce0	00 00 00 00	 DD	 $LN13@cpuTick
  01ce4	00 00 00 00	 DD	 $LN63@cpuTick
  01ce8	00 00 00 00	 DD	 $LN49@cpuTick
  01cec	00 00 00 00	 DD	 $LN66@cpuTick
  01cf0	00 00 00 00	 DD	 $LN83@cpuTick
  01cf4	00 00 00 00	 DD	 $LN75@cpuTick
  01cf8	00 00 00 00	 DD	 $LN74@cpuTick
  01cfc	00 00 00 00	 DD	 $LN72@cpuTick
  01d00	00 00 00 00	 DD	 $LN69@cpuTick
  01d04	00 00 00 00	 DD	 $LN85@cpuTick
  01d08	00 00 00 00	 DD	 $LN81@cpuTick
  01d0c	00 00 00 00	 DD	 $LN89@cpuTick
  01d10	00 00 00 00	 DD	 $LN82@cpuTick
  01d14	00 00 00 00	 DD	 $LN73@cpuTick
  01d18	00 00 00 00	 DD	 $LN71@cpuTick
  01d1c	00 00 00 00	 DD	 $LN90@cpuTick
  01d20	00 00 00 00	 DD	 $LN91@cpuTick
$LN95@cpuTick:
  01d24	00		 DB	 0
  01d25	2e		 DB	 46			; 0000002eH
  01d26	2e		 DB	 46			; 0000002eH
  01d27	2e		 DB	 46			; 0000002eH
  01d28	2e		 DB	 46			; 0000002eH
  01d29	2e		 DB	 46			; 0000002eH
  01d2a	01		 DB	 1
  01d2b	2e		 DB	 46			; 0000002eH
  01d2c	2e		 DB	 46			; 0000002eH
  01d2d	2e		 DB	 46			; 0000002eH
  01d2e	02		 DB	 2
  01d2f	2e		 DB	 46			; 0000002eH
  01d30	2e		 DB	 46			; 0000002eH
  01d31	03		 DB	 3
  01d32	2e		 DB	 46			; 0000002eH
  01d33	2e		 DB	 46			; 0000002eH
  01d34	04		 DB	 4
  01d35	2e		 DB	 46			; 0000002eH
  01d36	2e		 DB	 46			; 0000002eH
  01d37	2e		 DB	 46			; 0000002eH
  01d38	2e		 DB	 46			; 0000002eH
  01d39	2e		 DB	 46			; 0000002eH
  01d3a	2e		 DB	 46			; 0000002eH
  01d3b	2e		 DB	 46			; 0000002eH
  01d3c	05		 DB	 5
  01d3d	2e		 DB	 46			; 0000002eH
  01d3e	2e		 DB	 46			; 0000002eH
  01d3f	2e		 DB	 46			; 0000002eH
  01d40	2e		 DB	 46			; 0000002eH
  01d41	2e		 DB	 46			; 0000002eH
  01d42	2e		 DB	 46			; 0000002eH
  01d43	2e		 DB	 46			; 0000002eH
  01d44	06		 DB	 6
  01d45	2e		 DB	 46			; 0000002eH
  01d46	2e		 DB	 46			; 0000002eH
  01d47	2e		 DB	 46			; 0000002eH
  01d48	2e		 DB	 46			; 0000002eH
  01d49	07		 DB	 7
  01d4a	08		 DB	 8
  01d4b	2e		 DB	 46			; 0000002eH
  01d4c	2e		 DB	 46			; 0000002eH
  01d4d	09		 DB	 9
  01d4e	2e		 DB	 46			; 0000002eH
  01d4f	2e		 DB	 46			; 0000002eH
  01d50	2e		 DB	 46			; 0000002eH
  01d51	2e		 DB	 46			; 0000002eH
  01d52	2e		 DB	 46			; 0000002eH
  01d53	2e		 DB	 46			; 0000002eH
  01d54	2e		 DB	 46			; 0000002eH
  01d55	2e		 DB	 46			; 0000002eH
  01d56	2e		 DB	 46			; 0000002eH
  01d57	2e		 DB	 46			; 0000002eH
  01d58	2e		 DB	 46			; 0000002eH
  01d59	2e		 DB	 46			; 0000002eH
  01d5a	0a		 DB	 10
  01d5b	2e		 DB	 46			; 0000002eH
  01d5c	2e		 DB	 46			; 0000002eH
  01d5d	2e		 DB	 46			; 0000002eH
  01d5e	2e		 DB	 46			; 0000002eH
  01d5f	2e		 DB	 46			; 0000002eH
  01d60	2e		 DB	 46			; 0000002eH
  01d61	2e		 DB	 46			; 0000002eH
  01d62	2e		 DB	 46			; 0000002eH
  01d63	2e		 DB	 46			; 0000002eH
  01d64	0b		 DB	 11
  01d65	2e		 DB	 46			; 0000002eH
  01d66	2e		 DB	 46			; 0000002eH
  01d67	2e		 DB	 46			; 0000002eH
  01d68	2e		 DB	 46			; 0000002eH
  01d69	2e		 DB	 46			; 0000002eH
  01d6a	2e		 DB	 46			; 0000002eH
  01d6b	2e		 DB	 46			; 0000002eH
  01d6c	0c		 DB	 12
  01d6d	2e		 DB	 46			; 0000002eH
  01d6e	0d		 DB	 13
  01d6f	2e		 DB	 46			; 0000002eH
  01d70	0e		 DB	 14
  01d71	2e		 DB	 46			; 0000002eH
  01d72	2e		 DB	 46			; 0000002eH
  01d73	2e		 DB	 46			; 0000002eH
  01d74	2e		 DB	 46			; 0000002eH
  01d75	2e		 DB	 46			; 0000002eH
  01d76	2e		 DB	 46			; 0000002eH
  01d77	2e		 DB	 46			; 0000002eH
  01d78	2e		 DB	 46			; 0000002eH
  01d79	2e		 DB	 46			; 0000002eH
  01d7a	2e		 DB	 46			; 0000002eH
  01d7b	2e		 DB	 46			; 0000002eH
  01d7c	2e		 DB	 46			; 0000002eH
  01d7d	2e		 DB	 46			; 0000002eH
  01d7e	2e		 DB	 46			; 0000002eH
  01d7f	2e		 DB	 46			; 0000002eH
  01d80	2e		 DB	 46			; 0000002eH
  01d81	2e		 DB	 46			; 0000002eH
  01d82	2e		 DB	 46			; 0000002eH
  01d83	2e		 DB	 46			; 0000002eH
  01d84	0f		 DB	 15
  01d85	2e		 DB	 46			; 0000002eH
  01d86	2e		 DB	 46			; 0000002eH
  01d87	2e		 DB	 46			; 0000002eH
  01d88	2e		 DB	 46			; 0000002eH
  01d89	10		 DB	 16
  01d8a	2e		 DB	 46			; 0000002eH
  01d8b	2e		 DB	 46			; 0000002eH
  01d8c	11		 DB	 17
  01d8d	12		 DB	 18
  01d8e	2e		 DB	 46			; 0000002eH
  01d8f	2e		 DB	 46			; 0000002eH
  01d90	2e		 DB	 46			; 0000002eH
  01d91	2e		 DB	 46			; 0000002eH
  01d92	2e		 DB	 46			; 0000002eH
  01d93	2e		 DB	 46			; 0000002eH
  01d94	2e		 DB	 46			; 0000002eH
  01d95	2e		 DB	 46			; 0000002eH
  01d96	2e		 DB	 46			; 0000002eH
  01d97	2e		 DB	 46			; 0000002eH
  01d98	2e		 DB	 46			; 0000002eH
  01d99	2e		 DB	 46			; 0000002eH
  01d9a	2e		 DB	 46			; 0000002eH
  01d9b	2e		 DB	 46			; 0000002eH
  01d9c	13		 DB	 19
  01d9d	2e		 DB	 46			; 0000002eH
  01d9e	2e		 DB	 46			; 0000002eH
  01d9f	2e		 DB	 46			; 0000002eH
  01da0	2e		 DB	 46			; 0000002eH
  01da1	2e		 DB	 46			; 0000002eH
  01da2	2e		 DB	 46			; 0000002eH
  01da3	2e		 DB	 46			; 0000002eH
  01da4	2e		 DB	 46			; 0000002eH
  01da5	2e		 DB	 46			; 0000002eH
  01da6	2e		 DB	 46			; 0000002eH
  01da7	2e		 DB	 46			; 0000002eH
  01da8	14		 DB	 20
  01da9	15		 DB	 21
  01daa	2e		 DB	 46			; 0000002eH
  01dab	2e		 DB	 46			; 0000002eH
  01dac	16		 DB	 22
  01dad	2e		 DB	 46			; 0000002eH
  01dae	17		 DB	 23
  01daf	2e		 DB	 46			; 0000002eH
  01db0	2e		 DB	 46			; 0000002eH
  01db1	15		 DB	 21
  01db2	18		 DB	 24
  01db3	2e		 DB	 46			; 0000002eH
  01db4	04		 DB	 4
  01db5	15		 DB	 21
  01db6	2e		 DB	 46			; 0000002eH
  01db7	2e		 DB	 46			; 0000002eH
  01db8	2e		 DB	 46			; 0000002eH
  01db9	2e		 DB	 46			; 0000002eH
  01dba	2e		 DB	 46			; 0000002eH
  01dbb	2e		 DB	 46			; 0000002eH
  01dbc	19		 DB	 25
  01dbd	15		 DB	 21
  01dbe	1a		 DB	 26
  01dbf	2e		 DB	 46			; 0000002eH
  01dc0	2e		 DB	 46			; 0000002eH
  01dc1	2e		 DB	 46			; 0000002eH
  01dc2	2e		 DB	 46			; 0000002eH
  01dc3	2e		 DB	 46			; 0000002eH
  01dc4	1b		 DB	 27
  01dc5	2e		 DB	 46			; 0000002eH
  01dc6	1c		 DB	 28
  01dc7	2e		 DB	 46			; 0000002eH
  01dc8	1d		 DB	 29
  01dc9	1e		 DB	 30
  01dca	1f		 DB	 31
  01dcb	2e		 DB	 46			; 0000002eH
  01dcc	20		 DB	 32			; 00000020H
  01dcd	1e		 DB	 30
  01dce	21		 DB	 33			; 00000021H
  01dcf	2e		 DB	 46			; 0000002eH
  01dd0	2e		 DB	 46			; 0000002eH
  01dd1	1e		 DB	 30
  01dd2	2e		 DB	 46			; 0000002eH
  01dd3	2e		 DB	 46			; 0000002eH
  01dd4	04		 DB	 4
  01dd5	1e		 DB	 30
  01dd6	2e		 DB	 46			; 0000002eH
  01dd7	2e		 DB	 46			; 0000002eH
  01dd8	2e		 DB	 46			; 0000002eH
  01dd9	2e		 DB	 46			; 0000002eH
  01dda	2e		 DB	 46			; 0000002eH
  01ddb	2e		 DB	 46			; 0000002eH
  01ddc	2e		 DB	 46			; 0000002eH
  01ddd	1e		 DB	 30
  01dde	2e		 DB	 46			; 0000002eH
  01ddf	2e		 DB	 46			; 0000002eH
  01de0	2e		 DB	 46			; 0000002eH
  01de1	1e		 DB	 30
  01de2	2e		 DB	 46			; 0000002eH
  01de3	2e		 DB	 46			; 0000002eH
  01de4	22		 DB	 34			; 00000022H
  01de5	2e		 DB	 46			; 0000002eH
  01de6	2e		 DB	 46			; 0000002eH
  01de7	2e		 DB	 46			; 0000002eH
  01de8	2e		 DB	 46			; 0000002eH
  01de9	23		 DB	 35			; 00000023H
  01dea	24		 DB	 36			; 00000024H
  01deb	2e		 DB	 46			; 0000002eH
  01dec	25		 DB	 37			; 00000025H
  01ded	23		 DB	 35			; 00000023H
  01dee	26		 DB	 38			; 00000026H
  01def	2e		 DB	 46			; 0000002eH
  01df0	2e		 DB	 46			; 0000002eH
  01df1	2e		 DB	 46			; 0000002eH
  01df2	2e		 DB	 46			; 0000002eH
  01df3	2e		 DB	 46			; 0000002eH
  01df4	04		 DB	 4
  01df5	2e		 DB	 46			; 0000002eH
  01df6	2e		 DB	 46			; 0000002eH
  01df7	2e		 DB	 46			; 0000002eH
  01df8	2e		 DB	 46			; 0000002eH
  01df9	2e		 DB	 46			; 0000002eH
  01dfa	2e		 DB	 46			; 0000002eH
  01dfb	2e		 DB	 46			; 0000002eH
  01dfc	27		 DB	 39			; 00000027H
  01dfd	23		 DB	 35			; 00000023H
  01dfe	2e		 DB	 46			; 0000002eH
  01dff	2e		 DB	 46			; 0000002eH
  01e00	2e		 DB	 46			; 0000002eH
  01e01	2e		 DB	 46			; 0000002eH
  01e02	2e		 DB	 46			; 0000002eH
  01e03	2e		 DB	 46			; 0000002eH
  01e04	28		 DB	 40			; 00000028H
  01e05	29		 DB	 41			; 00000029H
  01e06	2e		 DB	 46			; 0000002eH
  01e07	2e		 DB	 46			; 0000002eH
  01e08	2a		 DB	 42			; 0000002aH
  01e09	2e		 DB	 46			; 0000002eH
  01e0a	2b		 DB	 43			; 0000002bH
  01e0b	2e		 DB	 46			; 0000002eH
  01e0c	2c		 DB	 44			; 0000002cH
  01e0d	2e		 DB	 46			; 0000002eH
  01e0e	2e		 DB	 46			; 0000002eH
  01e0f	2e		 DB	 46			; 0000002eH
  01e10	2e		 DB	 46			; 0000002eH
  01e11	2e		 DB	 46			; 0000002eH
  01e12	2e		 DB	 46			; 0000002eH
  01e13	2e		 DB	 46			; 0000002eH
  01e14	04		 DB	 4
  01e15	2d		 DB	 45			; 0000002dH
?cpuTick@@YAXPEAUcpu@@@Z ENDP				; cpuTick
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Value$ = 0
Address$ = 8
StackPointer$ = 32
MemoryOffset$ = 40
?PopStack@@YAEPEAE_K@Z PROC				; PopStack

; 157  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 158  :     uint8 *Address = (uint8 *)((*StackPointer + STACK_ADRS) + MemoryOffset);

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR StackPointer$[rsp]
  00013	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00016	05 00 01 00 00	 add	 eax, 256		; 00000100H
  0001b	48 98		 cdqe
  0001d	48 03 44 24 28	 add	 rax, QWORD PTR MemoryOffset$[rsp]
  00022	48 89 44 24 08	 mov	 QWORD PTR Address$[rsp], rax

; 159  :     uint8 Value = *Address;

  00027	48 8b 44 24 08	 mov	 rax, QWORD PTR Address$[rsp]
  0002c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002f	88 04 24	 mov	 BYTE PTR Value$[rsp], al

; 160  :     ++(*StackPointer);    

  00032	48 8b 44 24 20	 mov	 rax, QWORD PTR StackPointer$[rsp]
  00037	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003a	fe c0		 inc	 al
  0003c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR StackPointer$[rsp]
  00041	88 01		 mov	 BYTE PTR [rcx], al

; 161  :     return(Value);

  00043	0f b6 04 24	 movzx	 eax, BYTE PTR Value$[rsp]

; 162  : }

  00047	48 83 c4 18	 add	 rsp, 24
  0004b	c3		 ret	 0
?PopStack@@YAEPEAE_K@Z ENDP				; PopStack
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Address$ = 0
Byte$ = 32
StackPointer$ = 40
MemoryOffset$ = 48
?PushStack@@YAXEPEAE_K@Z PROC				; PushStack

; 151  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	48 83 ec 18	 sub	 rsp, 24

; 152  :     uint8 *Address = (uint8 *)((*StackPointer + STACK_ADRS) + MemoryOffset);

  00012	48 8b 44 24 28	 mov	 rax, QWORD PTR StackPointer$[rsp]
  00017	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001a	05 00 01 00 00	 add	 eax, 256		; 00000100H
  0001f	48 98		 cdqe
  00021	48 03 44 24 30	 add	 rax, QWORD PTR MemoryOffset$[rsp]
  00026	48 89 04 24	 mov	 QWORD PTR Address$[rsp], rax

; 153  :     *Address = Byte;

  0002a	48 8b 04 24	 mov	 rax, QWORD PTR Address$[rsp]
  0002e	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Byte$[rsp]
  00033	88 08		 mov	 BYTE PTR [rax], cl

; 154  :     --(*StackPointer);  

  00035	48 8b 44 24 28	 mov	 rax, QWORD PTR StackPointer$[rsp]
  0003a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003d	fe c8		 dec	 al
  0003f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR StackPointer$[rsp]
  00044	88 01		 mov	 BYTE PTR [rcx], al

; 155  : }

  00046	48 83 c4 18	 add	 rsp, 24
  0004a	c3		 ret	 0
?PushStack@@YAXEPEAE_K@Z ENDP				; PushStack
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
CmpValue$ = 32
Value$ = 64
Register$ = 72
Flags$ = 80
?cmp@@YAXEEPEAE@Z PROC					; cmp

; 128  : {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000d	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 129  :     uint8 CmpValue = Register - Value;

  00011	0f b6 44 24 48	 movzx	 eax, BYTE PTR Register$[rsp]
  00016	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR Value$[rsp]
  0001b	2b c1		 sub	 eax, ecx
  0001d	88 44 24 20	 mov	 BYTE PTR CmpValue$[rsp], al

; 130  :                         
; 131  :     setNegative(CmpValue, Flags);

  00021	48 8b 54 24 50	 mov	 rdx, QWORD PTR Flags$[rsp]
  00026	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  0002b	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 132  :     setZero(CmpValue, Flags);

  00030	48 8b 54 24 50	 mov	 rdx, QWORD PTR Flags$[rsp]
  00035	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  0003a	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 133  :                         
; 134  :     if(Register < Value)

  0003f	0f b6 44 24 48	 movzx	 eax, BYTE PTR Register$[rsp]
  00044	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR Value$[rsp]
  00049	3b c1		 cmp	 eax, ecx
  0004b	7d 0c		 jge	 SHORT $LN2@cmp

; 135  :     {
; 136  :         clearCarry(Flags);

  0004d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Flags$[rsp]
  00052	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry

; 137  :     }
; 138  :     else

  00057	eb 0a		 jmp	 SHORT $LN3@cmp
$LN2@cmp:

; 139  :         setCarry(Flags);

  00059	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Flags$[rsp]
  0005e	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry
$LN3@cmp:

; 140  : }

  00063	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00067	c3		 ret	 0
?cmp@@YAXEEPEAE@Z ENDP					; cmp
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Carry$ = 32
Result$ = 36
Value$ = 64
Registers$ = 72
?sbc@@YAXEPEAUcpuRegisters@@@Z PROC			; sbc

; 102  : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 103  :     uint8 Carry = 1 - (Registers->Flags & 1);

  0000d	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  00012	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00016	83 e0 01	 and	 eax, 1
  00019	b9 01 00 00 00	 mov	 ecx, 1
  0001e	2b c8		 sub	 ecx, eax
  00020	8b c1		 mov	 eax, ecx
  00022	88 44 24 20	 mov	 BYTE PTR Carry$[rsp], al

; 104  :     int32 Result = (int8)Registers->A - (int8)Value - Carry;

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  0002b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0002e	0f be 4c 24 40	 movsx	 ecx, BYTE PTR Value$[rsp]
  00033	2b c1		 sub	 eax, ecx
  00035	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Carry$[rsp]
  0003a	2b c1		 sub	 eax, ecx
  0003c	89 44 24 24	 mov	 DWORD PTR Result$[rsp], eax

; 105  :             
; 106  :     if(Result < -128 || Result > 127)

  00040	83 7c 24 24 80	 cmp	 DWORD PTR Result$[rsp], -128 ; ffffffffffffff80H
  00045	7c 07		 jl	 SHORT $LN4@sbc
  00047	83 7c 24 24 7f	 cmp	 DWORD PTR Result$[rsp], 127 ; 0000007fH
  0004c	7e 13		 jle	 SHORT $LN2@sbc
$LN4@sbc:

; 107  :     {
; 108  :         setOverflow(&Registers->Flags);

  0004e	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  00053	48 83 c0 03	 add	 rax, 3
  00057	48 8b c8	 mov	 rcx, rax
  0005a	e8 00 00 00 00	 call	 ?setOverflow@@YAXPEAE@Z	; setOverflow

; 109  :     }
; 110  :     else

  0005f	eb 11		 jmp	 SHORT $LN3@sbc
$LN2@sbc:

; 111  :         clearOverflow(&Registers->Flags);

  00061	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  00066	48 83 c0 03	 add	 rax, 3
  0006a	48 8b c8	 mov	 rcx, rax
  0006d	e8 00 00 00 00	 call	 ?clearOverflow@@YAXPEAE@Z ; clearOverflow
$LN3@sbc:

; 112  :                         
; 113  :     Registers->A = (uint8)Result;

  00072	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  00077	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Result$[rsp]
  0007c	88 08		 mov	 BYTE PTR [rax], cl

; 114  : 
; 115  :     if(Registers->A < (Value - Carry))

  0007e	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  00083	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00086	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR Value$[rsp]
  0008b	0f b6 54 24 20	 movzx	 edx, BYTE PTR Carry$[rsp]
  00090	2b ca		 sub	 ecx, edx
  00092	3b c1		 cmp	 eax, ecx
  00094	7d 13		 jge	 SHORT $LN5@sbc

; 116  :     {
; 117  :         clearCarry(&Registers->Flags);

  00096	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  0009b	48 83 c0 03	 add	 rax, 3
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry

; 118  :     }
; 119  :     else

  000a7	eb 11		 jmp	 SHORT $LN6@sbc
$LN5@sbc:

; 120  :         setCarry(&Registers->Flags);

  000a9	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  000ae	48 83 c0 03	 add	 rax, 3
  000b2	48 8b c8	 mov	 rcx, rax
  000b5	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry
$LN6@sbc:

; 121  :             
; 122  :     setNegative((uint8)Result, &Registers->Flags);

  000ba	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  000bf	48 83 c0 03	 add	 rax, 3
  000c3	48 8b d0	 mov	 rdx, rax
  000c6	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Result$[rsp]
  000cb	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 123  :     setZero((uint8)Result, &Registers->Flags);

  000d0	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  000d5	48 83 c0 03	 add	 rax, 3
  000d9	48 8b d0	 mov	 rdx, rax
  000dc	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Result$[rsp]
  000e1	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 124  : }

  000e6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ea	c3		 ret	 0
?sbc@@YAXEPEAUcpuRegisters@@@Z ENDP			; sbc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Carry$ = 32
Result$ = 36
Value$ = 64
Registers$ = 72
?adc@@YAXEPEAUcpuRegisters@@@Z PROC			; adc

; 78   : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 79   :     uint8 Carry = (Registers->Flags & 1);            

  0000d	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  00012	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00016	83 e0 01	 and	 eax, 1
  00019	88 44 24 20	 mov	 BYTE PTR Carry$[rsp], al

; 80   :     int32 Result = (int8)Registers->A + (int8)Value + Carry;

  0001d	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  00022	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00025	0f be 4c 24 40	 movsx	 ecx, BYTE PTR Value$[rsp]
  0002a	03 c1		 add	 eax, ecx
  0002c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Carry$[rsp]
  00031	03 c1		 add	 eax, ecx
  00033	89 44 24 24	 mov	 DWORD PTR Result$[rsp], eax

; 81   :             
; 82   :     if(Result < -128 || Result > 127)

  00037	83 7c 24 24 80	 cmp	 DWORD PTR Result$[rsp], -128 ; ffffffffffffff80H
  0003c	7c 07		 jl	 SHORT $LN4@adc
  0003e	83 7c 24 24 7f	 cmp	 DWORD PTR Result$[rsp], 127 ; 0000007fH
  00043	7e 13		 jle	 SHORT $LN2@adc
$LN4@adc:

; 83   :     {
; 84   :         setOverflow(&Registers->Flags);

  00045	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  0004a	48 83 c0 03	 add	 rax, 3
  0004e	48 8b c8	 mov	 rcx, rax
  00051	e8 00 00 00 00	 call	 ?setOverflow@@YAXPEAE@Z	; setOverflow

; 85   :     }
; 86   :     else

  00056	eb 11		 jmp	 SHORT $LN3@adc
$LN2@adc:

; 87   :         clearOverflow(&Registers->Flags);

  00058	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  0005d	48 83 c0 03	 add	 rax, 3
  00061	48 8b c8	 mov	 rcx, rax
  00064	e8 00 00 00 00	 call	 ?clearOverflow@@YAXPEAE@Z ; clearOverflow
$LN3@adc:

; 88   :                         
; 89   :     Registers->A = (uint8)Result;

  00069	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  0006e	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Result$[rsp]
  00073	88 08		 mov	 BYTE PTR [rax], cl

; 90   : 
; 91   :     if(Registers->A < (Value + Carry))

  00075	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  0007a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0007d	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR Value$[rsp]
  00082	0f b6 54 24 20	 movzx	 edx, BYTE PTR Carry$[rsp]
  00087	03 ca		 add	 ecx, edx
  00089	3b c1		 cmp	 eax, ecx
  0008b	7d 13		 jge	 SHORT $LN5@adc

; 92   :     {
; 93   :         clearCarry(&Registers->Flags);

  0008d	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  00092	48 83 c0 03	 add	 rax, 3
  00096	48 8b c8	 mov	 rcx, rax
  00099	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry

; 94   :     }
; 95   :     else

  0009e	eb 11		 jmp	 SHORT $LN6@adc
$LN5@adc:

; 96   :         setCarry(&Registers->Flags);

  000a0	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  000a5	48 83 c0 03	 add	 rax, 3
  000a9	48 8b c8	 mov	 rcx, rax
  000ac	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry
$LN6@adc:

; 97   :             
; 98   :     setNegative((uint8)Result, &Registers->Flags);

  000b1	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  000b6	48 83 c0 03	 add	 rax, 3
  000ba	48 8b d0	 mov	 rdx, rax
  000bd	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Result$[rsp]
  000c2	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 99   :     setZero((uint8)Result, &Registers->Flags);

  000c7	48 8b 44 24 48	 mov	 rax, QWORD PTR Registers$[rsp]
  000cc	48 83 c0 03	 add	 rax, 3
  000d0	48 8b d0	 mov	 rdx, rax
  000d3	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Result$[rsp]
  000d8	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 100  : }

  000dd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e1	c3		 ret	 0
?adc@@YAXEPEAUcpuRegisters@@@Z ENDP			; adc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearOverflow@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearOverflow@@YAXPEAE@Z PROC				; clearOverflow, COMDAT

; 72   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 73   :     *Flags = *Flags & ~(1 << 6);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 bf	 and	 eax, -65		; ffffffffffffffbfH
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al

; 74   : }

  00017	c3		 ret	 0
?clearOverflow@@YAXPEAE@Z ENDP				; clearOverflow
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setOverflow@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setOverflow@@YAXPEAE@Z PROC				; setOverflow, COMDAT

; 68   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 69   :     *Flags = *Flags | (1 << 6);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 40	 or	 eax, 64			; 00000040H
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al

; 70   : }

  00017	c3		 ret	 0
?setOverflow@@YAXPEAE@Z ENDP				; setOverflow
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearCarry@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearCarry@@YAXPEAE@Z PROC				; clearCarry, COMDAT

; 64   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 65   :     *Flags = *Flags & ~1;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 fe	 and	 eax, -2
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al

; 66   : }

  00017	c3		 ret	 0
?clearCarry@@YAXPEAE@Z ENDP				; clearCarry
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setCarry@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setCarry@@YAXPEAE@Z PROC				; setCarry, COMDAT

; 60   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 61   :     *Flags = *Flags | 1;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 01	 or	 eax, 1
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al

; 62   : }

  00017	c3		 ret	 0
?setCarry@@YAXPEAE@Z ENDP				; setCarry
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setZero@@YAXEPEAE@Z
_TEXT	SEGMENT
Value$ = 8
Flags$ = 16
?setZero@@YAXEPEAE@Z PROC				; setZero, COMDAT

; 53   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 54   :     if(Value == 0x00)

  00009	0f b6 44 24 08	 movzx	 eax, BYTE PTR Value$[rsp]
  0000e	85 c0		 test	 eax, eax
  00010	75 14		 jne	 SHORT $LN2@setZero

; 55   :         *Flags = *Flags | (1 << 1); // Set zero flag

  00012	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  00017	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001a	83 c8 02	 or	 eax, 2
  0001d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  00022	88 01		 mov	 BYTE PTR [rcx], al

; 56   :     else

  00024	eb 12		 jmp	 SHORT $LN3@setZero
$LN2@setZero:

; 57   :         *Flags = *Flags & ~(1 << 1);

  00026	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  0002b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002e	83 e0 fd	 and	 eax, -3
  00031	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  00036	88 01		 mov	 BYTE PTR [rcx], al
$LN3@setZero:

; 58   : }

  00038	c3		 ret	 0
?setZero@@YAXEPEAE@Z ENDP				; setZero
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setNegative@@YAXEPEAE@Z
_TEXT	SEGMENT
Value$ = 8
Flags$ = 16
?setNegative@@YAXEPEAE@Z PROC				; setNegative, COMDAT

; 46   : {  

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 47   :     if(Value >= 0x00 && Value <= 0x7F)

  00009	0f b6 44 24 08	 movzx	 eax, BYTE PTR Value$[rsp]
  0000e	85 c0		 test	 eax, eax
  00010	7c 1f		 jl	 SHORT $LN2@setNegativ
  00012	0f b6 44 24 08	 movzx	 eax, BYTE PTR Value$[rsp]
  00017	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  0001a	7f 15		 jg	 SHORT $LN2@setNegativ

; 48   :         *Flags = *Flags & ~(1 << 7); // clear negative flag

  0001c	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  00021	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00024	0f ba f0 07	 btr	 eax, 7
  00028	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  0002d	88 01		 mov	 BYTE PTR [rcx], al

; 49   :     else

  0002f	eb 13		 jmp	 SHORT $LN3@setNegativ
$LN2@setNegativ:

; 50   :         *Flags = *Flags | (1 << 7); // set negative flag

  00031	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  00036	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00039	0f ba e8 07	 bts	 eax, 7
  0003d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  00042	88 01		 mov	 BYTE PTR [rcx], al
$LN3@setNegativ:

; 51   : }

  00044	c3		 ret	 0
?setNegative@@YAXEPEAE@Z ENDP				; setNegative
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
NewAddress$ = 36
Address$ = 64
MemoryOffset$ = 72
?readCpuMemory16@@YAGG_K@Z PROC				; readCpuMemory16

; 304  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 305  :     // NOTE: Little Endian
; 306  :     uint8 LowByte = readCpuMemory8(Address, MemoryOffset);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00013	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00018	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  0001d	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 307  :     uint8 HighByte = readCpuMemory8(Address+1, MemoryOffset);

  00021	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00026	ff c0		 inc	 eax
  00028	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0002d	0f b7 c8	 movzx	 ecx, ax
  00030	e8 00 00 00 00	 call	 ?readCpuMemory8@@YAEG_K@Z ; readCpuMemory8
  00035	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 308  :         
; 309  :     uint16 NewAddress = (HighByte << 8) | LowByte;

  00039	0f b6 44 24 20	 movzx	 eax, BYTE PTR HighByte$[rsp]
  0003e	c1 e0 08	 shl	 eax, 8
  00041	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  00046	0b c1		 or	 eax, ecx
  00048	66 89 44 24 24	 mov	 WORD PTR NewAddress$[rsp], ax

; 310  :     return(NewAddress);

  0004d	0f b7 44 24 24	 movzx	 eax, WORD PTR NewAddress$[rsp]

; 311  : }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
?readCpuMemory16@@YAGG_K@Z ENDP				; readCpuMemory16
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Value$ = 32
NewAddress$1 = 40
Address$ = 64
MemoryOffset$ = 72
?readCpuMemory8@@YAEG_K@Z PROC				; readCpuMemory8

; 280  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 281  :     // NOTE: Mirrors the address for the 2kb ram 
; 282  :     if(0x800 <= Address && Address < 0x2000)

  0000e	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00013	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  00018	7c 1c		 jl	 SHORT $LN2@readCpuMem
  0001a	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0001f	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  00024	7d 10		 jge	 SHORT $LN2@readCpuMem

; 283  :         Address = Address & (Kilobytes(2) - 1);  // Modulus for values power of 2

  00026	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0002b	48 25 ff 07 00
	00		 and	 rax, 2047		; 000007ffH
  00031	66 89 44 24 40	 mov	 WORD PTR Address$[rsp], ax
$LN2@readCpuMem:

; 284  :     // NOTE: Mirror for PPU Registers
; 285  :     if(0x2008 <= Address && Address < 0x4000)

  00036	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0003b	3d 08 20 00 00	 cmp	 eax, 8200		; 00002008H
  00040	7c 19		 jl	 SHORT $LN3@readCpuMem
  00042	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00047	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  0004c	7d 0d		 jge	 SHORT $LN3@readCpuMem

; 286  :         Address = Address & 7; // Modulus, repeates every 8 bytes        

  0004e	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00053	83 e0 07	 and	 eax, 7
  00056	66 89 44 24 40	 mov	 WORD PTR Address$[rsp], ax
$LN3@readCpuMem:

; 287  : 
; 288  :     
; 289  :     uint8 Value = readMemory8(Address, MemoryOffset);

  0005b	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00060	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00065	e8 00 00 00 00	 call	 ?readMemory8@@YAEG_K@Z	; readMemory8
  0006a	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 290  : 
; 291  : 
; 292  :     if(Address == 0x2002)

  0006e	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00073	3d 02 20 00 00	 cmp	 eax, 8194		; 00002002H
  00078	75 36		 jne	 SHORT $LN4@readCpuMem

; 293  :     {
; 294  :         VRamAdrsWriteCount = VRamDataWriteCount = 0; // Clear VRam IO

  0007a	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?VRamDataWriteCount@@3EA, 0 ; VRamDataWriteCount
  00081	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?VRamDataWriteCount@@3EA ; VRamDataWriteCount
  00088	88 05 00 00 00
	00		 mov	 BYTE PTR ?VRamAdrsWriteCount@@3EA, al ; VRamAdrsWriteCount

; 295  :         uint8 *NewAddress = (uint8 *)(Address + MemoryOffset);

  0008e	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00093	48 03 44 24 48	 add	 rax, QWORD PTR MemoryOffset$[rsp]
  00098	48 89 44 24 28	 mov	 QWORD PTR NewAddress$1[rsp], rax

; 296  :         *NewAddress = *NewAddress & ~(1 << 7); // Clear bit 7 of status

  0009d	48 8b 44 24 28	 mov	 rax, QWORD PTR NewAddress$1[rsp]
  000a2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000a5	0f ba f0 07	 btr	 eax, 7
  000a9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR NewAddress$1[rsp]
  000ae	88 01		 mov	 BYTE PTR [rcx], al
$LN4@readCpuMem:

; 297  :     }
; 298  :     
; 299  :     return(Value);

  000b0	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]

; 300  : }

  000b5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b9	c3		 ret	 0
?readCpuMemory8@@YAEG_K@Z ENDP				; readCpuMemory8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Value$ = 0
NewAddress$ = 8
Address$ = 32
MemoryOffset$ = 40
?readMemory8@@YAEG_K@Z PROC				; readMemory8

; 273  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 274  :     uint8 *NewAddress = (uint8 *)(Address + MemoryOffset);

  0000e	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  00013	48 03 44 24 28	 add	 rax, QWORD PTR MemoryOffset$[rsp]
  00018	48 89 44 24 08	 mov	 QWORD PTR NewAddress$[rsp], rax

; 275  :     uint8 Value = *NewAddress;

  0001d	48 8b 44 24 08	 mov	 rax, QWORD PTR NewAddress$[rsp]
  00022	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00025	88 04 24	 mov	 BYTE PTR Value$[rsp], al

; 276  :     return(Value);

  00028	0f b6 04 24	 movzx	 eax, BYTE PTR Value$[rsp]

; 277  : }

  0002c	48 83 c4 18	 add	 rsp, 24
  00030	c3		 ret	 0
?readMemory8@@YAEG_K@Z ENDP				; readMemory8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Byte$ = 48
Address$ = 56
MemoryOffset$ = 64
?writeCpuMemory8@@YAXEG_K@Z PROC			; writeCpuMemory8

; 247  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 248  :     // NOTE: Mirrors the address for the 2kb ram 
; 249  :     if(0x800 <= Address && Address < 0x2000)

  00012	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00017	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  0001c	7c 1c		 jl	 SHORT $LN2@writeCpuMe
  0001e	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00023	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  00028	7d 10		 jge	 SHORT $LN2@writeCpuMe

; 250  :         Address = Address & (Kilobytes(2) - 1);  // Modulus for values power of 2

  0002a	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  0002f	48 25 ff 07 00
	00		 and	 rax, 2047		; 000007ffH
  00035	66 89 44 24 38	 mov	 WORD PTR Address$[rsp], ax
$LN2@writeCpuMe:

; 251  :     // NOTE: Mirror for PPU Registers
; 252  :     if(0x2008 <= Address && Address < 0x4000)

  0003a	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  0003f	3d 08 20 00 00	 cmp	 eax, 8200		; 00002008H
  00044	7c 19		 jl	 SHORT $LN3@writeCpuMe
  00046	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  0004b	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  00050	7d 0d		 jge	 SHORT $LN3@writeCpuMe

; 253  :         Address = Address & 7; // Modulus, repeates every 8 bytes

  00052	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00057	83 e0 07	 and	 eax, 7
  0005a	66 89 44 24 38	 mov	 WORD PTR Address$[rsp], ax
$LN3@writeCpuMe:

; 254  :     if(0x8000 < Address || Address == 0x2002)

  0005f	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00064	3d 00 80 00 00	 cmp	 eax, 32768		; 00008000H
  00069	7f 0c		 jg	 SHORT $LN5@writeCpuMe
  0006b	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00070	3d 02 20 00 00	 cmp	 eax, 8194		; 00002002H
  00075	75 12		 jne	 SHORT $LN4@writeCpuMe
$LN5@writeCpuMe:

; 255  :         Assert(0); // Writing to Program ROM, bank switching?     

  00077	33 c0		 xor	 eax, eax
  00079	83 f8 01	 cmp	 eax, 1
  0007c	74 0b		 je	 SHORT $LN6@writeCpuMe
  0007e	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN6@writeCpuMe:
$LN4@writeCpuMe:

; 256  :     
; 257  :     if(Address == 0x2006)

  00089	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  0008e	3d 06 20 00 00	 cmp	 eax, 8198		; 00002006H
  00093	75 0f		 jne	 SHORT $LN7@writeCpuMe

; 258  :         VRamAdrsWriteCount++;

  00095	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?VRamAdrsWriteCount@@3EA ; VRamAdrsWriteCount
  0009c	fe c0		 inc	 al
  0009e	88 05 00 00 00
	00		 mov	 BYTE PTR ?VRamAdrsWriteCount@@3EA, al ; VRamAdrsWriteCount
$LN7@writeCpuMe:

; 259  :     if(Address == 0x2007)

  000a4	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  000a9	3d 07 20 00 00	 cmp	 eax, 8199		; 00002007H
  000ae	75 0f		 jne	 SHORT $LN8@writeCpuMe

; 260  :         VRamDataWriteCount++;

  000b0	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?VRamDataWriteCount@@3EA ; VRamDataWriteCount
  000b7	fe c0		 inc	 al
  000b9	88 05 00 00 00
	00		 mov	 BYTE PTR ?VRamDataWriteCount@@3EA, al ; VRamDataWriteCount
$LN8@writeCpuMe:

; 261  : 
; 262  :     if(Address == 0x4016 || Address == 0x4017)

  000bf	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  000c4	3d 16 40 00 00	 cmp	 eax, 16406		; 00004016H
  000c9	74 0c		 je	 SHORT $LN10@writeCpuMe
  000cb	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  000d0	3d 17 40 00 00	 cmp	 eax, 16407		; 00004017H
  000d5	75 12		 jne	 SHORT $LN9@writeCpuMe
$LN10@writeCpuMe:

; 263  :     {
; 264  :         Assert(0); // TODO: This means input reading is restarted by strobing register

  000d7	33 c0		 xor	 eax, eax
  000d9	83 f8 01	 cmp	 eax, 1
  000dc	74 0b		 je	 SHORT $LN11@writeCpuMe
  000de	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN11@writeCpuMe:
$LN9@writeCpuMe:

; 265  :     }
; 266  :     
; 267  :     writeMemory8(Byte, Address, MemoryOffset);

  000e9	4c 8b 44 24 40	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  000ee	0f b7 54 24 38	 movzx	 edx, WORD PTR Address$[rsp]
  000f3	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR Byte$[rsp]
  000f8	e8 00 00 00 00	 call	 ?writeMemory8@@YAXEG_K@Z ; writeMemory8

; 268  : }

  000fd	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00101	c3		 ret	 0
?writeCpuMemory8@@YAXEG_K@Z ENDP			; writeCpuMemory8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
NewAddress$ = 0
Byte$ = 32
Address$ = 40
MemoryOffset$ = 48
?writeMemory8@@YAXEG_K@Z PROC				; writeMemory8

; 238  : {    

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	48 83 ec 18	 sub	 rsp, 24

; 239  :     uint8 *NewAddress = (uint8 *)(Address + MemoryOffset);

  00012	0f b7 44 24 28	 movzx	 eax, WORD PTR Address$[rsp]
  00017	48 03 44 24 30	 add	 rax, QWORD PTR MemoryOffset$[rsp]
  0001c	48 89 04 24	 mov	 QWORD PTR NewAddress$[rsp], rax

; 240  :     *NewAddress = Byte;

  00020	48 8b 04 24	 mov	 rax, QWORD PTR NewAddress$[rsp]
  00024	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Byte$[rsp]
  00029	88 08		 mov	 BYTE PTR [rax], cl

; 241  : }

  0002b	48 83 c4 18	 add	 rsp, 24
  0002f	c3		 ret	 0
?writeMemory8@@YAXEG_K@Z ENDP				; writeMemory8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Byte$1 = 0
Dest$ = 32
Src$ = 40
Size$ = 48
?cpyMemory@@YAXPEAE0G@Z PROC				; cpyMemory

; 228  : {

  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	48 83 ec 18	 sub	 rsp, 24

; 229  :     // NOTE: Very basic copy. Not bounds protection
; 230  :     for(uint16 Byte = 0; Byte < Size; ++Byte)

  00014	33 c0		 xor	 eax, eax
  00016	66 89 04 24	 mov	 WORD PTR Byte$1[rsp], ax
  0001a	eb 0b		 jmp	 SHORT $LN4@cpyMemory
$LN2@cpyMemory:
  0001c	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  00020	66 ff c0	 inc	 ax
  00023	66 89 04 24	 mov	 WORD PTR Byte$1[rsp], ax
$LN4@cpyMemory:
  00027	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  0002b	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Size$[rsp]
  00030	3b c1		 cmp	 eax, ecx
  00032	7d 1c		 jge	 SHORT $LN3@cpyMemory

; 231  :         Dest[Byte] = Src[Byte];

  00034	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  00038	0f b7 0c 24	 movzx	 ecx, WORD PTR Byte$1[rsp]
  0003c	48 8b 54 24 20	 mov	 rdx, QWORD PTR Dest$[rsp]
  00041	4c 8b 44 24 28	 mov	 r8, QWORD PTR Src$[rsp]
  00046	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0004b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0004e	eb cc		 jmp	 SHORT $LN2@cpyMemory
$LN3@cpyMemory:

; 232  : }

  00050	48 83 c4 18	 add	 rsp, 24
  00054	c3		 ret	 0
?cpyMemory@@YAXPEAE0G@Z ENDP				; cpyMemory
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
BytesRead$1 = 64
FileData$ = 72
FileHandle$ = 80
Filesize$2 = 88
Filename$ = 112
Size$ = 120
?LoadFile@@YAPEAXPEADPEAI@Z PROC			; LoadFile

; 187  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 188  :     void *FileData = 0;

  0000e	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR FileData$[rsp], 0

; 189  :     
; 190  :     HANDLE FileHandle = CreateFileA(Filename, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);

  00017	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00020	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00028	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  00030	45 33 c9	 xor	 r9d, r9d
  00033	41 b8 01 00 00
	00		 mov	 r8d, 1
  00039	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  0003e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Filename$[rsp]
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileA
  00049	48 89 44 24 50	 mov	 QWORD PTR FileHandle$[rsp], rax

; 191  :     if(FileHandle != INVALID_HANDLE_VALUE)

  0004e	48 83 7c 24 50
	ff		 cmp	 QWORD PTR FileHandle$[rsp], -1
  00054	0f 84 8d 00 00
	00		 je	 $LN2@LoadFile

; 192  :     {
; 193  :         LARGE_INTEGER Filesize;
; 194  :         if(GetFileSizeEx(FileHandle, &Filesize))

  0005a	48 8d 54 24 58	 lea	 rdx, QWORD PTR Filesize$2[rsp]
  0005f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR FileHandle$[rsp]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileSizeEx
  0006a	85 c0		 test	 eax, eax
  0006c	74 77		 je	 SHORT $LN4@LoadFile

; 195  :         {
; 196  :             FileData = VirtualAlloc(0, Filesize.LowPart, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);

  0006e	8b 44 24 58	 mov	 eax, DWORD PTR Filesize$2[rsp]
  00072	41 b9 04 00 00
	00		 mov	 r9d, 4
  00078	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  0007e	8b d0		 mov	 edx, eax
  00080	33 c9		 xor	 ecx, ecx
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  00088	48 89 44 24 48	 mov	 QWORD PTR FileData$[rsp], rax

; 197  :             if(FileData)

  0008d	48 83 7c 24 48
	00		 cmp	 QWORD PTR FileData$[rsp], 0
  00093	74 50		 je	 SHORT $LN6@LoadFile

; 198  :             {
; 199  :                 DWORD BytesRead;
; 200  :                 if(ReadFile(FileHandle, FileData, Filesize.LowPart, &BytesRead, 0) &&

  00095	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0009e	4c 8d 4c 24 40	 lea	 r9, QWORD PTR BytesRead$1[rsp]
  000a3	44 8b 44 24 58	 mov	 r8d, DWORD PTR Filesize$2[rsp]
  000a8	48 8b 54 24 48	 mov	 rdx, QWORD PTR FileData$[rsp]
  000ad	48 8b 4c 24 50	 mov	 rcx, QWORD PTR FileHandle$[rsp]
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReadFile
  000b8	85 c0		 test	 eax, eax
  000ba	74 17		 je	 SHORT $LN8@LoadFile
  000bc	8b 44 24 40	 mov	 eax, DWORD PTR BytesRead$1[rsp]
  000c0	39 44 24 58	 cmp	 DWORD PTR Filesize$2[rsp], eax
  000c4	75 0d		 jne	 SHORT $LN8@LoadFile

; 201  :                    (Filesize.LowPart == BytesRead))
; 202  :                 {
; 203  :                     *Size = (uint32)BytesRead;

  000c6	48 8b 44 24 78	 mov	 rax, QWORD PTR Size$[rsp]
  000cb	8b 4c 24 40	 mov	 ecx, DWORD PTR BytesRead$1[rsp]
  000cf	89 08		 mov	 DWORD PTR [rax], ecx

; 204  :                     // It worked!
; 205  :                 }
; 206  :                 else

  000d1	eb 12		 jmp	 SHORT $LN9@LoadFile
$LN8@LoadFile:

; 207  :                 {
; 208  :                     Assert(0);

  000d3	33 c0		 xor	 eax, eax
  000d5	83 f8 01	 cmp	 eax, 1
  000d8	74 0b		 je	 SHORT $LN10@LoadFile
  000da	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN10@LoadFile:
$LN9@LoadFile:
$LN6@LoadFile:
$LN4@LoadFile:

; 209  :                 }
; 210  :             }
; 211  :             else
; 212  :             {
; 213  :             }   
; 214  :         }
; 215  :         else
; 216  :         {
; 217  :         }
; 218  :     }
; 219  :     else

  000e5	eb 12		 jmp	 SHORT $LN3@LoadFile
$LN2@LoadFile:

; 220  :     {
; 221  :         Assert(0);

  000e7	33 c0		 xor	 eax, eax
  000e9	83 f8 01	 cmp	 eax, 1
  000ec	74 0b		 je	 SHORT $LN11@LoadFile
  000ee	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN11@LoadFile:
$LN3@LoadFile:

; 222  :     }
; 223  :     return(FileData);

  000f9	48 8b 44 24 48	 mov	 rax, QWORD PTR FileData$[rsp]

; 224  : }

  000fe	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00102	c3		 ret	 0
?LoadFile@@YAPEAXPEADPEAI@Z ENDP			; LoadFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
tv64 = 32
tv67 = 36
tv70 = 40
tv73 = 44
tv82 = 48
tv89 = 52
tv128 = 56
tv135 = 60
tv142 = 64
tv149 = 68
tv156 = 72
tv163 = 76
tv75 = 80
WasDown$1 = 88
IsDown$2 = 92
AltPressed$3 = 96
Result$ = 104
WindowHandle$ = 128
Message$ = 136
wParam$ = 144
lParam$ = 152
?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z PROC		; WinInputCallback

; 67   : {

$LN51:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 68   :     LRESULT Result = 0;

  00017	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR Result$[rsp], 0

; 69   :     
; 70   :     switch(Message) 

  00020	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR Message$[rsp]
  00027	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  0002b	83 7c 24 20 10	 cmp	 DWORD PTR tv64[rsp], 16
  00030	77 21		 ja	 SHORT $LN48@WinInputCa
  00032	83 7c 24 20 10	 cmp	 DWORD PTR tv64[rsp], 16
  00037	74 59		 je	 SHORT $LN8@WinInputCa
  00039	83 7c 24 20 01	 cmp	 DWORD PTR tv64[rsp], 1
  0003e	74 48		 je	 SHORT $LN6@WinInputCa
  00040	83 7c 24 20 02	 cmp	 DWORD PTR tv64[rsp], 2
  00045	74 5a		 je	 SHORT $LN9@WinInputCa
  00047	83 7c 24 20 05	 cmp	 DWORD PTR tv64[rsp], 5
  0004c	74 3f		 je	 SHORT $LN7@WinInputCa
  0004e	e9 d2 03 00 00	 jmp	 $LN24@WinInputCa
$LN48@WinInputCa:
  00053	81 7c 24 20 00
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 256 ; 00000100H
  0005b	0f 82 c4 03 00
	00		 jb	 $LN24@WinInputCa
  00061	81 7c 24 20 01
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 257 ; 00000101H
  00069	76 3b		 jbe	 SHORT $LN10@WinInputCa
  0006b	81 7c 24 20 03
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 259 ; 00000103H
  00073	0f 86 ac 03 00
	00		 jbe	 $LN24@WinInputCa
  00079	81 7c 24 20 05
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 261 ; 00000105H
  00081	76 23		 jbe	 SHORT $LN10@WinInputCa
  00083	e9 9d 03 00 00	 jmp	 $LN24@WinInputCa
$LN6@WinInputCa:

; 71   :     { 
; 72   :         case WM_CREATE:
; 73   :         {
; 74   :             // Initialize the window. 
; 75   :             break; 

  00088	e9 c2 03 00 00	 jmp	 $LN2@WinInputCa
$LN7@WinInputCa:

; 76   :         }
; 77   :         
; 78   :         case WM_SIZE:
; 79   :         {
; 80   :             // Set the size and position of the window. 
; 81   :             break;

  0008d	e9 bd 03 00 00	 jmp	 $LN2@WinInputCa
$LN8@WinInputCa:

; 82   :         }
; 83   :         case WM_CLOSE:
; 84   :         {
; 85   :             GlobalRunning = false;

  00092	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0

; 86   :             break;

  0009c	e9 ae 03 00 00	 jmp	 $LN2@WinInputCa
$LN9@WinInputCa:

; 87   :         }
; 88   :         case WM_DESTROY:
; 89   :         {
; 90   :             break;

  000a1	e9 a9 03 00 00	 jmp	 $LN2@WinInputCa
$LN10@WinInputCa:

; 91   :         }
; 92   :         case WM_SYSKEYDOWN:
; 93   :         case WM_SYSKEYUP:
; 94   :         case WM_KEYDOWN:
; 95   :         case WM_KEYUP:
; 96   :         {
; 97   :             bool32 IsDown = ((lParam & (1<<31)) == 0);

  000a6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR lParam$[rsp]
  000ae	48 25 00 00 00
	80		 and	 rax, -2147483648	; ffffffff80000000H
  000b4	48 85 c0	 test	 rax, rax
  000b7	75 0a		 jne	 SHORT $LN26@WinInputCa
  000b9	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  000c1	eb 08		 jmp	 SHORT $LN27@WinInputCa
$LN26@WinInputCa:
  000c3	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN27@WinInputCa:
  000cb	8b 44 24 24	 mov	 eax, DWORD PTR tv67[rsp]
  000cf	89 44 24 5c	 mov	 DWORD PTR IsDown$2[rsp], eax

; 98   :             bool32 WasDown = ((lParam & (1<<30)) != 0);

  000d3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR lParam$[rsp]
  000db	48 25 00 00 00
	40		 and	 rax, 1073741824		; 40000000H
  000e1	48 85 c0	 test	 rax, rax
  000e4	74 0a		 je	 SHORT $LN28@WinInputCa
  000e6	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  000ee	eb 08		 jmp	 SHORT $LN29@WinInputCa
$LN28@WinInputCa:
  000f0	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN29@WinInputCa:
  000f8	8b 44 24 28	 mov	 eax, DWORD PTR tv70[rsp]
  000fc	89 44 24 58	 mov	 DWORD PTR WasDown$1[rsp], eax

; 99   : 
; 100  :             // NOTE: Alt only on SYSDOWN messages
; 101  :             bool32 AltPressed = ((lParam & (1<<29)) != 0);

  00100	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR lParam$[rsp]
  00108	48 25 00 00 00
	20		 and	 rax, 536870912		; 20000000H
  0010e	48 85 c0	 test	 rax, rax
  00111	74 0a		 je	 SHORT $LN30@WinInputCa
  00113	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  0011b	eb 08		 jmp	 SHORT $LN31@WinInputCa
$LN30@WinInputCa:
  0011d	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN31@WinInputCa:
  00125	8b 44 24 2c	 mov	 eax, DWORD PTR tv73[rsp]
  00129	89 44 24 60	 mov	 DWORD PTR AltPressed$3[rsp], eax

; 102  :               
; 103  :             if(IsDown != WasDown)

  0012d	8b 44 24 58	 mov	 eax, DWORD PTR WasDown$1[rsp]
  00131	39 44 24 5c	 cmp	 DWORD PTR IsDown$2[rsp], eax
  00135	0f 84 e8 02 00
	00		 je	 $LN11@WinInputCa

; 104  :             {               
; 105  :                 switch(wParam)

  0013b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR wParam$[rsp]
  00143	48 89 44 24 50	 mov	 QWORD PTR tv75[rsp], rax
  00148	48 8b 44 24 50	 mov	 rax, QWORD PTR tv75[rsp]
  0014d	48 83 e8 0d	 sub	 rax, 13
  00151	48 89 44 24 50	 mov	 QWORD PTR tv75[rsp], rax
  00156	48 83 7c 24 50
	66		 cmp	 QWORD PTR tv75[rsp], 102 ; 00000066H
  0015c	0f 87 c1 02 00
	00		 ja	 $LN4@WinInputCa
  00162	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:__ImageBase
  00169	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv75[rsp]
  0016e	0f b6 8c 08 00
	00 00 00	 movzx	 ecx, BYTE PTR $LN49@WinInputCa[rax+rcx]
  00176	8b 8c 88 00 00
	00 00		 mov	 ecx, DWORD PTR $LN50@WinInputCa[rax+rcx*4]
  0017d	48 03 c8	 add	 rcx, rax
  00180	ff e1		 jmp	 rcx
$LN12@WinInputCa:

; 106  :                 {
; 107  :                     // NOTE: Up and down changes the octave the keys are in
; 108  :                     case VK_UP:
; 109  :                     {
; 110  :                         OutputDebugString("Up");

  00182	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG87607
  00189	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 111  :                         WinInput.buttons[input::B_UP] = !WinInput.buttons[input::B_UP];

  0018f	b8 04 00 00 00	 mov	 eax, 4
  00194	48 6b c0 00	 imul	 rax, rax, 0
  00198	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0019f	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  001a3	75 0a		 jne	 SHORT $LN32@WinInputCa
  001a5	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  001ad	eb 08		 jmp	 SHORT $LN33@WinInputCa
$LN32@WinInputCa:
  001af	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN33@WinInputCa:
  001b7	b8 04 00 00 00	 mov	 eax, 4
  001bc	48 6b c0 00	 imul	 rax, rax, 0
  001c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  001c7	8b 54 24 30	 mov	 edx, DWORD PTR tv82[rsp]
  001cb	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 112  :                         break;

  001ce	e9 50 02 00 00	 jmp	 $LN4@WinInputCa
$LN13@WinInputCa:

; 113  :                     }
; 114  :                     case VK_DOWN:
; 115  :                     {
; 116  :                         OutputDebugString("Up");

  001d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG87609
  001da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 117  :                         WinInput.buttons[input::B_DOWN] = !WinInput.buttons[input::B_DOWN];

  001e0	b8 04 00 00 00	 mov	 eax, 4
  001e5	48 6b c0 01	 imul	 rax, rax, 1
  001e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  001f0	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  001f4	75 0a		 jne	 SHORT $LN34@WinInputCa
  001f6	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv89[rsp], 1
  001fe	eb 08		 jmp	 SHORT $LN35@WinInputCa
$LN34@WinInputCa:
  00200	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv89[rsp], 0
$LN35@WinInputCa:
  00208	b8 04 00 00 00	 mov	 eax, 4
  0020d	48 6b c0 01	 imul	 rax, rax, 1
  00211	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00218	8b 54 24 34	 mov	 edx, DWORD PTR tv89[rsp]
  0021c	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 118  :                         break;

  0021f	e9 ff 01 00 00	 jmp	 $LN4@WinInputCa
$LN14@WinInputCa:

; 119  :                     }
; 120  :                     case VK_LEFT:
; 121  :                     {
; 122  :                         OutputDebugString("Up");

  00224	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG87611
  0022b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 123  :                         WinInput.buttons[input::B_LEFT] = !WinInput.buttons[input::B_LEFT];

  00231	b8 04 00 00 00	 mov	 eax, 4
  00236	48 6b c0 02	 imul	 rax, rax, 2
  0023a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00241	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  00245	75 0a		 jne	 SHORT $LN36@WinInputCa
  00247	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv128[rsp], 1
  0024f	eb 08		 jmp	 SHORT $LN37@WinInputCa
$LN36@WinInputCa:
  00251	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN37@WinInputCa:
  00259	b8 04 00 00 00	 mov	 eax, 4
  0025e	48 6b c0 02	 imul	 rax, rax, 2
  00262	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00269	8b 54 24 38	 mov	 edx, DWORD PTR tv128[rsp]
  0026d	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 124  :                         break;

  00270	e9 ae 01 00 00	 jmp	 $LN4@WinInputCa
$LN15@WinInputCa:

; 125  :                     }
; 126  :                     case VK_RIGHT:
; 127  :                     {
; 128  :                         OutputDebugString("Up");

  00275	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG87613
  0027c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 129  :                         WinInput.buttons[input::B_RIGHT] = !WinInput.buttons[input::B_RIGHT];

  00282	b8 04 00 00 00	 mov	 eax, 4
  00287	48 6b c0 03	 imul	 rax, rax, 3
  0028b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00292	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  00296	75 0a		 jne	 SHORT $LN38@WinInputCa
  00298	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv135[rsp], 1
  002a0	eb 08		 jmp	 SHORT $LN39@WinInputCa
$LN38@WinInputCa:
  002a2	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN39@WinInputCa:
  002aa	b8 04 00 00 00	 mov	 eax, 4
  002af	48 6b c0 03	 imul	 rax, rax, 3
  002b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  002ba	8b 54 24 3c	 mov	 edx, DWORD PTR tv135[rsp]
  002be	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 130  :                         break;

  002c1	e9 5d 01 00 00	 jmp	 $LN4@WinInputCa
$LN16@WinInputCa:

; 131  :                     }
; 132  :                     case 'Z':
; 133  :                     {
; 134  :                         OutputDebugString("Up");

  002c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG87615
  002cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 135  :                         WinInput.buttons[input::B_A] = !WinInput.buttons[input::B_A];

  002d3	b8 04 00 00 00	 mov	 eax, 4
  002d8	48 6b c0 04	 imul	 rax, rax, 4
  002dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  002e3	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  002e7	75 0a		 jne	 SHORT $LN40@WinInputCa
  002e9	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv142[rsp], 1
  002f1	eb 08		 jmp	 SHORT $LN41@WinInputCa
$LN40@WinInputCa:
  002f3	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN41@WinInputCa:
  002fb	b8 04 00 00 00	 mov	 eax, 4
  00300	48 6b c0 04	 imul	 rax, rax, 4
  00304	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0030b	8b 54 24 40	 mov	 edx, DWORD PTR tv142[rsp]
  0030f	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 136  :                         break;

  00312	e9 0c 01 00 00	 jmp	 $LN4@WinInputCa
$LN17@WinInputCa:

; 137  :                     }
; 138  :                     case 'X':
; 139  :                     {
; 140  :                         OutputDebugString("Up");

  00317	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG87617
  0031e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 141  :                         WinInput.buttons[input::B_B] = !WinInput.buttons[input::B_B];

  00324	b8 04 00 00 00	 mov	 eax, 4
  00329	48 6b c0 05	 imul	 rax, rax, 5
  0032d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00334	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  00338	75 0a		 jne	 SHORT $LN42@WinInputCa
  0033a	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv149[rsp], 1
  00342	eb 08		 jmp	 SHORT $LN43@WinInputCa
$LN42@WinInputCa:
  00344	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
$LN43@WinInputCa:
  0034c	b8 04 00 00 00	 mov	 eax, 4
  00351	48 6b c0 05	 imul	 rax, rax, 5
  00355	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0035c	8b 54 24 44	 mov	 edx, DWORD PTR tv149[rsp]
  00360	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 142  :                         break;

  00363	e9 bb 00 00 00	 jmp	 $LN4@WinInputCa
$LN18@WinInputCa:

; 143  :                     }
; 144  :                     case VK_RETURN:
; 145  :                     {
; 146  :                         OutputDebugString("Up");

  00368	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG87619
  0036f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 147  :                         WinInput.buttons[input::B_START] = !WinInput.buttons[input::B_START];

  00375	b8 04 00 00 00	 mov	 eax, 4
  0037a	48 6b c0 06	 imul	 rax, rax, 6
  0037e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00385	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  00389	75 0a		 jne	 SHORT $LN44@WinInputCa
  0038b	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv156[rsp], 1
  00393	eb 08		 jmp	 SHORT $LN45@WinInputCa
$LN44@WinInputCa:
  00395	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
$LN45@WinInputCa:
  0039d	b8 04 00 00 00	 mov	 eax, 4
  003a2	48 6b c0 06	 imul	 rax, rax, 6
  003a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  003ad	8b 54 24 48	 mov	 edx, DWORD PTR tv156[rsp]
  003b1	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 148  :                         break;

  003b4	eb 6d		 jmp	 SHORT $LN4@WinInputCa
$LN19@WinInputCa:

; 149  :                     }
; 150  :                     case VK_SHIFT:
; 151  :                     {
; 152  :                         OutputDebugString("Up");

  003b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG87621
  003bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 153  :                         WinInput.buttons[input::B_SELECT] = !WinInput.buttons[input::B_SELECT];

  003c3	b8 04 00 00 00	 mov	 eax, 4
  003c8	48 6b c0 07	 imul	 rax, rax, 7
  003cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  003d3	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  003d7	75 0a		 jne	 SHORT $LN46@WinInputCa
  003d9	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv163[rsp], 1
  003e1	eb 08		 jmp	 SHORT $LN47@WinInputCa
$LN46@WinInputCa:
  003e3	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv163[rsp], 0
$LN47@WinInputCa:
  003eb	b8 04 00 00 00	 mov	 eax, 4
  003f0	48 6b c0 07	 imul	 rax, rax, 7
  003f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  003fb	8b 54 24 4c	 mov	 edx, DWORD PTR tv163[rsp]
  003ff	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 154  :                         break;

  00402	eb 1f		 jmp	 SHORT $LN4@WinInputCa

; 155  :                     }
; 156  :                     case VK_SPACE:
; 157  :                     {
; 158  :                         
; 159  :                         break;

  00404	eb 1d		 jmp	 SHORT $LN4@WinInputCa
$LN21@WinInputCa:

; 160  :                     }
; 161  :                     case VK_ESCAPE:
; 162  :                     {
; 163  :                         GlobalRunning = false;

  00406	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0

; 164  :                         break;

  00410	eb 11		 jmp	 SHORT $LN4@WinInputCa
$LN22@WinInputCa:

; 165  :                     }
; 166  :                     case VK_F4:
; 167  :                     {
; 168  :                         if(AltPressed)

  00412	83 7c 24 60 00	 cmp	 DWORD PTR AltPressed$3[rsp], 0
  00417	74 0a		 je	 SHORT $LN23@WinInputCa

; 169  :                         {
; 170  :                             GlobalRunning = false;

  00419	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0
$LN23@WinInputCa:
$LN4@WinInputCa:
$LN11@WinInputCa:

; 171  :                         }
; 172  :                         break;
; 173  :                     }
; 174  :                 }
; 175  :             }
; 176  :             break;

  00423	eb 2a		 jmp	 SHORT $LN2@WinInputCa
$LN24@WinInputCa:

; 177  :         }            
; 178  :         default:
; 179  :         {
; 180  :             Result = DefWindowProc(WindowHandle, Message, wParam, lParam); 

  00425	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR lParam$[rsp]
  0042d	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR wParam$[rsp]
  00435	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR Message$[rsp]
  0043c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR WindowHandle$[rsp]
  00444	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DefWindowProcA
  0044a	48 89 44 24 68	 mov	 QWORD PTR Result$[rsp], rax
$LN2@WinInputCa:

; 181  :         }
; 182  :     }
; 183  :     return Result;

  0044f	48 8b 44 24 68	 mov	 rax, QWORD PTR Result$[rsp]

; 184  : }

  00454	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00458	c3		 ret	 0
  00459	0f 1f 00	 npad	 3
$LN50@WinInputCa:
  0045c	00 00 00 00	 DD	 $LN18@WinInputCa
  00460	00 00 00 00	 DD	 $LN19@WinInputCa
  00464	00 00 00 00	 DD	 $LN21@WinInputCa
  00468	00 00 00 00	 DD	 $LN14@WinInputCa
  0046c	00 00 00 00	 DD	 $LN12@WinInputCa
  00470	00 00 00 00	 DD	 $LN15@WinInputCa
  00474	00 00 00 00	 DD	 $LN13@WinInputCa
  00478	00 00 00 00	 DD	 $LN17@WinInputCa
  0047c	00 00 00 00	 DD	 $LN16@WinInputCa
  00480	00 00 00 00	 DD	 $LN22@WinInputCa
  00484	00 00 00 00	 DD	 $LN4@WinInputCa
$LN49@WinInputCa:
  00488	00		 DB	 0
  00489	0a		 DB	 10
  0048a	0a		 DB	 10
  0048b	01		 DB	 1
  0048c	0a		 DB	 10
  0048d	0a		 DB	 10
  0048e	0a		 DB	 10
  0048f	0a		 DB	 10
  00490	0a		 DB	 10
  00491	0a		 DB	 10
  00492	0a		 DB	 10
  00493	0a		 DB	 10
  00494	0a		 DB	 10
  00495	0a		 DB	 10
  00496	02		 DB	 2
  00497	0a		 DB	 10
  00498	0a		 DB	 10
  00499	0a		 DB	 10
  0049a	0a		 DB	 10
  0049b	0a		 DB	 10
  0049c	0a		 DB	 10
  0049d	0a		 DB	 10
  0049e	0a		 DB	 10
  0049f	0a		 DB	 10
  004a0	03		 DB	 3
  004a1	04		 DB	 4
  004a2	05		 DB	 5
  004a3	06		 DB	 6
  004a4	0a		 DB	 10
  004a5	0a		 DB	 10
  004a6	0a		 DB	 10
  004a7	0a		 DB	 10
  004a8	0a		 DB	 10
  004a9	0a		 DB	 10
  004aa	0a		 DB	 10
  004ab	0a		 DB	 10
  004ac	0a		 DB	 10
  004ad	0a		 DB	 10
  004ae	0a		 DB	 10
  004af	0a		 DB	 10
  004b0	0a		 DB	 10
  004b1	0a		 DB	 10
  004b2	0a		 DB	 10
  004b3	0a		 DB	 10
  004b4	0a		 DB	 10
  004b5	0a		 DB	 10
  004b6	0a		 DB	 10
  004b7	0a		 DB	 10
  004b8	0a		 DB	 10
  004b9	0a		 DB	 10
  004ba	0a		 DB	 10
  004bb	0a		 DB	 10
  004bc	0a		 DB	 10
  004bd	0a		 DB	 10
  004be	0a		 DB	 10
  004bf	0a		 DB	 10
  004c0	0a		 DB	 10
  004c1	0a		 DB	 10
  004c2	0a		 DB	 10
  004c3	0a		 DB	 10
  004c4	0a		 DB	 10
  004c5	0a		 DB	 10
  004c6	0a		 DB	 10
  004c7	0a		 DB	 10
  004c8	0a		 DB	 10
  004c9	0a		 DB	 10
  004ca	0a		 DB	 10
  004cb	0a		 DB	 10
  004cc	0a		 DB	 10
  004cd	0a		 DB	 10
  004ce	0a		 DB	 10
  004cf	0a		 DB	 10
  004d0	0a		 DB	 10
  004d1	0a		 DB	 10
  004d2	0a		 DB	 10
  004d3	07		 DB	 7
  004d4	0a		 DB	 10
  004d5	08		 DB	 8
  004d6	0a		 DB	 10
  004d7	0a		 DB	 10
  004d8	0a		 DB	 10
  004d9	0a		 DB	 10
  004da	0a		 DB	 10
  004db	0a		 DB	 10
  004dc	0a		 DB	 10
  004dd	0a		 DB	 10
  004de	0a		 DB	 10
  004df	0a		 DB	 10
  004e0	0a		 DB	 10
  004e1	0a		 DB	 10
  004e2	0a		 DB	 10
  004e3	0a		 DB	 10
  004e4	0a		 DB	 10
  004e5	0a		 DB	 10
  004e6	0a		 DB	 10
  004e7	0a		 DB	 10
  004e8	0a		 DB	 10
  004e9	0a		 DB	 10
  004ea	0a		 DB	 10
  004eb	0a		 DB	 10
  004ec	0a		 DB	 10
  004ed	0a		 DB	 10
  004ee	09		 DB	 9
?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z ENDP		; WinInputCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  00018	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  0001d	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00022	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00027	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0002c	45 33 c0	 xor	 r8d, r8d
  0002f	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00039	e8 00 00 00 00	 call	 _vsprintf_l
  0003e	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

  00042	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

  0004b	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1788 : }

  0004f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00053	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00027	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  0002c	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00038	e8 00 00 00 00	 call	 _vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 83 c8 01	 or	 rax, 1
  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00029	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00033	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00038	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003d	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00047	48 8b c8	 mov	 rcx, rax
  0004a	e8 00 00 00 00	 call	 __stdio_common_vsprintf
  0004f	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00053	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00058	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005a	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00062	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00064	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  00068	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006c	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1391 : }

  00070	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00074	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File u:\programs\visual studio\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 81   :     static unsigned __int64 _OptionsStorage;
; 82   :     return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 83   : }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
i$1 = 96
Flags6$ = 97
RomPrgBankCount$ = 98
MapperNumber$ = 99
ResScale$ = 100
Flags7$ = 101
WindowHeight$ = 104
WindowWidth$ = 108
TempCount$2 = 112
RenderScaleHeight$ = 116
RenderScaleWidth$ = 120
RomData$ = 128
RomChrBankCount$ = 136
RomPrgRamSize$ = 137
Flags9$ = 138
Flags10$ = 139
MemPrgBank1$ = 140
MemPrgBank2$ = 144
Window$3 = 152
TotalMemorySize$ = 160
tv161 = 164
PpuMemorySize$ = 168
CpuMemorySize$ = 172
RomPrgData$ = 176
Memory$ = 184
DeviceContext$4 = 192
FileSize$ = 200
Filename$ = 208
RomChrData$ = 216
LastCounter$5 = 224
LastCycles$6 = 232
PpuData$ = 240
WindowClass$ = 288
Message$7 = 368
CpuData$ = 416
ScreenBackBuffer$ = 448
Buffer$8 = 528
__$ArrayPad$ = 536
WindowInstance$ = 560
PrevWindowInstance$ = 568
CommandLine$ = 576
CommandShow$ = 584
WinMain	PROC

; 371  : {

$LN31:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 20 02
	00 00		 sub	 rsp, 544		; 00000220H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 18
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 372  :     // TODO: I could reduce the memory usage as the nes does not actually use 64 kbs,
; 373  :     //       the nes mirrors certain sections of address space
; 374  :     uint32 CpuMemorySize = Kilobytes(64);

  0002e	c7 84 24 ac 00
	00 00 00 00 01
	00		 mov	 DWORD PTR CpuMemorySize$[rsp], 65536 ; 00010000H

; 375  :     uint32 PpuMemorySize = Kilobytes(64);

  00039	c7 84 24 a8 00
	00 00 00 00 01
	00		 mov	 DWORD PTR PpuMemorySize$[rsp], 65536 ; 00010000H

; 376  :     uint32 TotalMemorySize = CpuMemorySize + PpuMemorySize;

  00044	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR PpuMemorySize$[rsp]
  0004b	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR CpuMemorySize$[rsp]
  00052	03 c8		 add	 ecx, eax
  00054	8b c1		 mov	 eax, ecx
  00056	89 84 24 a0 00
	00 00		 mov	 DWORD PTR TotalMemorySize$[rsp], eax

; 377  : 
; 378  :     // NOTE: Aiming to have one memory allocation for the whole program.
; 379  :     // TODO: Loading the cartridge also creates memory. Figure out to include in this call.
; 380  :     uint8 * Memory = (uint8 *)VirtualAlloc(0, (size_t)TotalMemorySize, MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);

  0005d	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR TotalMemorySize$[rsp]
  00064	41 b9 04 00 00
	00		 mov	 r9d, 4
  0006a	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  00070	8b d0		 mov	 edx, eax
  00072	33 c9		 xor	 ecx, ecx
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  0007a	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR Memory$[rsp], rax

; 381  : 
; 382  :     cpu CpuData = {};

  00082	48 8d 84 24 a0
	01 00 00	 lea	 rax, QWORD PTR CpuData$[rsp]
  0008a	48 8b f8	 mov	 rdi, rax
  0008d	33 c0		 xor	 eax, eax
  0008f	b9 18 00 00 00	 mov	 ecx, 24
  00094	f3 aa		 rep stosb

; 383  :     CpuData.MemoryOffset = (uint64)Memory; 

  00096	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR Memory$[rsp]
  0009e	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR CpuData$[rsp+8], rax

; 384  : 
; 385  :     
; 386  :     ppu PpuData = {};    

  000a6	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR PpuData$[rsp]
  000ae	48 8b f8	 mov	 rdi, rax
  000b1	33 c0		 xor	 eax, eax
  000b3	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  000b8	f3 aa		 rep stosb

; 387  :     PpuData.MemoryOffset = (uint64)Memory + Kilobytes(64);

  000ba	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR Memory$[rsp]
  000c2	48 05 00 00 01
	00		 add	 rax, 65536		; 00010000H
  000c8	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR PpuData$[rsp+8], rax

; 388  :       
; 389  : #define PPU_REG_ADRS 0x2000    
; 390  :     PpuData.Registers = (ppu_registers *)(CpuData.MemoryOffset + PPU_REG_ADRS);

  000d0	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR CpuData$[rsp+8]
  000d8	48 05 00 20 00
	00		 add	 rax, 8192		; 00002000H
  000de	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR PpuData$[rsp], rax

; 391  :     PpuData.Registers->Status = (1 << 7) | (1 << 5); 

  000e6	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR PpuData$[rsp]
  000ee	c6 40 02 a0	 mov	 BYTE PTR [rax+2], 160	; 000000a0H

; 392  :     
; 393  :     
; 394  :     // Reading rom file
; 395  :     char * Filename = "Pacman.nes";

  000f2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88284
  000f9	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR Filename$[rsp], rax

; 396  :     uint32 FileSize;
; 397  :     uint8 *RomData = (uint8 *)LoadFile(Filename, &FileSize);

  00101	48 8d 94 24 c8
	00 00 00	 lea	 rdx, QWORD PTR FileSize$[rsp]
  00109	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR Filename$[rsp]
  00111	e8 00 00 00 00	 call	 ?LoadFile@@YAPEAXPEADPEAI@Z ; LoadFile
  00116	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR RomData$[rsp], rax

; 398  : 
; 399  :     // NOTE: Check for correct header
; 400  :     if(RomData[0] != 'N' || RomData[1] != 'E' || RomData[2] != 'S')

  0011e	b8 01 00 00 00	 mov	 eax, 1
  00123	48 6b c0 00	 imul	 rax, rax, 0
  00127	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR RomData$[rsp]
  0012f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00133	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  00136	75 34		 jne	 SHORT $LN12@WinMain
  00138	b8 01 00 00 00	 mov	 eax, 1
  0013d	48 6b c0 01	 imul	 rax, rax, 1
  00141	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR RomData$[rsp]
  00149	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0014d	83 f8 45	 cmp	 eax, 69			; 00000045H
  00150	75 1a		 jne	 SHORT $LN12@WinMain
  00152	b8 01 00 00 00	 mov	 eax, 1
  00157	48 6b c0 02	 imul	 rax, rax, 2
  0015b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR RomData$[rsp]
  00163	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00167	83 f8 53	 cmp	 eax, 83			; 00000053H
  0016a	74 12		 je	 SHORT $LN11@WinMain
$LN12@WinMain:

; 401  :     {
; 402  :         Assert(0);   

  0016c	33 c0		 xor	 eax, eax
  0016e	83 f8 01	 cmp	 eax, 1
  00171	74 0b		 je	 SHORT $LN13@WinMain
  00173	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN13@WinMain:
$LN11@WinMain:

; 403  :     }
; 404  : 
; 405  :     // NOTE: Read header
; 406  :     uint8 RomPrgBankCount = RomData[4];

  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 04	 imul	 rax, rax, 4
  00187	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR RomData$[rsp]
  0018f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00193	88 44 24 62	 mov	 BYTE PTR RomPrgBankCount$[rsp], al

; 407  :     uint8 RomChrBankCount = RomData[5];

  00197	b8 01 00 00 00	 mov	 eax, 1
  0019c	48 6b c0 05	 imul	 rax, rax, 5
  001a0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR RomData$[rsp]
  001a8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ac	88 84 24 88 00
	00 00		 mov	 BYTE PTR RomChrBankCount$[rsp], al

; 408  : 
; 409  :     uint8 Flags6 = RomData[6];

  001b3	b8 01 00 00 00	 mov	 eax, 1
  001b8	48 6b c0 06	 imul	 rax, rax, 6
  001bc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR RomData$[rsp]
  001c4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c8	88 44 24 61	 mov	 BYTE PTR Flags6$[rsp], al

; 410  :     uint8 Flags7 = RomData[7];

  001cc	b8 01 00 00 00	 mov	 eax, 1
  001d1	48 6b c0 07	 imul	 rax, rax, 7
  001d5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR RomData$[rsp]
  001dd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001e1	88 44 24 65	 mov	 BYTE PTR Flags7$[rsp], al

; 411  : 
; 412  :     uint8 RomPrgRamSize = RomData[8];

  001e5	b8 01 00 00 00	 mov	 eax, 1
  001ea	48 6b c0 08	 imul	 rax, rax, 8
  001ee	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR RomData$[rsp]
  001f6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001fa	88 84 24 89 00
	00 00		 mov	 BYTE PTR RomPrgRamSize$[rsp], al

; 413  :     uint8 Flags9 = RomData[9];

  00201	b8 01 00 00 00	 mov	 eax, 1
  00206	48 6b c0 09	 imul	 rax, rax, 9
  0020a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR RomData$[rsp]
  00212	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00216	88 84 24 8a 00
	00 00		 mov	 BYTE PTR Flags9$[rsp], al

; 414  :     uint8 Flags10 = RomData[10];

  0021d	b8 01 00 00 00	 mov	 eax, 1
  00222	48 6b c0 0a	 imul	 rax, rax, 10
  00226	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR RomData$[rsp]
  0022e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00232	88 84 24 8b 00
	00 00		 mov	 BYTE PTR Flags10$[rsp], al

; 415  : 
; 416  :     uint8 *RomPrgData;
; 417  :     // NOTE: If trainer present. Data after header and before program data
; 418  :     if(Flags6 & (1 << 2))

  00239	0f b6 44 24 61	 movzx	 eax, BYTE PTR Flags6$[rsp]
  0023e	83 e0 04	 and	 eax, 4
  00241	85 c0		 test	 eax, eax
  00243	74 13		 je	 SHORT $LN14@WinMain

; 419  :     {
; 420  :         Assert(1); 

  00245	33 c0		 xor	 eax, eax
  00247	85 c0		 test	 eax, eax
  00249	74 0b		 je	 SHORT $LN16@WinMain
  0024b	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN16@WinMain:

; 421  :     }
; 422  :     else

  00256	eb 14		 jmp	 SHORT $LN15@WinMain
$LN14@WinMain:

; 423  :     {
; 424  :         RomPrgData = RomData + 16;

  00258	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR RomData$[rsp]
  00260	48 83 c0 10	 add	 rax, 16
  00264	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR RomPrgData$[rsp], rax
$LN15@WinMain:

; 425  :     }
; 426  : 
; 427  :     uint8 *RomChrData = RomPrgData + (RomPrgBankCount * Kilobytes(16));

  0026c	0f b6 44 24 62	 movzx	 eax, BYTE PTR RomPrgBankCount$[rsp]
  00271	48 69 c0 00 40
	00 00		 imul	 rax, rax, 16384		; 00004000H
  00278	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR RomPrgData$[rsp]
  00280	48 03 c8	 add	 rcx, rax
  00283	48 8b c1	 mov	 rax, rcx
  00286	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR RomChrData$[rsp], rax

; 428  :     // TODO: Implement Playchoice roms 
; 429  : 
; 430  : 
; 431  : 
; 432  : // NOTE: This is the two banks of memory that are currently loaded
; 433  : //       The mapper number will specify which initial banks are loaded
; 434  : //       Program will then change these banks while running.
; 435  : //       These pointers reference the rom memory.
; 436  : //       Offset is required to make relative to memory mapped address    
; 437  : 
; 438  :     
; 439  :     // TODO: Mappers
; 440  :     // NOTE: MY UNDERSTANDING OF HOW BANK REGISTERS WORK (SO FAR)
; 441  :     //
; 442  :     //       This is for M001. 
; 443  :     //       On the catridge, 4 registers are stored, each is 5 bits wide
; 444  :     //       These registers cannot be accessed directly, but can be set.
; 445  :     //       To set, writing to the prg rom 5 times will save the value.
; 446  :     //       To select the register to write too, the fifth write will be
; 447  :     //       to one of the prg banks. Only the fifth write will write to the specified
; 448  :     //       bank. If you write to 0x8000 4 times, then 0xE000 the fifth, only
; 449  :     //       0xE000 register will be written too. 0xE004 counts as 0xE000, and 0x8001
; 450  :     //       counts as 0x8000
; 451  :     //       There is a temporary port too
; 452  :     //       This is a byte with a reset bit and the bit just entered.
; 453  :     //       If reset is hit, then bit entered, plus temporary reg is cleared.
; 454  :     //       If 5 bits enter through port, then reg is saved
; 455  : 
; 456  :     // TODO: This will change as I add program mappers 
; 457  :     uint16 MemPrgBank1 = 0x8000;

  0028e	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00293	66 89 84 24 8c
	00 00 00	 mov	 WORD PTR MemPrgBank1$[rsp], ax

; 458  :     uint16 MemPrgBank2 = 0xC000;

  0029b	b8 00 c0 00 00	 mov	 eax, 49152		; 0000c000H
  002a0	66 89 84 24 90
	00 00 00	 mov	 WORD PTR MemPrgBank2$[rsp], ax

; 459  :     
; 460  :     uint8 MapperNumber = (Flags7 & 0xF0) | (Flags6 >> 4);

  002a8	0f b6 44 24 65	 movzx	 eax, BYTE PTR Flags7$[rsp]
  002ad	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  002b2	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR Flags6$[rsp]
  002b7	c1 f9 04	 sar	 ecx, 4
  002ba	0b c1		 or	 eax, ecx
  002bc	88 44 24 63	 mov	 BYTE PTR MapperNumber$[rsp], al

; 461  :     switch(MapperNumber)

  002c0	0f b6 44 24 63	 movzx	 eax, BYTE PTR MapperNumber$[rsp]
  002c5	88 84 24 a4 00
	00 00		 mov	 BYTE PTR tv161[rsp], al
  002cc	80 bc 24 a4 00
	00 00 00	 cmp	 BYTE PTR tv161[rsp], 0
  002d4	74 02		 je	 SHORT $LN17@WinMain
  002d6	eb 6a		 jmp	 SHORT $LN21@WinMain
$LN17@WinMain:

; 462  :     {
; 463  :         case 0:
; 464  :         {
; 465  :             if(RomPrgBankCount == 1) {

  002d8	0f b6 44 24 62	 movzx	 eax, BYTE PTR RomPrgBankCount$[rsp]
  002dd	83 f8 01	 cmp	 eax, 1
  002e0	75 4c		 jne	 SHORT $LN18@WinMain

; 466  :                 cpyMemory((uint8 *)MemPrgBank1 + CpuData.MemoryOffset, RomPrgData, Kilobytes(16));

  002e2	0f b7 84 24 8c
	00 00 00	 movzx	 eax, WORD PTR MemPrgBank1$[rsp]
  002ea	48 03 84 24 a8
	01 00 00	 add	 rax, QWORD PTR CpuData$[rsp+8]
  002f2	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  002f7	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR RomPrgData$[rsp]
  002ff	48 8b c8	 mov	 rcx, rax
  00302	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 467  :                 cpyMemory((uint8 *)MemPrgBank2 + CpuData.MemoryOffset, RomPrgData, Kilobytes(16));

  00307	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR MemPrgBank2$[rsp]
  0030f	48 03 84 24 a8
	01 00 00	 add	 rax, QWORD PTR CpuData$[rsp+8]
  00317	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  0031c	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR RomPrgData$[rsp]
  00324	48 8b c8	 mov	 rcx, rax
  00327	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 468  :             }
; 469  :             else

  0032c	eb 12		 jmp	 SHORT $LN19@WinMain
$LN18@WinMain:

; 470  :                 Assert(0);

  0032e	33 c0		 xor	 eax, eax
  00330	83 f8 01	 cmp	 eax, 1
  00333	74 0b		 je	 SHORT $LN20@WinMain
  00335	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN20@WinMain:
$LN19@WinMain:

; 471  :             break;

  00340	eb 3c		 jmp	 SHORT $LN2@WinMain
$LN21@WinMain:

; 472  :         }
; 473  :         
; 474  :         default:
; 475  :         {
; 476  :             char Buffer[8];
; 477  :             sprintf(Buffer, "Error: Unknown mapper number = %d\n", MapperNumber);

  00342	0f b6 44 24 63	 movzx	 eax, BYTE PTR MapperNumber$[rsp]
  00347	44 8b c0	 mov	 r8d, eax
  0034a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG88296
  00351	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR Buffer$8[rsp]
  00359	e8 00 00 00 00	 call	 sprintf

; 478  :             OutputDebugString(Buffer);

  0035e	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR Buffer$8[rsp]
  00366	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 479  :             Assert(0);

  0036c	33 c0		 xor	 eax, eax
  0036e	83 f8 01	 cmp	 eax, 1
  00371	74 0b		 je	 SHORT $LN22@WinMain
  00373	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN22@WinMain:
$LN2@WinMain:

; 480  :             break;
; 481  :         }
; 482  :     }
; 483  :     
; 484  :     // NOTE: Load the program counter with the reset vector
; 485  :     CpuData.Registers.PrgCounter = readCpuMemory16(RESET_VEC, CpuData.MemoryOffset);

  0037e	48 8b 94 24 a8
	01 00 00	 mov	 rdx, QWORD PTR CpuData$[rsp+8]
  00386	66 b9 fc ff	 mov	 cx, 65532		; 0000fffcH
  0038a	e8 00 00 00 00	 call	 ?readCpuMemory16@@YAGG_K@Z ; readCpuMemory16
  0038f	66 89 84 24 a6
	01 00 00	 mov	 WORD PTR CpuData$[rsp+6], ax

; 486  : 
; 487  :     
; 488  :     // Screen back buffer creation
; 489  :     uint16 RenderScaleWidth = 256, RenderScaleHeight = 240;

  00397	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  0039c	66 89 44 24 78	 mov	 WORD PTR RenderScaleWidth$[rsp], ax
  003a1	b8 f0 00 00 00	 mov	 eax, 240		; 000000f0H
  003a6	66 89 44 24 74	 mov	 WORD PTR RenderScaleHeight$[rsp], ax

; 490  :     uint8 ResScale = 5;

  003ab	c6 44 24 64 05	 mov	 BYTE PTR ResScale$[rsp], 5

; 491  :     uint16 WindowWidth = RenderScaleWidth * ResScale, WindowHeight = RenderScaleHeight * ResScale;

  003b0	0f b7 44 24 78	 movzx	 eax, WORD PTR RenderScaleWidth$[rsp]
  003b5	0f b6 4c 24 64	 movzx	 ecx, BYTE PTR ResScale$[rsp]
  003ba	0f af c1	 imul	 eax, ecx
  003bd	66 89 44 24 6c	 mov	 WORD PTR WindowWidth$[rsp], ax
  003c2	0f b7 44 24 74	 movzx	 eax, WORD PTR RenderScaleHeight$[rsp]
  003c7	0f b6 4c 24 64	 movzx	 ecx, BYTE PTR ResScale$[rsp]
  003cc	0f af c1	 imul	 eax, ecx
  003cf	66 89 44 24 68	 mov	 WORD PTR WindowHeight$[rsp], ax

; 492  :     screen_buffer ScreenBackBuffer = {};

  003d4	48 8d 84 24 c0
	01 00 00	 lea	 rax, QWORD PTR ScreenBackBuffer$[rsp]
  003dc	48 8b f8	 mov	 rdi, rax
  003df	33 c0		 xor	 eax, eax
  003e1	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  003e6	f3 aa		 rep stosb

; 493  :     createBackBuffer(&ScreenBackBuffer, RenderScaleWidth, RenderScaleHeight);

  003e8	44 0f b7 44 24
	74		 movzx	 r8d, WORD PTR RenderScaleHeight$[rsp]
  003ee	0f b7 54 24 78	 movzx	 edx, WORD PTR RenderScaleWidth$[rsp]
  003f3	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR ScreenBackBuffer$[rsp]
  003fb	e8 00 00 00 00	 call	 ?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z ; createBackBuffer

; 494  :     
; 495  :     // Window Creation
; 496  :     WNDCLASSA WindowClass = {};

  00400	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR WindowClass$[rsp]
  00408	48 8b f8	 mov	 rdi, rax
  0040b	33 c0		 xor	 eax, eax
  0040d	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00412	f3 aa		 rep stosb

; 497  :     WindowClass.style = CS_HREDRAW | CS_VREDRAW;

  00414	c7 84 24 20 01
	00 00 03 00 00
	00		 mov	 DWORD PTR WindowClass$[rsp], 3

; 498  :     WindowClass.lpfnWndProc = WinInputCallback;

  0041f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z ; WinInputCallback
  00426	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR WindowClass$[rsp+8], rax

; 499  :     WindowClass.hInstance = WindowInstance;

  0042e	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR WindowInstance$[rsp]
  00436	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR WindowClass$[rsp+24], rax

; 500  :     WindowClass.lpszClassName = "NesEmu";

  0043e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88298
  00445	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR WindowClass$[rsp+64], rax

; 501  :     
; 502  :     if(RegisterClassA(&WindowClass))

  0044d	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR WindowClass$[rsp]
  00455	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegisterClassA
  0045b	0f b7 c0	 movzx	 eax, ax
  0045e	85 c0		 test	 eax, eax
  00460	0f 84 f7 01 00
	00		 je	 $LN23@WinMain

; 503  :     {
; 504  :         HWND Window = CreateWindowExA(0, WindowClass.lpszClassName, "NesEmu",

  00466	0f b7 44 24 68	 movzx	 eax, WORD PTR WindowHeight$[rsp]
  0046b	0f b7 4c 24 6c	 movzx	 ecx, WORD PTR WindowWidth$[rsp]
  00470	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR [rsp+88], 0
  00479	48 8b 94 24 30
	02 00 00	 mov	 rdx, QWORD PTR WindowInstance$[rsp]
  00481	48 89 54 24 50	 mov	 QWORD PTR [rsp+80], rdx
  00486	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  0048f	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00498	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0049c	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  004a0	c7 44 24 28 00
	00 00 80	 mov	 DWORD PTR [rsp+40], -2147483648 ; ffffffff80000000H
  004a8	c7 44 24 20 00
	00 00 80	 mov	 DWORD PTR [rsp+32], -2147483648 ; ffffffff80000000H
  004b0	41 b9 00 00 cf
	10		 mov	 r9d, 282001408		; 10cf0000H
  004b6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG88301
  004bd	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR WindowClass$[rsp+64]
  004c5	33 c9		 xor	 ecx, ecx
  004c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateWindowExA
  004cd	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR Window$3[rsp], rax

; 505  :                                       WS_OVERLAPPEDWINDOW|WS_VISIBLE,
; 506  :                                       CW_USEDEFAULT, CW_USEDEFAULT,
; 507  :                                       WindowWidth, WindowHeight,
; 508  :                                       0, 0, WindowInstance, 0);
; 509  :         if(Window) // If window was created successfully

  004d5	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR Window$3[rsp], 0
  004de	0f 84 65 01 00
	00		 je	 $LN25@WinMain

; 510  :         {
; 511  :             LARGE_INTEGER LastCounter;
; 512  :             QueryPerformanceCounter(&LastCounter);                        

  004e4	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR LastCounter$5[rsp]
  004ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_QueryPerformanceCounter

; 513  :             uint64 LastCycles = __rdtsc();

  004f2	0f 31		 rdtsc
  004f4	48 c1 e2 20	 shl	 rdx, 32			; 00000020H
  004f8	48 0b c2	 or	 rax, rdx
  004fb	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR LastCycles$6[rsp], rax

; 514  :             
; 515  :             // TODO: Must run the emulation at the same speed as the nes would.
; 516  :             GlobalRunning = true;

  00503	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 1

; 517  : 
; 518  :             uint16 TempCount = 0;

  0050d	33 c0		 xor	 eax, eax
  0050f	66 89 44 24 70	 mov	 WORD PTR TempCount$2[rsp], ax
$LN4@WinMain:

; 519  :             
; 520  :             while(GlobalRunning)

  00514	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?GlobalRunning@@3HA, 0
  0051b	0f 84 26 01 00
	00		 je	 $LN5@WinMain

; 521  :             {
; 522  :                 MSG Message = {}; 

  00521	48 8d 84 24 70
	01 00 00	 lea	 rax, QWORD PTR Message$7[rsp]
  00529	48 8b f8	 mov	 rdi, rax
  0052c	33 c0		 xor	 eax, eax
  0052e	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00533	f3 aa		 rep stosb
$LN6@WinMain:

; 523  :                 while (PeekMessage(&Message, Window, 0, 0, PM_REMOVE))

  00535	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0053d	45 33 c9	 xor	 r9d, r9d
  00540	45 33 c0	 xor	 r8d, r8d
  00543	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR Window$3[rsp]
  0054b	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR Message$7[rsp]
  00553	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PeekMessageA
  00559	85 c0		 test	 eax, eax
  0055b	74 1e		 je	 SHORT $LN7@WinMain

; 524  :                 {
; 525  :                     TranslateMessage(&Message);

  0055d	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR Message$7[rsp]
  00565	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TranslateMessage

; 526  :                     DispatchMessage(&Message);

  0056b	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR Message$7[rsp]
  00573	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DispatchMessageA

; 527  :                 }

  00579	eb ba		 jmp	 SHORT $LN6@WinMain
$LN7@WinMain:

; 528  : 
; 529  :                 
; 530  :                 
; 531  :                 if(TempCount == 0xFF)

  0057b	0f b7 44 24 70	 movzx	 eax, WORD PTR TempCount$2[rsp]
  00580	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00585	75 0a		 jne	 SHORT $LN27@WinMain

; 532  :                     NMICalled = true;

  00587	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?NMICalled@@3HA, 1 ; NMICalled
$LN27@WinMain:

; 533  :                 cpuTick(&CpuData);

  00591	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR CpuData$[rsp]
  00599	e8 00 00 00 00	 call	 ?cpuTick@@YAXPEAUcpu@@@Z ; cpuTick

; 534  :                 // TODO: Timing is not complete
; 535  :                 //       Cpu opcodes execute in a different number of cycles
; 536  :                 //       Must multiply pputicks to stay synched.
; 537  :                 for(uint8 i = 0; i < 3; ++i)

  0059e	c6 44 24 60 00	 mov	 BYTE PTR i$1[rsp], 0
  005a3	eb 0b		 jmp	 SHORT $LN10@WinMain
$LN8@WinMain:
  005a5	0f b6 44 24 60	 movzx	 eax, BYTE PTR i$1[rsp]
  005aa	fe c0		 inc	 al
  005ac	88 44 24 60	 mov	 BYTE PTR i$1[rsp], al
$LN10@WinMain:
  005b0	0f b6 44 24 60	 movzx	 eax, BYTE PTR i$1[rsp]
  005b5	83 f8 03	 cmp	 eax, 3
  005b8	7d 17		 jge	 SHORT $LN9@WinMain

; 538  :                 {
; 539  :                     ppuTick(&ScreenBackBuffer, &PpuData);

  005ba	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR PpuData$[rsp]
  005c2	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR ScreenBackBuffer$[rsp]
  005ca	e8 00 00 00 00	 call	 ?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z ; ppuTick

; 540  :                 }

  005cf	eb d4		 jmp	 SHORT $LN8@WinMain
$LN9@WinMain:

; 541  :                 
; 542  :                 getWindowSize(Window, &WindowWidth, &WindowHeight);

  005d1	4c 8d 44 24 68	 lea	 r8, QWORD PTR WindowHeight$[rsp]
  005d6	48 8d 54 24 6c	 lea	 rdx, QWORD PTR WindowWidth$[rsp]
  005db	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Window$3[rsp]
  005e3	e8 00 00 00 00	 call	 ?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z ; getWindowSize

; 543  :                 
; 544  :                 // NOTE: Drawing the backbuffer to the window 
; 545  :                 HDC DeviceContext = GetDC(Window);

  005e8	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Window$3[rsp]
  005f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetDC
  005f6	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR DeviceContext$4[rsp], rax

; 546  :                 drawScreenBuffer(&ScreenBackBuffer, DeviceContext,

  005fe	44 0f b7 4c 24
	68		 movzx	 r9d, WORD PTR WindowHeight$[rsp]
  00604	44 0f b7 44 24
	6c		 movzx	 r8d, WORD PTR WindowWidth$[rsp]
  0060a	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR DeviceContext$4[rsp]
  00612	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR ScreenBackBuffer$[rsp]
  0061a	e8 00 00 00 00	 call	 ?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z ; drawScreenBuffer

; 547  :                                  WindowWidth, WindowHeight);
; 548  :                 ReleaseDC(Window, DeviceContext);

  0061f	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR DeviceContext$4[rsp]
  00627	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Window$3[rsp]
  0062f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReleaseDC

; 549  : 
; 550  :                 TempCount++;

  00635	0f b7 44 24 70	 movzx	 eax, WORD PTR TempCount$2[rsp]
  0063a	66 ff c0	 inc	 ax
  0063d	66 89 44 24 70	 mov	 WORD PTR TempCount$2[rsp], ax

; 551  : #if 0
; 552  :                 uint64 EndCycles = __rdtsc();
; 553  :                 
; 554  :                 LARGE_INTEGER EndCounter;
; 555  :                 QueryPerformanceCounter(&EndCounter);
; 556  :                 
; 557  :                 uint64 CounterElapsed = EndCounter.QuadPart - LastCounter.QuadPart; 
; 558  :                 uint64 CyclesElapsed = EndCycles - LastCycles;
; 559  :                 
; 560  :                 real32 MSElapsed = ((1000.0f * (real32)CounterElapsed) / (real32)PerfCountFrequency);
; 561  :                 real32 FPSElapsed = (real32)PerfCountFrequency / (real32)CounterElapsed;
; 562  :                 real32 MCElapsed = (real32)CyclesElapsed / (1000.0f*1000.0f);                 
; 563  :                 
; 564  :                 char TextBuffer[256];
; 565  :                 _snprintf(TextBuffer, 256, "Cycles: %f, FPS: %f, DeltaTime: %f\n", MCElapsed, FPSElapsed, MSElapsed);
; 566  :                 OutputDebugString(TextBuffer);
; 567  :                 
; 568  :                 LastCounter = EndCounter;
; 569  :                 LastCycles = EndCycles;
; 570  : #endif
; 571  :             }   

  00642	e9 cd fe ff ff	 jmp	 $LN4@WinMain
$LN5@WinMain:

; 572  :         }
; 573  :         else

  00647	eb 12		 jmp	 SHORT $LN26@WinMain
$LN25@WinMain:

; 574  :         {
; 575  :             Assert(0);

  00649	33 c0		 xor	 eax, eax
  0064b	83 f8 01	 cmp	 eax, 1
  0064e	74 0b		 je	 SHORT $LN28@WinMain
  00650	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN28@WinMain:
$LN26@WinMain:

; 576  :         }
; 577  :     }
; 578  :     else

  0065b	eb 12		 jmp	 SHORT $LN24@WinMain
$LN23@WinMain:

; 579  :     {
; 580  :         Assert(0);

  0065d	33 c0		 xor	 eax, eax
  0065f	83 f8 01	 cmp	 eax, 1
  00662	74 0b		 je	 SHORT $LN29@WinMain
  00664	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN29@WinMain:
$LN24@WinMain:

; 581  :     }
; 582  : 
; 583  :     return(0);

  0066f	33 c0		 xor	 eax, eax

; 584  : } 

  00671	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00679	48 33 cc	 xor	 rcx, rsp
  0067c	e8 00 00 00 00	 call	 __security_check_cookie
  00681	48 81 c4 20 02
	00 00		 add	 rsp, 544		; 00000220H
  00688	5f		 pop	 rdi
  00689	c3		 ret	 0
WinMain	ENDP
_TEXT	ENDS
END
