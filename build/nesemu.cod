; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?adc@@YAEGPEAUcpu@@E@Z				; adc
PUBLIC	?AND@@YAEGPEAUcpu@@E@Z				; AND
PUBLIC	?asl@@YAEGPEAUcpu@@E@Z				; asl
PUBLIC	?bcc@@YAEGPEAUcpu@@E@Z				; bcc
PUBLIC	?bcs@@YAEGPEAUcpu@@E@Z				; bcs
PUBLIC	?beq@@YAEGPEAUcpu@@E@Z				; beq
PUBLIC	?bit@@YAEGPEAUcpu@@E@Z				; bit
PUBLIC	?bmi@@YAEGPEAUcpu@@E@Z				; bmi
PUBLIC	?bne@@YAEGPEAUcpu@@E@Z				; bne
PUBLIC	?bpl@@YAEGPEAUcpu@@E@Z				; bpl
PUBLIC	?brk@@YAEGPEAUcpu@@E@Z				; brk
PUBLIC	?bvc@@YAEGPEAUcpu@@E@Z				; bvc
PUBLIC	?bvs@@YAEGPEAUcpu@@E@Z				; bvs
PUBLIC	?clc@@YAEGPEAUcpu@@E@Z				; clc
PUBLIC	?cld@@YAEGPEAUcpu@@E@Z				; cld
PUBLIC	?cli@@YAEGPEAUcpu@@E@Z				; cli
PUBLIC	?clv@@YAEGPEAUcpu@@E@Z				; clv
PUBLIC	?cmp@@YAEGPEAUcpu@@E@Z				; cmp
PUBLIC	?cpx@@YAEGPEAUcpu@@E@Z				; cpx
PUBLIC	?cpy@@YAEGPEAUcpu@@E@Z				; cpy
PUBLIC	?dec@@YAEGPEAUcpu@@E@Z				; dec
PUBLIC	?dex@@YAEGPEAUcpu@@E@Z				; dex
PUBLIC	?dey@@YAEGPEAUcpu@@E@Z				; dey
PUBLIC	?eor@@YAEGPEAUcpu@@E@Z				; eor
PUBLIC	?inc@@YAEGPEAUcpu@@E@Z				; inc
PUBLIC	?inx@@YAEGPEAUcpu@@E@Z				; inx
PUBLIC	?iny@@YAEGPEAUcpu@@E@Z				; iny
PUBLIC	?jmp@@YAEGPEAUcpu@@E@Z				; jmp
PUBLIC	?jsr@@YAEGPEAUcpu@@E@Z				; jsr
PUBLIC	?lda@@YAEGPEAUcpu@@E@Z				; lda
PUBLIC	?ldx@@YAEGPEAUcpu@@E@Z				; ldx
PUBLIC	?ldy@@YAEGPEAUcpu@@E@Z				; ldy
PUBLIC	?lsr@@YAEGPEAUcpu@@E@Z				; lsr
PUBLIC	?nop@@YAEGPEAUcpu@@E@Z				; nop
PUBLIC	?ora@@YAEGPEAUcpu@@E@Z				; ora
PUBLIC	?pha@@YAEGPEAUcpu@@E@Z				; pha
PUBLIC	?php@@YAEGPEAUcpu@@E@Z				; php
PUBLIC	?pla@@YAEGPEAUcpu@@E@Z				; pla
PUBLIC	?plp@@YAEGPEAUcpu@@E@Z				; plp
PUBLIC	?rol@@YAEGPEAUcpu@@E@Z				; rol
PUBLIC	?ror@@YAEGPEAUcpu@@E@Z				; ror
PUBLIC	?rti@@YAEGPEAUcpu@@E@Z				; rti
PUBLIC	?rts@@YAEGPEAUcpu@@E@Z				; rts
PUBLIC	?sbc@@YAEGPEAUcpu@@E@Z				; sbc
PUBLIC	?sec@@YAEGPEAUcpu@@E@Z				; sec
PUBLIC	?sed@@YAEGPEAUcpu@@E@Z				; sed
PUBLIC	?sei@@YAEGPEAUcpu@@E@Z				; sei
PUBLIC	?sta@@YAEGPEAUcpu@@E@Z				; sta
PUBLIC	?stx@@YAEGPEAUcpu@@E@Z				; stx
PUBLIC	?sty@@YAEGPEAUcpu@@E@Z				; sty
PUBLIC	?tax@@YAEGPEAUcpu@@E@Z				; tax
PUBLIC	?tay@@YAEGPEAUcpu@@E@Z				; tay
PUBLIC	?tsx@@YAEGPEAUcpu@@E@Z				; tsx
PUBLIC	?txa@@YAEGPEAUcpu@@E@Z				; txa
PUBLIC	?tya@@YAEGPEAUcpu@@E@Z				; tya
PUBLIC	?txs@@YAEGPEAUcpu@@E@Z				; txs
PUBLIC	?ahx@@YAEGPEAUcpu@@E@Z				; ahx
PUBLIC	?alr@@YAEGPEAUcpu@@E@Z				; alr
PUBLIC	?anc@@YAEGPEAUcpu@@E@Z				; anc
PUBLIC	?arr@@YAEGPEAUcpu@@E@Z				; arr
PUBLIC	?axs@@YAEGPEAUcpu@@E@Z				; axs
PUBLIC	?dcp@@YAEGPEAUcpu@@E@Z				; dcp
PUBLIC	?isc@@YAEGPEAUcpu@@E@Z				; isc
PUBLIC	?kil@@YAEGPEAUcpu@@E@Z				; kil
PUBLIC	?las@@YAEGPEAUcpu@@E@Z				; las
PUBLIC	?lax@@YAEGPEAUcpu@@E@Z				; lax
PUBLIC	?rla@@YAEGPEAUcpu@@E@Z				; rla
PUBLIC	?rra@@YAEGPEAUcpu@@E@Z				; rra
PUBLIC	?sax@@YAEGPEAUcpu@@E@Z				; sax
PUBLIC	?shx@@YAEGPEAUcpu@@E@Z				; shx
PUBLIC	?shy@@YAEGPEAUcpu@@E@Z				; shy
PUBLIC	?slo@@YAEGPEAUcpu@@E@Z				; slo
PUBLIC	?sre@@YAEGPEAUcpu@@E@Z				; sre
PUBLIC	?tas@@YAEGPEAUcpu@@E@Z				; tas
PUBLIC	?xaa@@YAEGPEAUcpu@@E@Z				; xaa
PUBLIC	?instrOps@@3PAP6AEGPEAUcpu@@E@ZA		; instrOps
PUBLIC	?Palette@@3PAY02EA				; Palette
PUBLIC	?NmiTriggered@@3HA				; NmiTriggered
PUBLIC	?IrqTriggered@@3HA				; IrqTriggered
PUBLIC	?VRamAdrsChange@@3HA				; VRamAdrsChange
PUBLIC	?VRamIOChange@@3HA				; VRamIOChange
PUBLIC	?ScrollAdrsChange@@3HA				; ScrollAdrsChange
PUBLIC	?VRamAdrsOnPalette@@3HA				; VRamAdrsOnPalette
PUBLIC	?IOReadFromCpu@@3HA				; IOReadFromCpu
PUBLIC	?ResetVRamIOAdrs@@3HA				; ResetVRamIOAdrs
PUBLIC	?ResetScrollIOAdrs@@3HA				; ResetScrollIOAdrs
PUBLIC	?DrawScreen@@3HA				; DrawScreen
_BSS	SEGMENT
?WinInput@@3Uinput@@A DB 020H DUP (?)			; WinInput
?NmiTriggered@@3HA DD 01H DUP (?)			; NmiTriggered
?IrqTriggered@@3HA DD 01H DUP (?)			; IrqTriggered
?VRamAdrsChange@@3HA DD 01H DUP (?)			; VRamAdrsChange
?VRamIOChange@@3HA DD 01H DUP (?)			; VRamIOChange
?ScrollAdrsChange@@3HA DD 01H DUP (?)			; ScrollAdrsChange
?VRamAdrsOnPalette@@3HA DD 01H DUP (?)			; VRamAdrsOnPalette
?IOReadFromCpu@@3HA DD 01H DUP (?)			; IOReadFromCpu
?ResetVRamIOAdrs@@3HA DD 01H DUP (?)			; ResetVRamIOAdrs
?ResetScrollIOAdrs@@3HA DD 01H DUP (?)			; ResetScrollIOAdrs
?DrawScreen@@3HA DD 01H DUP (?)				; DrawScreen
_BSS	ENDS
_DATA	SEGMENT
?instCycles@@3PAEA DB 07H				; instCycles
	DB	06H
	DB	00H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
	DB	06H
	DB	06H
	DB	00H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	04H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
	DB	06H
	DB	06H
	DB	00H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	03H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
	DB	06H
	DB	06H
	DB	00H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	04H
	DB	02H
	DB	02H
	DB	02H
	DB	05H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
	DB	02H
	DB	06H
	DB	02H
	DB	06H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	02H
	DB	06H
	DB	00H
	DB	06H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	02H
	DB	05H
	DB	02H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	02H
	DB	06H
	DB	02H
	DB	06H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	02H
	DB	05H
	DB	00H
	DB	05H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	02H
	DB	04H
	DB	02H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	02H
	DB	06H
	DB	02H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
	DB	02H
	DB	06H
	DB	02H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
?instBoundaryCheck@@3PAEA DB 00H			; instBoundaryCheck
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
?instrOps@@3PAP6AEGPEAUcpu@@E@ZA DQ FLAT:?brk@@YAEGPEAUcpu@@E@Z ; instrOps
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?asl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?php@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?asl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?anc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?asl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bpl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?asl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?clc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?asl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?jsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bit@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rol@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?plp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rol@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?anc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bit@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rol@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bmi@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rol@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sec@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rol@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rti@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?pha@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?alr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?jmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bvc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cli@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rts@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ror@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?pla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ror@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?arr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?jmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ror@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bvs@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ror@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sei@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ror@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sty@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?stx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dey@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?txa@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?xaa@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sty@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?stx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bcc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ahx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sty@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?stx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?tya@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?txs@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?tas@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?shy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?shx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ahx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?tay@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?tax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bcs@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?clv@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?tsx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?las@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dec@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?iny@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dex@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?axs@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dec@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bne@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dec@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cld@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dec@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?inc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?inx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?inc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?beq@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?inc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sed@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?inc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
?Palette@@3PAY02EA DB 075H				; Palette
	DB	075H
	DB	075H
	DB	027H
	DB	01bH
	DB	08fH
	DB	00H
	DB	00H
	DB	0abH
	DB	047H
	DB	00H
	DB	09fH
	DB	08fH
	DB	00H
	DB	077H
	DB	0abH
	DB	00H
	DB	013H
	DB	0a7H
	DB	00H
	DB	00H
	DB	07fH
	DB	0bH
	DB	00H
	DB	043H
	DB	02fH
	DB	00H
	DB	00H
	DB	047H
	DB	00H
	DB	00H
	DB	051H
	DB	00H
	DB	00H
	DB	03fH
	DB	017H
	DB	01bH
	DB	03fH
	DB	05fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0bcH
	DB	0bcH
	DB	0bcH
	DB	00H
	DB	073H
	DB	0efH
	DB	023H
	DB	03bH
	DB	0efH
	DB	083H
	DB	00H
	DB	0f3H
	DB	0bfH
	DB	00H
	DB	0bfH
	DB	0e7H
	DB	00H
	DB	05bH
	DB	0dbH
	DB	02bH
	DB	00H
	DB	0cbH
	DB	04fH
	DB	0fH
	DB	08bH
	DB	073H
	DB	00H
	DB	00H
	DB	097H
	DB	00H
	DB	00H
	DB	0abH
	DB	00H
	DB	00H
	DB	093H
	DB	03bH
	DB	00H
	DB	083H
	DB	08bH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	03fH
	DB	0bfH
	DB	0ffH
	DB	05fH
	DB	097H
	DB	0ffH
	DB	0a7H
	DB	08bH
	DB	0fdH
	DB	0f7H
	DB	07bH
	DB	0ffH
	DB	0ffH
	DB	077H
	DB	0b7H
	DB	0ffH
	DB	077H
	DB	063H
	DB	0ffH
	DB	09bH
	DB	03bH
	DB	0f3H
	DB	0bfH
	DB	03fH
	DB	083H
	DB	0d3H
	DB	013H
	DB	04fH
	DB	0dfH
	DB	04bH
	DB	058H
	DB	0f8H
	DB	098H
	DB	00H
	DB	0ebH
	DB	0dbH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0abH
	DB	0e7H
	DB	0ffH
	DB	0c7H
	DB	0d7H
	DB	0ffH
	DB	0d7H
	DB	0cbH
	DB	0ffH
	DB	0ffH
	DB	0c7H
	DB	0ffH
	DB	0ffH
	DB	0c7H
	DB	0dbH
	DB	0ffH
	DB	0bfH
	DB	0b3H
	DB	0ffH
	DB	0dbH
	DB	0abH
	DB	0ffH
	DB	0e7H
	DB	0a3H
	DB	0e3H
	DB	0ffH
	DB	0a3H
	DB	0abH
	DB	0f3H
	DB	0bfH
	DB	0b3H
	DB	0ffH
	DB	0cfH
	DB	09fH
	DB	0ffH
	DB	0f3H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
?instAddressMode@@3PAEA DB 09H				; instAddressMode
	DB	0bH
	DB	09H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	01H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	06H
	DB	0bH
	DB	09H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	01H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	09H
	DB	0bH
	DB	09H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	01H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	09H
	DB	0bH
	DB	09H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	01H
	DB	02H
	DB	0dH
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	02H
	DB	0bH
	DB	02H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	09H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	02H
	DB	0bH
	DB	02H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	09H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	02H
	DB	0bH
	DB	02H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	09H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	02H
	DB	0bH
	DB	02H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	09H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
?instLength@@3PAEA DB 01H				; instLength
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
?instName@@3PAPEADA DQ FLAT:$SG87822			; instName
	DQ	FLAT:$SG87823
	DQ	FLAT:$SG87824
	DQ	FLAT:$SG87825
	DQ	FLAT:$SG87826
	DQ	FLAT:$SG87827
	DQ	FLAT:$SG87828
	DQ	FLAT:$SG87829
	DQ	FLAT:$SG87830
	DQ	FLAT:$SG87831
	DQ	FLAT:$SG87832
	DQ	FLAT:$SG87833
	DQ	FLAT:$SG87834
	DQ	FLAT:$SG87835
	DQ	FLAT:$SG87836
	DQ	FLAT:$SG87837
	DQ	FLAT:$SG87838
	DQ	FLAT:$SG87839
	DQ	FLAT:$SG87840
	DQ	FLAT:$SG87841
	DQ	FLAT:$SG87842
	DQ	FLAT:$SG87843
	DQ	FLAT:$SG87844
	DQ	FLAT:$SG87845
	DQ	FLAT:$SG87846
	DQ	FLAT:$SG87847
	DQ	FLAT:$SG87848
	DQ	FLAT:$SG87849
	DQ	FLAT:$SG87850
	DQ	FLAT:$SG87851
	DQ	FLAT:$SG87852
	DQ	FLAT:$SG87853
	DQ	FLAT:$SG87854
	DQ	FLAT:$SG87855
	DQ	FLAT:$SG87856
	DQ	FLAT:$SG87857
	DQ	FLAT:$SG87858
	DQ	FLAT:$SG87859
	DQ	FLAT:$SG87860
	DQ	FLAT:$SG87861
	DQ	FLAT:$SG87862
	DQ	FLAT:$SG87863
	DQ	FLAT:$SG87864
	DQ	FLAT:$SG87865
	DQ	FLAT:$SG87866
	DQ	FLAT:$SG87867
	DQ	FLAT:$SG87868
	DQ	FLAT:$SG87869
	DQ	FLAT:$SG87870
	DQ	FLAT:$SG87871
	DQ	FLAT:$SG87872
	DQ	FLAT:$SG87873
	DQ	FLAT:$SG87874
	DQ	FLAT:$SG87875
	DQ	FLAT:$SG87876
	DQ	FLAT:$SG87877
	DQ	FLAT:$SG87878
	DQ	FLAT:$SG87879
	DQ	FLAT:$SG87880
	DQ	FLAT:$SG87881
	DQ	FLAT:$SG87882
	DQ	FLAT:$SG87883
	DQ	FLAT:$SG87884
	DQ	FLAT:$SG87885
	DQ	FLAT:$SG87886
	DQ	FLAT:$SG87887
	DQ	FLAT:$SG87888
	DQ	FLAT:$SG87889
	DQ	FLAT:$SG87890
	DQ	FLAT:$SG87891
	DQ	FLAT:$SG87892
	DQ	FLAT:$SG87893
	DQ	FLAT:$SG87894
	DQ	FLAT:$SG87895
	DQ	FLAT:$SG87896
	DQ	FLAT:$SG87897
	DQ	FLAT:$SG87898
	DQ	FLAT:$SG87899
	DQ	FLAT:$SG87900
	DQ	FLAT:$SG87901
	DQ	FLAT:$SG87902
	DQ	FLAT:$SG87903
	DQ	FLAT:$SG87904
	DQ	FLAT:$SG87905
	DQ	FLAT:$SG87906
	DQ	FLAT:$SG87907
	DQ	FLAT:$SG87908
	DQ	FLAT:$SG87909
	DQ	FLAT:$SG87910
	DQ	FLAT:$SG87911
	DQ	FLAT:$SG87912
	DQ	FLAT:$SG87913
	DQ	FLAT:$SG87914
	DQ	FLAT:$SG87915
	DQ	FLAT:$SG87916
	DQ	FLAT:$SG87917
	DQ	FLAT:$SG87918
	DQ	FLAT:$SG87919
	DQ	FLAT:$SG87920
	DQ	FLAT:$SG87921
	DQ	FLAT:$SG87922
	DQ	FLAT:$SG87923
	DQ	FLAT:$SG87924
	DQ	FLAT:$SG87925
	DQ	FLAT:$SG87926
	DQ	FLAT:$SG87927
	DQ	FLAT:$SG87928
	DQ	FLAT:$SG87929
	DQ	FLAT:$SG87930
	DQ	FLAT:$SG87931
	DQ	FLAT:$SG87932
	DQ	FLAT:$SG87933
	DQ	FLAT:$SG87934
	DQ	FLAT:$SG87935
	DQ	FLAT:$SG87936
	DQ	FLAT:$SG87937
	DQ	FLAT:$SG87938
	DQ	FLAT:$SG87939
	DQ	FLAT:$SG87940
	DQ	FLAT:$SG87941
	DQ	FLAT:$SG87942
	DQ	FLAT:$SG87943
	DQ	FLAT:$SG87944
	DQ	FLAT:$SG87945
	DQ	FLAT:$SG87946
	DQ	FLAT:$SG87947
	DQ	FLAT:$SG87948
	DQ	FLAT:$SG87949
	DQ	FLAT:$SG87950
	DQ	FLAT:$SG87951
	DQ	FLAT:$SG87952
	DQ	FLAT:$SG87953
	DQ	FLAT:$SG87954
	DQ	FLAT:$SG87955
	DQ	FLAT:$SG87956
	DQ	FLAT:$SG87957
	DQ	FLAT:$SG87958
	DQ	FLAT:$SG87959
	DQ	FLAT:$SG87960
	DQ	FLAT:$SG87961
	DQ	FLAT:$SG87962
	DQ	FLAT:$SG87963
	DQ	FLAT:$SG87964
	DQ	FLAT:$SG87965
	DQ	FLAT:$SG87966
	DQ	FLAT:$SG87967
	DQ	FLAT:$SG87968
	DQ	FLAT:$SG87969
	DQ	FLAT:$SG87970
	DQ	FLAT:$SG87971
	DQ	FLAT:$SG87972
	DQ	FLAT:$SG87973
	DQ	FLAT:$SG87974
	DQ	FLAT:$SG87975
	DQ	FLAT:$SG87976
	DQ	FLAT:$SG87977
	DQ	FLAT:$SG87978
	DQ	FLAT:$SG87979
	DQ	FLAT:$SG87980
	DQ	FLAT:$SG87981
	DQ	FLAT:$SG87982
	DQ	FLAT:$SG87983
	DQ	FLAT:$SG87984
	DQ	FLAT:$SG87985
	DQ	FLAT:$SG87986
	DQ	FLAT:$SG87987
	DQ	FLAT:$SG87988
	DQ	FLAT:$SG87989
	DQ	FLAT:$SG87990
	DQ	FLAT:$SG87991
	DQ	FLAT:$SG87992
	DQ	FLAT:$SG87993
	DQ	FLAT:$SG87994
	DQ	FLAT:$SG87995
	DQ	FLAT:$SG87996
	DQ	FLAT:$SG87997
	DQ	FLAT:$SG87998
	DQ	FLAT:$SG87999
	DQ	FLAT:$SG88000
	DQ	FLAT:$SG88001
	DQ	FLAT:$SG88002
	DQ	FLAT:$SG88003
	DQ	FLAT:$SG88004
	DQ	FLAT:$SG88005
	DQ	FLAT:$SG88006
	DQ	FLAT:$SG88007
	DQ	FLAT:$SG88008
	DQ	FLAT:$SG88009
	DQ	FLAT:$SG88010
	DQ	FLAT:$SG88011
	DQ	FLAT:$SG88012
	DQ	FLAT:$SG88013
	DQ	FLAT:$SG88014
	DQ	FLAT:$SG88015
	DQ	FLAT:$SG88016
	DQ	FLAT:$SG88017
	DQ	FLAT:$SG88018
	DQ	FLAT:$SG88019
	DQ	FLAT:$SG88020
	DQ	FLAT:$SG88021
	DQ	FLAT:$SG88022
	DQ	FLAT:$SG88023
	DQ	FLAT:$SG88024
	DQ	FLAT:$SG88025
	DQ	FLAT:$SG88026
	DQ	FLAT:$SG88027
	DQ	FLAT:$SG88028
	DQ	FLAT:$SG88029
	DQ	FLAT:$SG88030
	DQ	FLAT:$SG88031
	DQ	FLAT:$SG88032
	DQ	FLAT:$SG88033
	DQ	FLAT:$SG88034
	DQ	FLAT:$SG88035
	DQ	FLAT:$SG88036
	DQ	FLAT:$SG88037
	DQ	FLAT:$SG88038
	DQ	FLAT:$SG88039
	DQ	FLAT:$SG88040
	DQ	FLAT:$SG88041
	DQ	FLAT:$SG88042
	DQ	FLAT:$SG88043
	DQ	FLAT:$SG88044
	DQ	FLAT:$SG88045
	DQ	FLAT:$SG88046
	DQ	FLAT:$SG88047
	DQ	FLAT:$SG88048
	DQ	FLAT:$SG88049
	DQ	FLAT:$SG88050
	DQ	FLAT:$SG88051
	DQ	FLAT:$SG88052
	DQ	FLAT:$SG88053
	DQ	FLAT:$SG88054
	DQ	FLAT:$SG88055
	DQ	FLAT:$SG88056
	DQ	FLAT:$SG88057
	DQ	FLAT:$SG88058
	DQ	FLAT:$SG88059
	DQ	FLAT:$SG88060
	DQ	FLAT:$SG88061
	DQ	FLAT:$SG88062
	DQ	FLAT:$SG88063
	DQ	FLAT:$SG88064
	DQ	FLAT:$SG88065
	DQ	FLAT:$SG88066
	DQ	FLAT:$SG88067
	DQ	FLAT:$SG88068
	DQ	FLAT:$SG88069
	DQ	FLAT:$SG88070
	DQ	FLAT:$SG88071
	DQ	FLAT:$SG88072
	DQ	FLAT:$SG88073
	DQ	FLAT:$SG88074
	DQ	FLAT:$SG88075
	DQ	FLAT:$SG88076
	DQ	FLAT:$SG88077
_DATA	ENDS
CONST	SEGMENT
$SG88064 DB	'KIL', 00H
$SG88065 DB	'ISC', 00H
$SG88066 DB	'NOP', 00H
$SG88067 DB	'SBC', 00H
$SG88068 DB	'INC', 00H
$SG88069 DB	'ISC', 00H
$SG88070 DB	'SED', 00H
$SG88071 DB	'SBC', 00H
$SG88072 DB	'NOP', 00H
$SG88073 DB	'ISC', 00H
$SG88074 DB	'NOP', 00H
$SG88075 DB	'SBC', 00H
$SG88076 DB	'INC', 00H
$SG88077 DB	'ISC', 00H
$SG88688 DB	'%2X %2X %2X', 00H
$SG87822 DB	'BRK', 00H
$SG88691 DB	'%2X %2X   ', 00H
	ORG $+5
$SG88692 DB	'%2X      ', 00H
	ORG $+2
$SG87823 DB	'ORA', 00H
$SG88693 DB	'A:%2X X:%2X Y:%2X P:%2X SP:%2X CYC:    SL:', 00H
	ORG $+1
$SG87824 DB	'KIL', 00H
$SG88694 DB	'%4X %s  %s    %s', 0aH, 00H
	ORG $+2
$SG87825 DB	'SLO', 00H
$SG87826 DB	'NOP', 00H
$SG87827 DB	'ORA', 00H
$SG87828 DB	'ASL', 00H
$SG87829 DB	'SLO', 00H
$SG87830 DB	'PHP', 00H
$SG87831 DB	'ORA', 00H
$SG87832 DB	'ASL', 00H
$SG87833 DB	'ANC', 00H
$SG87834 DB	'NOP', 00H
$SG87835 DB	'ORA', 00H
$SG87836 DB	'ASL', 00H
$SG87837 DB	'SLO', 00H
$SG87838 DB	'BPL', 00H
$SG87839 DB	'ORA', 00H
$SG87840 DB	'KIL', 00H
$SG87841 DB	'SLO', 00H
$SG87842 DB	'NOP', 00H
$SG87843 DB	'ORA', 00H
$SG87844 DB	'ASL', 00H
$SG87845 DB	'SLO', 00H
$SG87846 DB	'CLC', 00H
$SG87847 DB	'ORA', 00H
$SG87848 DB	'NOP', 00H
$SG87849 DB	'SLO', 00H
$SG87850 DB	'NOP', 00H
$SG87851 DB	'ORA', 00H
$SG87852 DB	'ASL', 00H
$SG87853 DB	'SLO', 00H
$SG87854 DB	'JSR', 00H
$SG87855 DB	'AND', 00H
$SG87856 DB	'KIL', 00H
$SG87857 DB	'RLA', 00H
$SG87858 DB	'BIT', 00H
$SG87859 DB	'AND', 00H
$SG87860 DB	'ROL', 00H
$SG87861 DB	'RLA', 00H
$SG87862 DB	'PLP', 00H
$SG87863 DB	'AND', 00H
$SG87864 DB	'ROL', 00H
$SG87865 DB	'ANC', 00H
$SG87866 DB	'BIT', 00H
$SG87867 DB	'AND', 00H
$SG87868 DB	'ROL', 00H
$SG87869 DB	'RLA', 00H
$SG87870 DB	'BMI', 00H
$SG87871 DB	'AND', 00H
$SG87872 DB	'KIL', 00H
$SG87873 DB	'RLA', 00H
$SG87874 DB	'NOP', 00H
$SG87875 DB	'AND', 00H
$SG87876 DB	'ROL', 00H
$SG87877 DB	'RLA', 00H
$SG87878 DB	'SEC', 00H
$SG87879 DB	'AND', 00H
$SG87880 DB	'NOP', 00H
$SG87881 DB	'RLA', 00H
$SG87882 DB	'NOP', 00H
$SG87883 DB	'AND', 00H
$SG87884 DB	'ROL', 00H
$SG87885 DB	'RLA', 00H
$SG87886 DB	'RTI', 00H
$SG87887 DB	'EOR', 00H
$SG87888 DB	'KIL', 00H
$SG87889 DB	'SRE', 00H
$SG87890 DB	'NOP', 00H
$SG87891 DB	'EOR', 00H
$SG87892 DB	'LSR', 00H
$SG87893 DB	'SRE', 00H
$SG87894 DB	'PHA', 00H
$SG87895 DB	'EOR', 00H
$SG87896 DB	'LSR', 00H
$SG87897 DB	'ALR', 00H
$SG87898 DB	'JMP', 00H
$SG87899 DB	'EOR', 00H
$SG87900 DB	'LSR', 00H
$SG87901 DB	'SRE', 00H
$SG87902 DB	'BVC', 00H
$SG87903 DB	'EOR', 00H
$SG87904 DB	'KIL', 00H
$SG87905 DB	'SRE', 00H
$SG87906 DB	'NOP', 00H
$SG87907 DB	'EOR', 00H
$SG87908 DB	'LSR', 00H
$SG87909 DB	'SRE', 00H
$SG87910 DB	'CLI', 00H
$SG87911 DB	'EOR', 00H
$SG87912 DB	'NOP', 00H
$SG87913 DB	'SRE', 00H
$SG87914 DB	'NOP', 00H
$SG87915 DB	'EOR', 00H
$SG87916 DB	'LSR', 00H
$SG87917 DB	'SRE', 00H
$SG87918 DB	'RTS', 00H
$SG87919 DB	'ADC', 00H
$SG87920 DB	'KIL', 00H
$SG87921 DB	'RRA', 00H
$SG87922 DB	'NOP', 00H
$SG87923 DB	'ADC', 00H
$SG87924 DB	'ROR', 00H
$SG87925 DB	'RRA', 00H
$SG87926 DB	'PLA', 00H
$SG87927 DB	'ADC', 00H
$SG87928 DB	'ROR', 00H
$SG87929 DB	'ARR', 00H
$SG87930 DB	'JMP', 00H
$SG87931 DB	'ADC', 00H
$SG87932 DB	'ROR', 00H
$SG87933 DB	'RRA', 00H
$SG87934 DB	'BVS', 00H
$SG87935 DB	'ADC', 00H
$SG87936 DB	'KIL', 00H
$SG87937 DB	'RRA', 00H
$SG87938 DB	'NOP', 00H
$SG87939 DB	'ADC', 00H
$SG87940 DB	'ROR', 00H
$SG87941 DB	'RRA', 00H
$SG87942 DB	'SEI', 00H
$SG87943 DB	'ADC', 00H
$SG87944 DB	'NOP', 00H
$SG87945 DB	'RRA', 00H
$SG87946 DB	'NOP', 00H
$SG87947 DB	'ADC', 00H
$SG87948 DB	'ROR', 00H
$SG87949 DB	'RRA', 00H
$SG87950 DB	'NOP', 00H
$SG87951 DB	'STA', 00H
$SG87952 DB	'NOP', 00H
$SG87953 DB	'SAX', 00H
$SG87954 DB	'STY', 00H
$SG87955 DB	'STA', 00H
$SG87956 DB	'STX', 00H
$SG87957 DB	'SAX', 00H
$SG87958 DB	'DEY', 00H
$SG87959 DB	'NOP', 00H
$SG87960 DB	'TXA', 00H
$SG87961 DB	'XAA', 00H
$SG87962 DB	'STY', 00H
$SG87963 DB	'STA', 00H
$SG87964 DB	'STX', 00H
$SG87965 DB	'SAX', 00H
$SG87966 DB	'BCC', 00H
$SG87967 DB	'STA', 00H
$SG88992 DB	'nestest.nes', 00H
$SG87968 DB	'KIL', 00H
$SG87969 DB	'AHX', 00H
$SG87970 DB	'STY', 00H
$SG87971 DB	'STA', 00H
$SG87972 DB	'STX', 00H
$SG87973 DB	'SAX', 00H
$SG87974 DB	'TYA', 00H
$SG87975 DB	'STA', 00H
$SG87976 DB	'TXS', 00H
$SG87977 DB	'TAS', 00H
$SG87978 DB	'SHY', 00H
$SG87979 DB	'STA', 00H
$SG87980 DB	'SHX', 00H
$SG89005 DB	'Error: Unknown mapper number = %d', 0aH, 00H
	ORG $+1
$SG87981 DB	'AHX', 00H
$SG87982 DB	'LDY', 00H
$SG87983 DB	'LDA', 00H
$SG89008 DB	'NesEmu', 00H
	ORG $+1
$SG87984 DB	'LDX', 00H
$SG87985 DB	'LAX', 00H
$SG87986 DB	'LDY', 00H
$SG89011 DB	'NesEmu', 00H
	ORG $+1
$SG87987 DB	'LDA', 00H
$SG87988 DB	'LDX', 00H
$SG87989 DB	'LAX', 00H
$SG87990 DB	'TAY', 00H
$SG87991 DB	'LDA', 00H
$SG87992 DB	'TAX', 00H
$SG87993 DB	'LAX', 00H
$SG87994 DB	'LDY', 00H
$SG87995 DB	'LDA', 00H
$SG87996 DB	'LDX', 00H
$SG87997 DB	'LAX', 00H
$SG87998 DB	'BCS', 00H
$SG87999 DB	'LDA', 00H
$SG88000 DB	'KIL', 00H
$SG88001 DB	'LAX', 00H
$SG88002 DB	'LDY', 00H
$SG88003 DB	'LDA', 00H
$SG88004 DB	'LDX', 00H
$SG88005 DB	'LAX', 00H
$SG88006 DB	'CLV', 00H
$SG88007 DB	'LDA', 00H
$SG88008 DB	'TSX', 00H
$SG88009 DB	'LAS', 00H
$SG88010 DB	'LDY', 00H
$SG88011 DB	'LDA', 00H
$SG88012 DB	'LDX', 00H
$SG88013 DB	'LAX', 00H
$SG88014 DB	'CPY', 00H
$SG88015 DB	'CMP', 00H
$SG88016 DB	'NOP', 00H
$SG88017 DB	'DCP', 00H
$SG88018 DB	'CPY', 00H
$SG88019 DB	'CMP', 00H
$SG88020 DB	'DEC', 00H
$SG88021 DB	'DCP', 00H
$SG88022 DB	'INY', 00H
$SG88023 DB	'CMP', 00H
$SG88024 DB	'DEX', 00H
$SG88025 DB	'AXS', 00H
$SG88026 DB	'CPY', 00H
$SG88027 DB	'CMP', 00H
$SG88028 DB	'DEC', 00H
$SG88029 DB	'DCP', 00H
$SG88030 DB	'BNE', 00H
$SG88031 DB	'CMP', 00H
$SG88032 DB	'KIL', 00H
$SG88033 DB	'DCP', 00H
$SG88034 DB	'NOP', 00H
$SG88035 DB	'CMP', 00H
$SG88036 DB	'DEC', 00H
$SG88037 DB	'DCP', 00H
$SG88038 DB	'CLD', 00H
$SG88039 DB	'CMP', 00H
$SG88040 DB	'NOP', 00H
$SG88041 DB	'DCP', 00H
$SG88042 DB	'NOP', 00H
$SG88043 DB	'CMP', 00H
$SG88044 DB	'DEC', 00H
$SG88045 DB	'DCP', 00H
$SG88046 DB	'CPX', 00H
$SG88047 DB	'SBC', 00H
$SG88048 DB	'NOP', 00H
$SG88049 DB	'ISC', 00H
$SG88050 DB	'CPX', 00H
$SG88051 DB	'SBC', 00H
$SG88052 DB	'INC', 00H
$SG88053 DB	'ISC', 00H
$SG88054 DB	'INX', 00H
$SG88055 DB	'SBC', 00H
$SG88056 DB	'NOP', 00H
$SG88057 DB	'SBC', 00H
$SG88058 DB	'CPX', 00H
$SG88059 DB	'SBC', 00H
$SG88060 DB	'INC', 00H
$SG88061 DB	'ISC', 00H
$SG88062 DB	'BEQ', 00H
$SG88063 DB	'SBC', 00H
CONST	ENDS
PUBLIC	WinMain
PUBLIC	__local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z	; WinInputCallback
PUBLIC	?setCarry@@YAXPEAE@Z				; setCarry
PUBLIC	?clearCarry@@YAXPEAE@Z				; clearCarry
PUBLIC	?setInterrupt@@YAXPEAE@Z			; setInterrupt
PUBLIC	?clearInterrupt@@YAXPEAE@Z			; clearInterrupt
PUBLIC	?setDecimal@@YAXPEAE@Z				; setDecimal
PUBLIC	?clearDecimal@@YAXPEAE@Z			; clearDecimal
PUBLIC	?clearBreak@@YAXPEAE@Z				; clearBreak
PUBLIC	?setOverflow@@YAXPEAE@Z				; setOverflow
PUBLIC	?clearOverflow@@YAXPEAE@Z			; clearOverflow
PUBLIC	?setZero@@YAXEPEAE@Z				; setZero
PUBLIC	?setNegative@@YAXEPEAE@Z			; setNegative
PUBLIC	?isBitSet@@YAHEE@Z				; isBitSet
PUBLIC	?crossedPageCheck@@YAHGG@Z			; crossedPageCheck
PUBLIC	?getPaletteValue@@YAXEPEAE@Z			; getPaletteValue
PUBLIC	?drawPixel@@YAXPEAUppu@@GGPEAE@Z		; drawPixel
PUBLIC	?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z	; ppuTick
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	__real@3f800000
PUBLIC	__real@408f400000000000
PUBLIC	__real@42700000
PUBLIC	__real@447a0000
PUBLIC	__real@49da7a66
PUBLIC	__real@5f800000
EXTRN	__imp_CreateFileA:PROC
EXTRN	__imp_GetFileSizeEx:PROC
EXTRN	__imp_ReadFile:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_QueryPerformanceCounter:PROC
EXTRN	__imp_QueryPerformanceFrequency:PROC
EXTRN	__imp_VirtualAlloc:PROC
EXTRN	__imp_VirtualFree:PROC
EXTRN	__imp_StretchDIBits:PROC
EXTRN	__imp_TranslateMessage:PROC
EXTRN	__imp_DispatchMessageA:PROC
EXTRN	__imp_PeekMessageA:PROC
EXTRN	__imp_DefWindowProcA:PROC
EXTRN	__imp_RegisterClassA:PROC
EXTRN	__imp_CreateWindowExA:PROC
EXTRN	__imp_GetDC:PROC
EXTRN	__imp_ReleaseDC:PROC
EXTRN	__imp_GetClientRect:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?GlobalRunning@@3HA DD 01H DUP (?)			; GlobalRunning
_BSS	ENDS
pdata	SEGMENT
$pdata$WinMain DD imagerel $LN39
	DD	imagerel $LN39+2102
	DD	imagerel $unwind$WinMain
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$?getMilliSeconds@@YAM_K@Z DD imagerel ?getMilliSeconds@@YAM_K@Z
	DD	imagerel ?getMilliSeconds@@YAM_K@Z+112
	DD	imagerel $unwind$?getMilliSeconds@@YAM_K@Z
$pdata$?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z DD imagerel $LN51
	DD	imagerel $LN51+1159
	DD	imagerel $unwind$?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z
$pdata$?LoadFile@@YAPEAXPEADPEAI@Z DD imagerel ?LoadFile@@YAPEAXPEADPEAI@Z
	DD	imagerel ?LoadFile@@YAPEAXPEADPEAI@Z+259
	DD	imagerel $unwind$?LoadFile@@YAPEAXPEADPEAI@Z
$pdata$?cpyMem@@YAXPEAE0G@Z DD imagerel ?cpyMem@@YAXPEAE0G@Z
	DD	imagerel ?cpyMem@@YAXPEAE0G@Z+85
	DD	imagerel $unwind$?cpyMem@@YAXPEAE0G@Z
$pdata$?write8@@YAXEG_K@Z DD imagerel ?write8@@YAXEG_K@Z
	DD	imagerel ?write8@@YAXEG_K@Z+48
	DD	imagerel $unwind$?write8@@YAXEG_K@Z
$pdata$?read8@@YAEG_K@Z DD imagerel ?read8@@YAEG_K@Z
	DD	imagerel ?read8@@YAEG_K@Z+49
	DD	imagerel $unwind$?read8@@YAEG_K@Z
$pdata$?readCpu8@@YAEG_K@Z DD imagerel ?readCpu8@@YAEG_K@Z
	DD	imagerel ?readCpu8@@YAEG_K@Z+230
	DD	imagerel $unwind$?readCpu8@@YAEG_K@Z
$pdata$?writeCpu8@@YAXEG_K@Z DD imagerel ?writeCpu8@@YAXEG_K@Z
	DD	imagerel ?writeCpu8@@YAXEG_K@Z+251
	DD	imagerel $unwind$?writeCpu8@@YAXEG_K@Z
$pdata$?readCpu16@@YAGG_K@Z DD imagerel ?readCpu16@@YAGG_K@Z
	DD	imagerel ?readCpu16@@YAGG_K@Z+87
	DD	imagerel $unwind$?readCpu16@@YAGG_K@Z
$pdata$?bugReadCpu16@@YAGG_K@Z DD imagerel ?bugReadCpu16@@YAGG_K@Z
	DD	imagerel ?bugReadCpu16@@YAGG_K@Z+109
	DD	imagerel $unwind$?bugReadCpu16@@YAGG_K@Z
$pdata$?push@@YAXEPEAUcpu@@@Z DD imagerel ?push@@YAXEPEAUcpu@@@Z
	DD	imagerel ?push@@YAXEPEAUcpu@@@Z+72
	DD	imagerel $unwind$?push@@YAXEPEAUcpu@@@Z
$pdata$?pop@@YAEPEAUcpu@@@Z DD imagerel ?pop@@YAEPEAUcpu@@@Z
	DD	imagerel ?pop@@YAEPEAUcpu@@@Z+72
	DD	imagerel $unwind$?pop@@YAEPEAUcpu@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?crossedPageCheck@@YAHGG@Z DD imagerel $LN5
	DD	imagerel $LN5+63
	DD	imagerel $unwind$?crossedPageCheck@@YAHGG@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?adc@@YAEGPEAUcpu@@E@Z DD imagerel $LN7
	DD	imagerel $LN7+306
	DD	imagerel $unwind$?adc@@YAEGPEAUcpu@@E@Z
$pdata$?AND@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+121
	DD	imagerel $unwind$?AND@@YAEGPEAUcpu@@E@Z
$pdata$?asl@@YAEGPEAUcpu@@E@Z DD imagerel $LN9
	DD	imagerel $LN9+274
	DD	imagerel $unwind$?asl@@YAEGPEAUcpu@@E@Z
$pdata$?bcc@@YAEGPEAUcpu@@E@Z DD imagerel $LN6
	DD	imagerel $LN6+120
	DD	imagerel $unwind$?bcc@@YAEGPEAUcpu@@E@Z
$pdata$?bcs@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bcs@@YAEGPEAUcpu@@E@Z
$pdata$?beq@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?beq@@YAEGPEAUcpu@@E@Z
$pdata$?bit@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+151
	DD	imagerel $unwind$?bit@@YAEGPEAUcpu@@E@Z
$pdata$?bmi@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bmi@@YAEGPEAUcpu@@E@Z
$pdata$?bne@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bne@@YAEGPEAUcpu@@E@Z
$pdata$?bpl@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bpl@@YAEGPEAUcpu@@E@Z
$pdata$?brk@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+131
	DD	imagerel $unwind$?brk@@YAEGPEAUcpu@@E@Z
$pdata$?bvc@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bvc@@YAEGPEAUcpu@@E@Z
$pdata$?bvs@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bvs@@YAEGPEAUcpu@@E@Z
$pdata$?clc@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?clc@@YAEGPEAUcpu@@E@Z
$pdata$?cld@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?cld@@YAEGPEAUcpu@@E@Z
$pdata$?cli@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?cli@@YAEGPEAUcpu@@E@Z
$pdata$?clv@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?clv@@YAEGPEAUcpu@@E@Z
$pdata$?cmp@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+165
	DD	imagerel $unwind$?cmp@@YAEGPEAUcpu@@E@Z
$pdata$?cpx@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+167
	DD	imagerel $unwind$?cpx@@YAEGPEAUcpu@@E@Z
$pdata$?cpy@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+167
	DD	imagerel $unwind$?cpy@@YAEGPEAUcpu@@E@Z
$pdata$?dec@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+122
	DD	imagerel $unwind$?dec@@YAEGPEAUcpu@@E@Z
$pdata$?dex@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?dex@@YAEGPEAUcpu@@E@Z
$pdata$?dey@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?dey@@YAEGPEAUcpu@@E@Z
$pdata$?eor@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+121
	DD	imagerel $unwind$?eor@@YAEGPEAUcpu@@E@Z
$pdata$?inc@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+122
	DD	imagerel $unwind$?inc@@YAEGPEAUcpu@@E@Z
$pdata$?inx@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?inx@@YAEGPEAUcpu@@E@Z
$pdata$?iny@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?iny@@YAEGPEAUcpu@@E@Z
$pdata$?jsr@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$?jsr@@YAEGPEAUcpu@@E@Z
$pdata$?lda@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+105
	DD	imagerel $unwind$?lda@@YAEGPEAUcpu@@E@Z
$pdata$?ldx@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+106
	DD	imagerel $unwind$?ldx@@YAEGPEAUcpu@@E@Z
$pdata$?ldy@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+106
	DD	imagerel $unwind$?ldy@@YAEGPEAUcpu@@E@Z
$pdata$?lsr@@YAEGPEAUcpu@@E@Z DD imagerel $LN9
	DD	imagerel $LN9+273
	DD	imagerel $unwind$?lsr@@YAEGPEAUcpu@@E@Z
$pdata$?ora@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+121
	DD	imagerel $unwind$?ora@@YAEGPEAUcpu@@E@Z
$pdata$?pha@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?pha@@YAEGPEAUcpu@@E@Z
$pdata$?php@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?php@@YAEGPEAUcpu@@E@Z
$pdata$?pla@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$?pla@@YAEGPEAUcpu@@E@Z
$pdata$?plp@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?plp@@YAEGPEAUcpu@@E@Z
$pdata$?rol@@YAEGPEAUcpu@@E@Z DD imagerel $LN11
	DD	imagerel $LN11+339
	DD	imagerel $unwind$?rol@@YAEGPEAUcpu@@E@Z
$pdata$?ror@@YAEGPEAUcpu@@E@Z DD imagerel $LN11
	DD	imagerel $LN11+339
	DD	imagerel $unwind$?ror@@YAEGPEAUcpu@@E@Z
$pdata$?rti@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+125
	DD	imagerel $unwind$?rti@@YAEGPEAUcpu@@E@Z
$pdata$?rts@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$?rts@@YAEGPEAUcpu@@E@Z
$pdata$?sbc@@YAEGPEAUcpu@@E@Z DD imagerel $LN7
	DD	imagerel $LN7+324
	DD	imagerel $unwind$?sbc@@YAEGPEAUcpu@@E@Z
$pdata$?sec@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?sec@@YAEGPEAUcpu@@E@Z
$pdata$?sed@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?sed@@YAEGPEAUcpu@@E@Z
$pdata$?sei@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?sei@@YAEGPEAUcpu@@E@Z
$pdata$?sta@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?sta@@YAEGPEAUcpu@@E@Z
$pdata$?stx@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$?stx@@YAEGPEAUcpu@@E@Z
$pdata$?sty@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$?sty@@YAEGPEAUcpu@@E@Z
$pdata$?tax@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+94
	DD	imagerel $unwind$?tax@@YAEGPEAUcpu@@E@Z
$pdata$?tay@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+94
	DD	imagerel $unwind$?tay@@YAEGPEAUcpu@@E@Z
$pdata$?tsx@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$?tsx@@YAEGPEAUcpu@@E@Z
$pdata$?txa@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+92
	DD	imagerel $unwind$?txa@@YAEGPEAUcpu@@E@Z
$pdata$?tya@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+92
	DD	imagerel $unwind$?tya@@YAEGPEAUcpu@@E@Z
$pdata$?txs@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$?txs@@YAEGPEAUcpu@@E@Z
$pdata$?nmi@@YAEPEAUcpu@@@Z DD imagerel ?nmi@@YAEPEAUcpu@@@Z
	DD	imagerel ?nmi@@YAEPEAUcpu@@@Z+146
	DD	imagerel $unwind$?nmi@@YAEPEAUcpu@@@Z
$pdata$?irq@@YAEPEAUcpu@@@Z DD imagerel ?irq@@YAEPEAUcpu@@@Z
	DD	imagerel ?irq@@YAEPEAUcpu@@@Z+146
	DD	imagerel $unwind$?irq@@YAEPEAUcpu@@@Z
$pdata$?cpuTick@@YAEPEAUcpu@@@Z DD imagerel ?cpuTick@@YAEPEAUcpu@@@Z
	DD	imagerel ?cpuTick@@YAEPEAUcpu@@@Z+1672
	DD	imagerel $unwind$?cpuTick@@YAEPEAUcpu@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?drawPixel@@YAXPEAUppu@@GGPEAE@Z DD imagerel $LN3
	DD	imagerel $LN3+139
	DD	imagerel $unwind$?drawPixel@@YAXPEAUppu@@GGPEAE@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?readPpu8@@YAEG_K@Z DD imagerel ?readPpu8@@YAEG_K@Z
	DD	imagerel ?readPpu8@@YAEG_K@Z+157
	DD	imagerel $unwind$?readPpu8@@YAEG_K@Z
$pdata$?writePpu8@@YAXEG_K@Z DD imagerel ?writePpu8@@YAXEG_K@Z
	DD	imagerel ?writePpu8@@YAXEG_K@Z+157
	DD	imagerel $unwind$?writePpu8@@YAXEG_K@Z
$pdata$?getNameTableValue@@YAEGGG_K@Z DD imagerel ?getNameTableValue@@YAEGGG_K@Z
	DD	imagerel ?getNameTableValue@@YAEGGG_K@Z+179
	DD	imagerel $unwind$?getNameTableValue@@YAEGGG_K@Z
$pdata$?getPatternValue@@YAEGGEG_K@Z DD imagerel ?getPatternValue@@YAEGGEG_K@Z
	DD	imagerel ?getPatternValue@@YAEGGEG_K@Z+307
	DD	imagerel $unwind$?getPatternValue@@YAEGGEG_K@Z
$pdata$?getAttributeValue@@YAEGGG_K@Z DD imagerel ?getAttributeValue@@YAEGGG_K@Z
	DD	imagerel ?getAttributeValue@@YAEGGG_K@Z+291
	DD	imagerel $unwind$?getAttributeValue@@YAEGGG_K@Z
$pdata$?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z DD imagerel $LN47
	DD	imagerel $LN47+1705
	DD	imagerel $unwind$?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z
$pdata$?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z DD imagerel ?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z
	DD	imagerel ?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z+108
	DD	imagerel $unwind$?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z
$pdata$?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z DD imagerel ?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z
	DD	imagerel ?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z+262
	DD	imagerel $unwind$?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z
$pdata$?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z DD imagerel ?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z
	DD	imagerel ?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z+165
	DD	imagerel $unwind$?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z
pdata	ENDS
;	COMDAT __real@5f800000
CONST	SEGMENT
__real@5f800000 DD 05f800000r			; 1.84467e+19
CONST	ENDS
;	COMDAT __real@49da7a66
CONST	SEGMENT
__real@49da7a66 DD 049da7a66r			; 1.78977e+06
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?drawPixel@@YAXPEAUppu@@GGPEAE@Z DD 011901H
	DD	02219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?crossedPageCheck@@YAHGG@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
xdata	SEGMENT
$unwind$WinMain DD 032e19H
	DD	044011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0218H
$unwind$?getMilliSeconds@@YAM_K@Z DD 010901H
	DD	08209H
$unwind$?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z DD 011701H
	DD	0e217H
$unwind$?LoadFile@@YAPEAXPEADPEAI@Z DD 010e01H
	DD	0c20eH
$unwind$?cpyMem@@YAXPEAE0G@Z DD 011401H
	DD	02214H
$unwind$?write8@@YAXEG_K@Z DD 011201H
	DD	02212H
$unwind$?read8@@YAEG_K@Z DD 010e01H
	DD	0220eH
$unwind$?readCpu8@@YAEG_K@Z DD 010e01H
	DD	0620eH
$unwind$?writeCpu8@@YAXEG_K@Z DD 011201H
	DD	04212H
$unwind$?readCpu16@@YAGG_K@Z DD 010e01H
	DD	0620eH
$unwind$?bugReadCpu16@@YAGG_K@Z DD 010e01H
	DD	0620eH
$unwind$?push@@YAXEPEAUcpu@@@Z DD 010d01H
	DD	0420dH
$unwind$?pop@@YAEPEAUcpu@@@Z DD 010901H
	DD	06209H
$unwind$?adc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?AND@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?asl@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bcc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bcs@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?beq@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bit@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bmi@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bne@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bpl@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?brk@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bvc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bvs@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?clc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?cld@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?cli@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?clv@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?cmp@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?cpx@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?cpy@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?dec@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?dex@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?dey@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?eor@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?inc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?inx@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?iny@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?jsr@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?lda@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?ldx@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?ldy@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?lsr@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?ora@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?pha@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?php@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?pla@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?plp@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?rol@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?ror@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?rti@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?rts@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?sbc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?sec@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?sed@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?sei@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?sta@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?stx@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?sty@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?tax@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?tay@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?tsx@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?txa@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?tya@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?txs@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?nmi@@YAEPEAUcpu@@@Z DD 010901H
	DD	06209H
$unwind$?irq@@YAEPEAUcpu@@@Z DD 010901H
	DD	06209H
$unwind$?cpuTick@@YAEPEAUcpu@@@Z DD 021e19H
	DD	0a7010cH
	DD	imagerel __GSHandlerCheck
	DD	0520H
$unwind$?readPpu8@@YAEG_K@Z DD 010e01H
	DD	0620eH
$unwind$?writePpu8@@YAXEG_K@Z DD 011201H
	DD	04212H
$unwind$?getNameTableValue@@YAEGGG_K@Z DD 011901H
	DD	06219H
$unwind$?getPatternValue@@YAEGGEG_K@Z DD 011901H
	DD	08219H
$unwind$?getAttributeValue@@YAEGGG_K@Z DD 011901H
	DD	06219H
$unwind$?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z DD 021201H
	DD	0700bf212H
$unwind$?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z DD 012219H
	DD	08213H
	DD	imagerel __GSHandlerCheck
	DD	030H
$unwind$?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z DD 011401H
	DD	06214H
$unwind$?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z DD 011a01H
	DD	0e21aH
xdata	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
BackBuffer$ = 128
DeviceContext$ = 136
WindowWidth$ = 144
WindowHeight$ = 152
?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z PROC ; drawScreenBuffer

; 310  : {                

  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000c	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00011	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00016	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 311  :     StretchDIBits(DeviceContext,

  0001a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  00022	0f b7 8c 24 98
	00 00 00	 movzx	 ecx, WORD PTR WindowHeight$[rsp]
  0002a	0f b7 94 24 90
	00 00 00	 movzx	 edx, WORD PTR WindowWidth$[rsp]
  00032	c7 44 24 60 20
	00 cc 00	 mov	 DWORD PTR [rsp+96], 13369376 ; 00cc0020H
  0003a	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR [rsp+88], 0
  00042	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00047	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  0004f	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00053	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00058	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  00060	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00063	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00067	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  0006f	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00072	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00076	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  0007e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00086	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0008a	44 8b ca	 mov	 r9d, edx
  0008d	45 33 c0	 xor	 r8d, r8d
  00090	33 d2		 xor	 edx, edx
  00092	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR DeviceContext$[rsp]
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_StretchDIBits

; 312  :                   0, 0, WindowWidth, WindowHeight,
; 313  :                   0, 0, BackBuffer->Width, BackBuffer->Height,
; 314  :                   BackBuffer->Memory,
; 315  :                   &BackBuffer->Info,
; 316  :                   DIB_RGB_COLORS, SRCCOPY);
; 317  : }

  000a0	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000a4	c3		 ret	 0
?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z ENDP ; drawScreenBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
MemorySize$ = 32
Buffer$ = 64
Width$ = 72
Height$ = 80
?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z PROC	; createBackBuffer

; 284  : {

  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 285  :     // TODO: This is based on Handmade Hero code. Will need to reference and look at licences later on
; 286  :     //       website: handmadehero.org
; 287  :     if(Buffer->Memory)

  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  00019	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  0001e	74 17		 je	 SHORT $LN2@createBack

; 288  :     {
; 289  :         VirtualFree(Buffer->Memory, 0, MEM_RELEASE);

  00020	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00026	33 d2		 xor	 edx, edx
  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  0002d	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualFree
$LN2@createBack:

; 290  :     }
; 291  : 
; 292  :     Buffer->Width = Width;

  00037	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  00041	89 41 38	 mov	 DWORD PTR [rcx+56], eax

; 293  :     Buffer->Height = Height;

  00044	0f b7 44 24 50	 movzx	 eax, WORD PTR Height$[rsp]
  00049	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  0004e	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 294  :     Buffer->BytesPerPixel = 4;

  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  00056	c7 40 44 04 00
	00 00		 mov	 DWORD PTR [rax+68], 4

; 295  : 
; 296  :     Buffer->Info.bmiHeader.biSize = sizeof(Buffer->Info.bmiHeader);

  0005d	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  00062	c7 00 28 00 00
	00		 mov	 DWORD PTR [rax], 40	; 00000028H

; 297  :     Buffer->Info.bmiHeader.biWidth = Width;

  00068	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  0006d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  00072	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 298  :     Buffer->Info.bmiHeader.biHeight = -Height; // Negative tells windows that we raster top to bottom

  00075	0f b7 44 24 50	 movzx	 eax, WORD PTR Height$[rsp]
  0007a	f7 d8		 neg	 eax
  0007c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  00081	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 299  :     Buffer->Info.bmiHeader.biPlanes = 1;

  00084	b8 01 00 00 00	 mov	 eax, 1
  00089	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  0008e	66 89 41 0c	 mov	 WORD PTR [rcx+12], ax

; 300  :     Buffer->Info.bmiHeader.biBitCount = 32;

  00092	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  0009c	66 89 41 0e	 mov	 WORD PTR [rcx+14], ax

; 301  :     Buffer->Info.bmiHeader.biCompression = BI_RGB;

  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  000a5	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 302  : 
; 303  :     int MemorySize = Width * Height * Buffer->BytesPerPixel;

  000ac	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  000b1	0f b7 4c 24 50	 movzx	 ecx, WORD PTR Height$[rsp]
  000b6	0f af c1	 imul	 eax, ecx
  000b9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000be	0f af 41 44	 imul	 eax, DWORD PTR [rcx+68]
  000c2	89 44 24 20	 mov	 DWORD PTR MemorySize$[rsp], eax

; 304  :     Buffer->Memory = VirtualAlloc(0, MemorySize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);

  000c6	48 63 44 24 20	 movsxd	 rax, DWORD PTR MemorySize$[rsp]
  000cb	41 b9 04 00 00
	00		 mov	 r9d, 4
  000d1	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  000d7	48 8b d0	 mov	 rdx, rax
  000da	33 c9		 xor	 ecx, ecx
  000dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  000e2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000e7	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 305  :     Buffer->Pitch = Width * Buffer->BytesPerPixel;

  000eb	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  000f0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000f5	0f af 41 44	 imul	 eax, DWORD PTR [rcx+68]
  000f9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000fe	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 306  : }

  00101	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00105	c3		 ret	 0
?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z ENDP	; createBackBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
ClientRect$ = 32
__$ArrayPad$ = 48
Window$ = 80
Width$ = 88
Height$ = 96
?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z PROC		; getWindowSize

; 275  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 276  :     RECT ClientRect;
; 277  :     GetClientRect(Window, &ClientRect);

  00022	48 8d 54 24 20	 lea	 rdx, QWORD PTR ClientRect$[rsp]
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Window$[rsp]
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetClientRect

; 278  :     *Width = ClientRect.right - ClientRect.left;

  00032	8b 44 24 20	 mov	 eax, DWORD PTR ClientRect$[rsp]
  00036	8b 4c 24 28	 mov	 ecx, DWORD PTR ClientRect$[rsp+8]
  0003a	2b c8		 sub	 ecx, eax
  0003c	8b c1		 mov	 eax, ecx
  0003e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Width$[rsp]
  00043	66 89 01	 mov	 WORD PTR [rcx], ax

; 279  :     *Height = ClientRect.bottom - ClientRect.top;

  00046	8b 44 24 24	 mov	 eax, DWORD PTR ClientRect$[rsp+4]
  0004a	8b 4c 24 2c	 mov	 ecx, DWORD PTR ClientRect$[rsp+12]
  0004e	2b c8		 sub	 ecx, eax
  00050	8b c1		 mov	 eax, ecx
  00052	48 8b 4c 24 60	 mov	 rcx, QWORD PTR Height$[rsp]
  00057	66 89 01	 mov	 WORD PTR [rcx], ax

; 280  : }

  0005a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0005f	48 33 cc	 xor	 rcx, rsp
  00062	e8 00 00 00 00	 call	 __security_check_cookie
  00067	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006b	c3		 ret	 0
?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z ENDP		; getWindowSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
NameTableBaseNum$ = 48
NameTableBaseAdrs$ = 52
PixelY$1 = 56
PixelX$2 = 60
Registers$ = 64
NameTableValue$3 = 72
AttributeValue$4 = 73
PatternPixelValue$5 = 74
PixelColourIndex$6 = 75
PaletteIndex$7 = 76
PatternBase$ = 80
Colour$8 = 84
tv295 = 88
tv143 = 92
tv207 = 96
tv211 = 100
tv218 = 104
tv222 = 108
VisibleLine$ = 112
PostRenderLine$ = 116
VBlankLine$ = 120
PreRenderLine$ = 124
BackBuffer$ = 144
Ppu$ = 152
?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z PROC	; ppuTick

; 170  : {    

$LN47:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 171  :     ppu_registers *Registers = Ppu->Registers;

  00012	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0001a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001d	48 89 44 24 40	 mov	 QWORD PTR Registers$[rsp], rax

; 172  :     
; 173  :     // NOTE: This is where data is transferred from Cpu via IO registers
; 174  :     if(VRamAdrsChange)

  00022	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?VRamAdrsChange@@3HA, 0 ; VRamAdrsChange
  00029	74 7b		 je	 SHORT $LN4@ppuTick

; 175  :     {
; 176  :         Ppu->VRamIOAddress = (Ppu->VRamIOAddress << 8) | (uint16)Registers->VRamAddress;

  0002b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00033	0f b7 40 14	 movzx	 eax, WORD PTR [rax+20]
  00037	c1 e0 08	 shl	 eax, 8
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Registers$[rsp]
  0003f	0f b6 49 06	 movzx	 ecx, BYTE PTR [rcx+6]
  00043	0b c1		 or	 eax, ecx
  00045	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0004d	66 89 41 14	 mov	 WORD PTR [rcx+20], ax

; 177  :         
; 178  :         // NOTE: If address is on the pallette. Then IO register is updated immediately
; 179  :         if(0x3F00 <= Ppu->VRamIOAddress && Ppu->VRamIOAddress <= 0x3FFF)

  00051	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00059	0f b7 40 14	 movzx	 eax, WORD PTR [rax+20]
  0005d	3d 00 3f 00 00	 cmp	 eax, 16128		; 00003f00H
  00062	7c 38		 jl	 SHORT $LN5@ppuTick
  00064	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0006c	0f b7 40 14	 movzx	 eax, WORD PTR [rax+20]
  00070	3d ff 3f 00 00	 cmp	 eax, 16383		; 00003fffH
  00075	7f 25		 jg	 SHORT $LN5@ppuTick

; 180  :             Registers->VRamIO = readPpu8(Ppu->VRamIOAddress, Ppu->MemoryOffset);

  00077	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0007f	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00083	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0008b	0f b7 48 14	 movzx	 ecx, WORD PTR [rax+20]
  0008f	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  00094	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Registers$[rsp]
  00099	88 41 07	 mov	 BYTE PTR [rcx+7], al
$LN5@ppuTick:

; 181  : 
; 182  :         VRamAdrsChange = false;

  0009c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?VRamAdrsChange@@3HA, 0 ; VRamAdrsChange
$LN4@ppuTick:

; 183  :     }
; 184  :     if(VRamIOChange)

  000a6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?VRamIOChange@@3HA, 0 ; VRamIOChange
  000ad	74 77		 je	 SHORT $LN6@ppuTick

; 185  :     {
; 186  : #if 0
; 187  :         char TextBuffer[256];
; 188  :         _snprintf(TextBuffer, 256, "Address: %X Data: %X \n", Ppu->VRamIOAddress, Registers->VRamIO);
; 189  :         OutputDebugString(TextBuffer);
; 190  : #endif   
; 191  :         writePpu8(Registers->VRamIO, Ppu->VRamIOAddress, Ppu->MemoryOffset);

  000af	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  000b7	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  000bb	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  000c3	0f b7 50 14	 movzx	 edx, WORD PTR [rax+20]
  000c7	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  000cc	0f b6 48 07	 movzx	 ecx, BYTE PTR [rax+7]
  000d0	e8 00 00 00 00	 call	 ?writePpu8@@YAXEG_K@Z	; writePpu8

; 192  :         if(Registers->Ctrl1 & (1 << 2))

  000d5	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  000da	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000dd	83 e0 04	 and	 eax, 4
  000e0	85 c0		 test	 eax, eax
  000e2	74 1d		 je	 SHORT $LN7@ppuTick

; 193  :             Ppu->VRamIOAddress += 32;

  000e4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  000ec	0f b7 40 14	 movzx	 eax, WORD PTR [rax+20]
  000f0	83 c0 20	 add	 eax, 32			; 00000020H
  000f3	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  000fb	66 89 41 14	 mov	 WORD PTR [rcx+20], ax

; 194  :         else

  000ff	eb 1b		 jmp	 SHORT $LN8@ppuTick
$LN7@ppuTick:

; 195  :             ++Ppu->VRamIOAddress;

  00101	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00109	0f b7 40 14	 movzx	 eax, WORD PTR [rax+20]
  0010d	66 ff c0	 inc	 ax
  00110	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00118	66 89 41 14	 mov	 WORD PTR [rcx+20], ax
$LN8@ppuTick:

; 196  :         VRamIOChange = false;

  0011c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?VRamIOChange@@3HA, 0 ; VRamIOChange
$LN6@ppuTick:

; 197  :     }
; 198  : 
; 199  :     VRamAdrsOnPalette = (0x3F00 <= Ppu->VRamIOAddress && Ppu->VRamIOAddress <= 0x3FFF);

  00126	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0012e	0f b7 40 14	 movzx	 eax, WORD PTR [rax+20]
  00132	3d 00 3f 00 00	 cmp	 eax, 16128		; 00003f00H
  00137	7c 1d		 jl	 SHORT $LN37@ppuTick
  00139	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00141	0f b7 40 14	 movzx	 eax, WORD PTR [rax+20]
  00145	3d ff 3f 00 00	 cmp	 eax, 16383		; 00003fffH
  0014a	7f 0a		 jg	 SHORT $LN37@ppuTick
  0014c	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv143[rsp], 1
  00154	eb 08		 jmp	 SHORT $LN38@ppuTick
$LN37@ppuTick:
  00156	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv143[rsp], 0
$LN38@ppuTick:
  0015e	8b 44 24 5c	 mov	 eax, DWORD PTR tv143[rsp]
  00162	89 05 00 00 00
	00		 mov	 DWORD PTR ?VRamAdrsOnPalette@@3HA, eax ; VRamAdrsOnPalette

; 200  :     
; 201  :     if(IOReadFromCpu)

  00168	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IOReadFromCpu@@3HA, 0 ; IOReadFromCpu
  0016f	0f 84 ed 00 00
	00		 je	 $LN9@ppuTick

; 202  :     {
; 203  :         if(VRamAdrsOnPalette)

  00175	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?VRamAdrsOnPalette@@3HA, 0 ; VRamAdrsOnPalette
  0017c	74 6e		 je	 SHORT $LN10@ppuTick

; 204  :         {
; 205  :             if(Registers->Ctrl1 & (1 << 2))

  0017e	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00183	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00186	83 e0 04	 and	 eax, 4
  00189	85 c0		 test	 eax, eax
  0018b	74 1d		 je	 SHORT $LN12@ppuTick

; 206  :                 Ppu->VRamIOAddress += 32;

  0018d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00195	0f b7 40 14	 movzx	 eax, WORD PTR [rax+20]
  00199	83 c0 20	 add	 eax, 32			; 00000020H
  0019c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  001a4	66 89 41 14	 mov	 WORD PTR [rcx+20], ax

; 207  :             else

  001a8	eb 1b		 jmp	 SHORT $LN13@ppuTick
$LN12@ppuTick:

; 208  :                 ++Ppu->VRamIOAddress;

  001aa	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  001b2	0f b7 40 14	 movzx	 eax, WORD PTR [rax+20]
  001b6	66 ff c0	 inc	 ax
  001b9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  001c1	66 89 41 14	 mov	 WORD PTR [rcx+20], ax
$LN13@ppuTick:

; 209  :             Registers->VRamIO = readPpu8(Ppu->VRamIOAddress, Ppu->MemoryOffset);

  001c5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  001cd	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  001d1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  001d9	0f b7 48 14	 movzx	 ecx, WORD PTR [rax+20]
  001dd	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  001e2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Registers$[rsp]
  001e7	88 41 07	 mov	 BYTE PTR [rcx+7], al

; 210  :         }
; 211  :         else

  001ea	eb 6c		 jmp	 SHORT $LN11@ppuTick
$LN10@ppuTick:

; 212  :         {
; 213  :             Registers->VRamIO = readPpu8(Ppu->VRamIOAddress, Ppu->MemoryOffset);

  001ec	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  001f4	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  001f8	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00200	0f b7 48 14	 movzx	 ecx, WORD PTR [rax+20]
  00204	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  00209	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Registers$[rsp]
  0020e	88 41 07	 mov	 BYTE PTR [rcx+7], al

; 214  :             if(Registers->Ctrl1 & (1 << 2))

  00211	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00216	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00219	83 e0 04	 and	 eax, 4
  0021c	85 c0		 test	 eax, eax
  0021e	74 1d		 je	 SHORT $LN14@ppuTick

; 215  :                 Ppu->VRamIOAddress += 32;

  00220	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00228	0f b7 40 14	 movzx	 eax, WORD PTR [rax+20]
  0022c	83 c0 20	 add	 eax, 32			; 00000020H
  0022f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00237	66 89 41 14	 mov	 WORD PTR [rcx+20], ax

; 216  :             else

  0023b	eb 1b		 jmp	 SHORT $LN15@ppuTick
$LN14@ppuTick:

; 217  :                 ++Ppu->VRamIOAddress;

  0023d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00245	0f b7 40 14	 movzx	 eax, WORD PTR [rax+20]
  00249	66 ff c0	 inc	 ax
  0024c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00254	66 89 41 14	 mov	 WORD PTR [rcx+20], ax
$LN15@ppuTick:
$LN11@ppuTick:

; 218  :             
; 219  :         }
; 220  :         IOReadFromCpu = false;

  00258	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?IOReadFromCpu@@3HA, 0 ; IOReadFromCpu
$LN9@ppuTick:

; 221  :     }
; 222  :     
; 223  :     if(ResetVRamIOAdrs)

  00262	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ResetVRamIOAdrs@@3HA, 0 ; ResetVRamIOAdrs
  00269	74 18		 je	 SHORT $LN16@ppuTick

; 224  :     {
; 225  :         Ppu->VRamIOAddress = 0;

  0026b	33 c0		 xor	 eax, eax
  0026d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00275	66 89 41 14	 mov	 WORD PTR [rcx+20], ax

; 226  :         ResetVRamIOAdrs = false;

  00279	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ResetVRamIOAdrs@@3HA, 0 ; ResetVRamIOAdrs
$LN16@ppuTick:

; 227  :     }
; 228  :     if(ResetScrollIOAdrs)

  00283	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ResetScrollIOAdrs@@3HA, 0 ; ResetScrollIOAdrs
  0028a	74 0a		 je	 SHORT $LN17@ppuTick

; 229  :     {
; 230  :         // TODO:
; 231  :         ResetScrollIOAdrs = false;

  0028c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ResetScrollIOAdrs@@3HA, 0 ; ResetScrollIOAdrs
$LN17@ppuTick:

; 232  :     }
; 233  : 
; 234  :     
; 235  :     
; 236  :     uint16 PatternBase = 0x0000;

  00296	33 c0		 xor	 eax, eax
  00298	66 89 44 24 50	 mov	 WORD PTR PatternBase$[rsp], ax

; 237  :     if(Registers->Ctrl1 & (1 << 4))

  0029d	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  002a2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002a5	83 e0 10	 and	 eax, 16
  002a8	85 c0		 test	 eax, eax
  002aa	74 0a		 je	 SHORT $LN18@ppuTick

; 238  :         PatternBase = 0x1000;

  002ac	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  002b1	66 89 44 24 50	 mov	 WORD PTR PatternBase$[rsp], ax
$LN18@ppuTick:

; 239  : 
; 240  :     uint8 NameTableBaseNum = Registers->Ctrl1 & 3;

  002b6	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  002bb	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002be	83 e0 03	 and	 eax, 3
  002c1	88 44 24 30	 mov	 BYTE PTR NameTableBaseNum$[rsp], al

; 241  :     uint16 NameTableBaseAdrs; 
; 242  :     if(NameTableBaseNum == 0)

  002c5	0f b6 44 24 30	 movzx	 eax, BYTE PTR NameTableBaseNum$[rsp]
  002ca	85 c0		 test	 eax, eax
  002cc	75 0c		 jne	 SHORT $LN19@ppuTick

; 243  :         NameTableBaseAdrs = 0x2000;

  002ce	b8 00 20 00 00	 mov	 eax, 8192		; 00002000H
  002d3	66 89 44 24 34	 mov	 WORD PTR NameTableBaseAdrs$[rsp], ax
  002d8	eb 40		 jmp	 SHORT $LN20@ppuTick
$LN19@ppuTick:

; 244  :     else if(NameTableBaseNum == 1)

  002da	0f b6 44 24 30	 movzx	 eax, BYTE PTR NameTableBaseNum$[rsp]
  002df	83 f8 01	 cmp	 eax, 1
  002e2	75 0c		 jne	 SHORT $LN21@ppuTick

; 245  :         NameTableBaseAdrs = 0x2400;

  002e4	b8 00 24 00 00	 mov	 eax, 9216		; 00002400H
  002e9	66 89 44 24 34	 mov	 WORD PTR NameTableBaseAdrs$[rsp], ax
  002ee	eb 2a		 jmp	 SHORT $LN22@ppuTick
$LN21@ppuTick:

; 246  :     else if(NameTableBaseNum == 2)

  002f0	0f b6 44 24 30	 movzx	 eax, BYTE PTR NameTableBaseNum$[rsp]
  002f5	83 f8 02	 cmp	 eax, 2
  002f8	75 0c		 jne	 SHORT $LN23@ppuTick

; 247  :         NameTableBaseAdrs = 0x2800;

  002fa	b8 00 28 00 00	 mov	 eax, 10240		; 00002800H
  002ff	66 89 44 24 34	 mov	 WORD PTR NameTableBaseAdrs$[rsp], ax
  00304	eb 14		 jmp	 SHORT $LN24@ppuTick
$LN23@ppuTick:

; 248  :     else if(NameTableBaseNum == 3)

  00306	0f b6 44 24 30	 movzx	 eax, BYTE PTR NameTableBaseNum$[rsp]
  0030b	83 f8 03	 cmp	 eax, 3
  0030e	75 0a		 jne	 SHORT $LN25@ppuTick

; 249  :         NameTableBaseAdrs = 0x2C00;

  00310	b8 00 2c 00 00	 mov	 eax, 11264		; 00002c00H
  00315	66 89 44 24 34	 mov	 WORD PTR NameTableBaseAdrs$[rsp], ax
$LN25@ppuTick:
$LN24@ppuTick:
$LN22@ppuTick:
$LN20@ppuTick:

; 250  : 
; 251  :     
; 252  :     
; 253  :     bool32 VisibleLine = (0 <= Ppu->Scanline && Ppu->Scanline <= 239);

  0031a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00322	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00326	85 c0		 test	 eax, eax
  00328	7c 1d		 jl	 SHORT $LN39@ppuTick
  0032a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00332	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00336	3d ef 00 00 00	 cmp	 eax, 239		; 000000efH
  0033b	7f 0a		 jg	 SHORT $LN39@ppuTick
  0033d	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv207[rsp], 1
  00345	eb 08		 jmp	 SHORT $LN40@ppuTick
$LN39@ppuTick:
  00347	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv207[rsp], 0
$LN40@ppuTick:
  0034f	8b 44 24 60	 mov	 eax, DWORD PTR tv207[rsp]
  00353	89 44 24 70	 mov	 DWORD PTR VisibleLine$[rsp], eax

; 254  :     bool32 PostRenderLine = (Ppu->Scanline == 240);

  00357	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0035f	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00363	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  00368	75 0a		 jne	 SHORT $LN41@ppuTick
  0036a	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv211[rsp], 1
  00372	eb 08		 jmp	 SHORT $LN42@ppuTick
$LN41@ppuTick:
  00374	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv211[rsp], 0
$LN42@ppuTick:
  0037c	8b 44 24 64	 mov	 eax, DWORD PTR tv211[rsp]
  00380	89 44 24 74	 mov	 DWORD PTR PostRenderLine$[rsp], eax

; 255  :     bool32 VBlankLine = (241 <= Ppu->Scanline && Ppu->Scanline <= 260);

  00384	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0038c	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00390	3d f1 00 00 00	 cmp	 eax, 241		; 000000f1H
  00395	7c 1d		 jl	 SHORT $LN43@ppuTick
  00397	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0039f	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  003a3	3d 04 01 00 00	 cmp	 eax, 260		; 00000104H
  003a8	7f 0a		 jg	 SHORT $LN43@ppuTick
  003aa	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv218[rsp], 1
  003b2	eb 08		 jmp	 SHORT $LN44@ppuTick
$LN43@ppuTick:
  003b4	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv218[rsp], 0
$LN44@ppuTick:
  003bc	8b 44 24 68	 mov	 eax, DWORD PTR tv218[rsp]
  003c0	89 44 24 78	 mov	 DWORD PTR VBlankLine$[rsp], eax

; 256  :     bool32 PreRenderLine = (Ppu->Scanline == 261);

  003c4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  003cc	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  003d0	3d 05 01 00 00	 cmp	 eax, 261		; 00000105H
  003d5	75 0a		 jne	 SHORT $LN45@ppuTick
  003d7	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv222[rsp], 1
  003df	eb 08		 jmp	 SHORT $LN46@ppuTick
$LN45@ppuTick:
  003e1	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv222[rsp], 0
$LN46@ppuTick:
  003e9	8b 44 24 6c	 mov	 eax, DWORD PTR tv222[rsp]
  003ed	89 44 24 7c	 mov	 DWORD PTR PreRenderLine$[rsp], eax

; 257  :     
; 258  :     if(VisibleLine)

  003f1	83 7c 24 70 00	 cmp	 DWORD PTR VisibleLine$[rsp], 0
  003f6	0f 84 44 01 00
	00		 je	 $LN26@ppuTick

; 259  :     {
; 260  :         // NOTE: At the moment I am going to just produce a pixel per cycle with fetching happening each time.
; 261  :         // TODO: Timing of fetches so less loading happens, using fine X scrolling to move through bytes
; 262  : 
; 263  :         if(1 <= Ppu->ScanlineCycle && Ppu->ScanlineCycle <= PIXEL_WIDTH)

  003fc	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00404	0f b7 40 12	 movzx	 eax, WORD PTR [rax+18]
  00408	83 f8 01	 cmp	 eax, 1
  0040b	0f 8c 2f 01 00
	00		 jl	 $LN27@ppuTick
  00411	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00419	0f b7 40 12	 movzx	 eax, WORD PTR [rax+18]
  0041d	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00422	0f 8f 18 01 00
	00		 jg	 $LN27@ppuTick

; 264  :         {
; 265  :             uint16 PixelX = Ppu->ScanlineCycle - 1;

  00428	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00430	0f b7 40 12	 movzx	 eax, WORD PTR [rax+18]
  00434	ff c8		 dec	 eax
  00436	66 89 44 24 3c	 mov	 WORD PTR PixelX$2[rsp], ax

; 266  :             uint16 PixelY = Ppu->Scanline;

  0043b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00443	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00447	66 89 44 24 38	 mov	 WORD PTR PixelY$1[rsp], ax

; 267  : 
; 268  :             
; 269  :             uint8 NameTableValue = getNameTableValue(PixelX, PixelY, NameTableBaseAdrs, Ppu->MemoryOffset);

  0044c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00454	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
  00458	44 0f b7 44 24
	34		 movzx	 r8d, WORD PTR NameTableBaseAdrs$[rsp]
  0045e	0f b7 54 24 38	 movzx	 edx, WORD PTR PixelY$1[rsp]
  00463	0f b7 4c 24 3c	 movzx	 ecx, WORD PTR PixelX$2[rsp]
  00468	e8 00 00 00 00	 call	 ?getNameTableValue@@YAEGGG_K@Z ; getNameTableValue
  0046d	88 44 24 48	 mov	 BYTE PTR NameTableValue$3[rsp], al

; 270  :             uint8 PatternPixelValue = getPatternValue(PixelX, PixelY, NameTableValue, PatternBase, Ppu->MemoryOffset);

  00471	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00479	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0047d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00482	44 0f b7 4c 24
	50		 movzx	 r9d, WORD PTR PatternBase$[rsp]
  00488	44 0f b6 44 24
	48		 movzx	 r8d, BYTE PTR NameTableValue$3[rsp]
  0048e	0f b7 54 24 38	 movzx	 edx, WORD PTR PixelY$1[rsp]
  00493	0f b7 4c 24 3c	 movzx	 ecx, WORD PTR PixelX$2[rsp]
  00498	e8 00 00 00 00	 call	 ?getPatternValue@@YAEGGEG_K@Z ; getPatternValue
  0049d	88 44 24 4a	 mov	 BYTE PTR PatternPixelValue$5[rsp], al

; 271  :             uint8 AttributeValue = getAttributeValue(PixelX, PixelY, NameTableBaseAdrs + ATTRIBUTE_OFFSET, Ppu->MemoryOffset);

  004a1	0f b7 44 24 34	 movzx	 eax, WORD PTR NameTableBaseAdrs$[rsp]
  004a6	05 c0 03 00 00	 add	 eax, 960		; 000003c0H
  004ab	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  004b3	4c 8b 49 08	 mov	 r9, QWORD PTR [rcx+8]
  004b7	44 0f b7 c0	 movzx	 r8d, ax
  004bb	0f b7 54 24 38	 movzx	 edx, WORD PTR PixelY$1[rsp]
  004c0	0f b7 4c 24 3c	 movzx	 ecx, WORD PTR PixelX$2[rsp]
  004c5	e8 00 00 00 00	 call	 ?getAttributeValue@@YAEGGG_K@Z ; getAttributeValue
  004ca	88 44 24 49	 mov	 BYTE PTR AttributeValue$4[rsp], al

; 272  : 
; 273  :             uint8 PixelColourIndex = (AttributeValue << 2) | PatternPixelValue;

  004ce	0f b6 44 24 49	 movzx	 eax, BYTE PTR AttributeValue$4[rsp]
  004d3	c1 e0 02	 shl	 eax, 2
  004d6	0f b6 4c 24 4a	 movzx	 ecx, BYTE PTR PatternPixelValue$5[rsp]
  004db	0b c1		 or	 eax, ecx
  004dd	88 44 24 4b	 mov	 BYTE PTR PixelColourIndex$6[rsp], al

; 274  : 
; 275  :             uint8 PaletteIndex = readPpu8(BGRD_PALETTE_ADRS + PixelColourIndex, Ppu->MemoryOffset);

  004e1	0f b6 44 24 4b	 movzx	 eax, BYTE PTR PixelColourIndex$6[rsp]
  004e6	05 00 3f 00 00	 add	 eax, 16128		; 00003f00H
  004eb	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  004f3	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  004f7	0f b7 c8	 movzx	 ecx, ax
  004fa	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  004ff	88 44 24 4c	 mov	 BYTE PTR PaletteIndex$7[rsp], al

; 276  :             
; 277  :             uint8 Colour[3] = {};

  00503	48 8d 44 24 54	 lea	 rax, QWORD PTR Colour$8[rsp]
  00508	48 8b f8	 mov	 rdi, rax
  0050b	33 c0		 xor	 eax, eax
  0050d	b9 03 00 00 00	 mov	 ecx, 3
  00512	f3 aa		 rep stosb

; 278  :             getPaletteValue(PaletteIndex, Colour);

  00514	48 8d 54 24 54	 lea	 rdx, QWORD PTR Colour$8[rsp]
  00519	0f b6 4c 24 4c	 movzx	 ecx, BYTE PTR PaletteIndex$7[rsp]
  0051e	e8 00 00 00 00	 call	 ?getPaletteValue@@YAXEPEAE@Z ; getPaletteValue

; 279  :            
; 280  :             drawPixel(Ppu, PixelX, PixelY, Colour);

  00523	4c 8d 4c 24 54	 lea	 r9, QWORD PTR Colour$8[rsp]
  00528	44 0f b7 44 24
	38		 movzx	 r8d, WORD PTR PixelY$1[rsp]
  0052e	0f b7 54 24 3c	 movzx	 edx, WORD PTR PixelX$2[rsp]
  00533	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0053b	e8 00 00 00 00	 call	 ?drawPixel@@YAXPEAUppu@@GGPEAE@Z ; drawPixel
$LN27@ppuTick:
$LN26@ppuTick:

; 281  :             
; 282  : #if 0 
; 283  :             char TextBuffer[256];
; 284  :             _snprintf(TextBuffer, 256, "PixelPattern: %X AtrbValue: %X Complete: %X PaletteIndex: %X RGB: %d, %d, %d\n",
; 285  :                       PatternPixelValue, AttributeValue, PixelColourIndex, PaletteIndex, Colour[0], Colour[1], Colour[2]);
; 286  :             OutputDebugString(TextBuffer);
; 287  : 
; 288  : #endif
; 289  :         }
; 290  :     }
; 291  :     if(PostRenderLine)

  00540	83 7c 24 74 00	 cmp	 DWORD PTR PostRenderLine$[rsp], 0
  00545	74 0a		 je	 SHORT $LN28@ppuTick

; 292  :     {
; 293  :         DrawScreen = true;

  00547	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?DrawScreen@@3HA, 1 ; DrawScreen
$LN28@ppuTick:

; 294  :         // NOTE: Ppu sits idle for this scanline
; 295  :     }
; 296  :     if(VBlankLine)

  00551	83 7c 24 78 00	 cmp	 DWORD PTR VBlankLine$[rsp], 0
  00556	74 43		 je	 SHORT $LN29@ppuTick

; 297  :     {
; 298  :         if(Ppu->Scanline == 241 && Ppu->ScanlineCycle == 1)

  00558	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00560	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00564	3d f1 00 00 00	 cmp	 eax, 241		; 000000f1H
  00569	75 30		 jne	 SHORT $LN30@ppuTick
  0056b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00573	0f b7 40 12	 movzx	 eax, WORD PTR [rax+18]
  00577	83 f8 01	 cmp	 eax, 1
  0057a	75 1f		 jne	 SHORT $LN30@ppuTick

; 299  :         {
; 300  :             NmiTriggered = true;

  0057c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?NmiTriggered@@3HA, 1 ; NmiTriggered

; 301  :             Registers->Status = Registers->Status | (1 << 7); // Set VBlank Status

  00586	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  0058b	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0058f	0f ba e8 07	 bts	 eax, 7
  00593	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Registers$[rsp]
  00598	88 41 02	 mov	 BYTE PTR [rcx+2], al
$LN30@ppuTick:
$LN29@ppuTick:

; 302  :         }
; 303  :     }
; 304  :     if(PreRenderLine)

  0059b	83 7c 24 7c 00	 cmp	 DWORD PTR PreRenderLine$[rsp], 0
  005a0	0f 84 83 00 00
	00		 je	 $LN31@ppuTick

; 305  :     {
; 306  :         switch(Ppu->ScanlineCycle)

  005a6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  005ae	0f b7 40 12	 movzx	 eax, WORD PTR [rax+18]
  005b2	89 44 24 58	 mov	 DWORD PTR tv295[rsp], eax
  005b6	83 7c 24 58 01	 cmp	 DWORD PTR tv295[rsp], 1
  005bb	74 16		 je	 SHORT $LN32@ppuTick
  005bd	81 7c 24 58 41
	01 00 00	 cmp	 DWORD PTR tv295[rsp], 321 ; 00000141H
  005c5	74 4b		 je	 SHORT $LN33@ppuTick
  005c7	81 7c 24 58 49
	01 00 00	 cmp	 DWORD PTR tv295[rsp], 329 ; 00000149H
  005cf	74 41		 je	 SHORT $LN33@ppuTick
  005d1	eb 56		 jmp	 SHORT $LN2@ppuTick
$LN32@ppuTick:

; 307  :         {
; 308  :             case 1:
; 309  :             {
; 310  :                 Registers->Status = Registers->Status & ~(1 << 5); // Clear Sprite Overflow

  005d3	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  005d8	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  005dc	83 e0 df	 and	 eax, -33		; ffffffffffffffdfH
  005df	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Registers$[rsp]
  005e4	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 311  :                 Registers->Status = Registers->Status & ~(1 << 6); // Clear Sprite Zero Hit

  005e7	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  005ec	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  005f0	83 e0 bf	 and	 eax, -65		; ffffffffffffffbfH
  005f3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Registers$[rsp]
  005f8	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 312  :                 Registers->Status = Registers->Status & ~(1 << 7); // Clear Vblank status

  005fb	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00600	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00604	0f ba f0 07	 btr	 eax, 7
  00608	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Registers$[rsp]
  0060d	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 313  :                 break;

  00610	eb 17		 jmp	 SHORT $LN2@ppuTick
$LN33@ppuTick:

; 314  :             }
; 315  :             case 321:
; 316  :             case 329:
; 317  :             {
; 318  :                 Ppu->NameTableByte1 = Ppu->NameTableByte2;

  00612	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0061a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00622	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  00626	88 48 22	 mov	 BYTE PTR [rax+34], cl
$LN2@ppuTick:
$LN31@ppuTick:

; 319  :                 //Ppu->NameTableByte2 = getNameTableValue(PixelFetchX, PixelFetchY, TableBaseNum, Ppu->MemoryOffset);
; 320  :                 break;
; 321  :             }
; 322  :         }
; 323  :     }
; 324  : 
; 325  :     ++Ppu->ScanlineCycle;

  00629	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00631	0f b7 40 12	 movzx	 eax, WORD PTR [rax+18]
  00635	66 ff c0	 inc	 ax
  00638	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00640	66 89 41 12	 mov	 WORD PTR [rcx+18], ax

; 326  : 
; 327  :     if(Ppu->ScanlineCycle > 341)

  00644	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0064c	0f b7 40 12	 movzx	 eax, WORD PTR [rax+18]
  00650	3d 55 01 00 00	 cmp	 eax, 341		; 00000155H
  00655	7e 28		 jle	 SHORT $LN34@ppuTick

; 328  :     {
; 329  :         Ppu->Scanline += 1;

  00657	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0065f	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00663	ff c0		 inc	 eax
  00665	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0066d	66 89 41 10	 mov	 WORD PTR [rcx+16], ax

; 330  :         Ppu->ScanlineCycle = 0;

  00671	33 c0		 xor	 eax, eax
  00673	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0067b	66 89 41 12	 mov	 WORD PTR [rcx+18], ax
$LN34@ppuTick:

; 331  :     }
; 332  : 
; 333  :     if(Ppu->Scanline == 262)

  0067f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00687	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  0068b	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  00690	75 0e		 jne	 SHORT $LN35@ppuTick

; 334  :     {
; 335  :         Ppu->Scanline = 0;

  00692	33 c0		 xor	 eax, eax
  00694	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0069c	66 89 41 10	 mov	 WORD PTR [rcx+16], ax
$LN35@ppuTick:

; 336  :     }
; 337  : }

  006a0	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  006a7	5f		 pop	 rdi
  006a8	c3		 ret	 0
?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z ENDP	; ppuTick
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
Value$ = 32
BlockRelY$ = 33
Attribute$ = 34
BlockRelX$ = 35
AttributeByteY$ = 36
AttributeByteX$ = 37
AtrbByteAdrs$ = 40
X$ = 64
Y$ = 72
AtrbTableBaseAdrs$ = 80
MemoryOffset$ = 88
?getAttributeValue@@YAEGGG_K@Z PROC			; getAttributeValue

; 141  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000b	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00010	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00015	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 142  :     uint8 AttributeByteX = X / PIXELS_PER_ATRB_BYTE;

  00019	0f b7 44 24 40	 movzx	 eax, WORD PTR X$[rsp]
  0001e	99		 cdq
  0001f	83 e2 1f	 and	 edx, 31
  00022	03 c2		 add	 eax, edx
  00024	c1 f8 05	 sar	 eax, 5
  00027	88 44 24 25	 mov	 BYTE PTR AttributeByteX$[rsp], al

; 143  :     uint8 AttributeByteY = Y / PIXELS_PER_ATRB_BYTE;

  0002b	0f b7 44 24 48	 movzx	 eax, WORD PTR Y$[rsp]
  00030	99		 cdq
  00031	83 e2 1f	 and	 edx, 31
  00034	03 c2		 add	 eax, edx
  00036	c1 f8 05	 sar	 eax, 5
  00039	88 44 24 24	 mov	 BYTE PTR AttributeByteY$[rsp], al

; 144  :     
; 145  :     uint16 AtrbByteAdrs = (AtrbTableBaseAdrs + (AttributeByteY * ATRB_BYTE_PER_ROW)) + AttributeByteX;

  0003d	0f b7 44 24 50	 movzx	 eax, WORD PTR AtrbTableBaseAdrs$[rsp]
  00042	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR AttributeByteY$[rsp]
  00047	8d 04 c8	 lea	 eax, DWORD PTR [rax+rcx*8]
  0004a	0f b6 4c 24 25	 movzx	 ecx, BYTE PTR AttributeByteX$[rsp]
  0004f	03 c1		 add	 eax, ecx
  00051	66 89 44 24 28	 mov	 WORD PTR AtrbByteAdrs$[rsp], ax

; 146  :     uint8 Attribute = readPpu8(AtrbByteAdrs, MemoryOffset);

  00056	48 8b 54 24 58	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0005b	0f b7 4c 24 28	 movzx	 ecx, WORD PTR AtrbByteAdrs$[rsp]
  00060	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  00065	88 44 24 22	 mov	 BYTE PTR Attribute$[rsp], al

; 147  :     
; 148  :     uint8 BlockRelX = (X % PIXELS_PER_ATRB_BYTE) / 16;

  00069	0f b7 44 24 40	 movzx	 eax, WORD PTR X$[rsp]
  0006e	99		 cdq
  0006f	83 e2 1f	 and	 edx, 31
  00072	03 c2		 add	 eax, edx
  00074	83 e0 1f	 and	 eax, 31
  00077	2b c2		 sub	 eax, edx
  00079	99		 cdq
  0007a	83 e2 0f	 and	 edx, 15
  0007d	03 c2		 add	 eax, edx
  0007f	c1 f8 04	 sar	 eax, 4
  00082	88 44 24 23	 mov	 BYTE PTR BlockRelX$[rsp], al

; 149  :     uint8 BlockRelY = (Y % PIXELS_PER_ATRB_BYTE) / 16;

  00086	0f b7 44 24 48	 movzx	 eax, WORD PTR Y$[rsp]
  0008b	99		 cdq
  0008c	83 e2 1f	 and	 edx, 31
  0008f	03 c2		 add	 eax, edx
  00091	83 e0 1f	 and	 eax, 31
  00094	2b c2		 sub	 eax, edx
  00096	99		 cdq
  00097	83 e2 0f	 and	 edx, 15
  0009a	03 c2		 add	 eax, edx
  0009c	c1 f8 04	 sar	 eax, 4
  0009f	88 44 24 21	 mov	 BYTE PTR BlockRelY$[rsp], al

; 150  : 
; 151  :     uint8 Value;
; 152  :     
; 153  :     if(BlockRelX == 0)

  000a3	0f b6 44 24 23	 movzx	 eax, BYTE PTR BlockRelX$[rsp]
  000a8	85 c0		 test	 eax, eax
  000aa	75 2a		 jne	 SHORT $LN2@getAttribu

; 154  :         if(BlockRelY == 0)

  000ac	0f b6 44 24 21	 movzx	 eax, BYTE PTR BlockRelY$[rsp]
  000b1	85 c0		 test	 eax, eax
  000b3	75 0b		 jne	 SHORT $LN3@getAttribu

; 155  :             Value = Attribute;

  000b5	0f b6 44 24 22	 movzx	 eax, BYTE PTR Attribute$[rsp]
  000ba	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
  000be	eb 16		 jmp	 SHORT $LN4@getAttribu
$LN3@getAttribu:

; 156  :         else if(BlockRelY == 1)

  000c0	0f b6 44 24 21	 movzx	 eax, BYTE PTR BlockRelY$[rsp]
  000c5	83 f8 01	 cmp	 eax, 1
  000c8	75 0c		 jne	 SHORT $LN5@getAttribu

; 157  :             Value = Attribute >> 4;

  000ca	0f b6 44 24 22	 movzx	 eax, BYTE PTR Attribute$[rsp]
  000cf	c1 f8 04	 sar	 eax, 4
  000d2	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
$LN5@getAttribu:
$LN4@getAttribu:
$LN2@getAttribu:

; 158  :     if(BlockRelX == 1)

  000d6	0f b6 44 24 23	 movzx	 eax, BYTE PTR BlockRelX$[rsp]
  000db	83 f8 01	 cmp	 eax, 1
  000de	75 2d		 jne	 SHORT $LN6@getAttribu

; 159  :         if(BlockRelY == 0)

  000e0	0f b6 44 24 21	 movzx	 eax, BYTE PTR BlockRelY$[rsp]
  000e5	85 c0		 test	 eax, eax
  000e7	75 0e		 jne	 SHORT $LN7@getAttribu

; 160  :             Value = Attribute >> 2;

  000e9	0f b6 44 24 22	 movzx	 eax, BYTE PTR Attribute$[rsp]
  000ee	c1 f8 02	 sar	 eax, 2
  000f1	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
  000f5	eb 16		 jmp	 SHORT $LN8@getAttribu
$LN7@getAttribu:

; 161  :         else if(BlockRelY == 1)

  000f7	0f b6 44 24 21	 movzx	 eax, BYTE PTR BlockRelY$[rsp]
  000fc	83 f8 01	 cmp	 eax, 1
  000ff	75 0c		 jne	 SHORT $LN9@getAttribu

; 162  :             Value = Attribute >> 6;

  00101	0f b6 44 24 22	 movzx	 eax, BYTE PTR Attribute$[rsp]
  00106	c1 f8 06	 sar	 eax, 6
  00109	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
$LN9@getAttribu:
$LN8@getAttribu:
$LN6@getAttribu:

; 163  :     
; 164  :     Value = Value & 3;

  0010d	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  00112	83 e0 03	 and	 eax, 3
  00115	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 165  :     
; 166  :     return(Value);

  00119	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]

; 167  : }

  0011e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00122	c3		 ret	 0
?getAttributeValue@@YAEGGG_K@Z ENDP			; getAttributeValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
TileRelY$ = 32
TileRelX$ = 33
HighPattern$ = 34
LowPattern$ = 35
Value$ = 36
LowAddress$ = 40
HighAddress$ = 48
X$ = 80
Y$ = 88
NameTableValue$ = 96
PatternBase$ = 104
MemoryOffset$ = 112
?getPatternValue@@YAEGGEG_K@Z PROC			; getPatternValue

; 116  : {

  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000b	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00010	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00015	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 117  :     uint8 TileRelX = X % PIXEL_PER_TILE;

  00019	0f b7 44 24 50	 movzx	 eax, WORD PTR X$[rsp]
  0001e	99		 cdq
  0001f	83 e2 07	 and	 edx, 7
  00022	03 c2		 add	 eax, edx
  00024	83 e0 07	 and	 eax, 7
  00027	2b c2		 sub	 eax, edx
  00029	88 44 24 21	 mov	 BYTE PTR TileRelX$[rsp], al

; 118  :     uint8 TileRelY = Y % PIXEL_PER_TILE;

  0002d	0f b7 44 24 58	 movzx	 eax, WORD PTR Y$[rsp]
  00032	99		 cdq
  00033	83 e2 07	 and	 edx, 7
  00036	03 c2		 add	 eax, edx
  00038	83 e0 07	 and	 eax, 7
  0003b	2b c2		 sub	 eax, edx
  0003d	88 44 24 20	 mov	 BYTE PTR TileRelY$[rsp], al

; 119  :     
; 120  :     Assert(0 <= TileRelX && TileRelX < PIXEL_PER_TILE);

  00041	0f b6 44 24 21	 movzx	 eax, BYTE PTR TileRelX$[rsp]
  00046	85 c0		 test	 eax, eax
  00048	7c 0a		 jl	 SHORT $LN3@getPattern
  0004a	0f b6 44 24 21	 movzx	 eax, BYTE PTR TileRelX$[rsp]
  0004f	83 f8 08	 cmp	 eax, 8
  00052	7c 0b		 jl	 SHORT $LN2@getPattern
$LN3@getPattern:
  00054	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@getPattern:

; 121  :     Assert(0 <= TileRelY && TileRelY < PIXEL_PER_TILE);

  0005f	0f b6 44 24 20	 movzx	 eax, BYTE PTR TileRelY$[rsp]
  00064	85 c0		 test	 eax, eax
  00066	7c 0a		 jl	 SHORT $LN5@getPattern
  00068	0f b6 44 24 20	 movzx	 eax, BYTE PTR TileRelY$[rsp]
  0006d	83 f8 08	 cmp	 eax, 8
  00070	7c 0b		 jl	 SHORT $LN4@getPattern
$LN5@getPattern:
  00072	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN4@getPattern:

; 122  :   
; 123  :     uint64 LowAddress = (PatternBase + (NameTableValue * 16)) + TileRelY;

  0007d	0f b7 44 24 68	 movzx	 eax, WORD PTR PatternBase$[rsp]
  00082	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR NameTableValue$[rsp]
  00087	6b c9 10	 imul	 ecx, ecx, 16
  0008a	03 c1		 add	 eax, ecx
  0008c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR TileRelY$[rsp]
  00091	03 c1		 add	 eax, ecx
  00093	48 98		 cdqe
  00095	48 89 44 24 28	 mov	 QWORD PTR LowAddress$[rsp], rax

; 124  :     uint64 HighAddress = (PatternBase + (NameTableValue * 16) + 8) + TileRelY;

  0009a	0f b7 44 24 68	 movzx	 eax, WORD PTR PatternBase$[rsp]
  0009f	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR NameTableValue$[rsp]
  000a4	6b c9 10	 imul	 ecx, ecx, 16
  000a7	03 c1		 add	 eax, ecx
  000a9	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR TileRelY$[rsp]
  000ae	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  000b2	48 98		 cdqe
  000b4	48 89 44 24 30	 mov	 QWORD PTR HighAddress$[rsp], rax

; 125  :     
; 126  :     uint8 LowPattern = readPpu8(LowAddress, MemoryOffset);

  000b9	48 8b 54 24 70	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  000be	0f b7 4c 24 28	 movzx	 ecx, WORD PTR LowAddress$[rsp]
  000c3	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  000c8	88 44 24 23	 mov	 BYTE PTR LowPattern$[rsp], al

; 127  :     uint8 HighPattern = readPpu8(HighAddress, MemoryOffset);

  000cc	48 8b 54 24 70	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  000d1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR HighAddress$[rsp]
  000d6	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  000db	88 44 24 22	 mov	 BYTE PTR HighPattern$[rsp], al

; 128  : 
; 129  :     LowPattern  = (LowPattern >> (7 - TileRelX)) & 1;

  000df	0f b6 44 24 23	 movzx	 eax, BYTE PTR LowPattern$[rsp]
  000e4	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR TileRelX$[rsp]
  000e9	ba 07 00 00 00	 mov	 edx, 7
  000ee	2b d1		 sub	 edx, ecx
  000f0	8b ca		 mov	 ecx, edx
  000f2	d3 f8		 sar	 eax, cl
  000f4	83 e0 01	 and	 eax, 1
  000f7	88 44 24 23	 mov	 BYTE PTR LowPattern$[rsp], al

; 130  :     HighPattern = (HighPattern >> (7 - TileRelX)) & 1;

  000fb	0f b6 44 24 22	 movzx	 eax, BYTE PTR HighPattern$[rsp]
  00100	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR TileRelX$[rsp]
  00105	ba 07 00 00 00	 mov	 edx, 7
  0010a	2b d1		 sub	 edx, ecx
  0010c	8b ca		 mov	 ecx, edx
  0010e	d3 f8		 sar	 eax, cl
  00110	83 e0 01	 and	 eax, 1
  00113	88 44 24 22	 mov	 BYTE PTR HighPattern$[rsp], al

; 131  : 
; 132  :     uint8 Value = (HighPattern << 1) | LowPattern;

  00117	0f b6 44 24 22	 movzx	 eax, BYTE PTR HighPattern$[rsp]
  0011c	d1 e0		 shl	 eax, 1
  0011e	0f b6 4c 24 23	 movzx	 ecx, BYTE PTR LowPattern$[rsp]
  00123	0b c1		 or	 eax, ecx
  00125	88 44 24 24	 mov	 BYTE PTR Value$[rsp], al

; 133  :     
; 134  :     return(Value);

  00129	0f b6 44 24 24	 movzx	 eax, BYTE PTR Value$[rsp]

; 135  : }

  0012e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00132	c3		 ret	 0
?getPatternValue@@YAEGGEG_K@Z ENDP			; getPatternValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
Value$ = 32
TileY$ = 36
TileX$ = 40
Address$ = 44
X$ = 64
Y$ = 72
TableBaseAddress$ = 80
MemoryOffset$ = 88
?getNameTableValue@@YAEGGG_K@Z PROC			; getNameTableValue

; 101  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000b	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00010	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00015	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 102  :     uint16 TileX = X / PIXEL_PER_TILE;

  00019	0f b7 44 24 40	 movzx	 eax, WORD PTR X$[rsp]
  0001e	99		 cdq
  0001f	83 e2 07	 and	 edx, 7
  00022	03 c2		 add	 eax, edx
  00024	c1 f8 03	 sar	 eax, 3
  00027	66 89 44 24 28	 mov	 WORD PTR TileX$[rsp], ax

; 103  :     uint16 TileY = Y / PIXEL_PER_TILE;

  0002c	0f b7 44 24 48	 movzx	 eax, WORD PTR Y$[rsp]
  00031	99		 cdq
  00032	83 e2 07	 and	 edx, 7
  00035	03 c2		 add	 eax, edx
  00037	c1 f8 03	 sar	 eax, 3
  0003a	66 89 44 24 24	 mov	 WORD PTR TileY$[rsp], ax

; 104  :     
; 105  :     Assert(0 <= TileX && TileX < TILES_COUNT_X);

  0003f	0f b7 44 24 28	 movzx	 eax, WORD PTR TileX$[rsp]
  00044	85 c0		 test	 eax, eax
  00046	7c 0a		 jl	 SHORT $LN3@getNameTab
  00048	0f b7 44 24 28	 movzx	 eax, WORD PTR TileX$[rsp]
  0004d	83 f8 20	 cmp	 eax, 32			; 00000020H
  00050	7c 0b		 jl	 SHORT $LN2@getNameTab
$LN3@getNameTab:
  00052	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@getNameTab:

; 106  :     Assert(0 <= TileY && TileY < TILES_COUNT_Y);

  0005d	0f b7 44 24 24	 movzx	 eax, WORD PTR TileY$[rsp]
  00062	85 c0		 test	 eax, eax
  00064	7c 0a		 jl	 SHORT $LN5@getNameTab
  00066	0f b7 44 24 24	 movzx	 eax, WORD PTR TileY$[rsp]
  0006b	83 f8 1e	 cmp	 eax, 30
  0006e	7c 0b		 jl	 SHORT $LN4@getNameTab
$LN5@getNameTab:
  00070	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN4@getNameTab:

; 107  : 
; 108  :     uint16 Address = (TableBaseAddress + (TileY * TILES_COUNT_X)) + TileX;

  0007b	0f b7 44 24 50	 movzx	 eax, WORD PTR TableBaseAddress$[rsp]
  00080	0f b7 4c 24 24	 movzx	 ecx, WORD PTR TileY$[rsp]
  00085	6b c9 20	 imul	 ecx, ecx, 32		; 00000020H
  00088	03 c1		 add	 eax, ecx
  0008a	0f b7 4c 24 28	 movzx	 ecx, WORD PTR TileX$[rsp]
  0008f	03 c1		 add	 eax, ecx
  00091	66 89 44 24 2c	 mov	 WORD PTR Address$[rsp], ax

; 109  :     uint8 Value = readPpu8(Address, MemoryOffset);

  00096	48 8b 54 24 58	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0009b	0f b7 4c 24 2c	 movzx	 ecx, WORD PTR Address$[rsp]
  000a0	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  000a5	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 110  :     return(Value);

  000a9	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]

; 111  : }

  000ae	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b2	c3		 ret	 0
?getNameTableValue@@YAEGGG_K@Z ENDP			; getNameTableValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
Byte$ = 48
Address$ = 56
MemoryOffset$ = 64
?writePpu8@@YAXEG_K@Z PROC				; writePpu8

; 83   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 84   :     // TODO: Finish memory mirror
; 85   :     if(0x3000 <= Address && Address < 0x3F00)

  00012	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00017	3d 00 30 00 00	 cmp	 eax, 12288		; 00003000H
  0001c	7c 1e		 jl	 SHORT $LN2@writePpu8
  0001e	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00023	3d 00 3f 00 00	 cmp	 eax, 16128		; 00003f00H
  00028	7d 12		 jge	 SHORT $LN2@writePpu8

; 86   :     {
; 87   :         Assert(0);

  0002a	33 c0		 xor	 eax, eax
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	74 0b		 je	 SHORT $LN3@writePpu8
  00031	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN3@writePpu8:
$LN2@writePpu8:

; 88   :     }
; 89   :     if(0x3F20 <= Address && Address < 0x4000)

  0003c	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00041	3d 20 3f 00 00	 cmp	 eax, 16160		; 00003f20H
  00046	7c 1e		 jl	 SHORT $LN4@writePpu8
  00048	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  0004d	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  00052	7d 12		 jge	 SHORT $LN4@writePpu8

; 90   :     {
; 91   :         Assert(0);

  00054	33 c0		 xor	 eax, eax
  00056	83 f8 01	 cmp	 eax, 1
  00059	74 0b		 je	 SHORT $LN5@writePpu8
  0005b	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN5@writePpu8:
$LN4@writePpu8:

; 92   :     }
; 93   :     if(Address >= 0x4000)

  00066	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  0006b	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  00070	7c 12		 jl	 SHORT $LN6@writePpu8

; 94   :         Assert(0);

  00072	33 c0		 xor	 eax, eax
  00074	83 f8 01	 cmp	 eax, 1
  00077	74 0b		 je	 SHORT $LN7@writePpu8
  00079	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN7@writePpu8:
$LN6@writePpu8:

; 95   :     
; 96   :     write8(Byte, Address, MemoryOffset);

  00084	4c 8b 44 24 40	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  00089	0f b7 54 24 38	 movzx	 edx, WORD PTR Address$[rsp]
  0008e	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR Byte$[rsp]
  00093	e8 00 00 00 00	 call	 ?write8@@YAXEG_K@Z	; write8

; 97   : }

  00098	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009c	c3		 ret	 0
?writePpu8@@YAXEG_K@Z ENDP				; writePpu8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
Result$ = 32
Address$ = 64
MemoryOffset$ = 72
?readPpu8@@YAEG_K@Z PROC				; readPpu8

; 67   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 68   :     // TODO: Finish memory mirror
; 69   :     if(0x3000 <= Address && Address < 0x3F00)

  0000e	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00013	3d 00 30 00 00	 cmp	 eax, 12288		; 00003000H
  00018	7c 1e		 jl	 SHORT $LN2@readPpu8
  0001a	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0001f	3d 00 3f 00 00	 cmp	 eax, 16128		; 00003f00H
  00024	7d 12		 jge	 SHORT $LN2@readPpu8

; 70   :     {
; 71   :         Assert(0);

  00026	33 c0		 xor	 eax, eax
  00028	83 f8 01	 cmp	 eax, 1
  0002b	74 0b		 je	 SHORT $LN3@readPpu8
  0002d	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN3@readPpu8:
$LN2@readPpu8:

; 72   :     }
; 73   :     if(0x3F20 <= Address && Address < 0x4000)

  00038	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0003d	3d 20 3f 00 00	 cmp	 eax, 16160		; 00003f20H
  00042	7c 1e		 jl	 SHORT $LN4@readPpu8
  00044	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00049	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  0004e	7d 12		 jge	 SHORT $LN4@readPpu8

; 74   :     {
; 75   :         Assert(0);

  00050	33 c0		 xor	 eax, eax
  00052	83 f8 01	 cmp	 eax, 1
  00055	74 0b		 je	 SHORT $LN5@readPpu8
  00057	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN5@readPpu8:
$LN4@readPpu8:

; 76   :     }
; 77   :     if(Address >= 0x4000)

  00062	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00067	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  0006c	7c 12		 jl	 SHORT $LN6@readPpu8

; 78   :         Assert(0);

  0006e	33 c0		 xor	 eax, eax
  00070	83 f8 01	 cmp	 eax, 1
  00073	74 0b		 je	 SHORT $LN7@readPpu8
  00075	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN7@readPpu8:
$LN6@readPpu8:

; 79   :     uint8 Result = read8(Address, MemoryOffset);

  00080	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00085	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0008a	e8 00 00 00 00	 call	 ?read8@@YAEG_K@Z	; read8
  0008f	88 44 24 20	 mov	 BYTE PTR Result$[rsp], al

; 80   :     return(Result);

  00093	0f b6 44 24 20	 movzx	 eax, BYTE PTR Result$[rsp]

; 81   : }

  00098	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009c	c3		 ret	 0
?readPpu8@@YAEG_K@Z ENDP				; readPpu8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
;	COMDAT ?drawPixel@@YAXPEAUppu@@GGPEAE@Z
_TEXT	SEGMENT
CurrentPixel$ = 0
Ppu$ = 32
X$ = 40
Y$ = 48
Colour$ = 56
?drawPixel@@YAXPEAUppu@@GGPEAE@Z PROC			; drawPixel, COMDAT

; 61   : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000b	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	48 83 ec 18	 sub	 rsp, 24

; 62   :     uint32 *CurrentPixel = (Ppu->BasePixel + (Y * PIXEL_WIDTH)) + X;

  00019	0f b7 44 24 30	 movzx	 eax, WORD PTR Y$[rsp]
  0001e	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  00024	48 98		 cdqe
  00026	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0002b	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0002f	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  00033	0f b7 4c 24 28	 movzx	 ecx, WORD PTR X$[rsp]
  00038	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  0003c	48 89 04 24	 mov	 QWORD PTR CurrentPixel$[rsp], rax

; 63   :     *CurrentPixel  = ((Colour[0] << 16) | (Colour[1] << 8) | Colour[2]);

  00040	b8 01 00 00 00	 mov	 eax, 1
  00045	48 6b c0 00	 imul	 rax, rax, 0
  00049	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Colour$[rsp]
  0004e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00052	c1 e0 10	 shl	 eax, 16
  00055	b9 01 00 00 00	 mov	 ecx, 1
  0005a	48 6b c9 01	 imul	 rcx, rcx, 1
  0005e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Colour$[rsp]
  00063	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00067	c1 e1 08	 shl	 ecx, 8
  0006a	0b c1		 or	 eax, ecx
  0006c	b9 01 00 00 00	 mov	 ecx, 1
  00071	48 6b c9 02	 imul	 rcx, rcx, 2
  00075	48 8b 54 24 38	 mov	 rdx, QWORD PTR Colour$[rsp]
  0007a	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0007e	0b c1		 or	 eax, ecx
  00080	48 8b 0c 24	 mov	 rcx, QWORD PTR CurrentPixel$[rsp]
  00084	89 01		 mov	 DWORD PTR [rcx], eax

; 64   : }

  00086	48 83 c4 18	 add	 rsp, 24
  0008a	c3		 ret	 0
?drawPixel@@YAXPEAUppu@@GGPEAE@Z ENDP			; drawPixel
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\palette.cpp
_TEXT	SEGMENT
Entry$ = 8
Colour$ = 16
?getPaletteValue@@YAXEPEAE@Z PROC			; getPaletteValue

; 31   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 32   :     Colour[0] = Palette[Entry][0];

  00009	0f b6 44 24 08	 movzx	 eax, BYTE PTR Entry$[rsp]
  0000e	48 6b c0 03	 imul	 rax, rax, 3
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Palette@@3PAY02EA ; Palette
  00019	48 03 c8	 add	 rcx, rax
  0001c	48 8b c1	 mov	 rax, rcx
  0001f	b9 01 00 00 00	 mov	 ecx, 1
  00024	48 6b c9 00	 imul	 rcx, rcx, 0
  00028	ba 01 00 00 00	 mov	 edx, 1
  0002d	48 6b d2 00	 imul	 rdx, rdx, 0
  00031	4c 8b 44 24 10	 mov	 r8, QWORD PTR Colour$[rsp]
  00036	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0003a	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 33   :     Colour[1] = Palette[Entry][1];

  0003e	0f b6 44 24 08	 movzx	 eax, BYTE PTR Entry$[rsp]
  00043	48 6b c0 03	 imul	 rax, rax, 3
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Palette@@3PAY02EA ; Palette
  0004e	48 03 c8	 add	 rcx, rax
  00051	48 8b c1	 mov	 rax, rcx
  00054	b9 01 00 00 00	 mov	 ecx, 1
  00059	48 6b c9 01	 imul	 rcx, rcx, 1
  0005d	ba 01 00 00 00	 mov	 edx, 1
  00062	48 6b d2 01	 imul	 rdx, rdx, 1
  00066	4c 8b 44 24 10	 mov	 r8, QWORD PTR Colour$[rsp]
  0006b	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0006f	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 34   :     Colour[2]  = Palette[Entry][2];

  00073	0f b6 44 24 08	 movzx	 eax, BYTE PTR Entry$[rsp]
  00078	48 6b c0 03	 imul	 rax, rax, 3
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Palette@@3PAY02EA ; Palette
  00083	48 03 c8	 add	 rcx, rax
  00086	48 8b c1	 mov	 rax, rcx
  00089	b9 01 00 00 00	 mov	 ecx, 1
  0008e	48 6b c9 02	 imul	 rcx, rcx, 2
  00092	ba 01 00 00 00	 mov	 edx, 1
  00097	48 6b d2 02	 imul	 rdx, rdx, 2
  0009b	4c 8b 44 24 10	 mov	 r8, QWORD PTR Colour$[rsp]
  000a0	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000a4	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 35   : }

  000a8	c3		 ret	 0
?getPaletteValue@@YAXEPEAE@Z ENDP			; getPaletteValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
CyclesElapsed$ = 64
Address$ = 68
Instruction$ = 72
InstrData$ = 76
InstrLength$ = 80
AddressMode$ = 81
RelOffset$1 = 82
ZeroAddress$2 = 83
ZeroAddress$3 = 84
InstCycles$ = 85
AdditionalCycles$ = 86
i$4 = 88
CrossedPage$ = 92
IndirectAddress$5 = 96
tv95 = 100
tv344 = 104
MemoryOffset$ = 112
tv361 = 120
InstrName$ = 128
LogInstrData$ = 136
LogCpuInfo$ = 160
LogOpInfo$ = 224
LogBuffer$ = 288
__$ArrayPad$ = 1312
Cpu$ = 1344
?cpuTick@@YAEPEAUcpu@@@Z PROC				; cpuTick

; 324  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 38 05
	00 00		 sub	 rsp, 1336		; 00000538H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 20
	05 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 325  :     uint64 MemoryOffset = Cpu->MemoryOffset;

  0001e	48 8b 84 24 40
	05 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  00026	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002a	48 89 44 24 70	 mov	 QWORD PTR MemoryOffset$[rsp], rax

; 326  :     uint8 CyclesElapsed = 0;

  0002f	c6 44 24 40 00	 mov	 BYTE PTR CyclesElapsed$[rsp], 0

; 327  : 
; 328  :     uint16 Address = 0;

  00034	33 c0		 xor	 eax, eax
  00036	66 89 44 24 44	 mov	 WORD PTR Address$[rsp], ax

; 329  :     bool32 CrossedPage = 0;

  0003b	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR CrossedPage$[rsp], 0

; 330  :  
; 331  :     uint8 Instruction = readCpu8(Cpu->PrgCounter, MemoryOffset);

  00043	48 8b 54 24 70	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00048	48 8b 84 24 40
	05 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  00050	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00054	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00059	88 44 24 48	 mov	 BYTE PTR Instruction$[rsp], al

; 332  :     uint8 AddressMode = instAddressMode[Instruction];

  0005d	0f b6 44 24 48	 movzx	 eax, BYTE PTR Instruction$[rsp]
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instAddressMode@@3PAEA
  00069	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0006d	88 44 24 51	 mov	 BYTE PTR AddressMode$[rsp], al

; 333  :     uint8 InstrLength = instLength[Instruction];

  00071	0f b6 44 24 48	 movzx	 eax, BYTE PTR Instruction$[rsp]
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instLength@@3PAEA
  0007d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00081	88 44 24 50	 mov	 BYTE PTR InstrLength$[rsp], al

; 334  :     char *InstrName = instName[Instruction];

  00085	0f b6 44 24 48	 movzx	 eax, BYTE PTR Instruction$[rsp]
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instName@@3PAPEADA
  00091	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00095	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR InstrName$[rsp], rax

; 335  :     uint8 InstCycles = instCycles[Instruction];

  0009d	0f b6 44 24 48	 movzx	 eax, BYTE PTR Instruction$[rsp]
  000a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instCycles@@3PAEA
  000a9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ad	88 44 24 55	 mov	 BYTE PTR InstCycles$[rsp], al

; 336  : 
; 337  :     uint8 InstrData[3]; // Stores data for each instruction
; 338  :     for(int i = 0; i < InstrLength; ++i)

  000b1	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR i$4[rsp], 0
  000b9	eb 0a		 jmp	 SHORT $LN4@cpuTick
$LN2@cpuTick:
  000bb	8b 44 24 58	 mov	 eax, DWORD PTR i$4[rsp]
  000bf	ff c0		 inc	 eax
  000c1	89 44 24 58	 mov	 DWORD PTR i$4[rsp], eax
$LN4@cpuTick:
  000c5	0f b6 44 24 50	 movzx	 eax, BYTE PTR InstrLength$[rsp]
  000ca	39 44 24 58	 cmp	 DWORD PTR i$4[rsp], eax
  000ce	7d 28		 jge	 SHORT $LN3@cpuTick

; 339  :     {
; 340  :         InstrData[i] = readCpu8(Cpu->PrgCounter + i, MemoryOffset); 

  000d0	48 8b 84 24 40
	05 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  000d8	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  000dc	03 44 24 58	 add	 eax, DWORD PTR i$4[rsp]
  000e0	48 8b 54 24 70	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  000e5	0f b7 c8	 movzx	 ecx, ax
  000e8	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  000ed	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR i$4[rsp]
  000f2	88 44 0c 4c	 mov	 BYTE PTR InstrData$[rsp+rcx], al

; 341  :     }

  000f6	eb c3		 jmp	 SHORT $LN2@cpuTick
$LN3@cpuTick:

; 342  :         
; 343  :     switch(AddressMode)

  000f8	0f b6 44 24 51	 movzx	 eax, BYTE PTR AddressMode$[rsp]
  000fd	89 44 24 64	 mov	 DWORD PTR tv95[rsp], eax
  00101	83 7c 24 64 0d	 cmp	 DWORD PTR tv95[rsp], 13
  00106	0f 87 b3 02 00
	00		 ja	 $LN5@cpuTick
  0010c	48 63 44 24 64	 movsxd	 rax, DWORD PTR tv95[rsp]
  00111	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00118	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN30@cpuTick[rcx+rax*4]
  0011f	48 03 c1	 add	 rax, rcx
  00122	ff e0		 jmp	 rax

; 344  :     {
; 345  :         case ACM:
; 346  :             break;            

  00124	e9 96 02 00 00	 jmp	 $LN5@cpuTick

; 347  :         case IMPL:
; 348  :             break;

  00129	e9 91 02 00 00	 jmp	 $LN5@cpuTick
$LN9@cpuTick:

; 349  :         case IMED:
; 350  :             Address = Cpu->PrgCounter + 1;

  0012e	48 8b 84 24 40
	05 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  00136	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0013a	ff c0		 inc	 eax
  0013c	66 89 44 24 44	 mov	 WORD PTR Address$[rsp], ax

; 351  :             break;

  00141	e9 79 02 00 00	 jmp	 $LN5@cpuTick
$LN10@cpuTick:

; 352  :         case ZERO:
; 353  :             Address = (uint16)InstrData[1];

  00146	b8 01 00 00 00	 mov	 eax, 1
  0014b	48 6b c0 01	 imul	 rax, rax, 1
  0014f	0f b6 44 04 4c	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  00154	66 89 44 24 44	 mov	 WORD PTR Address$[rsp], ax

; 354  :             break;

  00159	e9 61 02 00 00	 jmp	 $LN5@cpuTick
$LN11@cpuTick:

; 355  :         case ZERX:
; 356  :             Address = (uint16)InstrData[1] + Cpu->X;

  0015e	b8 01 00 00 00	 mov	 eax, 1
  00163	48 6b c0 01	 imul	 rax, rax, 1
  00167	0f b6 44 04 4c	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  0016c	48 8b 8c 24 40
	05 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00174	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00178	03 c1		 add	 eax, ecx
  0017a	66 89 44 24 44	 mov	 WORD PTR Address$[rsp], ax

; 357  :             break;

  0017f	e9 3b 02 00 00	 jmp	 $LN5@cpuTick
$LN12@cpuTick:

; 358  :         case ZERY:
; 359  :             Address = (uint16)InstrData[1] + Cpu->Y;

  00184	b8 01 00 00 00	 mov	 eax, 1
  00189	48 6b c0 01	 imul	 rax, rax, 1
  0018d	0f b6 44 04 4c	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  00192	48 8b 8c 24 40
	05 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0019a	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  0019e	03 c1		 add	 eax, ecx
  001a0	66 89 44 24 44	 mov	 WORD PTR Address$[rsp], ax

; 360  :             break;

  001a5	e9 15 02 00 00	 jmp	 $LN5@cpuTick
$LN13@cpuTick:

; 361  :         case ABS:
; 362  :             Address = ((uint16)InstrData[2] << 8) | InstrData[1];

  001aa	b8 01 00 00 00	 mov	 eax, 1
  001af	48 6b c0 02	 imul	 rax, rax, 2
  001b3	0f b6 44 04 4c	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  001b8	c1 e0 08	 shl	 eax, 8
  001bb	b9 01 00 00 00	 mov	 ecx, 1
  001c0	48 6b c9 01	 imul	 rcx, rcx, 1
  001c4	0f b6 4c 0c 4c	 movzx	 ecx, BYTE PTR InstrData$[rsp+rcx]
  001c9	0b c1		 or	 eax, ecx
  001cb	66 89 44 24 44	 mov	 WORD PTR Address$[rsp], ax

; 363  :             break;

  001d0	e9 ea 01 00 00	 jmp	 $LN5@cpuTick
$LN14@cpuTick:

; 364  :         case ABSX:
; 365  :             Address = (((uint16)InstrData[2] << 8) | InstrData[1]) + Cpu->X;

  001d5	b8 01 00 00 00	 mov	 eax, 1
  001da	48 6b c0 02	 imul	 rax, rax, 2
  001de	0f b6 44 04 4c	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  001e3	c1 e0 08	 shl	 eax, 8
  001e6	b9 01 00 00 00	 mov	 ecx, 1
  001eb	48 6b c9 01	 imul	 rcx, rcx, 1
  001ef	0f b6 4c 0c 4c	 movzx	 ecx, BYTE PTR InstrData$[rsp+rcx]
  001f4	0b c1		 or	 eax, ecx
  001f6	48 8b 8c 24 40
	05 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  001fe	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00202	03 c1		 add	 eax, ecx
  00204	66 89 44 24 44	 mov	 WORD PTR Address$[rsp], ax

; 366  :             CrossedPage = crossedPageCheck(Address - Cpu->X, Address);

  00209	0f b7 44 24 44	 movzx	 eax, WORD PTR Address$[rsp]
  0020e	48 8b 8c 24 40
	05 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00216	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0021a	2b c1		 sub	 eax, ecx
  0021c	0f b7 54 24 44	 movzx	 edx, WORD PTR Address$[rsp]
  00221	0f b7 c8	 movzx	 ecx, ax
  00224	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  00229	89 44 24 5c	 mov	 DWORD PTR CrossedPage$[rsp], eax

; 367  :             break;

  0022d	e9 8d 01 00 00	 jmp	 $LN5@cpuTick
$LN15@cpuTick:

; 368  :         case ABSY:
; 369  :             Address = (((uint16)InstrData[2] << 8) | InstrData[1]) + Cpu->Y;

  00232	b8 01 00 00 00	 mov	 eax, 1
  00237	48 6b c0 02	 imul	 rax, rax, 2
  0023b	0f b6 44 04 4c	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  00240	c1 e0 08	 shl	 eax, 8
  00243	b9 01 00 00 00	 mov	 ecx, 1
  00248	48 6b c9 01	 imul	 rcx, rcx, 1
  0024c	0f b6 4c 0c 4c	 movzx	 ecx, BYTE PTR InstrData$[rsp+rcx]
  00251	0b c1		 or	 eax, ecx
  00253	48 8b 8c 24 40
	05 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0025b	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  0025f	03 c1		 add	 eax, ecx
  00261	66 89 44 24 44	 mov	 WORD PTR Address$[rsp], ax

; 370  :             CrossedPage = crossedPageCheck(Address - Cpu->Y, Address);

  00266	0f b7 44 24 44	 movzx	 eax, WORD PTR Address$[rsp]
  0026b	48 8b 8c 24 40
	05 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00273	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  00277	2b c1		 sub	 eax, ecx
  00279	0f b7 54 24 44	 movzx	 edx, WORD PTR Address$[rsp]
  0027e	0f b7 c8	 movzx	 ecx, ax
  00281	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  00286	89 44 24 5c	 mov	 DWORD PTR CrossedPage$[rsp], eax

; 371  :             break;

  0028a	e9 30 01 00 00	 jmp	 $LN5@cpuTick
$LN16@cpuTick:

; 372  :         case REL:
; 373  :         {
; 374  :             int8 RelOffset = InstrData[1];

  0028f	b8 01 00 00 00	 mov	 eax, 1
  00294	48 6b c0 01	 imul	 rax, rax, 1
  00298	0f b6 44 04 4c	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  0029d	88 44 24 52	 mov	 BYTE PTR RelOffset$1[rsp], al

; 375  :             Address = Cpu->PrgCounter + 2 + RelOffset;

  002a1	48 8b 84 24 40
	05 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  002a9	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  002ad	0f be 4c 24 52	 movsx	 ecx, BYTE PTR RelOffset$1[rsp]
  002b2	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  002b6	66 89 44 24 44	 mov	 WORD PTR Address$[rsp], ax

; 376  :             break;

  002bb	e9 ff 00 00 00	 jmp	 $LN5@cpuTick
$LN17@cpuTick:

; 377  :         }
; 378  :         case INDX:
; 379  :         {
; 380  :             uint8 ZeroAddress = InstrData[1];

  002c0	b8 01 00 00 00	 mov	 eax, 1
  002c5	48 6b c0 01	 imul	 rax, rax, 1
  002c9	0f b6 44 04 4c	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  002ce	88 44 24 53	 mov	 BYTE PTR ZeroAddress$2[rsp], al

; 381  :             Address = bugReadCpu16(ZeroAddress + Cpu->X, Cpu->MemoryOffset);

  002d2	0f b6 44 24 53	 movzx	 eax, BYTE PTR ZeroAddress$2[rsp]
  002d7	48 8b 8c 24 40
	05 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  002df	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  002e3	03 c1		 add	 eax, ecx
  002e5	48 8b 8c 24 40
	05 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  002ed	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  002f1	0f b7 c8	 movzx	 ecx, ax
  002f4	e8 00 00 00 00	 call	 ?bugReadCpu16@@YAGG_K@Z	; bugReadCpu16
  002f9	66 89 44 24 44	 mov	 WORD PTR Address$[rsp], ax

; 382  :             break;

  002fe	e9 bc 00 00 00	 jmp	 $LN5@cpuTick
$LN18@cpuTick:

; 383  :         }
; 384  :         case INDY:
; 385  :         {
; 386  :             uint8 ZeroAddress = InstrData[1];

  00303	b8 01 00 00 00	 mov	 eax, 1
  00308	48 6b c0 01	 imul	 rax, rax, 1
  0030c	0f b6 44 04 4c	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  00311	88 44 24 54	 mov	 BYTE PTR ZeroAddress$3[rsp], al

; 387  :             Address = bugReadCpu16(ZeroAddress, Cpu->MemoryOffset) + Cpu->Y;

  00315	0f b6 44 24 54	 movzx	 eax, BYTE PTR ZeroAddress$3[rsp]
  0031a	48 8b 8c 24 40
	05 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00322	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00326	0f b7 c8	 movzx	 ecx, ax
  00329	e8 00 00 00 00	 call	 ?bugReadCpu16@@YAGG_K@Z	; bugReadCpu16
  0032e	0f b7 c0	 movzx	 eax, ax
  00331	48 8b 8c 24 40
	05 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00339	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  0033d	03 c1		 add	 eax, ecx
  0033f	66 89 44 24 44	 mov	 WORD PTR Address$[rsp], ax

; 388  :             CrossedPage = crossedPageCheck(Address - Cpu->Y, Address);

  00344	0f b7 44 24 44	 movzx	 eax, WORD PTR Address$[rsp]
  00349	48 8b 8c 24 40
	05 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00351	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  00355	2b c1		 sub	 eax, ecx
  00357	0f b7 54 24 44	 movzx	 edx, WORD PTR Address$[rsp]
  0035c	0f b7 c8	 movzx	 ecx, ax
  0035f	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  00364	89 44 24 5c	 mov	 DWORD PTR CrossedPage$[rsp], eax

; 389  :             break;

  00368	eb 55		 jmp	 SHORT $LN5@cpuTick
$LN19@cpuTick:

; 390  :         }
; 391  :         case INDI:
; 392  :         {
; 393  :             uint16 IndirectAddress = ((uint16)InstrData[2] << 8) | InstrData[1];

  0036a	b8 01 00 00 00	 mov	 eax, 1
  0036f	48 6b c0 02	 imul	 rax, rax, 2
  00373	0f b6 44 04 4c	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  00378	c1 e0 08	 shl	 eax, 8
  0037b	b9 01 00 00 00	 mov	 ecx, 1
  00380	48 6b c9 01	 imul	 rcx, rcx, 1
  00384	0f b6 4c 0c 4c	 movzx	 ecx, BYTE PTR InstrData$[rsp+rcx]
  00389	0b c1		 or	 eax, ecx
  0038b	66 89 44 24 60	 mov	 WORD PTR IndirectAddress$5[rsp], ax

; 394  :             Address = bugReadCpu16(IndirectAddress, Cpu->MemoryOffset);

  00390	48 8b 84 24 40
	05 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  00398	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0039c	0f b7 4c 24 60	 movzx	 ecx, WORD PTR IndirectAddress$5[rsp]
  003a1	e8 00 00 00 00	 call	 ?bugReadCpu16@@YAGG_K@Z	; bugReadCpu16
  003a6	66 89 44 24 44	 mov	 WORD PTR Address$[rsp], ax

; 395  :             break;

  003ab	eb 12		 jmp	 SHORT $LN5@cpuTick
$LN20@cpuTick:

; 396  :         }
; 397  :         case NUL:
; 398  :         {
; 399  :             Assert(0);

  003ad	33 c0		 xor	 eax, eax
  003af	83 f8 01	 cmp	 eax, 1
  003b2	74 0b		 je	 SHORT $LN21@cpuTick
  003b4	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN21@cpuTick:
$LN5@cpuTick:

; 400  :             break;
; 401  :         }
; 402  :         
; 403  :     }
; 404  :     
; 405  :     Cpu->PrgCounter += InstrLength;

  003bf	0f b6 44 24 50	 movzx	 eax, BYTE PTR InstrLength$[rsp]
  003c4	48 8b 8c 24 40
	05 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  003cc	0f b7 49 06	 movzx	 ecx, WORD PTR [rcx+6]
  003d0	03 c8		 add	 ecx, eax
  003d2	8b c1		 mov	 eax, ecx
  003d4	48 8b 8c 24 40
	05 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  003dc	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 406  :     CyclesElapsed += InstCycles;

  003e0	0f b6 44 24 55	 movzx	 eax, BYTE PTR InstCycles$[rsp]
  003e5	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR CyclesElapsed$[rsp]
  003ea	03 c8		 add	 ecx, eax
  003ec	8b c1		 mov	 eax, ecx
  003ee	88 44 24 40	 mov	 BYTE PTR CyclesElapsed$[rsp], al

; 407  :     
; 408  :     if(CrossedPage)

  003f2	83 7c 24 5c 00	 cmp	 DWORD PTR CrossedPage$[rsp], 0
  003f7	74 1d		 je	 SHORT $LN22@cpuTick

; 409  :         CyclesElapsed += instBoundaryCheck[Instruction];

  003f9	0f b6 44 24 48	 movzx	 eax, BYTE PTR Instruction$[rsp]
  003fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instBoundaryCheck@@3PAEA
  00405	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00409	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR CyclesElapsed$[rsp]
  0040e	03 c8		 add	 ecx, eax
  00410	8b c1		 mov	 eax, ecx
  00412	88 44 24 40	 mov	 BYTE PTR CyclesElapsed$[rsp], al
$LN22@cpuTick:

; 410  : 
; 411  :     // NOTE: This is where the operation is executed, returning extra cycles, for branch ops
; 412  :     uint8 AdditionalCycles = instrOps[Instruction](Address, Cpu, AddressMode);

  00416	0f b6 44 24 48	 movzx	 eax, BYTE PTR Instruction$[rsp]
  0041b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instrOps@@3PAP6AEGPEAUcpu@@E@ZA ; instrOps
  00422	48 89 4c 24 78	 mov	 QWORD PTR tv361[rsp], rcx
  00427	44 0f b6 44 24
	51		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0042d	48 8b 94 24 40
	05 00 00	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00435	0f b7 4c 24 44	 movzx	 ecx, WORD PTR Address$[rsp]
  0043a	4c 8b 4c 24 78	 mov	 r9, QWORD PTR tv361[rsp]
  0043f	41 ff 14 c1	 call	 QWORD PTR [r9+rax*8]
  00443	88 44 24 56	 mov	 BYTE PTR AdditionalCycles$[rsp], al

; 413  :     CyclesElapsed += AdditionalCycles;

  00447	0f b6 44 24 56	 movzx	 eax, BYTE PTR AdditionalCycles$[rsp]
  0044c	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR CyclesElapsed$[rsp]
  00451	03 c8		 add	 ecx, eax
  00453	8b c1		 mov	 eax, ecx
  00455	88 44 24 40	 mov	 BYTE PTR CyclesElapsed$[rsp], al

; 414  :     
; 415  :     if(NmiTriggered)

  00459	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?NmiTriggered@@3HA, 0 ; NmiTriggered
  00460	74 27		 je	 SHORT $LN23@cpuTick

; 416  :     {
; 417  :         NmiTriggered = false;

  00462	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?NmiTriggered@@3HA, 0 ; NmiTriggered

; 418  :         CyclesElapsed += nmi(Cpu);

  0046c	48 8b 8c 24 40
	05 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00474	e8 00 00 00 00	 call	 ?nmi@@YAEPEAUcpu@@@Z	; nmi
  00479	0f b6 c0	 movzx	 eax, al
  0047c	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR CyclesElapsed$[rsp]
  00481	03 c8		 add	 ecx, eax
  00483	8b c1		 mov	 eax, ecx
  00485	88 44 24 40	 mov	 BYTE PTR CyclesElapsed$[rsp], al
$LN23@cpuTick:

; 419  :     }
; 420  :     if(IrqTriggered)

  00489	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IrqTriggered@@3HA, 0 ; IrqTriggered
  00490	74 27		 je	 SHORT $LN24@cpuTick

; 421  :     {
; 422  :         IrqTriggered = false;

  00492	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?IrqTriggered@@3HA, 0 ; IrqTriggered

; 423  :         CyclesElapsed += irq(Cpu);

  0049c	48 8b 8c 24 40
	05 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  004a4	e8 00 00 00 00	 call	 ?irq@@YAEPEAUcpu@@@Z	; irq
  004a9	0f b6 c0	 movzx	 eax, al
  004ac	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR CyclesElapsed$[rsp]
  004b1	03 c8		 add	 ecx, eax
  004b3	8b c1		 mov	 eax, ecx
  004b5	88 44 24 40	 mov	 BYTE PTR CyclesElapsed$[rsp], al
$LN24@cpuTick:

; 424  :     }
; 425  : 
; 426  : 
; 427  :     char LogInstrData[16];
; 428  :     if(InstrLength == 3)

  004b9	0f b6 44 24 50	 movzx	 eax, BYTE PTR InstrLength$[rsp]
  004be	83 f8 03	 cmp	 eax, 3
  004c1	75 4a		 jne	 SHORT $LN25@cpuTick

; 429  :         sprintf(LogInstrData, "%2X %2X %2X", InstrData[0], InstrData[1], InstrData[2]);

  004c3	b8 01 00 00 00	 mov	 eax, 1
  004c8	48 6b c0 02	 imul	 rax, rax, 2
  004cc	0f b6 44 04 4c	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  004d1	b9 01 00 00 00	 mov	 ecx, 1
  004d6	48 6b c9 01	 imul	 rcx, rcx, 1
  004da	0f b6 4c 0c 4c	 movzx	 ecx, BYTE PTR InstrData$[rsp+rcx]
  004df	ba 01 00 00 00	 mov	 edx, 1
  004e4	48 6b d2 00	 imul	 rdx, rdx, 0
  004e8	0f b6 54 14 4c	 movzx	 edx, BYTE PTR InstrData$[rsp+rdx]
  004ed	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  004f1	44 8b c9	 mov	 r9d, ecx
  004f4	44 8b c2	 mov	 r8d, edx
  004f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG88688
  004fe	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR LogInstrData$[rsp]
  00506	e8 00 00 00 00	 call	 sprintf
  0050b	eb 67		 jmp	 SHORT $LN26@cpuTick
$LN25@cpuTick:

; 430  :     else if(InstrLength == 2)

  0050d	0f b6 44 24 50	 movzx	 eax, BYTE PTR InstrLength$[rsp]
  00512	83 f8 02	 cmp	 eax, 2
  00515	75 38		 jne	 SHORT $LN27@cpuTick

; 431  :         sprintf(LogInstrData, "%2X %2X   ", InstrData[0], InstrData[1]);

  00517	b8 01 00 00 00	 mov	 eax, 1
  0051c	48 6b c0 01	 imul	 rax, rax, 1
  00520	0f b6 44 04 4c	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  00525	b9 01 00 00 00	 mov	 ecx, 1
  0052a	48 6b c9 00	 imul	 rcx, rcx, 0
  0052e	0f b6 4c 0c 4c	 movzx	 ecx, BYTE PTR InstrData$[rsp+rcx]
  00533	44 8b c8	 mov	 r9d, eax
  00536	44 8b c1	 mov	 r8d, ecx
  00539	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG88691
  00540	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR LogInstrData$[rsp]
  00548	e8 00 00 00 00	 call	 sprintf

; 432  :     else

  0054d	eb 25		 jmp	 SHORT $LN28@cpuTick
$LN27@cpuTick:

; 433  :         sprintf(LogInstrData, "%2X      ", InstrData[0]);

  0054f	b8 01 00 00 00	 mov	 eax, 1
  00554	48 6b c0 00	 imul	 rax, rax, 0
  00558	0f b6 44 04 4c	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  0055d	44 8b c0	 mov	 r8d, eax
  00560	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG88692
  00567	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR LogInstrData$[rsp]
  0056f	e8 00 00 00 00	 call	 sprintf
$LN28@cpuTick:
$LN26@cpuTick:

; 434  : 
; 435  :     char LogOpInfo[64];
; 436  : //    sprintf(LogOpInfo, ""
; 437  :     
; 438  :     char LogCpuInfo[64];
; 439  :     sprintf(LogCpuInfo, "A:%2X X:%2X Y:%2X P:%2X SP:%2X CYC:    SL:", Cpu->A, Cpu->X, Cpu->Y, Cpu->Flags, Cpu->StackPtr);

  00574	48 8b 84 24 40
	05 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  0057c	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00580	48 8b 8c 24 40
	05 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00588	0f b6 49 03	 movzx	 ecx, BYTE PTR [rcx+3]
  0058c	48 8b 94 24 40
	05 00 00	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00594	0f b6 52 02	 movzx	 edx, BYTE PTR [rdx+2]
  00598	4c 8b 84 24 40
	05 00 00	 mov	 r8, QWORD PTR Cpu$[rsp]
  005a0	45 0f b6 40 01	 movzx	 r8d, BYTE PTR [r8+1]
  005a5	4c 8b 8c 24 40
	05 00 00	 mov	 r9, QWORD PTR Cpu$[rsp]
  005ad	45 0f b6 09	 movzx	 r9d, BYTE PTR [r9]
  005b1	44 89 4c 24 68	 mov	 DWORD PTR tv344[rsp], r9d
  005b6	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  005ba	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  005be	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  005c2	45 8b c8	 mov	 r9d, r8d
  005c5	8b 44 24 68	 mov	 eax, DWORD PTR tv344[rsp]
  005c9	44 8b c0	 mov	 r8d, eax
  005cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG88693
  005d3	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR LogCpuInfo$[rsp]
  005db	e8 00 00 00 00	 call	 sprintf

; 440  : 
; 441  :     // NOTE: CPU Log options
; 442  :     char LogBuffer[1024];
; 443  :     sprintf(LogBuffer, "%4X %s  %s    %s\n", Cpu->PrgCounter, LogInstrData, LogOpInfo, LogCpuInfo);

  005e0	48 8b 84 24 40
	05 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  005e8	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  005ec	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR LogCpuInfo$[rsp]
  005f4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005f9	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR LogOpInfo$[rsp]
  00601	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00606	4c 8d 8c 24 88
	00 00 00	 lea	 r9, QWORD PTR LogInstrData$[rsp]
  0060e	44 8b c0	 mov	 r8d, eax
  00611	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG88694
  00618	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR LogBuffer$[rsp]
  00620	e8 00 00 00 00	 call	 sprintf

; 444  :     OutputDebugString(LogBuffer);

  00625	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR LogBuffer$[rsp]
  0062d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 445  : #
; 446  :     
; 447  :     return(CyclesElapsed);

  00633	0f b6 44 24 40	 movzx	 eax, BYTE PTR CyclesElapsed$[rsp]

; 448  : }

  00638	48 8b 8c 24 20
	05 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00640	48 33 cc	 xor	 rcx, rsp
  00643	e8 00 00 00 00	 call	 __security_check_cookie
  00648	48 81 c4 38 05
	00 00		 add	 rsp, 1336		; 00000538H
  0064f	c3		 ret	 0
$LN30@cpuTick:
  00650	00 00 00 00	 DD	 $LN20@cpuTick
  00654	00 00 00 00	 DD	 $LN5@cpuTick
  00658	00 00 00 00	 DD	 $LN9@cpuTick
  0065c	00 00 00 00	 DD	 $LN10@cpuTick
  00660	00 00 00 00	 DD	 $LN11@cpuTick
  00664	00 00 00 00	 DD	 $LN12@cpuTick
  00668	00 00 00 00	 DD	 $LN13@cpuTick
  0066c	00 00 00 00	 DD	 $LN14@cpuTick
  00670	00 00 00 00	 DD	 $LN15@cpuTick
  00674	00 00 00 00	 DD	 $LN5@cpuTick
  00678	00 00 00 00	 DD	 $LN16@cpuTick
  0067c	00 00 00 00	 DD	 $LN17@cpuTick
  00680	00 00 00 00	 DD	 $LN18@cpuTick
  00684	00 00 00 00	 DD	 $LN19@cpuTick
?cpuTick@@YAEPEAUcpu@@@Z ENDP				; cpuTick
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
Cycles$ = 34
Cpu$ = 64
?irq@@YAEPEAUcpu@@@Z PROC				; irq

; 307  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 308  :     uint8 Cycles = 7;

  00009	c6 44 24 22 07	 mov	 BYTE PTR Cycles$[rsp], 7

; 309  :     
; 310  :     uint8 HighByte = (uint8)(Cpu->PrgCounter >> 8);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR Cpu$[rsp]
  00013	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00017	c1 f8 08	 sar	 eax, 8
  0001a	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 311  :     uint8 LowByte = (uint8)Cpu->PrgCounter; 

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR Cpu$[rsp]
  00023	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  00027	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 312  :     push(HighByte, Cpu);

  0002b	48 8b 54 24 40	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00030	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR HighByte$[rsp]
  00035	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 313  :     push(LowByte, Cpu);

  0003a	48 8b 54 24 40	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0003f	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  00044	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 314  :     
; 315  :     push(Cpu->Flags, Cpu); // TODO: Check if I push the flags on with any changes??

  00049	48 8b 54 24 40	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR Cpu$[rsp]
  00053	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  00057	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 316  :     setInterrupt(&Cpu->Flags);

  0005c	48 8b 44 24 40	 mov	 rax, QWORD PTR Cpu$[rsp]
  00061	48 83 c0 03	 add	 rax, 3
  00065	48 8b c8	 mov	 rcx, rax
  00068	e8 00 00 00 00	 call	 ?setInterrupt@@YAXPEAE@Z ; setInterrupt

; 317  : 
; 318  :     Cpu->PrgCounter = readCpu16(IRQ_BRK_VEC, Cpu->MemoryOffset);

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR Cpu$[rsp]
  00072	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00076	66 b9 fe ff	 mov	 cx, 65534		; 0000fffeH
  0007a	e8 00 00 00 00	 call	 ?readCpu16@@YAGG_K@Z	; readCpu16
  0007f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00084	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 319  :     return(Cycles);

  00088	0f b6 44 24 22	 movzx	 eax, BYTE PTR Cycles$[rsp]

; 320  : }

  0008d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00091	c3		 ret	 0
?irq@@YAEPEAUcpu@@@Z ENDP				; irq
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
Cycles$ = 34
Cpu$ = 64
?nmi@@YAEPEAUcpu@@@Z PROC				; nmi

; 291  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 292  :     uint8 Cycles = 7;

  00009	c6 44 24 22 07	 mov	 BYTE PTR Cycles$[rsp], 7

; 293  :     
; 294  :     uint8 HighByte = (uint8)(Cpu->PrgCounter >> 8);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR Cpu$[rsp]
  00013	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00017	c1 f8 08	 sar	 eax, 8
  0001a	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 295  :     uint8 LowByte = (uint8)Cpu->PrgCounter; 

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR Cpu$[rsp]
  00023	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  00027	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 296  :     push(HighByte, Cpu);

  0002b	48 8b 54 24 40	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00030	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR HighByte$[rsp]
  00035	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 297  :     push(LowByte, Cpu);

  0003a	48 8b 54 24 40	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0003f	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  00044	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 298  :     
; 299  :     push(Cpu->Flags, Cpu); // TODO: Check if I push the flags on with any changes??

  00049	48 8b 54 24 40	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR Cpu$[rsp]
  00053	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  00057	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 300  :     setInterrupt(&Cpu->Flags);

  0005c	48 8b 44 24 40	 mov	 rax, QWORD PTR Cpu$[rsp]
  00061	48 83 c0 03	 add	 rax, 3
  00065	48 8b c8	 mov	 rcx, rax
  00068	e8 00 00 00 00	 call	 ?setInterrupt@@YAXPEAE@Z ; setInterrupt

; 301  : 
; 302  :     Cpu->PrgCounter = readCpu16(NMI_VEC, Cpu->MemoryOffset);

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR Cpu$[rsp]
  00072	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00076	66 b9 fa ff	 mov	 cx, 65530		; 0000fffaH
  0007a	e8 00 00 00 00	 call	 ?readCpu16@@YAGG_K@Z	; readCpu16
  0007f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00084	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 303  :     return(Cycles);

  00088	0f b6 44 24 22	 movzx	 eax, BYTE PTR Cycles$[rsp]

; 304  : }

  0008d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00091	c3		 ret	 0
?nmi@@YAEPEAUcpu@@@Z ENDP				; nmi
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?xaa@@YAEGPEAUcpu@@E@Z PROC				; xaa

; 706  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 707  :     Assert(0);

  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 0b		 je	 SHORT $LN2@xaa
  00016	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@xaa:

; 708  :     return(0);

  00021	32 c0		 xor	 al, al

; 709  : }

  00023	c3		 ret	 0
?xaa@@YAEGPEAUcpu@@E@Z ENDP				; xaa
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?tas@@YAEGPEAUcpu@@E@Z PROC				; tas

; 700  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 701  :     Assert(0);

  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 0b		 je	 SHORT $LN2@tas
  00016	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@tas:

; 702  :     return(0);

  00021	32 c0		 xor	 al, al

; 703  : }

  00023	c3		 ret	 0
?tas@@YAEGPEAUcpu@@E@Z ENDP				; tas
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?sre@@YAEGPEAUcpu@@E@Z PROC				; sre

; 695  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 696  :     Assert(0);

  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 0b		 je	 SHORT $LN2@sre
  00016	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@sre:

; 697  :     return(0);

  00021	32 c0		 xor	 al, al

; 698  : }

  00023	c3		 ret	 0
?sre@@YAEGPEAUcpu@@E@Z ENDP				; sre
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?slo@@YAEGPEAUcpu@@E@Z PROC				; slo

; 690  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 691  : //    Assert(0);
; 692  :     return(0);

  0000f	32 c0		 xor	 al, al

; 693  : }

  00011	c3		 ret	 0
?slo@@YAEGPEAUcpu@@E@Z ENDP				; slo
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?shy@@YAEGPEAUcpu@@E@Z PROC				; shy

; 685  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 686  :     Assert(0);

  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 0b		 je	 SHORT $LN2@shy
  00016	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@shy:

; 687  :     return(0);

  00021	32 c0		 xor	 al, al

; 688  : }

  00023	c3		 ret	 0
?shy@@YAEGPEAUcpu@@E@Z ENDP				; shy
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?shx@@YAEGPEAUcpu@@E@Z PROC				; shx

; 680  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 681  :     Assert(0);

  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 0b		 je	 SHORT $LN2@shx
  00016	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@shx:

; 682  :     return(0);

  00021	32 c0		 xor	 al, al

; 683  : }

  00023	c3		 ret	 0
?shx@@YAEGPEAUcpu@@E@Z ENDP				; shx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?sax@@YAEGPEAUcpu@@E@Z PROC				; sax

; 675  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 676  :     Assert(0);

  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 0b		 je	 SHORT $LN2@sax
  00016	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@sax:

; 677  :     return(0);

  00021	32 c0		 xor	 al, al

; 678  : }

  00023	c3		 ret	 0
?sax@@YAEGPEAUcpu@@E@Z ENDP				; sax
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?rra@@YAEGPEAUcpu@@E@Z PROC				; rra

; 670  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 671  :     Assert(0);

  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 0b		 je	 SHORT $LN2@rra
  00016	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@rra:

; 672  :     return(0);

  00021	32 c0		 xor	 al, al

; 673  : }

  00023	c3		 ret	 0
?rra@@YAEGPEAUcpu@@E@Z ENDP				; rra
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?rla@@YAEGPEAUcpu@@E@Z PROC				; rla

; 661  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 662  :     /*
; 663  :     Rotate one bit left in memory, then AND accumulator with memory. Status
; 664  :     flags: N,Z,C
; 665  :     */
; 666  :         
; 667  :     return(0);

  0000f	32 c0		 xor	 al, al

; 668  : }

  00011	c3		 ret	 0
?rla@@YAEGPEAUcpu@@E@Z ENDP				; rla
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?lax@@YAEGPEAUcpu@@E@Z PROC				; lax

; 656  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 657  :     Assert(0);

  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 0b		 je	 SHORT $LN2@lax
  00016	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@lax:

; 658  :     return(0);

  00021	32 c0		 xor	 al, al

; 659  : }

  00023	c3		 ret	 0
?lax@@YAEGPEAUcpu@@E@Z ENDP				; lax
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?las@@YAEGPEAUcpu@@E@Z PROC				; las

; 652  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 653  :     return(0); 

  0000f	32 c0		 xor	 al, al

; 654  : }

  00011	c3		 ret	 0
?las@@YAEGPEAUcpu@@E@Z ENDP				; las
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?kil@@YAEGPEAUcpu@@E@Z PROC				; kil

; 647  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 648  :     Assert(0);

  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 0b		 je	 SHORT $LN2@kil
  00016	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@kil:

; 649  :     return(0);

  00021	32 c0		 xor	 al, al

; 650  : }

  00023	c3		 ret	 0
?kil@@YAEGPEAUcpu@@E@Z ENDP				; kil
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?isc@@YAEGPEAUcpu@@E@Z PROC				; isc

; 642  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 643  :     Assert(0);

  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 0b		 je	 SHORT $LN2@isc
  00016	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@isc:

; 644  :     return(0);

  00021	32 c0		 xor	 al, al

; 645  : }

  00023	c3		 ret	 0
?isc@@YAEGPEAUcpu@@E@Z ENDP				; isc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?dcp@@YAEGPEAUcpu@@E@Z PROC				; dcp

; 637  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 638  :     Assert(0);

  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 0b		 je	 SHORT $LN2@dcp
  00016	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@dcp:

; 639  :     return(0);

  00021	32 c0		 xor	 al, al

; 640  : }

  00023	c3		 ret	 0
?dcp@@YAEGPEAUcpu@@E@Z ENDP				; dcp
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?axs@@YAEGPEAUcpu@@E@Z PROC				; axs

; 632  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 633  :     Assert(0);

  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 0b		 je	 SHORT $LN2@axs
  00016	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@axs:

; 634  :     return(0);

  00021	32 c0		 xor	 al, al

; 635  : }

  00023	c3		 ret	 0
?axs@@YAEGPEAUcpu@@E@Z ENDP				; axs
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?arr@@YAEGPEAUcpu@@E@Z PROC				; arr

; 627  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 628  :     Assert(0);

  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 0b		 je	 SHORT $LN2@arr
  00016	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@arr:

; 629  :     return(0);

  00021	32 c0		 xor	 al, al

; 630  : }

  00023	c3		 ret	 0
?arr@@YAEGPEAUcpu@@E@Z ENDP				; arr
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?anc@@YAEGPEAUcpu@@E@Z PROC				; anc

; 622  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 623  :     Assert(0);

  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 0b		 je	 SHORT $LN2@anc
  00016	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@anc:

; 624  :     return(0);

  00021	32 c0		 xor	 al, al

; 625  : }

  00023	c3		 ret	 0
?anc@@YAEGPEAUcpu@@E@Z ENDP				; anc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?alr@@YAEGPEAUcpu@@E@Z PROC				; alr

; 617  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 618  :     Assert(0);

  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 0b		 je	 SHORT $LN2@alr
  00016	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@alr:

; 619  :     return(0);

  00021	32 c0		 xor	 al, al

; 620  : }

  00023	c3		 ret	 0
?alr@@YAEGPEAUcpu@@E@Z ENDP				; alr
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?ahx@@YAEGPEAUcpu@@E@Z PROC				; ahx

; 612  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 613  :     Assert(0);

  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 0b		 je	 SHORT $LN2@ahx
  00016	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@ahx:

; 614  :     return(0);

  00021	32 c0		 xor	 al, al

; 615  : }

  00023	c3		 ret	 0
?ahx@@YAEGPEAUcpu@@E@Z ENDP				; ahx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?txs@@YAEGPEAUcpu@@E@Z PROC				; txs

; 602  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 603  :     Cpu->StackPtr = Cpu->X;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0001d	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00021	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 604  :     setZero(Cpu->StackPtr, &Cpu->Flags);

  00024	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00029	48 83 c0 03	 add	 rax, 3
  0002d	48 8b d0	 mov	 rdx, rax
  00030	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00035	0f b6 48 04	 movzx	 ecx, BYTE PTR [rax+4]
  00039	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 605  :     setNegative(Cpu->StackPtr, &Cpu->Flags);

  0003e	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00043	48 83 c0 03	 add	 rax, 3
  00047	48 8b d0	 mov	 rdx, rax
  0004a	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004f	0f b6 48 04	 movzx	 ecx, BYTE PTR [rax+4]
  00053	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 606  :     return(0);

  00058	32 c0		 xor	 al, al

; 607  : }

  0005a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005e	c3		 ret	 0
?txs@@YAEGPEAUcpu@@E@Z ENDP				; txs
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?tya@@YAEGPEAUcpu@@E@Z PROC				; tya

; 595  : {   

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 596  :     Cpu->A = Cpu->Y;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0001d	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  00021	88 08		 mov	 BYTE PTR [rax], cl

; 597  :     setZero(Cpu->A, &Cpu->Flags);

  00023	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	48 83 c0 03	 add	 rax, 3
  0002c	48 8b d0	 mov	 rdx, rax
  0002f	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00034	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00037	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 598  :     setNegative(Cpu->A, &Cpu->Flags);

  0003c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	48 83 c0 03	 add	 rax, 3
  00045	48 8b d0	 mov	 rdx, rax
  00048	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004d	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00050	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 599  :     return(0);

  00055	32 c0		 xor	 al, al

; 600  : }

  00057	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005b	c3		 ret	 0
?tya@@YAEGPEAUcpu@@E@Z ENDP				; tya
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?txa@@YAEGPEAUcpu@@E@Z PROC				; txa

; 588  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 589  :     Cpu->A = Cpu->X;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0001d	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00021	88 08		 mov	 BYTE PTR [rax], cl

; 590  :     setZero(Cpu->A, &Cpu->Flags);

  00023	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	48 83 c0 03	 add	 rax, 3
  0002c	48 8b d0	 mov	 rdx, rax
  0002f	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00034	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00037	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 591  :     setNegative(Cpu->A, &Cpu->Flags);

  0003c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	48 83 c0 03	 add	 rax, 3
  00045	48 8b d0	 mov	 rdx, rax
  00048	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004d	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00050	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 592  :     return(0);

  00055	32 c0		 xor	 al, al

; 593  : }

  00057	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005b	c3		 ret	 0
?txa@@YAEGPEAUcpu@@E@Z ENDP				; txa
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?tsx@@YAEGPEAUcpu@@E@Z PROC				; tsx

; 581  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 582  :     Cpu->X = Cpu->StackPtr;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0001d	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00021	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 583  :     setZero(Cpu->X, &Cpu->Flags);

  00024	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00029	48 83 c0 03	 add	 rax, 3
  0002d	48 8b d0	 mov	 rdx, rax
  00030	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00035	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00039	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 584  :     setNegative(Cpu->X, &Cpu->Flags);

  0003e	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00043	48 83 c0 03	 add	 rax, 3
  00047	48 8b d0	 mov	 rdx, rax
  0004a	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004f	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00053	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 585  :     return(0);

  00058	32 c0		 xor	 al, al

; 586  : }

  0005a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005e	c3		 ret	 0
?tsx@@YAEGPEAUcpu@@E@Z ENDP				; tsx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?tay@@YAEGPEAUcpu@@E@Z PROC				; tay

; 574  : {    

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 575  :     Cpu->Y = Cpu->A;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0001d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00020	88 48 02	 mov	 BYTE PTR [rax+2], cl

; 576  :     setZero(Cpu->Y, &Cpu->Flags);

  00023	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	48 83 c0 03	 add	 rax, 3
  0002c	48 8b d0	 mov	 rdx, rax
  0002f	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00034	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00038	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 577  :     setNegative(Cpu->Y, &Cpu->Flags);

  0003d	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00042	48 83 c0 03	 add	 rax, 3
  00046	48 8b d0	 mov	 rdx, rax
  00049	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004e	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00052	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 578  :     return(0);

  00057	32 c0		 xor	 al, al

; 579  : }

  00059	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005d	c3		 ret	 0
?tay@@YAEGPEAUcpu@@E@Z ENDP				; tay
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?tax@@YAEGPEAUcpu@@E@Z PROC				; tax

; 567  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 568  :     Cpu->X = Cpu->A;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0001d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00020	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 569  :     setZero(Cpu->X, &Cpu->Flags);

  00023	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	48 83 c0 03	 add	 rax, 3
  0002c	48 8b d0	 mov	 rdx, rax
  0002f	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00034	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00038	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 570  :     setNegative(Cpu->X, &Cpu->Flags);

  0003d	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00042	48 83 c0 03	 add	 rax, 3
  00046	48 8b d0	 mov	 rdx, rax
  00049	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004e	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00052	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 571  :     return(0);

  00057	32 c0		 xor	 al, al

; 572  : }

  00059	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005d	c3		 ret	 0
?tax@@YAEGPEAUcpu@@E@Z ENDP				; tax
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?sty@@YAEGPEAUcpu@@E@Z PROC				; sty

; 562  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 563  :     writeCpu8(Cpu->Y, Address, Cpu->MemoryOffset);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  0001c	0f b7 54 24 30	 movzx	 edx, WORD PTR Address$[rsp]
  00021	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00026	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  0002a	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEG_K@Z	; writeCpu8

; 564  :     return(0);

  0002f	32 c0		 xor	 al, al

; 565  : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
?sty@@YAEGPEAUcpu@@E@Z ENDP				; sty
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?stx@@YAEGPEAUcpu@@E@Z PROC				; stx

; 557  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 558  :     writeCpu8(Cpu->X, Address, Cpu->MemoryOffset);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  0001c	0f b7 54 24 30	 movzx	 edx, WORD PTR Address$[rsp]
  00021	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00026	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  0002a	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEG_K@Z	; writeCpu8

; 559  :     return(0);

  0002f	32 c0		 xor	 al, al

; 560  : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
?stx@@YAEGPEAUcpu@@E@Z ENDP				; stx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?sta@@YAEGPEAUcpu@@E@Z PROC				; sta

; 552  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 553  :     writeCpu8(Cpu->A, Address, Cpu->MemoryOffset);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  0001c	0f b7 54 24 30	 movzx	 edx, WORD PTR Address$[rsp]
  00021	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00026	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00029	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEG_K@Z	; writeCpu8

; 554  :     return(0);

  0002e	32 c0		 xor	 al, al

; 555  : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
?sta@@YAEGPEAUcpu@@E@Z ENDP				; sta
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?sei@@YAEGPEAUcpu@@E@Z PROC				; sei

; 547  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 548  :     setInterrupt(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?setInterrupt@@YAXPEAE@Z ; setInterrupt

; 549  :     return(0);

  00024	32 c0		 xor	 al, al

; 550  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?sei@@YAEGPEAUcpu@@E@Z ENDP				; sei
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?sed@@YAEGPEAUcpu@@E@Z PROC				; sed

; 542  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 543  :     setDecimal(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?setDecimal@@YAXPEAE@Z	; setDecimal

; 544  :     return(0);

  00024	32 c0		 xor	 al, al

; 545  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?sed@@YAEGPEAUcpu@@E@Z ENDP				; sed
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?sec@@YAEGPEAUcpu@@E@Z PROC				; sec

; 537  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 538  :     setCarry(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 539  :     return(0);

  00024	32 c0		 xor	 al, al

; 540  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?sec@@YAEGPEAUcpu@@E@Z ENDP				; sec
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
A$ = 32
B$ = 33
C$ = 34
CarryTest$ = 36
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?sbc@@YAEGPEAUcpu@@E@Z PROC				; sbc

; 512  : {

$LN7:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 513  :     // TODO: Revisit this to double check if it is correct
; 514  :     uint8 A = Cpu->A;

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001b	88 44 24 20	 mov	 BYTE PTR A$[rsp], al

; 515  :     uint8 B = readCpu8(Address, Cpu->MemoryOffset);

  0001f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00024	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00028	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0002d	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00032	88 44 24 21	 mov	 BYTE PTR B$[rsp], al

; 516  :     uint8 C = isBitSet(CARRY_BIT, Cpu->Flags);

  00036	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003b	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  0003f	b1 01		 mov	 cl, 1
  00041	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00046	88 44 24 22	 mov	 BYTE PTR C$[rsp], al

; 517  : 
; 518  :     Cpu->A = A - B - (1-C);

  0004a	0f b6 44 24 20	 movzx	 eax, BYTE PTR A$[rsp]
  0004f	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR B$[rsp]
  00054	2b c1		 sub	 eax, ecx
  00056	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR C$[rsp]
  0005b	ba 01 00 00 00	 mov	 edx, 1
  00060	2b d1		 sub	 edx, ecx
  00062	8b ca		 mov	 ecx, edx
  00064	2b c1		 sub	 eax, ecx
  00066	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0006b	88 01		 mov	 BYTE PTR [rcx], al

; 519  : 
; 520  :     uint16 CarryTest = (int16)A - (int16)B - (int16)(1-C);

  0006d	0f b6 44 24 20	 movzx	 eax, BYTE PTR A$[rsp]
  00072	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR B$[rsp]
  00077	2b c1		 sub	 eax, ecx
  00079	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR C$[rsp]
  0007e	ba 01 00 00 00	 mov	 edx, 1
  00083	2b d1		 sub	 edx, ecx
  00085	8b ca		 mov	 ecx, edx
  00087	0f bf c9	 movsx	 ecx, cx
  0008a	2b c1		 sub	 eax, ecx
  0008c	66 89 44 24 24	 mov	 WORD PTR CarryTest$[rsp], ax

; 521  :     if(CarryTest >= 0)

  00091	0f b7 44 24 24	 movzx	 eax, WORD PTR CarryTest$[rsp]
  00096	85 c0		 test	 eax, eax
  00098	7c 13		 jl	 SHORT $LN2@sbc

; 522  :         setCarry(&Cpu->Flags);

  0009a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0009f	48 83 c0 03	 add	 rax, 3
  000a3	48 8b c8	 mov	 rcx, rax
  000a6	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 523  :     else

  000ab	eb 11		 jmp	 SHORT $LN3@sbc
$LN2@sbc:

; 524  :         clearCarry(&Cpu->Flags);

  000ad	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000b2	48 83 c0 03	 add	 rax, 3
  000b6	48 8b c8	 mov	 rcx, rax
  000b9	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN3@sbc:

; 525  : 
; 526  :     // Overflow check, taken from the web. One day find out how this works
; 527  :     if(((A ^ B) & 0x80 != 0) && ((A ^ Cpu->A) & 0x80 != 0))

  000be	0f b6 44 24 20	 movzx	 eax, BYTE PTR A$[rsp]
  000c3	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR B$[rsp]
  000c8	33 c1		 xor	 eax, ecx
  000ca	83 e0 01	 and	 eax, 1
  000cd	85 c0		 test	 eax, eax
  000cf	74 29		 je	 SHORT $LN4@sbc
  000d1	0f b6 44 24 20	 movzx	 eax, BYTE PTR A$[rsp]
  000d6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  000db	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000de	33 c1		 xor	 eax, ecx
  000e0	83 e0 01	 and	 eax, 1
  000e3	85 c0		 test	 eax, eax
  000e5	74 13		 je	 SHORT $LN4@sbc

; 528  :         setOverflow(&Cpu->Flags);

  000e7	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000ec	48 83 c0 03	 add	 rax, 3
  000f0	48 8b c8	 mov	 rcx, rax
  000f3	e8 00 00 00 00	 call	 ?setOverflow@@YAXPEAE@Z	; setOverflow

; 529  :     else

  000f8	eb 11		 jmp	 SHORT $LN5@sbc
$LN4@sbc:

; 530  :         clearOverflow(&Cpu->Flags);

  000fa	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000ff	48 83 c0 03	 add	 rax, 3
  00103	48 8b c8	 mov	 rcx, rax
  00106	e8 00 00 00 00	 call	 ?clearOverflow@@YAXPEAE@Z ; clearOverflow
$LN5@sbc:

; 531  : 
; 532  :     setZero(Cpu->A, &Cpu->Flags);

  0010b	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00110	48 83 c0 03	 add	 rax, 3
  00114	48 8b d0	 mov	 rdx, rax
  00117	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0011c	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0011f	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 533  :     setNegative(Cpu->A, &Cpu->Flags);

  00124	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00129	48 83 c0 03	 add	 rax, 3
  0012d	48 8b d0	 mov	 rdx, rax
  00130	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00135	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00138	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 534  :     return(0);

  0013d	32 c0		 xor	 al, al

; 535  : }

  0013f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00143	c3		 ret	 0
?sbc@@YAEGPEAUcpu@@E@Z ENDP				; sbc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
ReturnAddress$ = 36
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?rts@@YAEGPEAUcpu@@E@Z PROC				; rts

; 504  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 505  :     uint8 LowByte = pop(Cpu);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  0001d	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 506  :     uint8 HighByte = pop(Cpu);

  00021	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00026	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  0002b	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 507  :     uint16 ReturnAddress = ((uint16)HighByte << 8) | (uint16)LowByte;

  0002f	0f b6 44 24 20	 movzx	 eax, BYTE PTR HighByte$[rsp]
  00034	c1 e0 08	 shl	 eax, 8
  00037	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  0003c	0b c1		 or	 eax, ecx
  0003e	66 89 44 24 24	 mov	 WORD PTR ReturnAddress$[rsp], ax

; 508  :     Cpu->PrgCounter = ReturnAddress + 1;

  00043	0f b7 44 24 24	 movzx	 eax, WORD PTR ReturnAddress$[rsp]
  00048	ff c0		 inc	 eax
  0004a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0004f	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 509  :     return(0);

  00053	32 c0		 xor	 al, al

; 510  : }

  00055	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00059	c3		 ret	 0
?rts@@YAEGPEAUcpu@@E@Z ENDP				; rts
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Flags$ = 32
HighByte$ = 33
LowByte$ = 34
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?rti@@YAEGPEAUcpu@@E@Z PROC				; rti

; 491  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 492  :     // TODO: Double check if problems arise
; 493  :     uint8 Flags = pop(Cpu);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  0001d	88 44 24 20	 mov	 BYTE PTR Flags$[rsp], al

; 494  :     clearBreak(&Flags);

  00021	48 8d 4c 24 20	 lea	 rcx, QWORD PTR Flags$[rsp]
  00026	e8 00 00 00 00	 call	 ?clearBreak@@YAXPEAE@Z	; clearBreak

; 495  :     setInterrupt(&Flags);

  0002b	48 8d 4c 24 20	 lea	 rcx, QWORD PTR Flags$[rsp]
  00030	e8 00 00 00 00	 call	 ?setInterrupt@@YAXPEAE@Z ; setInterrupt

; 496  :     Cpu->Flags = Flags;

  00035	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003a	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Flags$[rsp]
  0003f	88 48 03	 mov	 BYTE PTR [rax+3], cl

; 497  :     
; 498  :     uint8 LowByte = pop(Cpu);

  00042	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00047	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  0004c	88 44 24 22	 mov	 BYTE PTR LowByte$[rsp], al

; 499  :     uint8 HighByte = pop(Cpu);

  00050	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00055	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  0005a	88 44 24 21	 mov	 BYTE PTR HighByte$[rsp], al

; 500  :     Cpu->PrgCounter = ((uint16)HighByte << 8) | (uint16)LowByte;

  0005e	0f b6 44 24 21	 movzx	 eax, BYTE PTR HighByte$[rsp]
  00063	c1 e0 08	 shl	 eax, 8
  00066	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  0006b	0b c1		 or	 eax, ecx
  0006d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00072	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 501  :     return(0);

  00076	32 c0		 xor	 al, al

; 502  : }

  00078	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007c	c3		 ret	 0
?rti@@YAEGPEAUcpu@@E@Z ENDP				; rti
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
CarrySet$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?ror@@YAEGPEAUcpu@@E@Z PROC				; ror

; 453  : {

$LN11:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 454  :     uint8 Value = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR Value$[rsp], 0

; 455  :     uint8 CarrySet = isBitSet(CARRY_BIT, Cpu->Flags);

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 01		 mov	 cl, 1
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	88 44 24 21	 mov	 BYTE PTR CarrySet$[rsp], al

; 456  :     
; 457  :     if(AddressMode == ACM)

  0002c	0f b6 44 24 50	 movzx	 eax, BYTE PTR AddressMode$[rsp]
  00031	83 f8 01	 cmp	 eax, 1
  00034	75 69		 jne	 SHORT $LN2@ror

; 458  :     {        
; 459  :         if(Cpu->A & 1)

  00036	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003e	83 e0 01	 and	 eax, 1
  00041	85 c0		 test	 eax, eax
  00043	74 13		 je	 SHORT $LN4@ror

; 460  :             setCarry(&Cpu->Flags);

  00045	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004a	48 83 c0 03	 add	 rax, 3
  0004e	48 8b c8	 mov	 rcx, rax
  00051	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 461  :         else

  00056	eb 11		 jmp	 SHORT $LN5@ror
$LN4@ror:

; 462  :             clearCarry(&Cpu->Flags);

  00058	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005d	48 83 c0 03	 add	 rax, 3
  00061	48 8b c8	 mov	 rcx, rax
  00064	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN5@ror:

; 463  :         
; 464  :         Value = Cpu->A >> 1;

  00069	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0006e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00071	d1 f8		 sar	 eax, 1
  00073	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 465  :         
; 466  :         if(CarrySet)

  00077	0f b6 44 24 21	 movzx	 eax, BYTE PTR CarrySet$[rsp]
  0007c	85 c0		 test	 eax, eax
  0007e	74 0e		 je	 SHORT $LN6@ror

; 467  :             Value = Value & (1 << 7);

  00080	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  00085	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0008a	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
$LN6@ror:

; 468  :         
; 469  :         Cpu->A = Value;

  0008e	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00093	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00098	88 08		 mov	 BYTE PTR [rax], cl

; 470  :     }
; 471  :     else

  0009a	e9 81 00 00 00	 jmp	 $LN3@ror
$LN2@ror:

; 472  :     {
; 473  :         Value = readCpu8(Address, Cpu->MemoryOffset);

  0009f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000a4	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000a8	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  000ad	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  000b2	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 474  :         if(Value & 1)

  000b6	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000bb	83 e0 01	 and	 eax, 1
  000be	85 c0		 test	 eax, eax
  000c0	74 13		 je	 SHORT $LN7@ror

; 475  :             setCarry(&Cpu->Flags);

  000c2	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000c7	48 83 c0 03	 add	 rax, 3
  000cb	48 8b c8	 mov	 rcx, rax
  000ce	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 476  :         else

  000d3	eb 11		 jmp	 SHORT $LN8@ror
$LN7@ror:

; 477  :             clearCarry(&Cpu->Flags);

  000d5	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000da	48 83 c0 03	 add	 rax, 3
  000de	48 8b c8	 mov	 rcx, rax
  000e1	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN8@ror:

; 478  :         
; 479  :         Value = Value >> 1;

  000e6	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000eb	d1 f8		 sar	 eax, 1
  000ed	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 480  :         
; 481  :         if(CarrySet)

  000f1	0f b6 44 24 21	 movzx	 eax, BYTE PTR CarrySet$[rsp]
  000f6	85 c0		 test	 eax, eax
  000f8	74 0e		 je	 SHORT $LN9@ror

; 482  :             Value = Value & (1 << 7);

  000fa	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000ff	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00104	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
$LN9@ror:

; 483  :         
; 484  :         writeCpu8(Value, Address, Cpu->MemoryOffset);

  00108	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0010d	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00111	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  00116	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0011b	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEG_K@Z	; writeCpu8
$LN3@ror:

; 485  :     }
; 486  :     setZero(Value, &Cpu->Flags);

  00120	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00125	48 83 c0 03	 add	 rax, 3
  00129	48 8b d0	 mov	 rdx, rax
  0012c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00131	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 487  :     setNegative(Value, &Cpu->Flags);

  00136	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0013b	48 83 c0 03	 add	 rax, 3
  0013f	48 8b d0	 mov	 rdx, rax
  00142	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00147	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 488  :     return(0);

  0014c	32 c0		 xor	 al, al

; 489  : }

  0014e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00152	c3		 ret	 0
?ror@@YAEGPEAUcpu@@E@Z ENDP				; ror
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
CarrySet$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?rol@@YAEGPEAUcpu@@E@Z PROC				; rol

; 415  : {    

$LN11:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 416  :     uint8 Value = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR Value$[rsp], 0

; 417  :     uint8 CarrySet = isBitSet(CARRY_BIT, Cpu->Flags);

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 01		 mov	 cl, 1
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	88 44 24 21	 mov	 BYTE PTR CarrySet$[rsp], al

; 418  :     
; 419  :     if(AddressMode == ACM)

  0002c	0f b6 44 24 50	 movzx	 eax, BYTE PTR AddressMode$[rsp]
  00031	83 f8 01	 cmp	 eax, 1
  00034	75 69		 jne	 SHORT $LN2@rol

; 420  :     {        
; 421  :         if(Cpu->A & (1 << 7))

  00036	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003e	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00043	85 c0		 test	 eax, eax
  00045	74 13		 je	 SHORT $LN4@rol

; 422  :             setCarry(&Cpu->Flags);

  00047	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004c	48 83 c0 03	 add	 rax, 3
  00050	48 8b c8	 mov	 rcx, rax
  00053	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 423  :         else

  00058	eb 11		 jmp	 SHORT $LN5@rol
$LN4@rol:

; 424  :             clearCarry(&Cpu->Flags);

  0005a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005f	48 83 c0 03	 add	 rax, 3
  00063	48 8b c8	 mov	 rcx, rax
  00066	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN5@rol:

; 425  :         
; 426  :         Value = Cpu->A << 1;

  0006b	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00070	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00073	d1 e0		 shl	 eax, 1
  00075	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 427  :         
; 428  :         if(CarrySet)

  00079	0f b6 44 24 21	 movzx	 eax, BYTE PTR CarrySet$[rsp]
  0007e	85 c0		 test	 eax, eax
  00080	74 0c		 je	 SHORT $LN6@rol

; 429  :             Value = Value & 1;

  00082	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  00087	83 e0 01	 and	 eax, 1
  0008a	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
$LN6@rol:

; 430  :         
; 431  :         Cpu->A = Value;

  0008e	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00093	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00098	88 08		 mov	 BYTE PTR [rax], cl

; 432  :     }
; 433  :     else

  0009a	e9 81 00 00 00	 jmp	 $LN3@rol
$LN2@rol:

; 434  :     {
; 435  :         Value = readCpu8(Address, Cpu->MemoryOffset);

  0009f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000a4	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000a8	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  000ad	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  000b2	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 436  :         if(Value & (1 << 7))

  000b6	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000bb	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000c0	85 c0		 test	 eax, eax
  000c2	74 13		 je	 SHORT $LN7@rol

; 437  :             setCarry(&Cpu->Flags);

  000c4	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000c9	48 83 c0 03	 add	 rax, 3
  000cd	48 8b c8	 mov	 rcx, rax
  000d0	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 438  :         else

  000d5	eb 11		 jmp	 SHORT $LN8@rol
$LN7@rol:

; 439  :             clearCarry(&Cpu->Flags);

  000d7	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000dc	48 83 c0 03	 add	 rax, 3
  000e0	48 8b c8	 mov	 rcx, rax
  000e3	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN8@rol:

; 440  :         
; 441  :         Value = Value << 1;

  000e8	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000ed	d1 e0		 shl	 eax, 1
  000ef	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 442  :         
; 443  :         if(CarrySet)

  000f3	0f b6 44 24 21	 movzx	 eax, BYTE PTR CarrySet$[rsp]
  000f8	85 c0		 test	 eax, eax
  000fa	74 0c		 je	 SHORT $LN9@rol

; 444  :             Value = Value & 1;

  000fc	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  00101	83 e0 01	 and	 eax, 1
  00104	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
$LN9@rol:

; 445  :         
; 446  :         writeCpu8(Value, Address, Cpu->MemoryOffset);

  00108	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0010d	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00111	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  00116	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0011b	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEG_K@Z	; writeCpu8
$LN3@rol:

; 447  :     }
; 448  :     setZero(Value, &Cpu->Flags);

  00120	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00125	48 83 c0 03	 add	 rax, 3
  00129	48 8b d0	 mov	 rdx, rax
  0012c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00131	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 449  :     setNegative(Value, &Cpu->Flags);

  00136	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0013b	48 83 c0 03	 add	 rax, 3
  0013f	48 8b d0	 mov	 rdx, rax
  00142	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00147	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 450  :     return(0);

  0014c	32 c0		 xor	 al, al

; 451  : }

  0014e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00152	c3		 ret	 0
?rol@@YAEGPEAUcpu@@E@Z ENDP				; rol
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?plp@@YAEGPEAUcpu@@E@Z PROC				; plp

; 410  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 411  :     Cpu->Flags = pop(Cpu);

  00013	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  0001d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00022	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 412  :     return(0);

  00025	32 c0		 xor	 al, al

; 413  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
?plp@@YAEGPEAUcpu@@E@Z ENDP				; plp
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?pla@@YAEGPEAUcpu@@E@Z PROC				; pla

; 403  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 404  :     Cpu->A = pop(Cpu); 

  00013	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  0001d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00022	88 01		 mov	 BYTE PTR [rcx], al

; 405  :     setZero(Cpu->A, &Cpu->Flags);

  00024	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00029	48 83 c0 03	 add	 rax, 3
  0002d	48 8b d0	 mov	 rdx, rax
  00030	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00035	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00038	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 406  :     setNegative(Cpu->A, &Cpu->Flags);

  0003d	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00042	48 83 c0 03	 add	 rax, 3
  00046	48 8b d0	 mov	 rdx, rax
  00049	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004e	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00051	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 407  :     return(0);

  00056	32 c0		 xor	 al, al

; 408  : }

  00058	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005c	c3		 ret	 0
?pla@@YAEGPEAUcpu@@E@Z ENDP				; pla
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?php@@YAEGPEAUcpu@@E@Z PROC				; php

; 398  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 399  :     push(Cpu->Flags, Cpu);

  00013	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00018	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  00021	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 400  :     return(0);

  00026	32 c0		 xor	 al, al

; 401  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
?php@@YAEGPEAUcpu@@E@Z ENDP				; php
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?pha@@YAEGPEAUcpu@@E@Z PROC				; pha

; 393  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 394  :     push(Cpu->A, Cpu);

  00013	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00018	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00020	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 395  :     return(0);

  00025	32 c0		 xor	 al, al

; 396  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
?pha@@YAEGPEAUcpu@@E@Z ENDP				; pha
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?ora@@YAEGPEAUcpu@@E@Z PROC				; ora

; 385  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 386  :     uint8 Value = readCpu8(Address, Cpu->MemoryOffset);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 387  :     Cpu->A = Cpu->A | Value;

  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00032	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00037	0b c1		 or	 eax, ecx
  00039	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0003e	88 01		 mov	 BYTE PTR [rcx], al

; 388  :     setZero(Cpu->A, &Cpu->Flags);

  00040	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00045	48 83 c0 03	 add	 rax, 3
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00054	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 389  :     setNegative(Cpu->A, &Cpu->Flags);

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	48 83 c0 03	 add	 rax, 3
  00062	48 8b d0	 mov	 rdx, rax
  00065	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0006a	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0006d	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 390  :     return(0);

  00072	32 c0		 xor	 al, al

; 391  : }

  00074	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00078	c3		 ret	 0
?ora@@YAEGPEAUcpu@@E@Z ENDP				; ora
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?nop@@YAEGPEAUcpu@@E@Z PROC				; nop

; 381  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 382  :     return(0);

  0000f	32 c0		 xor	 al, al

; 383  : }

  00011	c3		 ret	 0
?nop@@YAEGPEAUcpu@@E@Z ENDP				; nop
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?lsr@@YAEGPEAUcpu@@E@Z PROC				; lsr

; 355  : {

$LN9:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 356  :     uint8 Value = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR Value$[rsp], 0

; 357  :     if(AddressMode == ACM)

  00018	0f b6 44 24 50	 movzx	 eax, BYTE PTR AddressMode$[rsp]
  0001d	83 f8 01	 cmp	 eax, 1
  00020	75 52		 jne	 SHORT $LN2@lsr

; 358  :     {        
; 359  :         if(Cpu->A & 1)

  00022	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00027	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002a	83 e0 01	 and	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	74 13		 je	 SHORT $LN4@lsr

; 360  :             setCarry(&Cpu->Flags);

  00031	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00036	48 83 c0 03	 add	 rax, 3
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 361  :         else

  00042	eb 11		 jmp	 SHORT $LN5@lsr
$LN4@lsr:

; 362  :             clearCarry(&Cpu->Flags);

  00044	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00049	48 83 c0 03	 add	 rax, 3
  0004d	48 8b c8	 mov	 rcx, rax
  00050	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN5@lsr:

; 363  :         Cpu->A = Cpu->A >> 1;

  00055	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005d	d1 f8		 sar	 eax, 1
  0005f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00064	88 01		 mov	 BYTE PTR [rcx], al

; 364  :         Value = Cpu->A;

  00066	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0006b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006e	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 365  :     }
; 366  :     else

  00072	eb 6a		 jmp	 SHORT $LN3@lsr
$LN2@lsr:

; 367  :     {
; 368  :         Value = readCpu8(Address, Cpu->MemoryOffset);

  00074	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00079	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0007d	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00082	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00087	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 369  :         if(Value & 1)

  0008b	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  00090	83 e0 01	 and	 eax, 1
  00093	85 c0		 test	 eax, eax
  00095	74 13		 je	 SHORT $LN6@lsr

; 370  :             setCarry(&Cpu->Flags);

  00097	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0009c	48 83 c0 03	 add	 rax, 3
  000a0	48 8b c8	 mov	 rcx, rax
  000a3	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 371  :         else

  000a8	eb 11		 jmp	 SHORT $LN7@lsr
$LN6@lsr:

; 372  :             clearCarry(&Cpu->Flags);

  000aa	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000af	48 83 c0 03	 add	 rax, 3
  000b3	48 8b c8	 mov	 rcx, rax
  000b6	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN7@lsr:

; 373  :         Value = Value >> 1;

  000bb	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000c0	d1 f8		 sar	 eax, 1
  000c2	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 374  :         writeCpu8(Value, Address, Cpu->MemoryOffset);

  000c6	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000cb	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  000cf	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  000d4	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  000d9	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEG_K@Z	; writeCpu8
$LN3@lsr:

; 375  :     }
; 376  :     setZero(Value, &Cpu->Flags);

  000de	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000e3	48 83 c0 03	 add	 rax, 3
  000e7	48 8b d0	 mov	 rdx, rax
  000ea	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  000ef	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 377  :     setNegative(Value, &Cpu->Flags);

  000f4	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000f9	48 83 c0 03	 add	 rax, 3
  000fd	48 8b d0	 mov	 rdx, rax
  00100	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00105	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 378  :     return(0);

  0010a	32 c0		 xor	 al, al

; 379  : }

  0010c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00110	c3		 ret	 0
?lsr@@YAEGPEAUcpu@@E@Z ENDP				; lsr
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?ldy@@YAEGPEAUcpu@@E@Z PROC				; ldy

; 347  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 348  :     uint8 Value = readCpu8(Address, Cpu->MemoryOffset);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 349  :     Cpu->Y = Value;

  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00034	88 48 02	 mov	 BYTE PTR [rax+2], cl

; 350  :     setZero(Value, &Cpu->Flags);

  00037	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003c	48 83 c0 03	 add	 rax, 3
  00040	48 8b d0	 mov	 rdx, rax
  00043	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00048	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 351  :     setNegative(Value, &Cpu->Flags);

  0004d	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00052	48 83 c0 03	 add	 rax, 3
  00056	48 8b d0	 mov	 rdx, rax
  00059	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0005e	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 352  :     return(0);

  00063	32 c0		 xor	 al, al

; 353  : }

  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
?ldy@@YAEGPEAUcpu@@E@Z ENDP				; ldy
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?ldx@@YAEGPEAUcpu@@E@Z PROC				; ldx

; 339  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 340  :     uint8 Value = readCpu8(Address, Cpu->MemoryOffset);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 341  :     Cpu->X = Value;

  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00034	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 342  :     setZero(Value, &Cpu->Flags);

  00037	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003c	48 83 c0 03	 add	 rax, 3
  00040	48 8b d0	 mov	 rdx, rax
  00043	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00048	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 343  :     setNegative(Value, &Cpu->Flags);

  0004d	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00052	48 83 c0 03	 add	 rax, 3
  00056	48 8b d0	 mov	 rdx, rax
  00059	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0005e	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 344  :     return(0);

  00063	32 c0		 xor	 al, al

; 345  : }

  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
?ldx@@YAEGPEAUcpu@@E@Z ENDP				; ldx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?lda@@YAEGPEAUcpu@@E@Z PROC				; lda

; 331  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 332  :     uint8 Value = readCpu8(Address, Cpu->MemoryOffset);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 333  :     Cpu->A = Value;

  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00034	88 08		 mov	 BYTE PTR [rax], cl

; 334  :     setZero(Value, &Cpu->Flags);

  00036	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003b	48 83 c0 03	 add	 rax, 3
  0003f	48 8b d0	 mov	 rdx, rax
  00042	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00047	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 335  :     setNegative(Value, &Cpu->Flags);

  0004c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	48 83 c0 03	 add	 rax, 3
  00055	48 8b d0	 mov	 rdx, rax
  00058	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0005d	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 336  :     return(0);

  00062	32 c0		 xor	 al, al

; 337  : }

  00064	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00068	c3		 ret	 0
?lda@@YAEGPEAUcpu@@E@Z ENDP				; lda
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
ReturnAddress$ = 36
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?jsr@@YAEGPEAUcpu@@E@Z PROC				; jsr

; 319  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 320  :     uint16 ReturnAddress = Cpu->PrgCounter - 1;

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0001c	ff c8		 dec	 eax
  0001e	66 89 44 24 24	 mov	 WORD PTR ReturnAddress$[rsp], ax

; 321  :     uint8 HighByte = (uint8)(ReturnAddress >> 8);

  00023	0f b7 44 24 24	 movzx	 eax, WORD PTR ReturnAddress$[rsp]
  00028	c1 f8 08	 sar	 eax, 8
  0002b	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 322  :     uint8 LowByte = (uint8)ReturnAddress; 

  0002f	0f b6 44 24 24	 movzx	 eax, BYTE PTR ReturnAddress$[rsp]
  00034	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 323  : 
; 324  :     push(HighByte, Cpu);

  00038	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0003d	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR HighByte$[rsp]
  00042	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 325  :     push(LowByte, Cpu);

  00047	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0004c	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  00051	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 326  : 
; 327  :     Cpu->PrgCounter = Address;

  00056	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005b	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00060	66 89 48 06	 mov	 WORD PTR [rax+6], cx

; 328  :     return(0);

  00064	32 c0		 xor	 al, al

; 329  : }

  00066	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006a	c3		 ret	 0
?jsr@@YAEGPEAUcpu@@E@Z ENDP				; jsr
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?jmp@@YAEGPEAUcpu@@E@Z PROC				; jmp

; 314  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 315  :     Cpu->PrgCounter = Address;

  0000f	48 8b 44 24 10	 mov	 rax, QWORD PTR Cpu$[rsp]
  00014	0f b7 4c 24 08	 movzx	 ecx, WORD PTR Address$[rsp]
  00019	66 89 48 06	 mov	 WORD PTR [rax+6], cx

; 316  :     return(0);

  0001d	32 c0		 xor	 al, al

; 317  : }

  0001f	c3		 ret	 0
?jmp@@YAEGPEAUcpu@@E@Z ENDP				; jmp
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?iny@@YAEGPEAUcpu@@E@Z PROC				; iny

; 307  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 308  :     ++Cpu->Y;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0001c	fe c0		 inc	 al
  0001e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00023	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 309  :     setZero(Cpu->Y, &Cpu->Flags);

  00026	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	48 83 c0 03	 add	 rax, 3
  0002f	48 8b d0	 mov	 rdx, rax
  00032	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00037	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  0003b	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 310  :     setNegative(Cpu->Y, &Cpu->Flags);

  00040	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00045	48 83 c0 03	 add	 rax, 3
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00055	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 311  :     return(0);

  0005a	32 c0		 xor	 al, al

; 312  : }

  0005c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00060	c3		 ret	 0
?iny@@YAEGPEAUcpu@@E@Z ENDP				; iny
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?inx@@YAEGPEAUcpu@@E@Z PROC				; inx

; 300  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 301  :     ++Cpu->X;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0001c	fe c0		 inc	 al
  0001e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00023	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 302  :     setZero(Cpu->X, &Cpu->Flags);

  00026	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	48 83 c0 03	 add	 rax, 3
  0002f	48 8b d0	 mov	 rdx, rax
  00032	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00037	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  0003b	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 303  :     setNegative(Cpu->X, &Cpu->Flags);

  00040	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00045	48 83 c0 03	 add	 rax, 3
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00055	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 304  :     return(0);

  0005a	32 c0		 xor	 al, al

; 305  : }

  0005c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00060	c3		 ret	 0
?inx@@YAEGPEAUcpu@@E@Z ENDP				; inx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?inc@@YAEGPEAUcpu@@E@Z PROC				; inc

; 292  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 293  :     uint8 Value = readCpu8(Address, Cpu->MemoryOffset) + 1;

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	0f b6 c0	 movzx	 eax, al
  00029	ff c0		 inc	 eax
  0002b	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 294  :     writeCpu8(Value, Address, Cpu->MemoryOffset);

  0002f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00034	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00038	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003d	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00042	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEG_K@Z	; writeCpu8

; 295  :     setZero(Value, &Cpu->Flags);

  00047	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004c	48 83 c0 03	 add	 rax, 3
  00050	48 8b d0	 mov	 rdx, rax
  00053	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00058	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 296  :     setNegative(Value, &Cpu->Flags);

  0005d	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00062	48 83 c0 03	 add	 rax, 3
  00066	48 8b d0	 mov	 rdx, rax
  00069	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0006e	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 297  :     return(0);

  00073	32 c0		 xor	 al, al

; 298  : }

  00075	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00079	c3		 ret	 0
?inc@@YAEGPEAUcpu@@E@Z ENDP				; inc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?eor@@YAEGPEAUcpu@@E@Z PROC				; eor

; 284  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 285  :     uint8 Value = readCpu8(Address, Cpu->MemoryOffset);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 286  :     Cpu->A = Cpu->A ^ Value;

  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00032	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00037	33 c1		 xor	 eax, ecx
  00039	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0003e	88 01		 mov	 BYTE PTR [rcx], al

; 287  :     setZero(Cpu->A, &Cpu->Flags);

  00040	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00045	48 83 c0 03	 add	 rax, 3
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00054	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 288  :     setNegative(Cpu->A, &Cpu->Flags);

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	48 83 c0 03	 add	 rax, 3
  00062	48 8b d0	 mov	 rdx, rax
  00065	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0006a	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0006d	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 289  :     return(0);

  00072	32 c0		 xor	 al, al

; 290  : }

  00074	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00078	c3		 ret	 0
?eor@@YAEGPEAUcpu@@E@Z ENDP				; eor
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?dey@@YAEGPEAUcpu@@E@Z PROC				; dey

; 277  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 278  :     --Cpu->Y;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0001c	fe c8		 dec	 al
  0001e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00023	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 279  :     setZero(Cpu->Y, &Cpu->Flags);

  00026	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	48 83 c0 03	 add	 rax, 3
  0002f	48 8b d0	 mov	 rdx, rax
  00032	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00037	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  0003b	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 280  :     setNegative(Cpu->Y, &Cpu->Flags);

  00040	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00045	48 83 c0 03	 add	 rax, 3
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00055	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 281  :     return(0);

  0005a	32 c0		 xor	 al, al

; 282  : }

  0005c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00060	c3		 ret	 0
?dey@@YAEGPEAUcpu@@E@Z ENDP				; dey
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?dex@@YAEGPEAUcpu@@E@Z PROC				; dex

; 270  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 271  :     --Cpu->X;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0001c	fe c8		 dec	 al
  0001e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00023	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 272  :     setZero(Cpu->X, &Cpu->Flags);

  00026	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	48 83 c0 03	 add	 rax, 3
  0002f	48 8b d0	 mov	 rdx, rax
  00032	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00037	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  0003b	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 273  :     setNegative(Cpu->X, &Cpu->Flags);

  00040	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00045	48 83 c0 03	 add	 rax, 3
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00055	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 274  :     return(0);

  0005a	32 c0		 xor	 al, al

; 275  : }

  0005c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00060	c3		 ret	 0
?dex@@YAEGPEAUcpu@@E@Z ENDP				; dex
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?dec@@YAEGPEAUcpu@@E@Z PROC				; dec

; 262  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 263  :     uint8 Value = readCpu8(Address, Cpu->MemoryOffset) - 1;

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	0f b6 c0	 movzx	 eax, al
  00029	ff c8		 dec	 eax
  0002b	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 264  :     writeCpu8(Value, Address, Cpu->MemoryOffset);

  0002f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00034	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00038	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003d	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00042	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEG_K@Z	; writeCpu8

; 265  :     setZero(Value, &Cpu->Flags);

  00047	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004c	48 83 c0 03	 add	 rax, 3
  00050	48 8b d0	 mov	 rdx, rax
  00053	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00058	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 266  :     setNegative(Value, &Cpu->Flags);

  0005d	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00062	48 83 c0 03	 add	 rax, 3
  00066	48 8b d0	 mov	 rdx, rax
  00069	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0006e	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 267  :     return(0);

  00073	32 c0		 xor	 al, al

; 268  : }

  00075	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00079	c3		 ret	 0
?dec@@YAEGPEAUcpu@@E@Z ENDP				; dec
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
CmpValue$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?cpy@@YAEGPEAUcpu@@E@Z PROC				; cpy

; 248  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 249  :     uint8 Value = readCpu8(Address, Cpu->MemoryOffset);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 250  : 
; 251  :     if(Cpu->Y >= Value)

  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002f	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00033	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00038	3b c1		 cmp	 eax, ecx
  0003a	7c 13		 jl	 SHORT $LN2@cpy

; 252  :         setCarry(&Cpu->Flags);

  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	48 83 c0 03	 add	 rax, 3
  00045	48 8b c8	 mov	 rcx, rax
  00048	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 253  :     else

  0004d	eb 11		 jmp	 SHORT $LN3@cpy
$LN2@cpy:

; 254  :         clearCarry(&Cpu->Flags);

  0004f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00054	48 83 c0 03	 add	 rax, 3
  00058	48 8b c8	 mov	 rcx, rax
  0005b	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN3@cpy:

; 255  :     
; 256  :     uint8 CmpValue = Cpu->Y - Value;

  00060	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00065	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00069	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0006e	2b c1		 sub	 eax, ecx
  00070	88 44 24 21	 mov	 BYTE PTR CmpValue$[rsp], al

; 257  :     setZero(CmpValue, &Cpu->Flags);

  00074	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00079	48 83 c0 03	 add	 rax, 3
  0007d	48 8b d0	 mov	 rdx, rax
  00080	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  00085	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 258  :     setNegative(CmpValue, &Cpu->Flags);

  0008a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0008f	48 83 c0 03	 add	 rax, 3
  00093	48 8b d0	 mov	 rdx, rax
  00096	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  0009b	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 259  :     return(0);

  000a0	32 c0		 xor	 al, al

; 260  : }

  000a2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a6	c3		 ret	 0
?cpy@@YAEGPEAUcpu@@E@Z ENDP				; cpy
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
CmpValue$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?cpx@@YAEGPEAUcpu@@E@Z PROC				; cpx

; 234  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 235  :     uint8 Value = readCpu8(Address, Cpu->MemoryOffset);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 236  : 
; 237  :     if(Cpu->X >= Value)

  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002f	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00033	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00038	3b c1		 cmp	 eax, ecx
  0003a	7c 13		 jl	 SHORT $LN2@cpx

; 238  :         setCarry(&Cpu->Flags);

  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	48 83 c0 03	 add	 rax, 3
  00045	48 8b c8	 mov	 rcx, rax
  00048	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 239  :     else

  0004d	eb 11		 jmp	 SHORT $LN3@cpx
$LN2@cpx:

; 240  :         clearCarry(&Cpu->Flags);

  0004f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00054	48 83 c0 03	 add	 rax, 3
  00058	48 8b c8	 mov	 rcx, rax
  0005b	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN3@cpx:

; 241  :     
; 242  :     uint8 CmpValue = Cpu->X - Value;

  00060	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00065	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00069	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0006e	2b c1		 sub	 eax, ecx
  00070	88 44 24 21	 mov	 BYTE PTR CmpValue$[rsp], al

; 243  :     setZero(CmpValue, &Cpu->Flags);

  00074	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00079	48 83 c0 03	 add	 rax, 3
  0007d	48 8b d0	 mov	 rdx, rax
  00080	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  00085	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 244  :     setNegative(CmpValue, &Cpu->Flags);

  0008a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0008f	48 83 c0 03	 add	 rax, 3
  00093	48 8b d0	 mov	 rdx, rax
  00096	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  0009b	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 245  :     return(0);

  000a0	32 c0		 xor	 al, al

; 246  : }

  000a2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a6	c3		 ret	 0
?cpx@@YAEGPEAUcpu@@E@Z ENDP				; cpx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
CmpValue$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?cmp@@YAEGPEAUcpu@@E@Z PROC				; cmp

; 220  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 221  :     uint8 Value = readCpu8(Address, Cpu->MemoryOffset);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 222  : 
; 223  :     if(Cpu->A >= Value)

  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00032	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00037	3b c1		 cmp	 eax, ecx
  00039	7c 13		 jl	 SHORT $LN2@cmp

; 224  :         setCarry(&Cpu->Flags);

  0003b	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00040	48 83 c0 03	 add	 rax, 3
  00044	48 8b c8	 mov	 rcx, rax
  00047	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 225  :     else

  0004c	eb 11		 jmp	 SHORT $LN3@cmp
$LN2@cmp:

; 226  :         clearCarry(&Cpu->Flags);

  0004e	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00053	48 83 c0 03	 add	 rax, 3
  00057	48 8b c8	 mov	 rcx, rax
  0005a	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN3@cmp:

; 227  :     
; 228  :     uint8 CmpValue = Cpu->A - Value;

  0005f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00064	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00067	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0006c	2b c1		 sub	 eax, ecx
  0006e	88 44 24 21	 mov	 BYTE PTR CmpValue$[rsp], al

; 229  :     setZero(CmpValue, &Cpu->Flags);

  00072	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00077	48 83 c0 03	 add	 rax, 3
  0007b	48 8b d0	 mov	 rdx, rax
  0007e	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  00083	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 230  :     setNegative(CmpValue, &Cpu->Flags);

  00088	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0008d	48 83 c0 03	 add	 rax, 3
  00091	48 8b d0	 mov	 rdx, rax
  00094	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  00099	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 231  :     return(0);

  0009e	32 c0		 xor	 al, al

; 232  : }

  000a0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a4	c3		 ret	 0
?cmp@@YAEGPEAUcpu@@E@Z ENDP				; cmp
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?clv@@YAEGPEAUcpu@@E@Z PROC				; clv

; 215  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 216  :     clearOverflow(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?clearOverflow@@YAXPEAE@Z ; clearOverflow

; 217  :     return(0);

  00024	32 c0		 xor	 al, al

; 218  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?clv@@YAEGPEAUcpu@@E@Z ENDP				; clv
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?cli@@YAEGPEAUcpu@@E@Z PROC				; cli

; 210  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 211  :     clearInterrupt(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?clearInterrupt@@YAXPEAE@Z ; clearInterrupt

; 212  :     return(0);

  00024	32 c0		 xor	 al, al

; 213  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?cli@@YAEGPEAUcpu@@E@Z ENDP				; cli
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?cld@@YAEGPEAUcpu@@E@Z PROC				; cld

; 205  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 206  :     clearDecimal(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?clearDecimal@@YAXPEAE@Z ; clearDecimal

; 207  :     return(0);

  00024	32 c0		 xor	 al, al

; 208  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?cld@@YAEGPEAUcpu@@E@Z ENDP				; cld
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?clc@@YAEGPEAUcpu@@E@Z PROC				; clc

; 200  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 201  :     clearCarry(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry

; 202  :     return(0);

  00024	32 c0		 xor	 al, al

; 203  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?clc@@YAEGPEAUcpu@@E@Z ENDP				; clc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bvs@@YAEGPEAUcpu@@E@Z PROC				; bvs

; 187  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 188  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 189  :     if(isBitSet(OVERFLOW_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 40		 mov	 cl, 64			; 00000040H
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	74 3b		 je	 SHORT $LN2@bvs

; 190  :     {
; 191  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 192  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bvs

; 193  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bvs:

; 194  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bvs:

; 195  :     }   
; 196  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 197  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bvs@@YAEGPEAUcpu@@E@Z ENDP				; bvs
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bvc@@YAEGPEAUcpu@@E@Z PROC				; bvc

; 174  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 175  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 176  :     if(!isBitSet(OVERFLOW_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 40		 mov	 cl, 64			; 00000040H
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	75 3b		 jne	 SHORT $LN2@bvc

; 177  :     {
; 178  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 179  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bvc

; 180  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bvc:

; 181  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bvc:

; 182  :     }   
; 183  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 184  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bvc@@YAEGPEAUcpu@@E@Z ENDP				; bvc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?brk@@YAEGPEAUcpu@@E@Z PROC				; brk

; 162  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 163  :     uint8 HighByte = (uint8)(Cpu->PrgCounter >> 8);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0001c	c1 f8 08	 sar	 eax, 8
  0001f	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 164  :     uint8 LowByte = (uint8)Cpu->PrgCounter; 

  00023	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  0002c	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 165  :     push(HighByte, Cpu);

  00030	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00035	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR HighByte$[rsp]
  0003a	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 166  :     push(LowByte, Cpu);

  0003f	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00044	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  00049	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 167  :     push(Cpu->Flags, Cpu);

  0004e	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00053	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00058	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  0005c	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 168  : 
; 169  :     Cpu->PrgCounter = readCpu16(IRQ_BRK_VEC, Cpu->MemoryOffset);

  00061	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00066	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0006a	66 b9 fe ff	 mov	 cx, 65534		; 0000fffeH
  0006e	e8 00 00 00 00	 call	 ?readCpu16@@YAGG_K@Z	; readCpu16
  00073	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00078	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 170  :     return(0);

  0007c	32 c0		 xor	 al, al

; 171  : }

  0007e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00082	c3		 ret	 0
?brk@@YAEGPEAUcpu@@E@Z ENDP				; brk
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bpl@@YAEGPEAUcpu@@E@Z PROC				; bpl

; 149  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 150  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 151  :     if(!isBitSet(NEGATIVE_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 80		 mov	 cl, 128			; 00000080H
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	75 3b		 jne	 SHORT $LN2@bpl

; 152  :     {
; 153  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 154  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bpl

; 155  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bpl:

; 156  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bpl:

; 157  :     }   
; 158  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 159  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bpl@@YAEGPEAUcpu@@E@Z ENDP				; bpl
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bne@@YAEGPEAUcpu@@E@Z PROC				; bne

; 136  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 137  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 138  :     if(!isBitSet(ZERO_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 02		 mov	 cl, 2
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	75 3b		 jne	 SHORT $LN2@bne

; 139  :     {
; 140  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 141  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bne

; 142  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bne:

; 143  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bne:

; 144  :     }   
; 145  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 146  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bne@@YAEGPEAUcpu@@E@Z ENDP				; bne
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bmi@@YAEGPEAUcpu@@E@Z PROC				; bmi

; 123  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 124  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 125  :     if(isBitSet(NEGATIVE_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 80		 mov	 cl, 128			; 00000080H
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	74 3b		 je	 SHORT $LN2@bmi

; 126  :     {
; 127  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 128  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bmi

; 129  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bmi:

; 130  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bmi:

; 131  :     }   
; 132  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 133  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bmi@@YAEGPEAUcpu@@E@Z ENDP				; bmi
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bit@@YAEGPEAUcpu@@E@Z PROC				; bit

; 111  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 112  :     uint8 Value = readCpu8(Address, Cpu->MemoryOffset);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 113  :     if(Value & (1 << 6))

  0002a	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  0002f	83 e0 40	 and	 eax, 64			; 00000040H
  00032	85 c0		 test	 eax, eax
  00034	74 13		 je	 SHORT $LN2@bit

; 114  :         setOverflow(&Cpu->Flags);

  00036	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003b	48 83 c0 03	 add	 rax, 3
  0003f	48 8b c8	 mov	 rcx, rax
  00042	e8 00 00 00 00	 call	 ?setOverflow@@YAXPEAE@Z	; setOverflow

; 115  :     else

  00047	eb 11		 jmp	 SHORT $LN3@bit
$LN2@bit:

; 116  :         clearOverflow(&Cpu->Flags);

  00049	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004e	48 83 c0 03	 add	 rax, 3
  00052	48 8b c8	 mov	 rcx, rax
  00055	e8 00 00 00 00	 call	 ?clearOverflow@@YAXPEAE@Z ; clearOverflow
$LN3@bit:

; 117  :     setNegative(Value, &Cpu->Flags);

  0005a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005f	48 83 c0 03	 add	 rax, 3
  00063	48 8b d0	 mov	 rdx, rax
  00066	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0006b	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 118  :     setZero(Cpu->A & Value, &Cpu->Flags);

  00070	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00075	48 83 c0 03	 add	 rax, 3
  00079	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0007e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00081	0f b6 54 24 20	 movzx	 edx, BYTE PTR Value$[rsp]
  00086	23 ca		 and	 ecx, edx
  00088	48 8b d0	 mov	 rdx, rax
  0008b	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 119  :     return(0);

  00090	32 c0		 xor	 al, al

; 120  : }

  00092	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00096	c3		 ret	 0
?bit@@YAEGPEAUcpu@@E@Z ENDP				; bit
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?beq@@YAEGPEAUcpu@@E@Z PROC				; beq

; 98   : {   

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 99   :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 100  :     if(isBitSet(ZERO_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 02		 mov	 cl, 2
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	74 3b		 je	 SHORT $LN2@beq

; 101  :     {
; 102  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 103  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@beq

; 104  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@beq:

; 105  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@beq:

; 106  :     }   
; 107  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 108  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?beq@@YAEGPEAUcpu@@E@Z ENDP				; beq
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bcs@@YAEGPEAUcpu@@E@Z PROC				; bcs

; 86   : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 87   :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 88   :     if(isBitSet(CARRY_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 01		 mov	 cl, 1
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	74 3b		 je	 SHORT $LN2@bcs

; 89   :     {
; 90   :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 91   :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bcs

; 92   :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bcs:

; 93   :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bcs:

; 94   :     }   
; 95   :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 96   : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bcs@@YAEGPEAUcpu@@E@Z ENDP				; bcs
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Test$1 = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bcc@@YAEGPEAUcpu@@E@Z PROC				; bcc

; 70   : {

$LN6:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 71   :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 72   :     
; 73   :     if(!isBitSet(CARRY_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 01		 mov	 cl, 1
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	75 3d		 jne	 SHORT $LN2@bcc

; 74   :     {
; 75   :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 76   :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN4@bcc

; 77   :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN4@bcc:

; 78   :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx

; 79   :     }
; 80   :     else

  00067	eb 05		 jmp	 SHORT $LN3@bcc
$LN2@bcc:

; 81   :         uint8 Test =0;

  00069	c6 44 24 21 00	 mov	 BYTE PTR Test$1[rsp], 0
$LN3@bcc:

; 82   :     return(AddCycles);

  0006e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 83   : }

  00073	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00077	c3		 ret	 0
?bcc@@YAEGPEAUcpu@@E@Z ENDP				; bcc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?asl@@YAEGPEAUcpu@@E@Z PROC				; asl

; 43   : {

$LN9:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 44   :     uint8 Value = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR Value$[rsp], 0

; 45   :     if(AddressMode == ACM)

  00018	0f b6 44 24 50	 movzx	 eax, BYTE PTR AddressMode$[rsp]
  0001d	83 f8 01	 cmp	 eax, 1
  00020	75 51		 jne	 SHORT $LN2@asl

; 46   :     {        
; 47   :         if(Cpu->A & (1 << 7))

  00022	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00027	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002a	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0002f	85 c0		 test	 eax, eax
  00031	74 13		 je	 SHORT $LN4@asl

; 48   :             setCarry(&Cpu->Flags);

  00033	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00038	48 83 c0 03	 add	 rax, 3
  0003c	48 8b c8	 mov	 rcx, rax
  0003f	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 49   :         else

  00044	eb 11		 jmp	 SHORT $LN5@asl
$LN4@asl:

; 50   :             clearCarry(&Cpu->Flags);

  00046	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004b	48 83 c0 03	 add	 rax, 3
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN5@asl:

; 51   :         Value = Cpu->A << 1;

  00057	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005f	d1 e0		 shl	 eax, 1
  00061	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 52   :         Cpu->A = Value;

  00065	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0006a	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0006f	88 08		 mov	 BYTE PTR [rax], cl

; 53   :     }
; 54   :     else

  00071	eb 6c		 jmp	 SHORT $LN3@asl
$LN2@asl:

; 55   :     {
; 56   :         Value = readCpu8(Address, Cpu->MemoryOffset);

  00073	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00078	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0007c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00081	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00086	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 57   :         if(Value & (1 << 7))

  0008a	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  0008f	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00094	85 c0		 test	 eax, eax
  00096	74 13		 je	 SHORT $LN6@asl

; 58   :             setCarry(&Cpu->Flags);

  00098	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0009d	48 83 c0 03	 add	 rax, 3
  000a1	48 8b c8	 mov	 rcx, rax
  000a4	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 59   :         else

  000a9	eb 11		 jmp	 SHORT $LN7@asl
$LN6@asl:

; 60   :             clearCarry(&Cpu->Flags);

  000ab	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000b0	48 83 c0 03	 add	 rax, 3
  000b4	48 8b c8	 mov	 rcx, rax
  000b7	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN7@asl:

; 61   :         Value = Value << 1;

  000bc	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000c1	d1 e0		 shl	 eax, 1
  000c3	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 62   :         writeCpu8(Value, Address, Cpu->MemoryOffset);

  000c7	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000cc	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  000d0	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  000d5	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  000da	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEG_K@Z	; writeCpu8
$LN3@asl:

; 63   :     }
; 64   :     setZero(Value, &Cpu->Flags);

  000df	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000e4	48 83 c0 03	 add	 rax, 3
  000e8	48 8b d0	 mov	 rdx, rax
  000eb	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  000f0	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 65   :     setNegative(Value, &Cpu->Flags);

  000f5	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000fa	48 83 c0 03	 add	 rax, 3
  000fe	48 8b d0	 mov	 rdx, rax
  00101	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00106	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 66   :     return(0);

  0010b	32 c0		 xor	 al, al

; 67   : }

  0010d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00111	c3		 ret	 0
?asl@@YAEGPEAUcpu@@E@Z ENDP				; asl
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?AND@@YAEGPEAUcpu@@E@Z PROC				; AND

; 34   : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 35   :     uint8 Value = readCpu8(Address, Cpu->MemoryOffset);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 36   :     Cpu->A = Cpu->A & Value;

  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00032	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00037	23 c1		 and	 eax, ecx
  00039	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0003e	88 01		 mov	 BYTE PTR [rcx], al

; 37   :     setZero(Cpu->A, &Cpu->Flags);

  00040	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00045	48 83 c0 03	 add	 rax, 3
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00054	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 38   :     setNegative(Cpu->A, &Cpu->Flags);

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	48 83 c0 03	 add	 rax, 3
  00062	48 8b d0	 mov	 rdx, rax
  00065	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0006a	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0006d	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 39   :     return(0);

  00072	32 c0		 xor	 al, al

; 40   : }

  00074	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00078	c3		 ret	 0
?AND@@YAEGPEAUcpu@@E@Z ENDP				; AND
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
A$ = 32
B$ = 33
C$ = 34
CarryTest$ = 36
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?adc@@YAEGPEAUcpu@@E@Z PROC				; adc

; 9    : {

$LN7:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 10   :     uint8 A = Cpu->A;

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001b	88 44 24 20	 mov	 BYTE PTR A$[rsp], al

; 11   :     uint8 B = readCpu8(Address, Cpu->MemoryOffset);

  0001f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00024	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00028	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0002d	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00032	88 44 24 21	 mov	 BYTE PTR B$[rsp], al

; 12   :     uint8 C = isBitSet(CARRY_BIT, Cpu->Flags);

  00036	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003b	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  0003f	b1 01		 mov	 cl, 1
  00041	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00046	88 44 24 22	 mov	 BYTE PTR C$[rsp], al

; 13   : 
; 14   :     Cpu->A = A + B + C;

  0004a	0f b6 44 24 20	 movzx	 eax, BYTE PTR A$[rsp]
  0004f	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR B$[rsp]
  00054	03 c1		 add	 eax, ecx
  00056	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR C$[rsp]
  0005b	03 c1		 add	 eax, ecx
  0005d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00062	88 01		 mov	 BYTE PTR [rcx], al

; 15   : 
; 16   :     uint16 CarryTest = (uint16)A + (uint16)B + (uint16)C;

  00064	0f b6 44 24 20	 movzx	 eax, BYTE PTR A$[rsp]
  00069	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR B$[rsp]
  0006e	03 c1		 add	 eax, ecx
  00070	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR C$[rsp]
  00075	03 c1		 add	 eax, ecx
  00077	66 89 44 24 24	 mov	 WORD PTR CarryTest$[rsp], ax

; 17   :     if(CarryTest > 0xFF)

  0007c	0f b7 44 24 24	 movzx	 eax, WORD PTR CarryTest$[rsp]
  00081	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00086	7e 13		 jle	 SHORT $LN2@adc

; 18   :         setCarry(&Cpu->Flags);

  00088	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0008d	48 83 c0 03	 add	 rax, 3
  00091	48 8b c8	 mov	 rcx, rax
  00094	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 19   :     else

  00099	eb 11		 jmp	 SHORT $LN3@adc
$LN2@adc:

; 20   :         clearCarry(&Cpu->Flags);

  0009b	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000a0	48 83 c0 03	 add	 rax, 3
  000a4	48 8b c8	 mov	 rcx, rax
  000a7	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN3@adc:

; 21   : 
; 22   :     // Overflow check, taken from the web. One day find out how this works
; 23   :     if(((A ^ B) & 0x80 == 0) && ((A ^ Cpu->A) & 0x80 != 0))

  000ac	0f b6 44 24 20	 movzx	 eax, BYTE PTR A$[rsp]
  000b1	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR B$[rsp]
  000b6	33 c1		 xor	 eax, ecx
  000b8	83 e0 00	 and	 eax, 0
  000bb	85 c0		 test	 eax, eax
  000bd	74 29		 je	 SHORT $LN4@adc
  000bf	0f b6 44 24 20	 movzx	 eax, BYTE PTR A$[rsp]
  000c4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  000c9	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000cc	33 c1		 xor	 eax, ecx
  000ce	83 e0 01	 and	 eax, 1
  000d1	85 c0		 test	 eax, eax
  000d3	74 13		 je	 SHORT $LN4@adc

; 24   :         setOverflow(&Cpu->Flags);

  000d5	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000da	48 83 c0 03	 add	 rax, 3
  000de	48 8b c8	 mov	 rcx, rax
  000e1	e8 00 00 00 00	 call	 ?setOverflow@@YAXPEAE@Z	; setOverflow

; 25   :     else

  000e6	eb 11		 jmp	 SHORT $LN5@adc
$LN4@adc:

; 26   :         clearOverflow(&Cpu->Flags);

  000e8	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000ed	48 83 c0 03	 add	 rax, 3
  000f1	48 8b c8	 mov	 rcx, rax
  000f4	e8 00 00 00 00	 call	 ?clearOverflow@@YAXPEAE@Z ; clearOverflow
$LN5@adc:

; 27   : 
; 28   :     setZero(Cpu->A, &Cpu->Flags);

  000f9	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000fe	48 83 c0 03	 add	 rax, 3
  00102	48 8b d0	 mov	 rdx, rax
  00105	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0010a	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0010d	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 29   :     setNegative(Cpu->A, &Cpu->Flags);

  00112	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00117	48 83 c0 03	 add	 rax, 3
  0011b	48 8b d0	 mov	 rdx, rax
  0011e	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00123	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00126	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 30   :     return(0);

  0012b	32 c0		 xor	 al, al

; 31   : }

  0012d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00131	c3		 ret	 0
?adc@@YAEGPEAUcpu@@E@Z ENDP				; adc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?crossedPageCheck@@YAHGG@Z
_TEXT	SEGMENT
tv69 = 0
Before$ = 32
Now$ = 40
?crossedPageCheck@@YAHGG@Z PROC				; crossedPageCheck, COMDAT

; 151  : inline bool32 crossedPageCheck(uint16 Before, uint16 Now) { return((Before & 0xFF00) != (Now & 0xFF00));}

$LN5:
  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 18	 sub	 rsp, 24
  0000e	0f b7 44 24 20	 movzx	 eax, WORD PTR Before$[rsp]
  00013	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00018	0f b7 4c 24 28	 movzx	 ecx, WORD PTR Now$[rsp]
  0001d	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00023	3b c1		 cmp	 eax, ecx
  00025	74 09		 je	 SHORT $LN3@crossedPag
  00027	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv69[rsp], 1
  0002e	eb 07		 jmp	 SHORT $LN4@crossedPag
$LN3@crossedPag:
  00030	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv69[rsp], 0
$LN4@crossedPag:
  00037	8b 04 24	 mov	 eax, DWORD PTR tv69[rsp]
  0003a	48 83 c4 18	 add	 rsp, 24
  0003e	c3		 ret	 0
?crossedPageCheck@@YAHGG@Z ENDP				; crossedPageCheck
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?isBitSet@@YAHEE@Z
_TEXT	SEGMENT
Bit$ = 8
Flags$ = 16
?isBitSet@@YAHEE@Z PROC					; isBitSet, COMDAT

; 150  : inline bool32 isBitSet(uint8 Bit, uint8 Flags) { return(Bit & Flags); }

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00008	0f b6 44 24 08	 movzx	 eax, BYTE PTR Bit$[rsp]
  0000d	0f b6 4c 24 10	 movzx	 ecx, BYTE PTR Flags$[rsp]
  00012	23 c1		 and	 eax, ecx
  00014	c3		 ret	 0
?isBitSet@@YAHEE@Z ENDP					; isBitSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setNegative@@YAXEPEAE@Z
_TEXT	SEGMENT
Value$ = 8
Flags$ = 16
?setNegative@@YAXEPEAE@Z PROC				; setNegative, COMDAT

; 144  : {  

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 145  :     if(Value >= 0x00 && Value <= 0x7F)

  00009	0f b6 44 24 08	 movzx	 eax, BYTE PTR Value$[rsp]
  0000e	85 c0		 test	 eax, eax
  00010	7c 1f		 jl	 SHORT $LN2@setNegativ
  00012	0f b6 44 24 08	 movzx	 eax, BYTE PTR Value$[rsp]
  00017	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  0001a	7f 15		 jg	 SHORT $LN2@setNegativ

; 146  :         *Flags = *Flags & ~NEGATIVE_BIT; // clear negative flag

  0001c	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  00021	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00024	0f ba f0 07	 btr	 eax, 7
  00028	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  0002d	88 01		 mov	 BYTE PTR [rcx], al

; 147  :     else

  0002f	eb 13		 jmp	 SHORT $LN3@setNegativ
$LN2@setNegativ:

; 148  :         *Flags = *Flags | NEGATIVE_BIT; // set negative flag

  00031	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  00036	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00039	0f ba e8 07	 bts	 eax, 7
  0003d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  00042	88 01		 mov	 BYTE PTR [rcx], al
$LN3@setNegativ:

; 149  : }

  00044	c3		 ret	 0
?setNegative@@YAXEPEAE@Z ENDP				; setNegative
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setZero@@YAXEPEAE@Z
_TEXT	SEGMENT
Value$ = 8
Flags$ = 16
?setZero@@YAXEPEAE@Z PROC				; setZero, COMDAT

; 137  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 138  :     if(Value == 0x00)

  00009	0f b6 44 24 08	 movzx	 eax, BYTE PTR Value$[rsp]
  0000e	85 c0		 test	 eax, eax
  00010	75 14		 jne	 SHORT $LN2@setZero

; 139  :         *Flags = *Flags | ZERO_BIT;

  00012	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  00017	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001a	83 c8 02	 or	 eax, 2
  0001d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  00022	88 01		 mov	 BYTE PTR [rcx], al

; 140  :     else

  00024	eb 12		 jmp	 SHORT $LN3@setZero
$LN2@setZero:

; 141  :         *Flags = *Flags & ~ZERO_BIT;

  00026	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  0002b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002e	83 e0 fd	 and	 eax, -3
  00031	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  00036	88 01		 mov	 BYTE PTR [rcx], al
$LN3@setZero:

; 142  : }

  00038	c3		 ret	 0
?setZero@@YAXEPEAE@Z ENDP				; setZero
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearOverflow@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearOverflow@@YAXPEAE@Z PROC				; clearOverflow, COMDAT

; 135  : inline void clearOverflow(uint8 *Flags) { *Flags = *Flags & ~OVERFLOW_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 bf	 and	 eax, -65		; ffffffffffffffbfH
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?clearOverflow@@YAXPEAE@Z ENDP				; clearOverflow
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setOverflow@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setOverflow@@YAXPEAE@Z PROC				; setOverflow, COMDAT

; 134  : inline void setOverflow(uint8 *Flags)   { *Flags = *Flags | OVERFLOW_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 40	 or	 eax, 64			; 00000040H
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?setOverflow@@YAXPEAE@Z ENDP				; setOverflow
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearBreak@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearBreak@@YAXPEAE@Z PROC				; clearBreak, COMDAT

; 133  : inline void clearBreak(uint8 *Flags)    { *Flags = *Flags & ~BREAK_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 ef	 and	 eax, -17
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?clearBreak@@YAXPEAE@Z ENDP				; clearBreak
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearDecimal@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearDecimal@@YAXPEAE@Z PROC				; clearDecimal, COMDAT

; 131  : inline void clearDecimal(uint8 *Flags)  { *Flags = *Flags & ~DECIMAL_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 f7	 and	 eax, -9
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?clearDecimal@@YAXPEAE@Z ENDP				; clearDecimal
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setDecimal@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setDecimal@@YAXPEAE@Z PROC				; setDecimal, COMDAT

; 130  : inline void setDecimal(uint8 *Flags)  { *Flags = *Flags | DECIMAL_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 08	 or	 eax, 8
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?setDecimal@@YAXPEAE@Z ENDP				; setDecimal
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearInterrupt@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearInterrupt@@YAXPEAE@Z PROC				; clearInterrupt, COMDAT

; 129  : inline void clearInterrupt(uint8 *Flags){ *Flags = *Flags & ~INTERRUPT_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 fb	 and	 eax, -5
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?clearInterrupt@@YAXPEAE@Z ENDP				; clearInterrupt
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setInterrupt@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setInterrupt@@YAXPEAE@Z PROC				; setInterrupt, COMDAT

; 128  : inline void setInterrupt(uint8 *Flags)  { *Flags = *Flags | INTERRUPT_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 04	 or	 eax, 4
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?setInterrupt@@YAXPEAE@Z ENDP				; setInterrupt
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearCarry@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearCarry@@YAXPEAE@Z PROC				; clearCarry, COMDAT

; 127  : inline void clearCarry(uint8 *Flags)    { *Flags = *Flags & ~CARRY_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 fe	 and	 eax, -2
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?clearCarry@@YAXPEAE@Z ENDP				; clearCarry
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setCarry@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setCarry@@YAXPEAE@Z PROC				; setCarry, COMDAT

; 126  : inline void setCarry(uint8 *Flags)      { *Flags = *Flags | CARRY_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 01	 or	 eax, 1
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?setCarry@@YAXPEAE@Z ENDP				; setCarry
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Value$ = 32
Cpu$ = 64
?pop@@YAEPEAUcpu@@@Z PROC				; pop

; 111  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 112  :     ++Cpu->StackPtr;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR Cpu$[rsp]
  0000e	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00012	fe c0		 inc	 al
  00014	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00019	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 113  :     uint8 Value = readCpu8((uint16)Cpu->StackPtr | STACK_ADDRESS, Cpu->MemoryOffset);

  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR Cpu$[rsp]
  00021	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00025	0f ba e8 08	 bts	 eax, 8
  00029	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0002e	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00032	0f b7 c8	 movzx	 ecx, ax
  00035	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  0003a	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 114  :     return(Value);

  0003e	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]

; 115  : }

  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	c3		 ret	 0
?pop@@YAEPEAUcpu@@@Z ENDP				; pop
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Byte$ = 48
Cpu$ = 56
?push@@YAXEPEAUcpu@@@Z PROC				; push

; 106  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 107  :     writeCpu8(Byte, (uint16)Cpu->StackPtr | STACK_ADDRESS, Cpu->MemoryOffset);

  0000d	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00012	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00016	0f ba e8 08	 bts	 eax, 8
  0001a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0001f	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  00023	0f b7 d0	 movzx	 edx, ax
  00026	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR Byte$[rsp]
  0002b	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEG_K@Z	; writeCpu8

; 108  :     --Cpu->StackPtr;  

  00030	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00035	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00039	fe c8		 dec	 al
  0003b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00040	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 109  : }

  00043	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00047	c3		 ret	 0
?push@@YAXEPEAUcpu@@@Z ENDP				; push
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
Byte2Adrs$ = 36
NewAddress$ = 40
Address$ = 64
MemoryOffset$ = 72
?bugReadCpu16@@YAGG_K@Z PROC				; bugReadCpu16

; 86   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 87   :     // NOTE: This is a bug in the nes 6502 that will wrap the value instead of going to new page.
; 88   :     //       Only happens with indirect addressing.
; 89   :     
; 90   :     uint8 LowByte = readCpu8(Address, MemoryOffset);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00013	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00018	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  0001d	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 91   :     uint16 Byte2Adrs = (Address & 0xFF00) | (uint16)((uint8)(Address + 1));

  00021	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00026	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  0002b	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00030	ff c1		 inc	 ecx
  00032	0f b6 c9	 movzx	 ecx, cl
  00035	0b c1		 or	 eax, ecx
  00037	66 89 44 24 24	 mov	 WORD PTR Byte2Adrs$[rsp], ax

; 92   :     uint8 HighByte = readCpu8(Byte2Adrs, MemoryOffset);

  0003c	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00041	0f b7 4c 24 24	 movzx	 ecx, WORD PTR Byte2Adrs$[rsp]
  00046	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  0004b	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 93   :         
; 94   :     uint16 NewAddress = (HighByte << 8) | LowByte;

  0004f	0f b6 44 24 20	 movzx	 eax, BYTE PTR HighByte$[rsp]
  00054	c1 e0 08	 shl	 eax, 8
  00057	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  0005c	0b c1		 or	 eax, ecx
  0005e	66 89 44 24 28	 mov	 WORD PTR NewAddress$[rsp], ax

; 95   :     return(NewAddress);

  00063	0f b7 44 24 28	 movzx	 eax, WORD PTR NewAddress$[rsp]

; 96   : }

  00068	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006c	c3		 ret	 0
?bugReadCpu16@@YAGG_K@Z ENDP				; bugReadCpu16
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
NewAddress$ = 36
Address$ = 64
MemoryOffset$ = 72
?readCpu16@@YAGG_K@Z PROC				; readCpu16

; 75   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 76   :     // NOTE: Little Endian
; 77   :     uint8 LowByte = readCpu8(Address, MemoryOffset);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00013	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00018	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  0001d	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 78   :     uint8 HighByte = readCpu8(Address+1, MemoryOffset);

  00021	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00026	ff c0		 inc	 eax
  00028	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0002d	0f b7 c8	 movzx	 ecx, ax
  00030	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00035	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 79   :         
; 80   :     uint16 NewAddress = (HighByte << 8) | LowByte;

  00039	0f b6 44 24 20	 movzx	 eax, BYTE PTR HighByte$[rsp]
  0003e	c1 e0 08	 shl	 eax, 8
  00041	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  00046	0b c1		 or	 eax, ecx
  00048	66 89 44 24 24	 mov	 WORD PTR NewAddress$[rsp], ax

; 81   :     return(NewAddress);

  0004d	0f b7 44 24 24	 movzx	 eax, WORD PTR NewAddress$[rsp]

; 82   : }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
?readCpu16@@YAGG_K@Z ENDP				; readCpu16
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Byte$ = 48
Address$ = 56
MemoryOffset$ = 64
?writeCpu8@@YAXEG_K@Z PROC				; writeCpu8

; 54   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 55   :     // NOTE: Mirrors the address for the 2kb ram 
; 56   :     if(0x800 <= Address && Address < 0x2000)

  00012	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00017	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  0001c	7c 26		 jl	 SHORT $LN2@writeCpu8
  0001e	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00023	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  00028	7d 1a		 jge	 SHORT $LN2@writeCpu8

; 57   :         Address = (Address % 0x800);

  0002a	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  0002f	99		 cdq
  00030	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  00036	03 c2		 add	 eax, edx
  00038	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0003d	2b c2		 sub	 eax, edx
  0003f	66 89 44 24 38	 mov	 WORD PTR Address$[rsp], ax
$LN2@writeCpu8:

; 58   :     // NOTE: Mirror for PPU Registers
; 59   :     if(0x2008 <= Address && Address < 0x4000)

  00044	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00049	3d 08 20 00 00	 cmp	 eax, 8200		; 00002008H
  0004e	7c 26		 jl	 SHORT $LN3@writeCpu8
  00050	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00055	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  0005a	7d 1a		 jge	 SHORT $LN3@writeCpu8

; 60   :         Address = (Address % (0x2008 - 0x2000)) + 0x2000;

  0005c	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00061	99		 cdq
  00062	83 e2 07	 and	 edx, 7
  00065	03 c2		 add	 eax, edx
  00067	83 e0 07	 and	 eax, 7
  0006a	2b c2		 sub	 eax, edx
  0006c	05 00 20 00 00	 add	 eax, 8192		; 00002000H
  00071	66 89 44 24 38	 mov	 WORD PTR Address$[rsp], ax
$LN3@writeCpu8:

; 61   :     if(0x8000 < Address || Address == 0x2002)

  00076	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  0007b	3d 00 80 00 00	 cmp	 eax, 32768		; 00008000H
  00080	7f 0c		 jg	 SHORT $LN5@writeCpu8
  00082	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00087	3d 02 20 00 00	 cmp	 eax, 8194		; 00002002H
  0008c	75 12		 jne	 SHORT $LN4@writeCpu8
$LN5@writeCpu8:

; 62   :         Assert(0); // TODO: Writing to Program ROM, bank switching?     

  0008e	33 c0		 xor	 eax, eax
  00090	83 f8 01	 cmp	 eax, 1
  00093	74 0b		 je	 SHORT $LN6@writeCpu8
  00095	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN6@writeCpu8:
$LN4@writeCpu8:

; 63   :     
; 64   :     write8(Byte, Address, MemoryOffset);

  000a0	4c 8b 44 24 40	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  000a5	0f b7 54 24 38	 movzx	 edx, WORD PTR Address$[rsp]
  000aa	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR Byte$[rsp]
  000af	e8 00 00 00 00	 call	 ?write8@@YAXEG_K@Z	; write8

; 65   :     
; 66   :     if(Address == 0x2005) // Scroll address

  000b4	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  000b9	3d 05 20 00 00	 cmp	 eax, 8197		; 00002005H
  000be	75 0a		 jne	 SHORT $LN7@writeCpu8

; 67   :         ScrollAdrsChange = true;

  000c0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?ScrollAdrsChange@@3HA, 1 ; ScrollAdrsChange
$LN7@writeCpu8:

; 68   :     if(Address == 0x2006) // Writing to ppu io address register

  000ca	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  000cf	3d 06 20 00 00	 cmp	 eax, 8198		; 00002006H
  000d4	75 0a		 jne	 SHORT $LN8@writeCpu8

; 69   :         VRamAdrsChange = true;

  000d6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?VRamAdrsChange@@3HA, 1 ; VRamAdrsChange
$LN8@writeCpu8:

; 70   :     if(Address == 0x2007) // Write to IO for ppu. Happens after two writes to 0x2006

  000e0	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  000e5	3d 07 20 00 00	 cmp	 eax, 8199		; 00002007H
  000ea	75 0a		 jne	 SHORT $LN9@writeCpu8

; 71   :         VRamIOChange = true;

  000ec	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?VRamIOChange@@3HA, 1 ; VRamIOChange
$LN9@writeCpu8:

; 72   : }

  000f6	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000fa	c3		 ret	 0
?writeCpu8@@YAXEG_K@Z ENDP				; writeCpu8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Value$ = 32
ResetValue$1 = 33
Address$ = 64
MemoryOffset$ = 72
?readCpu8@@YAEG_K@Z PROC				; readCpu8

; 27   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 28   :     // NOTE: Mirrors the address for the 2kb ram 
; 29   :     if(0x800 <= Address && Address < 0x2000)

  0000e	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00013	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  00018	7c 26		 jl	 SHORT $LN2@readCpu8
  0001a	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0001f	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  00024	7d 1a		 jge	 SHORT $LN2@readCpu8

; 30   :         Address = (Address % 0x800);

  00026	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0002b	99		 cdq
  0002c	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  00032	03 c2		 add	 eax, edx
  00034	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00039	2b c2		 sub	 eax, edx
  0003b	66 89 44 24 40	 mov	 WORD PTR Address$[rsp], ax
$LN2@readCpu8:

; 31   :     // NOTE: Mirror for PPU Registers
; 32   :     if(0x2008 <= Address && Address < 0x4000)

  00040	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00045	3d 08 20 00 00	 cmp	 eax, 8200		; 00002008H
  0004a	7c 26		 jl	 SHORT $LN3@readCpu8
  0004c	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00051	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  00056	7d 1a		 jge	 SHORT $LN3@readCpu8

; 33   :         Address = (Address % (0x2008 - 0x2000)) + 0x2000;

  00058	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0005d	99		 cdq
  0005e	83 e2 07	 and	 edx, 7
  00061	03 c2		 add	 eax, edx
  00063	83 e0 07	 and	 eax, 7
  00066	2b c2		 sub	 eax, edx
  00068	05 00 20 00 00	 add	 eax, 8192		; 00002000H
  0006d	66 89 44 24 40	 mov	 WORD PTR Address$[rsp], ax
$LN3@readCpu8:

; 34   :     
; 35   :     if(Address == 0x2007) // Reading from the IO of ppu. First read is junk, unless its the colour palette

  00072	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00077	3d 07 20 00 00	 cmp	 eax, 8199		; 00002007H
  0007c	75 0a		 jne	 SHORT $LN4@readCpu8

; 36   :         IOReadFromCpu = true;

  0007e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?IOReadFromCpu@@3HA, 1 ; IOReadFromCpu
$LN4@readCpu8:

; 37   :         
; 38   :     uint8 Value = read8(Address, MemoryOffset);

  00088	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0008d	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00092	e8 00 00 00 00	 call	 ?read8@@YAEG_K@Z	; read8
  00097	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 39   :             
; 40   :     if(Address == 0x2002)

  0009b	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  000a0	3d 02 20 00 00	 cmp	 eax, 8194		; 00002002H
  000a5	75 35		 jne	 SHORT $LN5@readCpu8

; 41   :     {
; 42   :         // NOTE: Will reset 2005 and 2006 registers, and turn off bit 7 of 0x2002
; 43   :         ResetScrollIOAdrs = true;

  000a7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?ResetScrollIOAdrs@@3HA, 1 ; ResetScrollIOAdrs

; 44   :         ResetVRamIOAdrs = true;

  000b1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?ResetVRamIOAdrs@@3HA, 1 ; ResetVRamIOAdrs

; 45   :         
; 46   :         uint8 ResetValue = Value & ~(1 << 7);

  000bb	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000c0	0f ba f0 07	 btr	 eax, 7
  000c4	88 44 24 21	 mov	 BYTE PTR ResetValue$1[rsp], al

; 47   :         write8(ResetValue, Address, MemoryOffset);

  000c8	4c 8b 44 24 48	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  000cd	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  000d2	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ResetValue$1[rsp]
  000d7	e8 00 00 00 00	 call	 ?write8@@YAXEG_K@Z	; write8
$LN5@readCpu8:

; 48   :     }
; 49   :     
; 50   :     return(Value);

  000dc	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]

; 51   : }

  000e1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e5	c3		 ret	 0
?readCpu8@@YAEG_K@Z ENDP				; readCpu8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Value$ = 0
NewAddress$ = 8
Address$ = 32
MemoryOffset$ = 40
?read8@@YAEG_K@Z PROC					; read8

; 248  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 249  :     uint8 *NewAddress = (uint8 *)(Address + MemoryOffset);

  0000e	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  00013	48 03 44 24 28	 add	 rax, QWORD PTR MemoryOffset$[rsp]
  00018	48 89 44 24 08	 mov	 QWORD PTR NewAddress$[rsp], rax

; 250  :     uint8 Value = *NewAddress;

  0001d	48 8b 44 24 08	 mov	 rax, QWORD PTR NewAddress$[rsp]
  00022	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00025	88 04 24	 mov	 BYTE PTR Value$[rsp], al

; 251  :     return(Value);

  00028	0f b6 04 24	 movzx	 eax, BYTE PTR Value$[rsp]

; 252  : }

  0002c	48 83 c4 18	 add	 rsp, 24
  00030	c3		 ret	 0
?read8@@YAEG_K@Z ENDP					; read8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
NewAddress$ = 0
Byte$ = 32
Address$ = 40
MemoryOffset$ = 48
?write8@@YAXEG_K@Z PROC					; write8

; 242  : {   

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	48 83 ec 18	 sub	 rsp, 24

; 243  :     uint8 *NewAddress = (uint8 *)(Address + MemoryOffset);

  00012	0f b7 44 24 28	 movzx	 eax, WORD PTR Address$[rsp]
  00017	48 03 44 24 30	 add	 rax, QWORD PTR MemoryOffset$[rsp]
  0001c	48 89 04 24	 mov	 QWORD PTR NewAddress$[rsp], rax

; 244  :     *NewAddress = Byte;

  00020	48 8b 04 24	 mov	 rax, QWORD PTR NewAddress$[rsp]
  00024	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Byte$[rsp]
  00029	88 08		 mov	 BYTE PTR [rax], cl

; 245  : }

  0002b	48 83 c4 18	 add	 rsp, 24
  0002f	c3		 ret	 0
?write8@@YAXEG_K@Z ENDP					; write8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Byte$1 = 0
Dest$ = 32
Src$ = 40
Size$ = 48
?cpyMem@@YAXPEAE0G@Z PROC				; cpyMem

; 235  : {

  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	48 83 ec 18	 sub	 rsp, 24

; 236  :     // NOTE: Very basic copy. Not bounds protection
; 237  :     for(uint16 Byte = 0; Byte < Size; ++Byte)

  00014	33 c0		 xor	 eax, eax
  00016	66 89 04 24	 mov	 WORD PTR Byte$1[rsp], ax
  0001a	eb 0b		 jmp	 SHORT $LN4@cpyMem
$LN2@cpyMem:
  0001c	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  00020	66 ff c0	 inc	 ax
  00023	66 89 04 24	 mov	 WORD PTR Byte$1[rsp], ax
$LN4@cpyMem:
  00027	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  0002b	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Size$[rsp]
  00030	3b c1		 cmp	 eax, ecx
  00032	7d 1c		 jge	 SHORT $LN3@cpyMem

; 238  :         Dest[Byte] = Src[Byte];

  00034	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  00038	0f b7 0c 24	 movzx	 ecx, WORD PTR Byte$1[rsp]
  0003c	48 8b 54 24 20	 mov	 rdx, QWORD PTR Dest$[rsp]
  00041	4c 8b 44 24 28	 mov	 r8, QWORD PTR Src$[rsp]
  00046	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0004b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0004e	eb cc		 jmp	 SHORT $LN2@cpyMem
$LN3@cpyMem:

; 239  : }

  00050	48 83 c4 18	 add	 rsp, 24
  00054	c3		 ret	 0
?cpyMem@@YAXPEAE0G@Z ENDP				; cpyMem
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
BytesRead$1 = 64
FileData$ = 72
FileHandle$ = 80
Filesize$2 = 88
Filename$ = 112
Size$ = 120
?LoadFile@@YAPEAXPEADPEAI@Z PROC			; LoadFile

; 194  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 195  :     void *FileData = 0;

  0000e	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR FileData$[rsp], 0

; 196  :     
; 197  :     HANDLE FileHandle = CreateFileA(Filename, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);

  00017	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00020	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00028	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  00030	45 33 c9	 xor	 r9d, r9d
  00033	41 b8 01 00 00
	00		 mov	 r8d, 1
  00039	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  0003e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Filename$[rsp]
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileA
  00049	48 89 44 24 50	 mov	 QWORD PTR FileHandle$[rsp], rax

; 198  :     if(FileHandle != INVALID_HANDLE_VALUE)

  0004e	48 83 7c 24 50
	ff		 cmp	 QWORD PTR FileHandle$[rsp], -1
  00054	0f 84 8d 00 00
	00		 je	 $LN2@LoadFile

; 199  :     {
; 200  :         LARGE_INTEGER Filesize;
; 201  :         if(GetFileSizeEx(FileHandle, &Filesize))

  0005a	48 8d 54 24 58	 lea	 rdx, QWORD PTR Filesize$2[rsp]
  0005f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR FileHandle$[rsp]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileSizeEx
  0006a	85 c0		 test	 eax, eax
  0006c	74 77		 je	 SHORT $LN4@LoadFile

; 202  :         {
; 203  :             FileData = VirtualAlloc(0, Filesize.LowPart, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);

  0006e	8b 44 24 58	 mov	 eax, DWORD PTR Filesize$2[rsp]
  00072	41 b9 04 00 00
	00		 mov	 r9d, 4
  00078	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  0007e	8b d0		 mov	 edx, eax
  00080	33 c9		 xor	 ecx, ecx
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  00088	48 89 44 24 48	 mov	 QWORD PTR FileData$[rsp], rax

; 204  :             if(FileData)

  0008d	48 83 7c 24 48
	00		 cmp	 QWORD PTR FileData$[rsp], 0
  00093	74 50		 je	 SHORT $LN6@LoadFile

; 205  :             {
; 206  :                 DWORD BytesRead;
; 207  :                 if(ReadFile(FileHandle, FileData, Filesize.LowPart, &BytesRead, 0) &&

  00095	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0009e	4c 8d 4c 24 40	 lea	 r9, QWORD PTR BytesRead$1[rsp]
  000a3	44 8b 44 24 58	 mov	 r8d, DWORD PTR Filesize$2[rsp]
  000a8	48 8b 54 24 48	 mov	 rdx, QWORD PTR FileData$[rsp]
  000ad	48 8b 4c 24 50	 mov	 rcx, QWORD PTR FileHandle$[rsp]
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReadFile
  000b8	85 c0		 test	 eax, eax
  000ba	74 17		 je	 SHORT $LN8@LoadFile
  000bc	8b 44 24 40	 mov	 eax, DWORD PTR BytesRead$1[rsp]
  000c0	39 44 24 58	 cmp	 DWORD PTR Filesize$2[rsp], eax
  000c4	75 0d		 jne	 SHORT $LN8@LoadFile

; 208  :                    (Filesize.LowPart == BytesRead))
; 209  :                 {
; 210  :                     *Size = (uint32)BytesRead;

  000c6	48 8b 44 24 78	 mov	 rax, QWORD PTR Size$[rsp]
  000cb	8b 4c 24 40	 mov	 ecx, DWORD PTR BytesRead$1[rsp]
  000cf	89 08		 mov	 DWORD PTR [rax], ecx

; 211  :                     // It worked!
; 212  :                 }
; 213  :                 else

  000d1	eb 12		 jmp	 SHORT $LN9@LoadFile
$LN8@LoadFile:

; 214  :                 {
; 215  :                     Assert(0);

  000d3	33 c0		 xor	 eax, eax
  000d5	83 f8 01	 cmp	 eax, 1
  000d8	74 0b		 je	 SHORT $LN10@LoadFile
  000da	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN10@LoadFile:
$LN9@LoadFile:
$LN6@LoadFile:
$LN4@LoadFile:

; 216  :                 }
; 217  :             }
; 218  :             else
; 219  :             {
; 220  :             }   
; 221  :         }
; 222  :         else
; 223  :         {
; 224  :         }
; 225  :     }
; 226  :     else

  000e5	eb 12		 jmp	 SHORT $LN3@LoadFile
$LN2@LoadFile:

; 227  :     {
; 228  :         Assert(0);

  000e7	33 c0		 xor	 eax, eax
  000e9	83 f8 01	 cmp	 eax, 1
  000ec	74 0b		 je	 SHORT $LN11@LoadFile
  000ee	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN11@LoadFile:
$LN3@LoadFile:

; 229  :     }
; 230  :     return(FileData);

  000f9	48 8b 44 24 48	 mov	 rax, QWORD PTR FileData$[rsp]

; 231  : }

  000fe	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00102	c3		 ret	 0
?LoadFile@@YAPEAXPEADPEAI@Z ENDP			; LoadFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
tv64 = 32
tv67 = 36
tv70 = 40
tv73 = 44
tv81 = 48
tv87 = 52
tv93 = 56
tv131 = 60
tv137 = 64
tv143 = 68
tv149 = 72
tv155 = 76
tv75 = 80
WasDown$1 = 88
IsDown$2 = 92
AltPressed$3 = 96
Result$ = 104
WindowHandle$ = 128
Message$ = 136
wParam$ = 144
lParam$ = 152
?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z PROC		; WinInputCallback

; 82   : {

$LN51:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 83   :     LRESULT Result = 0;

  00017	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR Result$[rsp], 0

; 84   :     
; 85   :     switch(Message) 

  00020	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR Message$[rsp]
  00027	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  0002b	83 7c 24 20 10	 cmp	 DWORD PTR tv64[rsp], 16
  00030	77 21		 ja	 SHORT $LN48@WinInputCa
  00032	83 7c 24 20 10	 cmp	 DWORD PTR tv64[rsp], 16
  00037	74 59		 je	 SHORT $LN8@WinInputCa
  00039	83 7c 24 20 01	 cmp	 DWORD PTR tv64[rsp], 1
  0003e	74 48		 je	 SHORT $LN6@WinInputCa
  00040	83 7c 24 20 02	 cmp	 DWORD PTR tv64[rsp], 2
  00045	74 5a		 je	 SHORT $LN9@WinInputCa
  00047	83 7c 24 20 05	 cmp	 DWORD PTR tv64[rsp], 5
  0004c	74 3f		 je	 SHORT $LN7@WinInputCa
  0004e	e9 6a 03 00 00	 jmp	 $LN24@WinInputCa
$LN48@WinInputCa:
  00053	81 7c 24 20 00
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 256 ; 00000100H
  0005b	0f 82 5c 03 00
	00		 jb	 $LN24@WinInputCa
  00061	81 7c 24 20 01
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 257 ; 00000101H
  00069	76 3b		 jbe	 SHORT $LN10@WinInputCa
  0006b	81 7c 24 20 03
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 259 ; 00000103H
  00073	0f 86 44 03 00
	00		 jbe	 $LN24@WinInputCa
  00079	81 7c 24 20 05
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 261 ; 00000105H
  00081	76 23		 jbe	 SHORT $LN10@WinInputCa
  00083	e9 35 03 00 00	 jmp	 $LN24@WinInputCa
$LN6@WinInputCa:

; 86   :     { 
; 87   :         case WM_CREATE:
; 88   :         {
; 89   :             // Initialize the window. 
; 90   :             break; 

  00088	e9 5a 03 00 00	 jmp	 $LN2@WinInputCa
$LN7@WinInputCa:

; 91   :         }
; 92   :         
; 93   :         case WM_SIZE:
; 94   :         {
; 95   :             // Set the size and position of the window. 
; 96   :             break;

  0008d	e9 55 03 00 00	 jmp	 $LN2@WinInputCa
$LN8@WinInputCa:

; 97   :         }
; 98   :         case WM_CLOSE:
; 99   :         {
; 100  :             GlobalRunning = false;

  00092	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0

; 101  :             break;

  0009c	e9 46 03 00 00	 jmp	 $LN2@WinInputCa
$LN9@WinInputCa:

; 102  :         }
; 103  :         case WM_DESTROY:
; 104  :         {
; 105  :             break;

  000a1	e9 41 03 00 00	 jmp	 $LN2@WinInputCa
$LN10@WinInputCa:

; 106  :         }
; 107  :         case WM_SYSKEYDOWN:
; 108  :         case WM_SYSKEYUP:
; 109  :         case WM_KEYDOWN:
; 110  :         case WM_KEYUP:
; 111  :         {
; 112  :             bool32 IsDown = ((lParam & (1<<31)) == 0);

  000a6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR lParam$[rsp]
  000ae	48 25 00 00 00
	80		 and	 rax, -2147483648	; ffffffff80000000H
  000b4	48 85 c0	 test	 rax, rax
  000b7	75 0a		 jne	 SHORT $LN26@WinInputCa
  000b9	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  000c1	eb 08		 jmp	 SHORT $LN27@WinInputCa
$LN26@WinInputCa:
  000c3	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN27@WinInputCa:
  000cb	8b 44 24 24	 mov	 eax, DWORD PTR tv67[rsp]
  000cf	89 44 24 5c	 mov	 DWORD PTR IsDown$2[rsp], eax

; 113  :             bool32 WasDown = ((lParam & (1<<30)) != 0);

  000d3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR lParam$[rsp]
  000db	48 25 00 00 00
	40		 and	 rax, 1073741824		; 40000000H
  000e1	48 85 c0	 test	 rax, rax
  000e4	74 0a		 je	 SHORT $LN28@WinInputCa
  000e6	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  000ee	eb 08		 jmp	 SHORT $LN29@WinInputCa
$LN28@WinInputCa:
  000f0	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN29@WinInputCa:
  000f8	8b 44 24 28	 mov	 eax, DWORD PTR tv70[rsp]
  000fc	89 44 24 58	 mov	 DWORD PTR WasDown$1[rsp], eax

; 114  : 
; 115  :             // NOTE: Alt only on SYSDOWN messages
; 116  :             bool32 AltPressed = ((lParam & (1<<29)) != 0);

  00100	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR lParam$[rsp]
  00108	48 25 00 00 00
	20		 and	 rax, 536870912		; 20000000H
  0010e	48 85 c0	 test	 rax, rax
  00111	74 0a		 je	 SHORT $LN30@WinInputCa
  00113	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  0011b	eb 08		 jmp	 SHORT $LN31@WinInputCa
$LN30@WinInputCa:
  0011d	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN31@WinInputCa:
  00125	8b 44 24 2c	 mov	 eax, DWORD PTR tv73[rsp]
  00129	89 44 24 60	 mov	 DWORD PTR AltPressed$3[rsp], eax

; 117  :               
; 118  :             if(IsDown != WasDown)

  0012d	8b 44 24 58	 mov	 eax, DWORD PTR WasDown$1[rsp]
  00131	39 44 24 5c	 cmp	 DWORD PTR IsDown$2[rsp], eax
  00135	0f 84 80 02 00
	00		 je	 $LN11@WinInputCa

; 119  :             {               
; 120  :                 switch(wParam)

  0013b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR wParam$[rsp]
  00143	48 89 44 24 50	 mov	 QWORD PTR tv75[rsp], rax
  00148	48 8b 44 24 50	 mov	 rax, QWORD PTR tv75[rsp]
  0014d	48 83 e8 0d	 sub	 rax, 13
  00151	48 89 44 24 50	 mov	 QWORD PTR tv75[rsp], rax
  00156	48 83 7c 24 50
	66		 cmp	 QWORD PTR tv75[rsp], 102 ; 00000066H
  0015c	0f 87 59 02 00
	00		 ja	 $LN4@WinInputCa
  00162	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:__ImageBase
  00169	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv75[rsp]
  0016e	0f b6 8c 08 00
	00 00 00	 movzx	 ecx, BYTE PTR $LN49@WinInputCa[rax+rcx]
  00176	8b 8c 88 00 00
	00 00		 mov	 ecx, DWORD PTR $LN50@WinInputCa[rax+rcx*4]
  0017d	48 03 c8	 add	 rcx, rax
  00180	ff e1		 jmp	 rcx
$LN12@WinInputCa:

; 121  :                 {
; 122  :                     // NOTE: Up and down changes the octave the keys are in
; 123  :                     case VK_UP:
; 124  :                     {
; 125  :                         WinInput.buttons[input::B_UP] = !WinInput.buttons[input::B_UP];

  00182	b8 04 00 00 00	 mov	 eax, 4
  00187	48 6b c0 04	 imul	 rax, rax, 4
  0018b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00192	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  00196	75 0a		 jne	 SHORT $LN32@WinInputCa
  00198	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  001a0	eb 08		 jmp	 SHORT $LN33@WinInputCa
$LN32@WinInputCa:
  001a2	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN33@WinInputCa:
  001aa	b8 04 00 00 00	 mov	 eax, 4
  001af	48 6b c0 04	 imul	 rax, rax, 4
  001b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  001ba	8b 54 24 30	 mov	 edx, DWORD PTR tv81[rsp]
  001be	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 126  :                         break;

  001c1	e9 f5 01 00 00	 jmp	 $LN4@WinInputCa
$LN13@WinInputCa:

; 127  :                     }
; 128  :                     case VK_DOWN:
; 129  :                     {
; 130  :                         WinInput.buttons[input::B_DOWN] = !WinInput.buttons[input::B_DOWN];

  001c6	b8 04 00 00 00	 mov	 eax, 4
  001cb	48 6b c0 05	 imul	 rax, rax, 5
  001cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  001d6	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  001da	75 0a		 jne	 SHORT $LN34@WinInputCa
  001dc	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv87[rsp], 1
  001e4	eb 08		 jmp	 SHORT $LN35@WinInputCa
$LN34@WinInputCa:
  001e6	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
$LN35@WinInputCa:
  001ee	b8 04 00 00 00	 mov	 eax, 4
  001f3	48 6b c0 05	 imul	 rax, rax, 5
  001f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  001fe	8b 54 24 34	 mov	 edx, DWORD PTR tv87[rsp]
  00202	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 131  :                         break;

  00205	e9 b1 01 00 00	 jmp	 $LN4@WinInputCa
$LN14@WinInputCa:

; 132  :                     }
; 133  :                     case VK_LEFT:
; 134  :                     {
; 135  :                         WinInput.buttons[input::B_LEFT] = !WinInput.buttons[input::B_LEFT];

  0020a	b8 04 00 00 00	 mov	 eax, 4
  0020f	48 6b c0 06	 imul	 rax, rax, 6
  00213	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0021a	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  0021e	75 0a		 jne	 SHORT $LN36@WinInputCa
  00220	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  00228	eb 08		 jmp	 SHORT $LN37@WinInputCa
$LN36@WinInputCa:
  0022a	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN37@WinInputCa:
  00232	b8 04 00 00 00	 mov	 eax, 4
  00237	48 6b c0 06	 imul	 rax, rax, 6
  0023b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00242	8b 54 24 38	 mov	 edx, DWORD PTR tv93[rsp]
  00246	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 136  :                         break;

  00249	e9 6d 01 00 00	 jmp	 $LN4@WinInputCa
$LN15@WinInputCa:

; 137  :                     }
; 138  :                     case VK_RIGHT:
; 139  :                     {
; 140  :                         WinInput.buttons[input::B_RIGHT] = !WinInput.buttons[input::B_RIGHT];

  0024e	b8 04 00 00 00	 mov	 eax, 4
  00253	48 6b c0 07	 imul	 rax, rax, 7
  00257	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0025e	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  00262	75 0a		 jne	 SHORT $LN38@WinInputCa
  00264	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  0026c	eb 08		 jmp	 SHORT $LN39@WinInputCa
$LN38@WinInputCa:
  0026e	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN39@WinInputCa:
  00276	b8 04 00 00 00	 mov	 eax, 4
  0027b	48 6b c0 07	 imul	 rax, rax, 7
  0027f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00286	8b 54 24 3c	 mov	 edx, DWORD PTR tv131[rsp]
  0028a	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 141  :                         break;

  0028d	e9 29 01 00 00	 jmp	 $LN4@WinInputCa
$LN16@WinInputCa:

; 142  :                     }
; 143  :                     case 'Z':
; 144  :                     {
; 145  :                         WinInput.buttons[input::B_A] = !WinInput.buttons[input::B_A];

  00292	b8 04 00 00 00	 mov	 eax, 4
  00297	48 6b c0 00	 imul	 rax, rax, 0
  0029b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  002a2	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  002a6	75 0a		 jne	 SHORT $LN40@WinInputCa
  002a8	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv137[rsp], 1
  002b0	eb 08		 jmp	 SHORT $LN41@WinInputCa
$LN40@WinInputCa:
  002b2	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN41@WinInputCa:
  002ba	b8 04 00 00 00	 mov	 eax, 4
  002bf	48 6b c0 00	 imul	 rax, rax, 0
  002c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  002ca	8b 54 24 40	 mov	 edx, DWORD PTR tv137[rsp]
  002ce	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 146  :                         break;

  002d1	e9 e5 00 00 00	 jmp	 $LN4@WinInputCa
$LN17@WinInputCa:

; 147  :                     }
; 148  :                     case 'X':
; 149  :                     {
; 150  :                         WinInput.buttons[input::B_B] = !WinInput.buttons[input::B_B];

  002d6	b8 04 00 00 00	 mov	 eax, 4
  002db	48 6b c0 01	 imul	 rax, rax, 1
  002df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  002e6	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  002ea	75 0a		 jne	 SHORT $LN42@WinInputCa
  002ec	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv143[rsp], 1
  002f4	eb 08		 jmp	 SHORT $LN43@WinInputCa
$LN42@WinInputCa:
  002f6	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv143[rsp], 0
$LN43@WinInputCa:
  002fe	b8 04 00 00 00	 mov	 eax, 4
  00303	48 6b c0 01	 imul	 rax, rax, 1
  00307	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0030e	8b 54 24 44	 mov	 edx, DWORD PTR tv143[rsp]
  00312	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 151  :                         break;

  00315	e9 a1 00 00 00	 jmp	 $LN4@WinInputCa
$LN18@WinInputCa:

; 152  :                     }
; 153  :                     case VK_RETURN:
; 154  :                     {
; 155  :                         WinInput.buttons[input::B_START] = !WinInput.buttons[input::B_START];

  0031a	b8 04 00 00 00	 mov	 eax, 4
  0031f	48 6b c0 03	 imul	 rax, rax, 3
  00323	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0032a	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  0032e	75 0a		 jne	 SHORT $LN44@WinInputCa
  00330	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv149[rsp], 1
  00338	eb 08		 jmp	 SHORT $LN45@WinInputCa
$LN44@WinInputCa:
  0033a	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
$LN45@WinInputCa:
  00342	b8 04 00 00 00	 mov	 eax, 4
  00347	48 6b c0 03	 imul	 rax, rax, 3
  0034b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00352	8b 54 24 48	 mov	 edx, DWORD PTR tv149[rsp]
  00356	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 156  :                         break;

  00359	eb 60		 jmp	 SHORT $LN4@WinInputCa
$LN19@WinInputCa:

; 157  :                     }
; 158  :                     case VK_SHIFT:
; 159  :                     {
; 160  :                         WinInput.buttons[input::B_SELECT] = !WinInput.buttons[input::B_SELECT];

  0035b	b8 04 00 00 00	 mov	 eax, 4
  00360	48 6b c0 02	 imul	 rax, rax, 2
  00364	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0036b	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  0036f	75 0a		 jne	 SHORT $LN46@WinInputCa
  00371	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv155[rsp], 1
  00379	eb 08		 jmp	 SHORT $LN47@WinInputCa
$LN46@WinInputCa:
  0037b	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv155[rsp], 0
$LN47@WinInputCa:
  00383	b8 04 00 00 00	 mov	 eax, 4
  00388	48 6b c0 02	 imul	 rax, rax, 2
  0038c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00393	8b 54 24 4c	 mov	 edx, DWORD PTR tv155[rsp]
  00397	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 161  :                         break;

  0039a	eb 1f		 jmp	 SHORT $LN4@WinInputCa

; 162  :                     }
; 163  :                     case VK_SPACE:
; 164  :                     {
; 165  :                         
; 166  :                         break;

  0039c	eb 1d		 jmp	 SHORT $LN4@WinInputCa
$LN21@WinInputCa:

; 167  :                     }
; 168  :                     case VK_ESCAPE:
; 169  :                     {
; 170  :                         GlobalRunning = false;

  0039e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0

; 171  :                         break;

  003a8	eb 11		 jmp	 SHORT $LN4@WinInputCa
$LN22@WinInputCa:

; 172  :                     }
; 173  :                     case VK_F4:
; 174  :                     {
; 175  :                         if(AltPressed)

  003aa	83 7c 24 60 00	 cmp	 DWORD PTR AltPressed$3[rsp], 0
  003af	74 0a		 je	 SHORT $LN23@WinInputCa

; 176  :                         {
; 177  :                             GlobalRunning = false;

  003b1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0
$LN23@WinInputCa:
$LN4@WinInputCa:
$LN11@WinInputCa:

; 178  :                         }
; 179  :                         break;
; 180  :                     }
; 181  :                 }
; 182  :             }
; 183  :             break;

  003bb	eb 2a		 jmp	 SHORT $LN2@WinInputCa
$LN24@WinInputCa:

; 184  :         }            
; 185  :         default:
; 186  :         {
; 187  :             Result = DefWindowProc(WindowHandle, Message, wParam, lParam); 

  003bd	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR lParam$[rsp]
  003c5	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR wParam$[rsp]
  003cd	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR Message$[rsp]
  003d4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR WindowHandle$[rsp]
  003dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DefWindowProcA
  003e2	48 89 44 24 68	 mov	 QWORD PTR Result$[rsp], rax
$LN2@WinInputCa:

; 188  :         }
; 189  :     }
; 190  :     return Result;

  003e7	48 8b 44 24 68	 mov	 rax, QWORD PTR Result$[rsp]

; 191  : }

  003ec	48 83 c4 78	 add	 rsp, 120		; 00000078H
  003f0	c3		 ret	 0
  003f1	0f 1f 00	 npad	 3
$LN50@WinInputCa:
  003f4	00 00 00 00	 DD	 $LN18@WinInputCa
  003f8	00 00 00 00	 DD	 $LN19@WinInputCa
  003fc	00 00 00 00	 DD	 $LN21@WinInputCa
  00400	00 00 00 00	 DD	 $LN14@WinInputCa
  00404	00 00 00 00	 DD	 $LN12@WinInputCa
  00408	00 00 00 00	 DD	 $LN15@WinInputCa
  0040c	00 00 00 00	 DD	 $LN13@WinInputCa
  00410	00 00 00 00	 DD	 $LN17@WinInputCa
  00414	00 00 00 00	 DD	 $LN16@WinInputCa
  00418	00 00 00 00	 DD	 $LN22@WinInputCa
  0041c	00 00 00 00	 DD	 $LN4@WinInputCa
$LN49@WinInputCa:
  00420	00		 DB	 0
  00421	0a		 DB	 10
  00422	0a		 DB	 10
  00423	01		 DB	 1
  00424	0a		 DB	 10
  00425	0a		 DB	 10
  00426	0a		 DB	 10
  00427	0a		 DB	 10
  00428	0a		 DB	 10
  00429	0a		 DB	 10
  0042a	0a		 DB	 10
  0042b	0a		 DB	 10
  0042c	0a		 DB	 10
  0042d	0a		 DB	 10
  0042e	02		 DB	 2
  0042f	0a		 DB	 10
  00430	0a		 DB	 10
  00431	0a		 DB	 10
  00432	0a		 DB	 10
  00433	0a		 DB	 10
  00434	0a		 DB	 10
  00435	0a		 DB	 10
  00436	0a		 DB	 10
  00437	0a		 DB	 10
  00438	03		 DB	 3
  00439	04		 DB	 4
  0043a	05		 DB	 5
  0043b	06		 DB	 6
  0043c	0a		 DB	 10
  0043d	0a		 DB	 10
  0043e	0a		 DB	 10
  0043f	0a		 DB	 10
  00440	0a		 DB	 10
  00441	0a		 DB	 10
  00442	0a		 DB	 10
  00443	0a		 DB	 10
  00444	0a		 DB	 10
  00445	0a		 DB	 10
  00446	0a		 DB	 10
  00447	0a		 DB	 10
  00448	0a		 DB	 10
  00449	0a		 DB	 10
  0044a	0a		 DB	 10
  0044b	0a		 DB	 10
  0044c	0a		 DB	 10
  0044d	0a		 DB	 10
  0044e	0a		 DB	 10
  0044f	0a		 DB	 10
  00450	0a		 DB	 10
  00451	0a		 DB	 10
  00452	0a		 DB	 10
  00453	0a		 DB	 10
  00454	0a		 DB	 10
  00455	0a		 DB	 10
  00456	0a		 DB	 10
  00457	0a		 DB	 10
  00458	0a		 DB	 10
  00459	0a		 DB	 10
  0045a	0a		 DB	 10
  0045b	0a		 DB	 10
  0045c	0a		 DB	 10
  0045d	0a		 DB	 10
  0045e	0a		 DB	 10
  0045f	0a		 DB	 10
  00460	0a		 DB	 10
  00461	0a		 DB	 10
  00462	0a		 DB	 10
  00463	0a		 DB	 10
  00464	0a		 DB	 10
  00465	0a		 DB	 10
  00466	0a		 DB	 10
  00467	0a		 DB	 10
  00468	0a		 DB	 10
  00469	0a		 DB	 10
  0046a	0a		 DB	 10
  0046b	07		 DB	 7
  0046c	0a		 DB	 10
  0046d	08		 DB	 8
  0046e	0a		 DB	 10
  0046f	0a		 DB	 10
  00470	0a		 DB	 10
  00471	0a		 DB	 10
  00472	0a		 DB	 10
  00473	0a		 DB	 10
  00474	0a		 DB	 10
  00475	0a		 DB	 10
  00476	0a		 DB	 10
  00477	0a		 DB	 10
  00478	0a		 DB	 10
  00479	0a		 DB	 10
  0047a	0a		 DB	 10
  0047b	0a		 DB	 10
  0047c	0a		 DB	 10
  0047d	0a		 DB	 10
  0047e	0a		 DB	 10
  0047f	0a		 DB	 10
  00480	0a		 DB	 10
  00481	0a		 DB	 10
  00482	0a		 DB	 10
  00483	0a		 DB	 10
  00484	0a		 DB	 10
  00485	0a		 DB	 10
  00486	09		 DB	 9
?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z ENDP		; WinInputCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
MSElapsed$ = 32
Counter$ = 40
CounterElapsed$ = 48
PerfCountFrequency$ = 80
?getMilliSeconds@@YAM_K@Z PROC				; getMilliSeconds

; 69   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 70   :     LARGE_INTEGER Counter;
; 71   :     QueryPerformanceCounter(&Counter);

  00009	48 8d 4c 24 28	 lea	 rcx, QWORD PTR Counter$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_QueryPerformanceCounter

; 72   :     
; 73   :     uint64 CounterElapsed = Counter.QuadPart;

  00014	48 8b 44 24 28	 mov	 rax, QWORD PTR Counter$[rsp]
  00019	48 89 44 24 30	 mov	 QWORD PTR CounterElapsed$[rsp], rax

; 74   :     real32 MSElapsed = ((1000.0f * (real32)CounterElapsed) / (real32)PerfCountFrequency);

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR CounterElapsed$[rsp]
  00023	f3 48 0f 2a c0	 cvtsi2ss xmm0, rax
  00028	48 85 c0	 test	 rax, rax
  0002b	7d 08		 jge	 SHORT $LN4@getMilliSe
  0002d	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@5f800000
$LN4@getMilliSe:
  00035	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@447a0000
  0003d	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00041	0f 28 c1	 movaps	 xmm0, xmm1
  00044	48 8b 44 24 50	 mov	 rax, QWORD PTR PerfCountFrequency$[rsp]
  00049	f3 48 0f 2a c8	 cvtsi2ss xmm1, rax
  0004e	48 85 c0	 test	 rax, rax
  00051	7d 08		 jge	 SHORT $LN3@getMilliSe
  00053	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@5f800000
$LN3@getMilliSe:
  0005b	f3 0f 5e c1	 divss	 xmm0, xmm1
  0005f	f3 0f 11 44 24
	20		 movss	 DWORD PTR MSElapsed$[rsp], xmm0

; 75   : 
; 76   :     return(MSElapsed);

  00065	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR MSElapsed$[rsp]

; 77   : }

  0006b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006f	c3		 ret	 0
?getMilliSeconds@@YAM_K@Z ENDP				; getMilliSeconds
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  00018	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  0001d	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00022	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00027	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0002c	45 33 c0	 xor	 r8d, r8d
  0002f	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00039	e8 00 00 00 00	 call	 _vsprintf_l
  0003e	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

  00042	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

  0004b	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1788 : }

  0004f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00053	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00027	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  0002c	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00038	e8 00 00 00 00	 call	 _vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 83 c8 01	 or	 rax, 1
  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00029	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00033	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00038	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003d	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00047	48 8b c8	 mov	 rcx, rax
  0004a	e8 00 00 00 00	 call	 __stdio_common_vsprintf
  0004f	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00053	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00058	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005a	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00062	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00064	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  00068	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006c	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1391 : }

  00070	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00074	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File u:\programs\visual studio\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 81   :     static unsigned __int64 _OptionsStorage;
; 82   :     return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 83   : }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
CpuCyclesElapsed$1 = 96
i$2 = 97
Flags6$ = 98
RomPrgBankCount$ = 99
MapperNumber$ = 100
ResScale$ = 101
Flags7$ = 102
RomChrBankCount$ = 103
WindowHeight$ = 104
WindowWidth$ = 108
MemPrgBank1$ = 112
MemPrgBank2$ = 116
RenderScaleHeight$ = 120
RenderScaleWidth$ = 124
RomData$ = 128
RomPrgRamSize$ = 136
Flags9$ = 137
Flags10$ = 138
InitialWindowPosY$ = 140
InitialWindowPosX$ = 144
ElapsedMS$3 = 148
CpuCyclesPerMS$4 = 152
CurrentMS$5 = 156
PrevMS$6 = 160
tv194 = 164
RomPrgData$ = 168
Window$7 = 176
tv192 = 184
CpuClockRateHz$8 = 188
PpuMemorySize$ = 192
CpuMemorySize$ = 196
TotalMemorySize$ = 200
Memory$ = 208
DeviceContext$9 = 216
PerfCountFrequency$ = 224
FileSize$ = 232
FramesPerSecond$10 = 236
Filename$ = 240
RomChrData$ = 248
WinPerfCountFrequency$ = 256
Ppu$ = 264
WindowClass$ = 304
Message$11 = 384
Cpu$ = 432
ScreenBackBuffer$ = 448
Buffer$12 = 528
__$ArrayPad$ = 536
WindowInstance$ = 560
PrevWindowInstance$ = 568
CommandLine$ = 576
CommandShow$ = 584
WinMain	PROC

; 322  : {

$LN39:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 20 02
	00 00		 sub	 rsp, 544		; 00000220H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 18
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 323  :     // TODO: I could reduce the memory usage as the nes does not actually use 64 kbs,
; 324  :     //       the nes mirrors certain sections of address space
; 325  :     uint32 CpuMemorySize = Kilobytes(64);

  0002e	c7 84 24 c4 00
	00 00 00 00 01
	00		 mov	 DWORD PTR CpuMemorySize$[rsp], 65536 ; 00010000H

; 326  :     uint32 PpuMemorySize = Kilobytes(64);

  00039	c7 84 24 c0 00
	00 00 00 00 01
	00		 mov	 DWORD PTR PpuMemorySize$[rsp], 65536 ; 00010000H

; 327  :     uint32 TotalMemorySize = CpuMemorySize + PpuMemorySize;

  00044	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR PpuMemorySize$[rsp]
  0004b	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR CpuMemorySize$[rsp]
  00052	03 c8		 add	 ecx, eax
  00054	8b c1		 mov	 eax, ecx
  00056	89 84 24 c8 00
	00 00		 mov	 DWORD PTR TotalMemorySize$[rsp], eax

; 328  : 
; 329  :     // NOTE: Aiming to have one memory allocation for the whole program.
; 330  :     // TODO: Loading the cartridge also creates memory. Figure out to include in this call.
; 331  :     uint8 * Memory = (uint8 *)VirtualAlloc(0, (size_t)TotalMemorySize, MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);

  0005d	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR TotalMemorySize$[rsp]
  00064	41 b9 04 00 00
	00		 mov	 r9d, 4
  0006a	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  00070	8b d0		 mov	 edx, eax
  00072	33 c9		 xor	 ecx, ecx
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  0007a	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR Memory$[rsp], rax

; 332  : 
; 333  :     cpu Cpu = {};

  00082	48 8d 84 24 b0
	01 00 00	 lea	 rax, QWORD PTR Cpu$[rsp]
  0008a	48 8b f8	 mov	 rdi, rax
  0008d	33 c0		 xor	 eax, eax
  0008f	b9 10 00 00 00	 mov	 ecx, 16
  00094	f3 aa		 rep stosb

; 334  :     Cpu.MemoryOffset = (uint64)Memory; 

  00096	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR Memory$[rsp]
  0009e	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR Cpu$[rsp+8], rax

; 335  :     
; 336  :     ppu Ppu = {};    

  000a6	48 8d 84 24 08
	01 00 00	 lea	 rax, QWORD PTR Ppu$[rsp]
  000ae	48 8b f8	 mov	 rdi, rax
  000b1	33 c0		 xor	 eax, eax
  000b3	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  000b8	f3 aa		 rep stosb

; 337  :     Ppu.MemoryOffset = (uint64)Memory + Kilobytes(64);

  000ba	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR Memory$[rsp]
  000c2	48 05 00 00 01
	00		 add	 rax, 65536		; 00010000H
  000c8	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR Ppu$[rsp+8], rax

; 338  :       
; 339  : #define PPU_REG_ADRS 0x2000    
; 340  :     Ppu.Registers = (ppu_registers *)(Cpu.MemoryOffset + PPU_REG_ADRS);

  000d0	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp+8]
  000d8	48 05 00 20 00
	00		 add	 rax, 8192		; 00002000H
  000de	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR Ppu$[rsp], rax

; 341  :     //Ppu.Registers->Status = (1 << 7) | (1 << 5); // TODO: Pull out into the PPU? An initalilising function? 
; 342  :     
; 343  :     Ppu.Scanline = 261; // Start here as its prerender line

  000e6	b8 05 01 00 00	 mov	 eax, 261		; 00000105H
  000eb	66 89 84 24 18
	01 00 00	 mov	 WORD PTR Ppu$[rsp+16], ax

; 344  :     
; 345  :     // Reading rom file
; 346  :     char * Filename = "nestest.nes";

  000f3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88992
  000fa	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR Filename$[rsp], rax

; 347  :     uint32 FileSize;
; 348  :     uint8 *RomData = (uint8 *)LoadFile(Filename, &FileSize);

  00102	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR FileSize$[rsp]
  0010a	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR Filename$[rsp]
  00112	e8 00 00 00 00	 call	 ?LoadFile@@YAPEAXPEADPEAI@Z ; LoadFile
  00117	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR RomData$[rsp], rax

; 349  : 
; 350  :     // NOTE: Check for correct header
; 351  :     if(RomData[0] != 'N' || RomData[1] != 'E' || RomData[2] != 'S')

  0011f	b8 01 00 00 00	 mov	 eax, 1
  00124	48 6b c0 00	 imul	 rax, rax, 0
  00128	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR RomData$[rsp]
  00130	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00134	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  00137	75 34		 jne	 SHORT $LN14@WinMain
  00139	b8 01 00 00 00	 mov	 eax, 1
  0013e	48 6b c0 01	 imul	 rax, rax, 1
  00142	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR RomData$[rsp]
  0014a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0014e	83 f8 45	 cmp	 eax, 69			; 00000045H
  00151	75 1a		 jne	 SHORT $LN14@WinMain
  00153	b8 01 00 00 00	 mov	 eax, 1
  00158	48 6b c0 02	 imul	 rax, rax, 2
  0015c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR RomData$[rsp]
  00164	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00168	83 f8 53	 cmp	 eax, 83			; 00000053H
  0016b	74 12		 je	 SHORT $LN13@WinMain
$LN14@WinMain:

; 352  :     {
; 353  :         Assert(0);   

  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 01	 cmp	 eax, 1
  00172	74 0b		 je	 SHORT $LN15@WinMain
  00174	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN15@WinMain:
$LN13@WinMain:

; 354  :     }
; 355  : 
; 356  :     // NOTE: Read header
; 357  :     uint8 RomPrgBankCount = RomData[4];

  0017f	b8 01 00 00 00	 mov	 eax, 1
  00184	48 6b c0 04	 imul	 rax, rax, 4
  00188	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR RomData$[rsp]
  00190	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00194	88 44 24 63	 mov	 BYTE PTR RomPrgBankCount$[rsp], al

; 358  :     uint8 RomChrBankCount = RomData[5];

  00198	b8 01 00 00 00	 mov	 eax, 1
  0019d	48 6b c0 05	 imul	 rax, rax, 5
  001a1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR RomData$[rsp]
  001a9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ad	88 44 24 67	 mov	 BYTE PTR RomChrBankCount$[rsp], al

; 359  : 
; 360  :     uint8 Flags6 = RomData[6];

  001b1	b8 01 00 00 00	 mov	 eax, 1
  001b6	48 6b c0 06	 imul	 rax, rax, 6
  001ba	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR RomData$[rsp]
  001c2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c6	88 44 24 62	 mov	 BYTE PTR Flags6$[rsp], al

; 361  :     uint8 Flags7 = RomData[7];

  001ca	b8 01 00 00 00	 mov	 eax, 1
  001cf	48 6b c0 07	 imul	 rax, rax, 7
  001d3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR RomData$[rsp]
  001db	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001df	88 44 24 66	 mov	 BYTE PTR Flags7$[rsp], al

; 362  : 
; 363  :     uint8 RomPrgRamSize = RomData[8];

  001e3	b8 01 00 00 00	 mov	 eax, 1
  001e8	48 6b c0 08	 imul	 rax, rax, 8
  001ec	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR RomData$[rsp]
  001f4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f8	88 84 24 88 00
	00 00		 mov	 BYTE PTR RomPrgRamSize$[rsp], al

; 364  :     uint8 Flags9 = RomData[9];

  001ff	b8 01 00 00 00	 mov	 eax, 1
  00204	48 6b c0 09	 imul	 rax, rax, 9
  00208	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR RomData$[rsp]
  00210	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00214	88 84 24 89 00
	00 00		 mov	 BYTE PTR Flags9$[rsp], al

; 365  :     uint8 Flags10 = RomData[10];

  0021b	b8 01 00 00 00	 mov	 eax, 1
  00220	48 6b c0 0a	 imul	 rax, rax, 10
  00224	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR RomData$[rsp]
  0022c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00230	88 84 24 8a 00
	00 00		 mov	 BYTE PTR Flags10$[rsp], al

; 366  : 
; 367  :     uint8 *RomPrgData;
; 368  :     // NOTE: If trainer present. Data after header and before program data
; 369  :     if(Flags6 & (1 << 2))

  00237	0f b6 44 24 62	 movzx	 eax, BYTE PTR Flags6$[rsp]
  0023c	83 e0 04	 and	 eax, 4
  0023f	85 c0		 test	 eax, eax
  00241	74 14		 je	 SHORT $LN16@WinMain

; 370  :     {
; 371  :         Assert(0); 

  00243	33 c0		 xor	 eax, eax
  00245	83 f8 01	 cmp	 eax, 1
  00248	74 0b		 je	 SHORT $LN18@WinMain
  0024a	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN18@WinMain:

; 372  :     }
; 373  :     else

  00255	eb 14		 jmp	 SHORT $LN17@WinMain
$LN16@WinMain:

; 374  :     {
; 375  :         RomPrgData = RomData + 16;

  00257	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR RomData$[rsp]
  0025f	48 83 c0 10	 add	 rax, 16
  00263	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR RomPrgData$[rsp], rax
$LN17@WinMain:

; 376  :     }
; 377  : 
; 378  :     uint8 *RomChrData = RomPrgData + (RomPrgBankCount * Kilobytes(16));

  0026b	0f b6 44 24 63	 movzx	 eax, BYTE PTR RomPrgBankCount$[rsp]
  00270	48 69 c0 00 40
	00 00		 imul	 rax, rax, 16384		; 00004000H
  00277	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR RomPrgData$[rsp]
  0027f	48 03 c8	 add	 rcx, rax
  00282	48 8b c1	 mov	 rax, rcx
  00285	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR RomChrData$[rsp], rax

; 379  :     // TODO: Implement Playchoice roms 
; 380  : 
; 381  : 
; 382  : 
; 383  : // NOTE: This is the two banks of memory that are currently loaded
; 384  : //       The mapper number will specify which initial banks are loaded
; 385  : //       Program will then change these banks while running.
; 386  : //       These pointers reference the rom memory.
; 387  : //       Offset is required to make relative to memory mapped address    
; 388  : 
; 389  :     
; 390  :     // TODO: Mappers
; 391  :     // NOTE: MY UNDERSTANDING OF HOW BANK REGISTERS WORK (SO FAR)
; 392  :     //
; 393  :     //       This is for M001. 
; 394  :     //       On the catridge, 4 registers are stored, each is 5 bits wide
; 395  :     //       These registers cannot be accessed directly, but can be set.
; 396  :     //       To set, writing to the prg rom 5 times will save the value.
; 397  :     //       To select the register to write too, the fifth write will be
; 398  :     //       to one of the prg banks. Only the fifth write will write to the specified
; 399  :     //       bank. If you write to 0x8000 4 times, then 0xE000 the fifth, only
; 400  :     //       0xE000 register will be written too. 0xE004 counts as 0xE000, and 0x8001
; 401  :     //       counts as 0x8000
; 402  :     //       There is a temporary port too
; 403  :     //       This is a byte with a reset bit and the bit just entered.
; 404  :     //       If reset is hit, then bit entered, plus temporary reg is cleared.
; 405  :     //       If 5 bits enter through port, then reg is saved
; 406  : 
; 407  :     // TODO: This will change as I add program mappers 
; 408  :     uint16 MemPrgBank1 = 0x8000;

  0028d	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00292	66 89 44 24 70	 mov	 WORD PTR MemPrgBank1$[rsp], ax

; 409  :     uint16 MemPrgBank2 = 0xC000;

  00297	b8 00 c0 00 00	 mov	 eax, 49152		; 0000c000H
  0029c	66 89 44 24 74	 mov	 WORD PTR MemPrgBank2$[rsp], ax

; 410  :     
; 411  :     uint8 MapperNumber = (Flags7 & 0xF0) | (Flags6 >> 4);

  002a1	0f b6 44 24 66	 movzx	 eax, BYTE PTR Flags7$[rsp]
  002a6	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  002ab	0f b6 4c 24 62	 movzx	 ecx, BYTE PTR Flags6$[rsp]
  002b0	c1 f9 04	 sar	 ecx, 4
  002b3	0b c1		 or	 eax, ecx
  002b5	88 44 24 64	 mov	 BYTE PTR MapperNumber$[rsp], al

; 412  :     switch(MapperNumber)

  002b9	0f b6 44 24 64	 movzx	 eax, BYTE PTR MapperNumber$[rsp]
  002be	88 84 24 b8 00
	00 00		 mov	 BYTE PTR tv192[rsp], al
  002c5	80 bc 24 b8 00
	00 00 00	 cmp	 BYTE PTR tv192[rsp], 0
  002cd	74 05		 je	 SHORT $LN19@WinMain
  002cf	e9 cb 00 00 00	 jmp	 $LN24@WinMain
$LN19@WinMain:

; 413  :     {
; 414  :         case 0:
; 415  :         {
; 416  :             switch(RomPrgBankCount)

  002d4	0f b6 44 24 63	 movzx	 eax, BYTE PTR RomPrgBankCount$[rsp]
  002d9	88 84 24 a4 00
	00 00		 mov	 BYTE PTR tv194[rsp], al
  002e0	80 bc 24 a4 00
	00 00 01	 cmp	 BYTE PTR tv194[rsp], 1
  002e8	74 0f		 je	 SHORT $LN20@WinMain
  002ea	80 bc 24 a4 00
	00 00 02	 cmp	 BYTE PTR tv194[rsp], 2
  002f2	74 4b		 je	 SHORT $LN21@WinMain
  002f4	e9 92 00 00 00	 jmp	 $LN22@WinMain
$LN20@WinMain:

; 417  :             {
; 418  :                 case 1:
; 419  :                 {
; 420  :                     cpyMem((uint8 *)MemPrgBank1 + Cpu.MemoryOffset, RomPrgData, Kilobytes(16));

  002f9	0f b7 44 24 70	 movzx	 eax, WORD PTR MemPrgBank1$[rsp]
  002fe	48 03 84 24 b8
	01 00 00	 add	 rax, QWORD PTR Cpu$[rsp+8]
  00306	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  0030b	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR RomPrgData$[rsp]
  00313	48 8b c8	 mov	 rcx, rax
  00316	e8 00 00 00 00	 call	 ?cpyMem@@YAXPEAE0G@Z	; cpyMem

; 421  :                     cpyMem((uint8 *)MemPrgBank2 + Cpu.MemoryOffset, RomPrgData, Kilobytes(16));

  0031b	0f b7 44 24 74	 movzx	 eax, WORD PTR MemPrgBank2$[rsp]
  00320	48 03 84 24 b8
	01 00 00	 add	 rax, QWORD PTR Cpu$[rsp+8]
  00328	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  0032d	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR RomPrgData$[rsp]
  00335	48 8b c8	 mov	 rcx, rax
  00338	e8 00 00 00 00	 call	 ?cpyMem@@YAXPEAE0G@Z	; cpyMem

; 422  :                     break;

  0033d	eb 5e		 jmp	 SHORT $LN4@WinMain
$LN21@WinMain:

; 423  :                 }
; 424  :                 case 2:
; 425  :                 {
; 426  :                     cpyMem((uint8 *)MemPrgBank1 + Cpu.MemoryOffset, RomPrgData, Kilobytes(16));

  0033f	0f b7 44 24 70	 movzx	 eax, WORD PTR MemPrgBank1$[rsp]
  00344	48 03 84 24 b8
	01 00 00	 add	 rax, QWORD PTR Cpu$[rsp+8]
  0034c	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  00351	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR RomPrgData$[rsp]
  00359	48 8b c8	 mov	 rcx, rax
  0035c	e8 00 00 00 00	 call	 ?cpyMem@@YAXPEAE0G@Z	; cpyMem

; 427  :                     cpyMem((uint8 *)MemPrgBank2 + Cpu.MemoryOffset, RomPrgData + Kilobytes(16), Kilobytes(16));

  00361	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR RomPrgData$[rsp]
  00369	48 05 00 40 00
	00		 add	 rax, 16384		; 00004000H
  0036f	0f b7 4c 24 74	 movzx	 ecx, WORD PTR MemPrgBank2$[rsp]
  00374	48 03 8c 24 b8
	01 00 00	 add	 rcx, QWORD PTR Cpu$[rsp+8]
  0037c	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  00381	48 8b d0	 mov	 rdx, rax
  00384	e8 00 00 00 00	 call	 ?cpyMem@@YAXPEAE0G@Z	; cpyMem

; 428  :                     break;

  00389	eb 12		 jmp	 SHORT $LN4@WinMain
$LN22@WinMain:

; 429  :                 }
; 430  :                 default:
; 431  :                 {
; 432  :                     Assert(0);

  0038b	33 c0		 xor	 eax, eax
  0038d	83 f8 01	 cmp	 eax, 1
  00390	74 0b		 je	 SHORT $LN23@WinMain
  00392	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN23@WinMain:
$LN4@WinMain:

; 433  :                     break;
; 434  :                 }
; 435  :             }
; 436  :             break;

  0039d	eb 3c		 jmp	 SHORT $LN2@WinMain
$LN24@WinMain:

; 437  :         }
; 438  :         
; 439  :         default:
; 440  :         {
; 441  :             char Buffer[8];
; 442  :             sprintf(Buffer, "Error: Unknown mapper number = %d\n", MapperNumber);

  0039f	0f b6 44 24 64	 movzx	 eax, BYTE PTR MapperNumber$[rsp]
  003a4	44 8b c0	 mov	 r8d, eax
  003a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG89005
  003ae	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR Buffer$12[rsp]
  003b6	e8 00 00 00 00	 call	 sprintf

; 443  :             OutputDebugString(Buffer);

  003bb	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR Buffer$12[rsp]
  003c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 444  :             Assert(0);

  003c9	33 c0		 xor	 eax, eax
  003cb	83 f8 01	 cmp	 eax, 1
  003ce	74 0b		 je	 SHORT $LN25@WinMain
  003d0	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN25@WinMain:
$LN2@WinMain:

; 445  :             break;
; 446  :         }
; 447  :     }
; 448  : 
; 449  : 
; 450  :     // NOTE: Map CHR Data to Ppu // TODO: Will change when Mapper Numbers are introduced
; 451  :     if(RomChrBankCount == 1)

  003db	0f b6 44 24 67	 movzx	 eax, BYTE PTR RomChrBankCount$[rsp]
  003e0	83 f8 01	 cmp	 eax, 1
  003e3	75 1a		 jne	 SHORT $LN26@WinMain

; 452  :     {
; 453  :         cpyMem((uint8 *)Ppu.MemoryOffset, RomChrData, Kilobytes(8));

  003e5	66 41 b8 00 20	 mov	 r8w, 8192		; 00002000H
  003ea	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR RomChrData$[rsp]
  003f2	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp+8]
  003fa	e8 00 00 00 00	 call	 ?cpyMem@@YAXPEAE0G@Z	; cpyMem
$LN26@WinMain:

; 454  :     }
; 455  :     
; 456  :     
; 457  :     // NOTE: Load the program counter with the reset vector
; 458  :     Cpu.PrgCounter = readCpu16(RESET_VEC, Cpu.MemoryOffset);

  003ff	48 8b 94 24 b8
	01 00 00	 mov	 rdx, QWORD PTR Cpu$[rsp+8]
  00407	66 b9 fc ff	 mov	 cx, 65532		; 0000fffcH
  0040b	e8 00 00 00 00	 call	 ?readCpu16@@YAGG_K@Z	; readCpu16
  00410	66 89 84 24 b6
	01 00 00	 mov	 WORD PTR Cpu$[rsp+6], ax

; 459  :     
; 460  :     // Screen back buffer creation
; 461  :     uint16 RenderScaleWidth = 256, RenderScaleHeight = 240;

  00418	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  0041d	66 89 44 24 7c	 mov	 WORD PTR RenderScaleWidth$[rsp], ax
  00422	b8 f0 00 00 00	 mov	 eax, 240		; 000000f0H
  00427	66 89 44 24 78	 mov	 WORD PTR RenderScaleHeight$[rsp], ax

; 462  :     uint8 ResScale = 5;

  0042c	c6 44 24 65 05	 mov	 BYTE PTR ResScale$[rsp], 5

; 463  :     uint16 WindowWidth = RenderScaleWidth * ResScale, WindowHeight = RenderScaleHeight * ResScale;

  00431	0f b7 44 24 7c	 movzx	 eax, WORD PTR RenderScaleWidth$[rsp]
  00436	0f b6 4c 24 65	 movzx	 ecx, BYTE PTR ResScale$[rsp]
  0043b	0f af c1	 imul	 eax, ecx
  0043e	66 89 44 24 6c	 mov	 WORD PTR WindowWidth$[rsp], ax
  00443	0f b7 44 24 78	 movzx	 eax, WORD PTR RenderScaleHeight$[rsp]
  00448	0f b6 4c 24 65	 movzx	 ecx, BYTE PTR ResScale$[rsp]
  0044d	0f af c1	 imul	 eax, ecx
  00450	66 89 44 24 68	 mov	 WORD PTR WindowHeight$[rsp], ax

; 464  :     screen_buffer ScreenBackBuffer = {};

  00455	48 8d 84 24 c0
	01 00 00	 lea	 rax, QWORD PTR ScreenBackBuffer$[rsp]
  0045d	48 8b f8	 mov	 rdi, rax
  00460	33 c0		 xor	 eax, eax
  00462	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00467	f3 aa		 rep stosb

; 465  :     createBackBuffer(&ScreenBackBuffer, RenderScaleWidth, RenderScaleHeight);

  00469	44 0f b7 44 24
	78		 movzx	 r8d, WORD PTR RenderScaleHeight$[rsp]
  0046f	0f b7 54 24 7c	 movzx	 edx, WORD PTR RenderScaleWidth$[rsp]
  00474	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR ScreenBackBuffer$[rsp]
  0047c	e8 00 00 00 00	 call	 ?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z ; createBackBuffer

; 466  : 
; 467  :     Ppu.BasePixel = (uint32 *)ScreenBackBuffer.Memory;

  00481	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR ScreenBackBuffer$[rsp+48]
  00489	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR Ppu$[rsp+24], rax

; 468  :     
; 469  :     // NOTE: Window Creation
; 470  :     WNDCLASSA WindowClass = {};

  00491	48 8d 84 24 30
	01 00 00	 lea	 rax, QWORD PTR WindowClass$[rsp]
  00499	48 8b f8	 mov	 rdi, rax
  0049c	33 c0		 xor	 eax, eax
  0049e	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  004a3	f3 aa		 rep stosb

; 471  :     WindowClass.style = CS_HREDRAW | CS_VREDRAW;

  004a5	c7 84 24 30 01
	00 00 03 00 00
	00		 mov	 DWORD PTR WindowClass$[rsp], 3

; 472  :     WindowClass.lpfnWndProc = WinInputCallback;

  004b0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z ; WinInputCallback
  004b7	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR WindowClass$[rsp+8], rax

; 473  :     WindowClass.hInstance = WindowInstance;

  004bf	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR WindowInstance$[rsp]
  004c7	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR WindowClass$[rsp+24], rax

; 474  :     WindowClass.lpszClassName = "NesEmu";

  004cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG89008
  004d6	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR WindowClass$[rsp+64], rax

; 475  : 
; 476  :     LARGE_INTEGER WinPerfCountFrequency;
; 477  :     QueryPerformanceFrequency(&WinPerfCountFrequency); 

  004de	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR WinPerfCountFrequency$[rsp]
  004e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_QueryPerformanceFrequency

; 478  :     uint64 PerfCountFrequency = WinPerfCountFrequency.QuadPart;            

  004ec	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR WinPerfCountFrequency$[rsp]
  004f4	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR PerfCountFrequency$[rsp], rax

; 479  : 
; 480  :     uint16 InitialWindowPosX = 0;

  004fc	33 c0		 xor	 eax, eax
  004fe	66 89 84 24 90
	00 00 00	 mov	 WORD PTR InitialWindowPosX$[rsp], ax

; 481  :     uint16 InitialWindowPosY = 0;

  00506	33 c0		 xor	 eax, eax
  00508	66 89 84 24 8c
	00 00 00	 mov	 WORD PTR InitialWindowPosY$[rsp], ax

; 482  :     
; 483  :     if(RegisterClassA(&WindowClass))

  00510	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR WindowClass$[rsp]
  00518	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegisterClassA
  0051e	0f b7 c0	 movzx	 eax, ax
  00521	85 c0		 test	 eax, eax
  00523	0f 84 e0 02 00
	00		 je	 $LN27@WinMain

; 484  :     {
; 485  :         HWND Window = CreateWindowExA(0, WindowClass.lpszClassName, "NesEmu",

  00529	0f b7 44 24 68	 movzx	 eax, WORD PTR WindowHeight$[rsp]
  0052e	0f b7 4c 24 6c	 movzx	 ecx, WORD PTR WindowWidth$[rsp]
  00533	0f b7 94 24 8c
	00 00 00	 movzx	 edx, WORD PTR InitialWindowPosY$[rsp]
  0053b	0f b7 bc 24 90
	00 00 00	 movzx	 edi, WORD PTR InitialWindowPosX$[rsp]
  00543	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR [rsp+88], 0
  0054c	4c 8b 84 24 30
	02 00 00	 mov	 r8, QWORD PTR WindowInstance$[rsp]
  00554	4c 89 44 24 50	 mov	 QWORD PTR [rsp+80], r8
  00559	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  00562	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  0056b	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0056f	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  00573	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  00577	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  0057b	41 b9 00 00 cf
	10		 mov	 r9d, 282001408		; 10cf0000H
  00581	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG89011
  00588	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR WindowClass$[rsp+64]
  00590	33 c9		 xor	 ecx, ecx
  00592	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateWindowExA
  00598	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR Window$7[rsp], rax

; 486  :                                       WS_OVERLAPPEDWINDOW|WS_VISIBLE,
; 487  :                                       InitialWindowPosX, InitialWindowPosY,
; 488  :                                       WindowWidth, WindowHeight,
; 489  :                                       0, 0, WindowInstance, 0);
; 490  :         if(Window) // If window was created successfully

  005a0	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR Window$7[rsp], 0
  005a9	0f 84 46 02 00
	00		 je	 $LN29@WinMain

; 491  :         {
; 492  :             
; 493  :             real32 FramesPerSecond = 60.0;

  005af	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42700000
  005b7	f3 0f 11 84 24
	ec 00 00 00	 movss	 DWORD PTR FramesPerSecond$10[rsp], xmm0

; 494  :             real32 CpuClockRateHz = 1789772.727272728;

  005c0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@49da7a66
  005c8	f3 0f 11 84 24
	bc 00 00 00	 movss	 DWORD PTR CpuClockRateHz$8[rsp], xmm0

; 495  :             real32 CpuCyclesPerMS = CpuClockRateHz / 1000.0;

  005d1	f3 0f 5a 84 24
	bc 00 00 00	 cvtss2sd xmm0, DWORD PTR CpuClockRateHz$8[rsp]
  005da	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@408f400000000000
  005e2	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  005e6	f3 0f 11 84 24
	98 00 00 00	 movss	 DWORD PTR CpuCyclesPerMS$4[rsp], xmm0

; 496  :        
; 497  :             uint8 CpuCyclesElapsed = 0;

  005ef	c6 44 24 60 00	 mov	 BYTE PTR CpuCyclesElapsed$1[rsp], 0

; 498  : 
; 499  :             real32 ElapsedMS = 0;

  005f4	0f 57 c0	 xorps	 xmm0, xmm0
  005f7	f3 0f 11 84 24
	94 00 00 00	 movss	 DWORD PTR ElapsedMS$3[rsp], xmm0

; 500  :             real32 CurrentMS, PrevMS = getMilliSeconds(PerfCountFrequency);

  00600	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR PerfCountFrequency$[rsp]
  00608	e8 00 00 00 00	 call	 ?getMilliSeconds@@YAM_K@Z ; getMilliSeconds
  0060d	f3 0f 11 84 24
	a0 00 00 00	 movss	 DWORD PTR PrevMS$6[rsp], xmm0

; 501  : 
; 502  :             GlobalRunning = true; 

  00616	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 1
$LN6@WinMain:

; 503  :             while(GlobalRunning)

  00620	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?GlobalRunning@@3HA, 0
  00627	0f 84 c6 01 00
	00		 je	 $LN7@WinMain

; 504  :             {
; 505  :                 if(ElapsedMS < 1)

  0062d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00635	0f 2f 84 24 94
	00 00 00	 comiss	 xmm0, DWORD PTR ElapsedMS$3[rsp]
  0063d	0f 86 3a 01 00
	00		 jbe	 $LN31@WinMain

; 506  :                 {
; 507  :                     MSG Message = {}; 

  00643	48 8d 84 24 80
	01 00 00	 lea	 rax, QWORD PTR Message$11[rsp]
  0064b	48 8b f8	 mov	 rdi, rax
  0064e	33 c0		 xor	 eax, eax
  00650	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00655	f3 aa		 rep stosb
$LN8@WinMain:

; 508  :                     while (PeekMessage(&Message, Window, 0, 0, PM_REMOVE))

  00657	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0065f	45 33 c9	 xor	 r9d, r9d
  00662	45 33 c0	 xor	 r8d, r8d
  00665	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR Window$7[rsp]
  0066d	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Message$11[rsp]
  00675	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PeekMessageA
  0067b	85 c0		 test	 eax, eax
  0067d	74 1e		 je	 SHORT $LN9@WinMain

; 509  :                     {
; 510  :                         TranslateMessage(&Message);

  0067f	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Message$11[rsp]
  00687	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TranslateMessage

; 511  :                         DispatchMessage(&Message);

  0068d	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Message$11[rsp]
  00695	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DispatchMessageA

; 512  :                     }

  0069b	eb ba		 jmp	 SHORT $LN8@WinMain
$LN9@WinMain:

; 513  :                 
; 514  :                     if(CpuCyclesElapsed < CpuCyclesPerMS)

  0069d	0f b6 44 24 60	 movzx	 eax, BYTE PTR CpuCyclesElapsed$1[rsp]
  006a2	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  006a6	f3 0f 10 8c 24
	98 00 00 00	 movss	 xmm1, DWORD PTR CpuCyclesPerMS$4[rsp]
  006af	0f 2f c8	 comiss	 xmm1, xmm0
  006b2	76 50		 jbe	 SHORT $LN33@WinMain

; 515  :                     {
; 516  :                         CpuCyclesElapsed += cpuTick(&Cpu);

  006b4	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR Cpu$[rsp]
  006bc	e8 00 00 00 00	 call	 ?cpuTick@@YAEPEAUcpu@@@Z ; cpuTick
  006c1	0f b6 c0	 movzx	 eax, al
  006c4	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR CpuCyclesElapsed$1[rsp]
  006c9	03 c8		 add	 ecx, eax
  006cb	8b c1		 mov	 eax, ecx
  006cd	88 44 24 60	 mov	 BYTE PTR CpuCyclesElapsed$1[rsp], al

; 517  :                     
; 518  :                         for(uint8 i = 0; i < 3; ++i)

  006d1	c6 44 24 61 00	 mov	 BYTE PTR i$2[rsp], 0
  006d6	eb 0b		 jmp	 SHORT $LN12@WinMain
$LN10@WinMain:
  006d8	0f b6 44 24 61	 movzx	 eax, BYTE PTR i$2[rsp]
  006dd	fe c0		 inc	 al
  006df	88 44 24 61	 mov	 BYTE PTR i$2[rsp], al
$LN12@WinMain:
  006e3	0f b6 44 24 61	 movzx	 eax, BYTE PTR i$2[rsp]
  006e8	83 f8 03	 cmp	 eax, 3
  006eb	7d 17		 jge	 SHORT $LN11@WinMain

; 519  :                         {
; 520  :                             ppuTick(&ScreenBackBuffer, &Ppu);

  006ed	48 8d 94 24 08
	01 00 00	 lea	 rdx, QWORD PTR Ppu$[rsp]
  006f5	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR ScreenBackBuffer$[rsp]
  006fd	e8 00 00 00 00	 call	 ?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z ; ppuTick

; 521  :                         }

  00702	eb d4		 jmp	 SHORT $LN10@WinMain
$LN11@WinMain:
$LN33@WinMain:

; 522  :                     }
; 523  :                     else
; 524  :                     {
; 525  :                         //   Sleep(1);
; 526  :                     }
; 527  : 
; 528  :                     if(DrawScreen)

  00704	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DrawScreen@@3HA, 0 ; DrawScreen
  0070b	74 6e		 je	 SHORT $LN35@WinMain

; 529  :                     {
; 530  :                         DrawScreen = false; 

  0070d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?DrawScreen@@3HA, 0 ; DrawScreen

; 531  :                         getWindowSize(Window, &WindowWidth, &WindowHeight);

  00717	4c 8d 44 24 68	 lea	 r8, QWORD PTR WindowHeight$[rsp]
  0071c	48 8d 54 24 6c	 lea	 rdx, QWORD PTR WindowWidth$[rsp]
  00721	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR Window$7[rsp]
  00729	e8 00 00 00 00	 call	 ?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z ; getWindowSize

; 532  :                 
; 533  :                         // NOTE: Drawing the backbuffer to the window 
; 534  :                         HDC DeviceContext = GetDC(Window);

  0072e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR Window$7[rsp]
  00736	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetDC
  0073c	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR DeviceContext$9[rsp], rax

; 535  :                         drawScreenBuffer(&ScreenBackBuffer, DeviceContext,

  00744	44 0f b7 4c 24
	68		 movzx	 r9d, WORD PTR WindowHeight$[rsp]
  0074a	44 0f b7 44 24
	6c		 movzx	 r8d, WORD PTR WindowWidth$[rsp]
  00750	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR DeviceContext$9[rsp]
  00758	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR ScreenBackBuffer$[rsp]
  00760	e8 00 00 00 00	 call	 ?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z ; drawScreenBuffer

; 536  :                                          WindowWidth, WindowHeight);
; 537  :                         ReleaseDC(Window, DeviceContext);

  00765	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR DeviceContext$9[rsp]
  0076d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR Window$7[rsp]
  00775	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReleaseDC
$LN35@WinMain:

; 538  :                     }
; 539  :                 }
; 540  :                 else

  0077b	eb 2e		 jmp	 SHORT $LN32@WinMain
$LN31@WinMain:

; 541  :                 {
; 542  :                     ElapsedMS = 0;

  0077d	0f 57 c0	 xorps	 xmm0, xmm0
  00780	f3 0f 11 84 24
	94 00 00 00	 movss	 DWORD PTR ElapsedMS$3[rsp], xmm0

; 543  :                     CpuCyclesElapsed = CpuCyclesPerMS - CpuCyclesElapsed;

  00789	0f b6 44 24 60	 movzx	 eax, BYTE PTR CpuCyclesElapsed$1[rsp]
  0078e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00792	f3 0f 10 8c 24
	98 00 00 00	 movss	 xmm1, DWORD PTR CpuCyclesPerMS$4[rsp]
  0079b	f3 0f 5c c8	 subss	 xmm1, xmm0
  0079f	0f 28 c1	 movaps	 xmm0, xmm1
  007a2	f3 48 0f 2c c0	 cvttss2si rax, xmm0
  007a7	88 44 24 60	 mov	 BYTE PTR CpuCyclesElapsed$1[rsp], al
$LN32@WinMain:

; 544  :                 }
; 545  :                 
; 546  :                 
; 547  :                 CurrentMS = getMilliSeconds(PerfCountFrequency);

  007ab	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR PerfCountFrequency$[rsp]
  007b3	e8 00 00 00 00	 call	 ?getMilliSeconds@@YAM_K@Z ; getMilliSeconds
  007b8	f3 0f 11 84 24
	9c 00 00 00	 movss	 DWORD PTR CurrentMS$5[rsp], xmm0

; 548  :                 ElapsedMS = CurrentMS - PrevMS;

  007c1	f3 0f 10 84 24
	9c 00 00 00	 movss	 xmm0, DWORD PTR CurrentMS$5[rsp]
  007ca	f3 0f 5c 84 24
	a0 00 00 00	 subss	 xmm0, DWORD PTR PrevMS$6[rsp]
  007d3	f3 0f 11 84 24
	94 00 00 00	 movss	 DWORD PTR ElapsedMS$3[rsp], xmm0

; 549  :                 PrevMS = CurrentMS;

  007dc	f3 0f 10 84 24
	9c 00 00 00	 movss	 xmm0, DWORD PTR CurrentMS$5[rsp]
  007e5	f3 0f 11 84 24
	a0 00 00 00	 movss	 DWORD PTR PrevMS$6[rsp], xmm0

; 550  :             }

  007ee	e9 2d fe ff ff	 jmp	 $LN6@WinMain
$LN7@WinMain:

; 551  :         }
; 552  :         else

  007f3	eb 12		 jmp	 SHORT $LN30@WinMain
$LN29@WinMain:

; 553  :         {
; 554  :             Assert(0);

  007f5	33 c0		 xor	 eax, eax
  007f7	83 f8 01	 cmp	 eax, 1
  007fa	74 0b		 je	 SHORT $LN36@WinMain
  007fc	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN36@WinMain:
$LN30@WinMain:

; 555  :         }
; 556  :     }
; 557  :     else

  00807	eb 12		 jmp	 SHORT $LN28@WinMain
$LN27@WinMain:

; 558  :     {
; 559  :         Assert(0);

  00809	33 c0		 xor	 eax, eax
  0080b	83 f8 01	 cmp	 eax, 1
  0080e	74 0b		 je	 SHORT $LN37@WinMain
  00810	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN37@WinMain:
$LN28@WinMain:

; 560  :     }
; 561  :     return(0);

  0081b	33 c0		 xor	 eax, eax

; 562  : } 

  0081d	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00825	48 33 cc	 xor	 rcx, rsp
  00828	e8 00 00 00 00	 call	 __security_check_cookie
  0082d	48 81 c4 20 02
	00 00		 add	 rsp, 544		; 00000220H
  00834	5f		 pop	 rdi
  00835	c3		 ret	 0
WinMain	ENDP
_TEXT	ENDS
END
