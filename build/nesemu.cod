; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?rra@@YAEGPEAUcpu@@E@Z				; rra
PUBLIC	?sax@@YAEGPEAUcpu@@E@Z				; sax
PUBLIC	?shx@@YAEGPEAUcpu@@E@Z				; shx
PUBLIC	?shy@@YAEGPEAUcpu@@E@Z				; shy
PUBLIC	?slo@@YAEGPEAUcpu@@E@Z				; slo
PUBLIC	?sre@@YAEGPEAUcpu@@E@Z				; sre
PUBLIC	?tas@@YAEGPEAUcpu@@E@Z				; tas
PUBLIC	?Palette@@3PAY02EA				; Palette
PUBLIC	?xaa@@YAEGPEAUcpu@@E@Z				; xaa
PUBLIC	?instrOps@@3PAP6AEGPEAUcpu@@E@ZA		; instrOps
PUBLIC	?LowPatternShiftReg@@3GA			; LowPatternShiftReg
PUBLIC	?HighPatternShiftReg@@3GA			; HighPatternShiftReg
PUBLIC	?PaletteLatchOld@@3EA				; PaletteLatchOld
PUBLIC	?PaletteLatchNew@@3EA				; PaletteLatchNew
PUBLIC	?NextLowPattern@@3EA				; NextLowPattern
PUBLIC	?NextHighPattern@@3EA				; NextHighPattern
PUBLIC	?NextAtrbByte@@3EA				; NextAtrbByte
PUBLIC	?NextNametableAdrs@@3GA				; NextNametableAdrs
PUBLIC	?nromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ; nromInit
PUBLIC	?mmc1Init@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ; mmc1Init
PUBLIC	?unromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ; unromInit
PUBLIC	?axromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ; axromInit
PUBLIC	?mapperInit@@3PAP6AXPEAUcartridge@@PEAUcpu@@PEAUppu@@@ZA ; mapperInit
PUBLIC	?nromUpdate@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ; nromUpdate
PUBLIC	?mmc1Update@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ; mmc1Update
PUBLIC	?unromUpdate@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ; unromUpdate
PUBLIC	?axromUpdate@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ; axromUpdate
PUBLIC	?mapperUpdate@@3PAP6AXPEAUcartridge@@PEAUcpu@@PEAUppu@@@ZA ; mapperUpdate
PUBLIC	?IOReadFromCpu@@3HA				; IOReadFromCpu
PUBLIC	?IOWriteFromCpu@@3HA				; IOWriteFromCpu
PUBLIC	?ScrollAdrsChange@@3HA				; ScrollAdrsChange
PUBLIC	?VRamAdrsChange@@3HA				; VRamAdrsChange
PUBLIC	?ResetScrollIOAdrs@@3HA				; ResetScrollIOAdrs
PUBLIC	?ResetVRamIOAdrs@@3HA				; ResetVRamIOAdrs
PUBLIC	?adc@@YAEGPEAUcpu@@E@Z				; adc
PUBLIC	?AND@@YAEGPEAUcpu@@E@Z				; AND
PUBLIC	?asl@@YAEGPEAUcpu@@E@Z				; asl
PUBLIC	?bcc@@YAEGPEAUcpu@@E@Z				; bcc
PUBLIC	?bcs@@YAEGPEAUcpu@@E@Z				; bcs
PUBLIC	?beq@@YAEGPEAUcpu@@E@Z				; beq
PUBLIC	?bit@@YAEGPEAUcpu@@E@Z				; bit
PUBLIC	?bmi@@YAEGPEAUcpu@@E@Z				; bmi
PUBLIC	?bne@@YAEGPEAUcpu@@E@Z				; bne
PUBLIC	?bpl@@YAEGPEAUcpu@@E@Z				; bpl
PUBLIC	?brk@@YAEGPEAUcpu@@E@Z				; brk
PUBLIC	?TriggerNmi@@3HA				; TriggerNmi
PUBLIC	?NmiTriggered@@3HA				; NmiTriggered
PUBLIC	?bvc@@YAEGPEAUcpu@@E@Z				; bvc
PUBLIC	?IrqTriggered@@3HA				; IrqTriggered
PUBLIC	?OamDataChange@@3HA				; OamDataChange
PUBLIC	?bvs@@YAEGPEAUcpu@@E@Z				; bvs
PUBLIC	?clc@@YAEGPEAUcpu@@E@Z				; clc
PUBLIC	?cld@@YAEGPEAUcpu@@E@Z				; cld
PUBLIC	?cli@@YAEGPEAUcpu@@E@Z				; cli
PUBLIC	?clv@@YAEGPEAUcpu@@E@Z				; clv
PUBLIC	?cmp@@YAEGPEAUcpu@@E@Z				; cmp
PUBLIC	?cpx@@YAEGPEAUcpu@@E@Z				; cpx
PUBLIC	?cpy@@YAEGPEAUcpu@@E@Z				; cpy
PUBLIC	?dec@@YAEGPEAUcpu@@E@Z				; dec
PUBLIC	?dex@@YAEGPEAUcpu@@E@Z				; dex
PUBLIC	?dey@@YAEGPEAUcpu@@E@Z				; dey
PUBLIC	?eor@@YAEGPEAUcpu@@E@Z				; eor
PUBLIC	?inc@@YAEGPEAUcpu@@E@Z				; inc
PUBLIC	?inx@@YAEGPEAUcpu@@E@Z				; inx
PUBLIC	?iny@@YAEGPEAUcpu@@E@Z				; iny
PUBLIC	?jmp@@YAEGPEAUcpu@@E@Z				; jmp
PUBLIC	?jsr@@YAEGPEAUcpu@@E@Z				; jsr
PUBLIC	?lda@@YAEGPEAUcpu@@E@Z				; lda
PUBLIC	?ldx@@YAEGPEAUcpu@@E@Z				; ldx
PUBLIC	?ldy@@YAEGPEAUcpu@@E@Z				; ldy
PUBLIC	?lsr@@YAEGPEAUcpu@@E@Z				; lsr
PUBLIC	?nop@@YAEGPEAUcpu@@E@Z				; nop
PUBLIC	?ora@@YAEGPEAUcpu@@E@Z				; ora
PUBLIC	?pha@@YAEGPEAUcpu@@E@Z				; pha
PUBLIC	?php@@YAEGPEAUcpu@@E@Z				; php
PUBLIC	?pla@@YAEGPEAUcpu@@E@Z				; pla
PUBLIC	?plp@@YAEGPEAUcpu@@E@Z				; plp
PUBLIC	?rol@@YAEGPEAUcpu@@E@Z				; rol
PUBLIC	?ror@@YAEGPEAUcpu@@E@Z				; ror
PUBLIC	?rti@@YAEGPEAUcpu@@E@Z				; rti
PUBLIC	?rts@@YAEGPEAUcpu@@E@Z				; rts
PUBLIC	?sbc@@YAEGPEAUcpu@@E@Z				; sbc
PUBLIC	?sec@@YAEGPEAUcpu@@E@Z				; sec
PUBLIC	?sed@@YAEGPEAUcpu@@E@Z				; sed
PUBLIC	?sei@@YAEGPEAUcpu@@E@Z				; sei
PUBLIC	?sta@@YAEGPEAUcpu@@E@Z				; sta
PUBLIC	?stx@@YAEGPEAUcpu@@E@Z				; stx
PUBLIC	?sty@@YAEGPEAUcpu@@E@Z				; sty
PUBLIC	?tax@@YAEGPEAUcpu@@E@Z				; tax
PUBLIC	?tay@@YAEGPEAUcpu@@E@Z				; tay
PUBLIC	?tsx@@YAEGPEAUcpu@@E@Z				; tsx
PUBLIC	?txa@@YAEGPEAUcpu@@E@Z				; txa
PUBLIC	?tya@@YAEGPEAUcpu@@E@Z				; tya
PUBLIC	?txs@@YAEGPEAUcpu@@E@Z				; txs
PUBLIC	?ahx@@YAEGPEAUcpu@@E@Z				; ahx
PUBLIC	?alr@@YAEGPEAUcpu@@E@Z				; alr
PUBLIC	?anc@@YAEGPEAUcpu@@E@Z				; anc
PUBLIC	?arr@@YAEGPEAUcpu@@E@Z				; arr
PUBLIC	?axs@@YAEGPEAUcpu@@E@Z				; axs
PUBLIC	?dcp@@YAEGPEAUcpu@@E@Z				; dcp
PUBLIC	?isc@@YAEGPEAUcpu@@E@Z				; isc
PUBLIC	?kil@@YAEGPEAUcpu@@E@Z				; kil
PUBLIC	?las@@YAEGPEAUcpu@@E@Z				; las
PUBLIC	?lax@@YAEGPEAUcpu@@E@Z				; lax
PUBLIC	?rla@@YAEGPEAUcpu@@E@Z				; rla
_BSS	SEGMENT
?LowPatternShiftReg@@3GA DW 01H DUP (?)			; LowPatternShiftReg
	ALIGN	4

?HighPatternShiftReg@@3GA DW 01H DUP (?)		; HighPatternShiftReg
	ALIGN	4

?PaletteLatchOld@@3EA DB 01H DUP (?)			; PaletteLatchOld
	ALIGN	4

?PaletteLatchNew@@3EA DB 01H DUP (?)			; PaletteLatchNew
	ALIGN	4

?NextLowPattern@@3EA DB 01H DUP (?)			; NextLowPattern
	ALIGN	4

?NextHighPattern@@3EA DB 01H DUP (?)			; NextHighPattern
	ALIGN	4

?NextAtrbByte@@3EA DB 01H DUP (?)			; NextAtrbByte
	ALIGN	4

?NextNametableAdrs@@3GA DW 01H DUP (?)			; NextNametableAdrs
	ALIGN	4

?IOReadFromCpu@@3HA DD 01H DUP (?)			; IOReadFromCpu
?IOWriteFromCpu@@3HA DD 01H DUP (?)			; IOWriteFromCpu
?ScrollAdrsChange@@3HA DD 01H DUP (?)			; ScrollAdrsChange
?VRamAdrsChange@@3HA DD 01H DUP (?)			; VRamAdrsChange
?ResetScrollIOAdrs@@3HA DD 01H DUP (?)			; ResetScrollIOAdrs
?ResetVRamIOAdrs@@3HA DD 01H DUP (?)			; ResetVRamIOAdrs
?DrawScreen@@3HA DD 01H DUP (?)				; DrawScreen
?WinInput@@3Uinput@@A DB 020H DUP (?)			; WinInput
?MapperExtWrite@@3HA DD 01H DUP (?)			; MapperExtWrite
?PowerHit@@3HA DD 01H DUP (?)				; PowerHit
?ResetHit@@3HA DD 01H DUP (?)				; ResetHit
?OamData@@3PEAEEA DQ 01H DUP (?)			; OamData
?TriggerNmi@@3HA DD 01H DUP (?)				; TriggerNmi
?NmiTriggered@@3HA DD 01H DUP (?)			; NmiTriggered
?IrqTriggered@@3HA DD 01H DUP (?)			; IrqTriggered
?OamDataChange@@3HA DD 01H DUP (?)			; OamDataChange
?GlobalCpuMemoryBase@@3_KA DQ 01H DUP (?)		; GlobalCpuMemoryBase
?GlobalPpuMemoryBase@@3_KA DQ 01H DUP (?)		; GlobalPpuMemoryBase
_BSS	ENDS
CONST	SEGMENT
$SG89185 DB	'NMI', 00H
$SG89188 DB	'IRQ', 00H
$SG88344 DB	'BRK', 00H
$SG88345 DB	'ORA', 00H
$SG88346 DB	'KIL', 00H
$SG88347 DB	'SLO', 00H
$SG88348 DB	'NOP', 00H
$SG88349 DB	'ORA', 00H
$SG88350 DB	'ASL', 00H
$SG88351 DB	'SLO', 00H
$SG88352 DB	'PHP', 00H
$SG88353 DB	'ORA', 00H
$SG88354 DB	'ASL', 00H
$SG88355 DB	'ANC', 00H
$SG88356 DB	'NOP', 00H
$SG88357 DB	'ORA', 00H
$SG88358 DB	'ASL', 00H
$SG88359 DB	'SLO', 00H
$SG88360 DB	'BPL', 00H
$SG88361 DB	'ORA', 00H
$SG88362 DB	'KIL', 00H
$SG88363 DB	'SLO', 00H
$SG88364 DB	'NOP', 00H
$SG88365 DB	'ORA', 00H
$SG88366 DB	'ASL', 00H
$SG88367 DB	'SLO', 00H
$SG88368 DB	'CLC', 00H
$SG88369 DB	'ORA', 00H
$SG88370 DB	'NOP', 00H
$SG88371 DB	'SLO', 00H
$SG88372 DB	'NOP', 00H
$SG88373 DB	'ORA', 00H
$SG88374 DB	'ASL', 00H
$SG88375 DB	'SLO', 00H
$SG88376 DB	'JSR', 00H
$SG88377 DB	'AND', 00H
$SG88378 DB	'KIL', 00H
$SG88379 DB	'RLA', 00H
$SG88380 DB	'BIT', 00H
$SG88381 DB	'AND', 00H
$SG88382 DB	'ROL', 00H
$SG88383 DB	'RLA', 00H
$SG88384 DB	'PLP', 00H
$SG88385 DB	'AND', 00H
$SG88386 DB	'ROL', 00H
$SG88387 DB	'ANC', 00H
$SG88388 DB	'BIT', 00H
$SG88389 DB	'AND', 00H
$SG88390 DB	'ROL', 00H
$SG88391 DB	'RLA', 00H
$SG88392 DB	'BMI', 00H
$SG88393 DB	'AND', 00H
$SG88394 DB	'KIL', 00H
$SG88395 DB	'RLA', 00H
$SG88396 DB	'NOP', 00H
$SG88397 DB	'AND', 00H
$SG88398 DB	'ROL', 00H
$SG88399 DB	'RLA', 00H
$SG88400 DB	'SEC', 00H
$SG88401 DB	'AND', 00H
$SG88402 DB	'NOP', 00H
$SG88403 DB	'RLA', 00H
$SG88404 DB	'NOP', 00H
$SG88405 DB	'AND', 00H
$SG88406 DB	'ROL', 00H
$SG88407 DB	'RLA', 00H
$SG88408 DB	'RTI', 00H
$SG88409 DB	'EOR', 00H
$SG88410 DB	'KIL', 00H
$SG88411 DB	'SRE', 00H
$SG88412 DB	'NOP', 00H
$SG88413 DB	'EOR', 00H
$SG88414 DB	'LSR', 00H
$SG88415 DB	'SRE', 00H
$SG88416 DB	'PHA', 00H
$SG88417 DB	'EOR', 00H
$SG88418 DB	'LSR', 00H
$SG88419 DB	'ALR', 00H
$SG88420 DB	'JMP', 00H
$SG88421 DB	'EOR', 00H
$SG88422 DB	'LSR', 00H
$SG88423 DB	'SRE', 00H
$SG88424 DB	'BVC', 00H
$SG88425 DB	'EOR', 00H
$SG88426 DB	'KIL', 00H
$SG88427 DB	'SRE', 00H
$SG88428 DB	'NOP', 00H
$SG88429 DB	'EOR', 00H
$SG88430 DB	'LSR', 00H
$SG88431 DB	'SRE', 00H
$SG88432 DB	'CLI', 00H
$SG88433 DB	'EOR', 00H
$SG89458 DB	'Nes Emulator', 00H
	ORG $+3
$SG88434 DB	'NOP', 00H
$SG88435 DB	'SRE', 00H
$SG88436 DB	'NOP', 00H
$SG89461 DB	'NesEmu', 00H
	ORG $+1
$SG88437 DB	'EOR', 00H
$SG88438 DB	'LSR', 00H
$SG88439 DB	'SRE', 00H
$SG89464 DB	'&Open Rom', 00H
	ORG $+2
$SG88440 DB	'RTS', 00H
$SG89465 DB	'&Close Rom', 00H
	ORG $+1
$SG88441 DB	'ADC', 00H
$SG89466 DB	'&Quit', 00H
	ORG $+2
$SG88442 DB	'KIL', 00H
$SG89467 DB	'&File', 00H
	ORG $+2
$SG88443 DB	'RRA', 00H
$SG89468 DB	'Cpu Base = %X , Ppu Base = %X', 0aH, 00H
	ORG $+1
$SG88444 DB	'NOP', 00H
$SG88445 DB	'ADC', 00H
$SG89469 DB	'Mario Bros.nes', 00H
	ORG $+1
$SG88446 DB	'ROR', 00H
$SG88447 DB	'RRA', 00H
$SG88448 DB	'PLA', 00H
$SG88449 DB	'ADC', 00H
$SG88450 DB	'ROR', 00H
$SG88451 DB	'ARR', 00H
$SG88452 DB	'JMP', 00H
$SG88453 DB	'ADC', 00H
$SG88454 DB	'ROR', 00H
$SG88455 DB	'RRA', 00H
$SG88456 DB	'BVS', 00H
$SG88457 DB	'ADC', 00H
$SG88458 DB	'KIL', 00H
$SG88459 DB	'RRA', 00H
$SG88460 DB	'NOP', 00H
$SG88461 DB	'ADC', 00H
$SG88462 DB	'ROR', 00H
$SG88463 DB	'RRA', 00H
$SG88464 DB	'SEI', 00H
$SG88465 DB	'ADC', 00H
$SG88466 DB	'NOP', 00H
$SG88467 DB	'RRA', 00H
$SG88468 DB	'NOP', 00H
$SG88469 DB	'ADC', 00H
$SG88470 DB	'ROR', 00H
$SG88471 DB	'RRA', 00H
$SG88472 DB	'NOP', 00H
$SG88473 DB	'STA', 00H
$SG88474 DB	'NOP', 00H
$SG88475 DB	'SAX', 00H
$SG88476 DB	'STY', 00H
$SG88477 DB	'STA', 00H
$SG88478 DB	'STX', 00H
$SG88479 DB	'SAX', 00H
$SG88480 DB	'DEY', 00H
$SG88481 DB	'NOP', 00H
$SG88482 DB	'TXA', 00H
$SG88483 DB	'XAA', 00H
$SG88484 DB	'STY', 00H
$SG88485 DB	'STA', 00H
$SG88486 DB	'STX', 00H
$SG88487 DB	'SAX', 00H
$SG88488 DB	'BCC', 00H
$SG88489 DB	'STA', 00H
$SG88490 DB	'KIL', 00H
$SG88491 DB	'AHX', 00H
$SG88492 DB	'STY', 00H
$SG88493 DB	'STA', 00H
$SG88494 DB	'STX', 00H
$SG88495 DB	'SAX', 00H
$SG88496 DB	'TYA', 00H
$SG88497 DB	'STA', 00H
$SG88498 DB	'TXS', 00H
$SG88499 DB	'TAS', 00H
$SG88500 DB	'SHY', 00H
$SG88501 DB	'STA', 00H
$SG88502 DB	'SHX', 00H
$SG88503 DB	'AHX', 00H
$SG88504 DB	'LDY', 00H
$SG88505 DB	'LDA', 00H
$SG88506 DB	'LDX', 00H
$SG88507 DB	'LAX', 00H
$SG88508 DB	'LDY', 00H
$SG88509 DB	'LDA', 00H
$SG88510 DB	'LDX', 00H
$SG88511 DB	'LAX', 00H
$SG88512 DB	'TAY', 00H
$SG88513 DB	'LDA', 00H
$SG88514 DB	'TAX', 00H
$SG88515 DB	'LAX', 00H
$SG88516 DB	'LDY', 00H
$SG88517 DB	'LDA', 00H
$SG88518 DB	'LDX', 00H
$SG88519 DB	'LAX', 00H
$SG88520 DB	'BCS', 00H
$SG88521 DB	'LDA', 00H
$SG88522 DB	'KIL', 00H
$SG88523 DB	'LAX', 00H
$SG88524 DB	'LDY', 00H
$SG88525 DB	'LDA', 00H
$SG88526 DB	'LDX', 00H
$SG88527 DB	'LAX', 00H
$SG88528 DB	'CLV', 00H
$SG88529 DB	'LDA', 00H
$SG88530 DB	'TSX', 00H
$SG88531 DB	'LAS', 00H
$SG88532 DB	'LDY', 00H
$SG88533 DB	'LDA', 00H
$SG88534 DB	'LDX', 00H
$SG88535 DB	'LAX', 00H
$SG88536 DB	'CPY', 00H
$SG88537 DB	'CMP', 00H
$SG88538 DB	'NOP', 00H
$SG88539 DB	'DCP', 00H
$SG88540 DB	'CPY', 00H
$SG88541 DB	'CMP', 00H
$SG88542 DB	'DEC', 00H
$SG88543 DB	'DCP', 00H
$SG88544 DB	'INY', 00H
$SG88545 DB	'CMP', 00H
$SG88546 DB	'DEX', 00H
$SG88547 DB	'AXS', 00H
$SG88548 DB	'CPY', 00H
$SG88549 DB	'CMP', 00H
$SG88550 DB	'DEC', 00H
$SG88551 DB	'DCP', 00H
$SG88552 DB	'BNE', 00H
$SG88553 DB	'CMP', 00H
$SG88554 DB	'KIL', 00H
$SG88555 DB	'DCP', 00H
$SG88556 DB	'NOP', 00H
$SG88557 DB	'CMP', 00H
$SG88558 DB	'DEC', 00H
$SG88559 DB	'DCP', 00H
$SG88560 DB	'CLD', 00H
$SG88561 DB	'CMP', 00H
$SG88562 DB	'NOP', 00H
$SG88563 DB	'DCP', 00H
$SG88564 DB	'NOP', 00H
$SG88565 DB	'CMP', 00H
$SG88566 DB	'DEC', 00H
$SG88567 DB	'DCP', 00H
$SG88568 DB	'CPX', 00H
$SG88569 DB	'SBC', 00H
$SG88570 DB	'NOP', 00H
$SG88571 DB	'ISC', 00H
$SG88572 DB	'CPX', 00H
$SG88573 DB	'SBC', 00H
$SG88574 DB	'INC', 00H
$SG88575 DB	'ISC', 00H
$SG88576 DB	'INX', 00H
$SG88577 DB	'SBC', 00H
$SG88578 DB	'NOP', 00H
$SG88579 DB	'SBC', 00H
$SG88580 DB	'CPX', 00H
$SG88581 DB	'SBC', 00H
$SG88582 DB	'INC', 00H
$SG88583 DB	'ISC', 00H
$SG88584 DB	'BEQ', 00H
$SG88585 DB	'SBC', 00H
$SG88586 DB	'KIL', 00H
$SG88587 DB	'ISC', 00H
$SG88588 DB	'NOP', 00H
$SG88589 DB	'SBC', 00H
$SG88590 DB	'INC', 00H
$SG88591 DB	'ISC', 00H
$SG88592 DB	'SED', 00H
$SG88593 DB	'SBC', 00H
$SG88594 DB	'NOP', 00H
$SG88595 DB	'ISC', 00H
$SG88596 DB	'NOP', 00H
$SG88597 DB	'SBC', 00H
$SG88598 DB	'INC', 00H
$SG88599 DB	'ISC', 00H
$SG87661 DB	'.nes', 00H, '*.nes', 00H, 00H
CONST	ENDS
_DATA	SEGMENT
?Palette@@3PAY02EA DB 075H				; Palette
	DB	075H
	DB	075H
	DB	027H
	DB	01bH
	DB	08fH
	DB	00H
	DB	00H
	DB	0abH
	DB	047H
	DB	00H
	DB	09fH
	DB	08fH
	DB	00H
	DB	077H
	DB	0abH
	DB	00H
	DB	013H
	DB	0a7H
	DB	00H
	DB	00H
	DB	07fH
	DB	0bH
	DB	00H
	DB	043H
	DB	02fH
	DB	00H
	DB	00H
	DB	047H
	DB	00H
	DB	00H
	DB	051H
	DB	00H
	DB	00H
	DB	03fH
	DB	017H
	DB	01bH
	DB	03fH
	DB	05fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0bcH
	DB	0bcH
	DB	0bcH
	DB	00H
	DB	073H
	DB	0efH
	DB	023H
	DB	03bH
	DB	0efH
	DB	083H
	DB	00H
	DB	0f3H
	DB	0bfH
	DB	00H
	DB	0bfH
	DB	0e7H
	DB	00H
	DB	05bH
	DB	0dbH
	DB	02bH
	DB	00H
	DB	0cbH
	DB	04fH
	DB	0fH
	DB	08bH
	DB	073H
	DB	00H
	DB	00H
	DB	097H
	DB	00H
	DB	00H
	DB	0abH
	DB	00H
	DB	00H
	DB	093H
	DB	03bH
	DB	00H
	DB	083H
	DB	08bH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	03fH
	DB	0bfH
	DB	0ffH
	DB	05fH
	DB	097H
	DB	0ffH
	DB	0a7H
	DB	08bH
	DB	0fdH
	DB	0f7H
	DB	07bH
	DB	0ffH
	DB	0ffH
	DB	077H
	DB	0b7H
	DB	0ffH
	DB	077H
	DB	063H
	DB	0ffH
	DB	09bH
	DB	03bH
	DB	0f3H
	DB	0bfH
	DB	03fH
	DB	083H
	DB	0d3H
	DB	013H
	DB	04fH
	DB	0dfH
	DB	04bH
	DB	058H
	DB	0f8H
	DB	098H
	DB	00H
	DB	0ebH
	DB	0dbH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0abH
	DB	0e7H
	DB	0ffH
	DB	0c7H
	DB	0d7H
	DB	0ffH
	DB	0d7H
	DB	0cbH
	DB	0ffH
	DB	0ffH
	DB	0c7H
	DB	0ffH
	DB	0ffH
	DB	0c7H
	DB	0dbH
	DB	0ffH
	DB	0bfH
	DB	0b3H
	DB	0ffH
	DB	0dbH
	DB	0abH
	DB	0ffH
	DB	0e7H
	DB	0a3H
	DB	0e3H
	DB	0ffH
	DB	0a3H
	DB	0abH
	DB	0f3H
	DB	0bfH
	DB	0b3H
	DB	0ffH
	DB	0cfH
	DB	09fH
	DB	0ffH
	DB	0f3H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
?instrOps@@3PAP6AEGPEAUcpu@@E@ZA DQ FLAT:?brk@@YAEGPEAUcpu@@E@Z ; instrOps
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?asl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?php@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?asl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?anc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?asl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bpl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?asl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?clc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?asl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?jsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bit@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rol@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?plp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rol@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?anc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bit@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rol@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bmi@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rol@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sec@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rol@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rti@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?pha@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?alr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?jmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bvc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cli@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rts@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ror@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?pla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ror@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?arr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?jmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ror@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bvs@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ror@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sei@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ror@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sty@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?stx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dey@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?txa@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?xaa@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sty@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?stx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bcc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ahx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sty@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?stx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?tya@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?txs@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?tas@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?shy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?shx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ahx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?tay@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?tax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bcs@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?clv@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?tsx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?las@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dec@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?iny@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dex@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?axs@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dec@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bne@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dec@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cld@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dec@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?inc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?inx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?inc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?beq@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?inc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sed@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?inc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
?mapperInit@@3PAP6AXPEAUcartridge@@PEAUcpu@@PEAUppu@@@ZA DQ FLAT:?nromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ; mapperInit
	DQ	FLAT:?mmc1Init@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z
	DQ	FLAT:?unromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:?axromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z
?mapperUpdate@@3PAP6AXPEAUcartridge@@PEAUcpu@@PEAUppu@@@ZA DQ FLAT:?nromUpdate@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ; mapperUpdate
	DQ	FLAT:?mmc1Update@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z
	DQ	FLAT:?unromUpdate@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:?axromUpdate@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z
?instAddressMode@@3PAEA DB 09H				; instAddressMode
	DB	0bH
	DB	09H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	01H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	06H
	DB	0bH
	DB	09H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	01H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	09H
	DB	0bH
	DB	09H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	01H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	09H
	DB	0bH
	DB	09H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	01H
	DB	02H
	DB	0dH
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	02H
	DB	0bH
	DB	02H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	09H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	02H
	DB	0bH
	DB	02H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	09H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	02H
	DB	0bH
	DB	02H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	09H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	02H
	DB	0bH
	DB	02H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	09H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
?instLength@@3PAEA DB 02H				; instLength
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
?instName@@3PAPEADA DQ FLAT:$SG88344			; instName
	DQ	FLAT:$SG88345
	DQ	FLAT:$SG88346
	DQ	FLAT:$SG88347
	DQ	FLAT:$SG88348
	DQ	FLAT:$SG88349
	DQ	FLAT:$SG88350
	DQ	FLAT:$SG88351
	DQ	FLAT:$SG88352
	DQ	FLAT:$SG88353
	DQ	FLAT:$SG88354
	DQ	FLAT:$SG88355
	DQ	FLAT:$SG88356
	DQ	FLAT:$SG88357
	DQ	FLAT:$SG88358
	DQ	FLAT:$SG88359
	DQ	FLAT:$SG88360
	DQ	FLAT:$SG88361
	DQ	FLAT:$SG88362
	DQ	FLAT:$SG88363
	DQ	FLAT:$SG88364
	DQ	FLAT:$SG88365
	DQ	FLAT:$SG88366
	DQ	FLAT:$SG88367
	DQ	FLAT:$SG88368
	DQ	FLAT:$SG88369
	DQ	FLAT:$SG88370
	DQ	FLAT:$SG88371
	DQ	FLAT:$SG88372
	DQ	FLAT:$SG88373
	DQ	FLAT:$SG88374
	DQ	FLAT:$SG88375
	DQ	FLAT:$SG88376
	DQ	FLAT:$SG88377
	DQ	FLAT:$SG88378
	DQ	FLAT:$SG88379
	DQ	FLAT:$SG88380
	DQ	FLAT:$SG88381
	DQ	FLAT:$SG88382
	DQ	FLAT:$SG88383
	DQ	FLAT:$SG88384
	DQ	FLAT:$SG88385
	DQ	FLAT:$SG88386
	DQ	FLAT:$SG88387
	DQ	FLAT:$SG88388
	DQ	FLAT:$SG88389
	DQ	FLAT:$SG88390
	DQ	FLAT:$SG88391
	DQ	FLAT:$SG88392
	DQ	FLAT:$SG88393
	DQ	FLAT:$SG88394
	DQ	FLAT:$SG88395
	DQ	FLAT:$SG88396
	DQ	FLAT:$SG88397
	DQ	FLAT:$SG88398
	DQ	FLAT:$SG88399
	DQ	FLAT:$SG88400
	DQ	FLAT:$SG88401
	DQ	FLAT:$SG88402
	DQ	FLAT:$SG88403
	DQ	FLAT:$SG88404
	DQ	FLAT:$SG88405
	DQ	FLAT:$SG88406
	DQ	FLAT:$SG88407
	DQ	FLAT:$SG88408
	DQ	FLAT:$SG88409
	DQ	FLAT:$SG88410
	DQ	FLAT:$SG88411
	DQ	FLAT:$SG88412
	DQ	FLAT:$SG88413
	DQ	FLAT:$SG88414
	DQ	FLAT:$SG88415
	DQ	FLAT:$SG88416
	DQ	FLAT:$SG88417
	DQ	FLAT:$SG88418
	DQ	FLAT:$SG88419
	DQ	FLAT:$SG88420
	DQ	FLAT:$SG88421
	DQ	FLAT:$SG88422
	DQ	FLAT:$SG88423
	DQ	FLAT:$SG88424
	DQ	FLAT:$SG88425
	DQ	FLAT:$SG88426
	DQ	FLAT:$SG88427
	DQ	FLAT:$SG88428
	DQ	FLAT:$SG88429
	DQ	FLAT:$SG88430
	DQ	FLAT:$SG88431
	DQ	FLAT:$SG88432
	DQ	FLAT:$SG88433
	DQ	FLAT:$SG88434
	DQ	FLAT:$SG88435
	DQ	FLAT:$SG88436
	DQ	FLAT:$SG88437
	DQ	FLAT:$SG88438
	DQ	FLAT:$SG88439
	DQ	FLAT:$SG88440
	DQ	FLAT:$SG88441
	DQ	FLAT:$SG88442
	DQ	FLAT:$SG88443
	DQ	FLAT:$SG88444
	DQ	FLAT:$SG88445
	DQ	FLAT:$SG88446
	DQ	FLAT:$SG88447
	DQ	FLAT:$SG88448
	DQ	FLAT:$SG88449
	DQ	FLAT:$SG88450
	DQ	FLAT:$SG88451
	DQ	FLAT:$SG88452
	DQ	FLAT:$SG88453
	DQ	FLAT:$SG88454
	DQ	FLAT:$SG88455
	DQ	FLAT:$SG88456
	DQ	FLAT:$SG88457
	DQ	FLAT:$SG88458
	DQ	FLAT:$SG88459
	DQ	FLAT:$SG88460
	DQ	FLAT:$SG88461
	DQ	FLAT:$SG88462
	DQ	FLAT:$SG88463
	DQ	FLAT:$SG88464
	DQ	FLAT:$SG88465
	DQ	FLAT:$SG88466
	DQ	FLAT:$SG88467
	DQ	FLAT:$SG88468
	DQ	FLAT:$SG88469
	DQ	FLAT:$SG88470
	DQ	FLAT:$SG88471
	DQ	FLAT:$SG88472
	DQ	FLAT:$SG88473
	DQ	FLAT:$SG88474
	DQ	FLAT:$SG88475
	DQ	FLAT:$SG88476
	DQ	FLAT:$SG88477
	DQ	FLAT:$SG88478
	DQ	FLAT:$SG88479
	DQ	FLAT:$SG88480
	DQ	FLAT:$SG88481
	DQ	FLAT:$SG88482
	DQ	FLAT:$SG88483
	DQ	FLAT:$SG88484
	DQ	FLAT:$SG88485
	DQ	FLAT:$SG88486
	DQ	FLAT:$SG88487
	DQ	FLAT:$SG88488
	DQ	FLAT:$SG88489
	DQ	FLAT:$SG88490
	DQ	FLAT:$SG88491
	DQ	FLAT:$SG88492
	DQ	FLAT:$SG88493
	DQ	FLAT:$SG88494
	DQ	FLAT:$SG88495
	DQ	FLAT:$SG88496
	DQ	FLAT:$SG88497
	DQ	FLAT:$SG88498
	DQ	FLAT:$SG88499
	DQ	FLAT:$SG88500
	DQ	FLAT:$SG88501
	DQ	FLAT:$SG88502
	DQ	FLAT:$SG88503
	DQ	FLAT:$SG88504
	DQ	FLAT:$SG88505
	DQ	FLAT:$SG88506
	DQ	FLAT:$SG88507
	DQ	FLAT:$SG88508
	DQ	FLAT:$SG88509
	DQ	FLAT:$SG88510
	DQ	FLAT:$SG88511
	DQ	FLAT:$SG88512
	DQ	FLAT:$SG88513
	DQ	FLAT:$SG88514
	DQ	FLAT:$SG88515
	DQ	FLAT:$SG88516
	DQ	FLAT:$SG88517
	DQ	FLAT:$SG88518
	DQ	FLAT:$SG88519
	DQ	FLAT:$SG88520
	DQ	FLAT:$SG88521
	DQ	FLAT:$SG88522
	DQ	FLAT:$SG88523
	DQ	FLAT:$SG88524
	DQ	FLAT:$SG88525
	DQ	FLAT:$SG88526
	DQ	FLAT:$SG88527
	DQ	FLAT:$SG88528
	DQ	FLAT:$SG88529
	DQ	FLAT:$SG88530
	DQ	FLAT:$SG88531
	DQ	FLAT:$SG88532
	DQ	FLAT:$SG88533
	DQ	FLAT:$SG88534
	DQ	FLAT:$SG88535
	DQ	FLAT:$SG88536
	DQ	FLAT:$SG88537
	DQ	FLAT:$SG88538
	DQ	FLAT:$SG88539
	DQ	FLAT:$SG88540
	DQ	FLAT:$SG88541
	DQ	FLAT:$SG88542
	DQ	FLAT:$SG88543
	DQ	FLAT:$SG88544
	DQ	FLAT:$SG88545
	DQ	FLAT:$SG88546
	DQ	FLAT:$SG88547
	DQ	FLAT:$SG88548
	DQ	FLAT:$SG88549
	DQ	FLAT:$SG88550
	DQ	FLAT:$SG88551
	DQ	FLAT:$SG88552
	DQ	FLAT:$SG88553
	DQ	FLAT:$SG88554
	DQ	FLAT:$SG88555
	DQ	FLAT:$SG88556
	DQ	FLAT:$SG88557
	DQ	FLAT:$SG88558
	DQ	FLAT:$SG88559
	DQ	FLAT:$SG88560
	DQ	FLAT:$SG88561
	DQ	FLAT:$SG88562
	DQ	FLAT:$SG88563
	DQ	FLAT:$SG88564
	DQ	FLAT:$SG88565
	DQ	FLAT:$SG88566
	DQ	FLAT:$SG88567
	DQ	FLAT:$SG88568
	DQ	FLAT:$SG88569
	DQ	FLAT:$SG88570
	DQ	FLAT:$SG88571
	DQ	FLAT:$SG88572
	DQ	FLAT:$SG88573
	DQ	FLAT:$SG88574
	DQ	FLAT:$SG88575
	DQ	FLAT:$SG88576
	DQ	FLAT:$SG88577
	DQ	FLAT:$SG88578
	DQ	FLAT:$SG88579
	DQ	FLAT:$SG88580
	DQ	FLAT:$SG88581
	DQ	FLAT:$SG88582
	DQ	FLAT:$SG88583
	DQ	FLAT:$SG88584
	DQ	FLAT:$SG88585
	DQ	FLAT:$SG88586
	DQ	FLAT:$SG88587
	DQ	FLAT:$SG88588
	DQ	FLAT:$SG88589
	DQ	FLAT:$SG88590
	DQ	FLAT:$SG88591
	DQ	FLAT:$SG88592
	DQ	FLAT:$SG88593
	DQ	FLAT:$SG88594
	DQ	FLAT:$SG88595
	DQ	FLAT:$SG88596
	DQ	FLAT:$SG88597
	DQ	FLAT:$SG88598
	DQ	FLAT:$SG88599
?instCycles@@3PAEA DB 07H				; instCycles
	DB	06H
	DB	00H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
	DB	06H
	DB	06H
	DB	00H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	04H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
	DB	06H
	DB	06H
	DB	00H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	03H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
	DB	06H
	DB	06H
	DB	00H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	04H
	DB	02H
	DB	02H
	DB	02H
	DB	05H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
	DB	02H
	DB	06H
	DB	02H
	DB	06H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	02H
	DB	06H
	DB	00H
	DB	06H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	02H
	DB	05H
	DB	02H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	02H
	DB	06H
	DB	02H
	DB	06H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	02H
	DB	05H
	DB	00H
	DB	05H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	02H
	DB	04H
	DB	02H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	02H
	DB	06H
	DB	02H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
	DB	02H
	DB	06H
	DB	02H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
?instBoundaryCheck@@3PAEA DB 00H			; instBoundaryCheck
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
?PowerOn@@3HA DD 01H					; PowerOn
_DATA	ENDS
PUBLIC	WinMain
PUBLIC	__local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z	; WinInputCallback
PUBLIC	?getPaletteValue@@YAXEPEAE@Z			; getPaletteValue
PUBLIC	?resetScrollHorz@@YAXPEAUvram_io@@@Z		; resetScrollHorz
PUBLIC	?resetScrollVert@@YAXPEAUvram_io@@@Z		; resetScrollVert
PUBLIC	?scrollIncHorz@@YAXPEAUvram_io@@@Z		; scrollIncHorz
PUBLIC	?scrollIncVert@@YAXPEAUvram_io@@@Z		; scrollIncVert
PUBLIC	?setCarry@@YAXPEAE@Z				; setCarry
PUBLIC	?clearCarry@@YAXPEAE@Z				; clearCarry
PUBLIC	?setInterrupt@@YAXPEAE@Z			; setInterrupt
PUBLIC	?clearInterrupt@@YAXPEAE@Z			; clearInterrupt
PUBLIC	?setDecimal@@YAXPEAE@Z				; setDecimal
PUBLIC	?clearDecimal@@YAXPEAE@Z			; clearDecimal
PUBLIC	?setBreak@@YAXPEAE@Z				; setBreak
PUBLIC	?clearBreak@@YAXPEAE@Z				; clearBreak
PUBLIC	?setBlank@@YAXPEAE@Z				; setBlank
PUBLIC	?setOverflow@@YAXPEAE@Z				; setOverflow
PUBLIC	?clearOverflow@@YAXPEAE@Z			; clearOverflow
PUBLIC	?setZero@@YAXEPEAE@Z				; setZero
PUBLIC	?setNegative@@YAXEPEAE@Z			; setNegative
PUBLIC	?isBitSet@@YAHEE@Z				; isBitSet
PUBLIC	?crossedPageCheck@@YAHGG@Z			; crossedPageCheck
PUBLIC	?catchUpPpu@@YAXPEAUcpu@@@Z			; catchUpPpu
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	__real@408f400000000000
PUBLIC	__real@447a0000
PUBLIC	__real@49da7a66
PUBLIC	__real@5f800000
EXTRN	__report_rangecheckfailure:PROC
EXTRN	memset:PROC
EXTRN	strlen:PROC
EXTRN	__imp_CreateFileA:PROC
EXTRN	__imp_GetFileSizeEx:PROC
EXTRN	__imp_ReadFile:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_QueryPerformanceCounter:PROC
EXTRN	__imp_QueryPerformanceFrequency:PROC
EXTRN	__imp_VirtualAlloc:PROC
EXTRN	__imp_VirtualFree:PROC
EXTRN	__imp_StretchDIBits:PROC
EXTRN	__imp_TranslateMessage:PROC
EXTRN	__imp_DispatchMessageA:PROC
EXTRN	__imp_PeekMessageA:PROC
EXTRN	__imp_DefWindowProcA:PROC
EXTRN	__imp_RegisterClassA:PROC
EXTRN	__imp_CreateWindowExA:PROC
EXTRN	__imp_SetMenu:PROC
EXTRN	__imp_CreateMenu:PROC
EXTRN	__imp_CreatePopupMenu:PROC
EXTRN	__imp_AppendMenuA:PROC
EXTRN	__imp_GetDC:PROC
EXTRN	__imp_ReleaseDC:PROC
EXTRN	__imp_GetClientRect:PROC
EXTRN	__imp_GetOpenFileNameA:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?GlobalRunning@@3HA DD 01H DUP (?)			; GlobalRunning
?RomFileName@@3PADA DB 0100H DUP (?)			; RomFileName
	ALIGN	8

?GlobalCpu@@3PEAUcpu@@EA DQ 01H DUP (?)			; GlobalCpu
?GlobalPpu@@3PEAUppu@@EA DQ 01H DUP (?)			; GlobalPpu
_BSS	ENDS
;	COMDAT ?PrgRomMode@?1??mmc1Update@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z@4EA
_BSS	SEGMENT
?PrgRomMode@?1??mmc1Update@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z@4EA DB 01H DUP (?) ; `mmc1Update'::`2'::PrgRomMode
_BSS	ENDS
;	COMDAT ?ChrRomMode@?1??mmc1Update@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z@4EA
_BSS	SEGMENT
?ChrRomMode@?1??mmc1Update@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z@4EA DB 01H DUP (?) ; `mmc1Update'::`2'::ChrRomMode
_BSS	ENDS
pdata	SEGMENT
$pdata$WinMain DD imagerel $LN21
	DD	imagerel $LN21+1727
	DD	imagerel $unwind$WinMain
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$?getMilliSeconds@@YAM_K@Z DD imagerel ?getMilliSeconds@@YAM_K@Z
	DD	imagerel ?getMilliSeconds@@YAM_K@Z+112
	DD	imagerel $unwind$?getMilliSeconds@@YAM_K@Z
$pdata$?cpyMemory@@YAXPEAE0G@Z DD imagerel ?cpyMemory@@YAXPEAE0G@Z
	DD	imagerel ?cpyMemory@@YAXPEAE0G@Z+85
	DD	imagerel $unwind$?cpyMemory@@YAXPEAE0G@Z
$pdata$?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z DD imagerel $LN60
	DD	imagerel $LN60+1495
	DD	imagerel $unwind$?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z
$pdata$?LoadFile@@YAPEAXPEADPEAI@Z DD imagerel ?LoadFile@@YAPEAXPEADPEAI@Z
	DD	imagerel ?LoadFile@@YAPEAXPEADPEAI@Z+239
	DD	imagerel $unwind$?LoadFile@@YAPEAXPEADPEAI@Z
$pdata$?readPpuRegister@@YAEG@Z DD imagerel ?readPpuRegister@@YAEG@Z
	DD	imagerel ?readPpuRegister@@YAEG@Z+911
	DD	imagerel $unwind$?readPpuRegister@@YAEG@Z
$pdata$?writePpuRegister@@YAXEG@Z DD imagerel ?writePpuRegister@@YAXEG@Z
	DD	imagerel ?writePpuRegister@@YAXEG@Z+2108
	DD	imagerel $unwind$?writePpuRegister@@YAXEG@Z
$pdata$?write8@@YAXEG_K@Z DD imagerel ?write8@@YAXEG_K@Z
	DD	imagerel ?write8@@YAXEG_K@Z+48
	DD	imagerel $unwind$?write8@@YAXEG_K@Z
$pdata$?read8@@YAEG_K@Z DD imagerel ?read8@@YAEG_K@Z
	DD	imagerel ?read8@@YAEG_K@Z+49
	DD	imagerel $unwind$?read8@@YAEG_K@Z
$pdata$?ppuMemoryMirror@@YAGG@Z DD imagerel ?ppuMemoryMirror@@YAGG@Z
	DD	imagerel ?ppuMemoryMirror@@YAGG@Z+279
	DD	imagerel $unwind$?ppuMemoryMirror@@YAGG@Z
$pdata$?readCpu8@@YAEGPEAUcpu@@@Z DD imagerel ?readCpu8@@YAEGPEAUcpu@@@Z
	DD	imagerel ?readCpu8@@YAEGPEAUcpu@@@Z+400
	DD	imagerel $unwind$?readCpu8@@YAEGPEAUcpu@@@Z
$pdata$?readCpu16@@YAGGPEAUcpu@@@Z DD imagerel ?readCpu16@@YAGGPEAUcpu@@@Z
	DD	imagerel ?readCpu16@@YAGGPEAUcpu@@@Z+87
	DD	imagerel $unwind$?readCpu16@@YAGGPEAUcpu@@@Z
$pdata$?bugReadCpu16@@YAGGPEAUcpu@@@Z DD imagerel ?bugReadCpu16@@YAGGPEAUcpu@@@Z
	DD	imagerel ?bugReadCpu16@@YAGGPEAUcpu@@@Z+109
	DD	imagerel $unwind$?bugReadCpu16@@YAGGPEAUcpu@@@Z
$pdata$?writeCpu8@@YAXEGPEAUcpu@@@Z DD imagerel ?writeCpu8@@YAXEGPEAUcpu@@@Z
	DD	imagerel ?writeCpu8@@YAXEGPEAUcpu@@@Z+425
	DD	imagerel $unwind$?writeCpu8@@YAXEGPEAUcpu@@@Z
$pdata$?getNametableBank@@YAPEAEGPEAUppu@@@Z DD imagerel ?getNametableBank@@YAPEAEGPEAUppu@@@Z
	DD	imagerel ?getNametableBank@@YAPEAEGPEAUppu@@@Z+368
	DD	imagerel $unwind$?getNametableBank@@YAPEAEGPEAUppu@@@Z
$pdata$?readNametable@@YAEGPEAUppu@@@Z DD imagerel ?readNametable@@YAEGPEAUppu@@@Z
	DD	imagerel ?readNametable@@YAEGPEAUppu@@@Z+85
	DD	imagerel $unwind$?readNametable@@YAEGPEAUppu@@@Z
$pdata$?writeNametable@@YAXEGPEAUppu@@@Z DD imagerel ?writeNametable@@YAXEGPEAUppu@@@Z
	DD	imagerel ?writeNametable@@YAXEGPEAUppu@@@Z+79
	DD	imagerel $unwind$?writeNametable@@YAXEGPEAUppu@@@Z
$pdata$?readPpu8@@YAEGPEAUppu@@@Z DD imagerel ?readPpu8@@YAEGPEAUppu@@@Z
	DD	imagerel ?readPpu8@@YAEGPEAUppu@@@Z+188
	DD	imagerel $unwind$?readPpu8@@YAEGPEAUppu@@@Z
$pdata$?writePpu8@@YAXEGPEAUppu@@@Z DD imagerel ?writePpu8@@YAXEGPEAUppu@@@Z
	DD	imagerel ?writePpu8@@YAXEGPEAUppu@@@Z+107
	DD	imagerel $unwind$?writePpu8@@YAXEGPEAUppu@@@Z
$pdata$?drawPixel@@YAXPEAUppu@@GGPEAE@Z DD imagerel ?drawPixel@@YAXPEAUppu@@GGPEAE@Z
	DD	imagerel ?drawPixel@@YAXPEAUppu@@GGPEAE@Z+139
	DD	imagerel $unwind$?drawPixel@@YAXPEAUppu@@GGPEAE@Z
$pdata$?scrollIncVert@@YAXPEAUvram_io@@@Z DD imagerel $LN9
	DD	imagerel $LN9+195
	DD	imagerel $unwind$?scrollIncVert@@YAXPEAUvram_io@@@Z
$pdata$?loadFutureData@@YAXPEAUppu@@@Z DD imagerel ?loadFutureData@@YAXPEAUppu@@@Z
	DD	imagerel ?loadFutureData@@YAXPEAUppu@@@Z+567
	DD	imagerel $unwind$?loadFutureData@@YAXPEAUppu@@@Z
$pdata$?clearSecondaryOam@@YAXPEAUppu@@@Z DD imagerel ?clearSecondaryOam@@YAXPEAUppu@@@Z
	DD	imagerel ?clearSecondaryOam@@YAXPEAUppu@@@Z+76
	DD	imagerel $unwind$?clearSecondaryOam@@YAXPEAUppu@@@Z
$pdata$?clearPreparedSprites@@YAXPEAUppu@@@Z DD imagerel ?clearPreparedSprites@@YAXPEAUppu@@@Z
	DD	imagerel ?clearPreparedSprites@@YAXPEAUppu@@@Z+76
	DD	imagerel $unwind$?clearPreparedSprites@@YAXPEAUppu@@@Z
$pdata$?evaluateSecondaryOam@@YAXPEAUppu@@@Z DD imagerel ?evaluateSecondaryOam@@YAXPEAUppu@@@Z
	DD	imagerel ?evaluateSecondaryOam@@YAXPEAUppu@@@Z+776
	DD	imagerel $unwind$?evaluateSecondaryOam@@YAXPEAUppu@@@Z
$pdata$?prepareSprites@@YAXPEAUppu@@@Z DD imagerel ?prepareSprites@@YAXPEAUppu@@@Z
	DD	imagerel ?prepareSprites@@YAXPEAUppu@@@Z+129
	DD	imagerel $unwind$?prepareSprites@@YAXPEAUppu@@@Z
$pdata$?ppuTick@@YAXPEAUppu@@@Z DD imagerel ?ppuTick@@YAXPEAUppu@@@Z
	DD	imagerel ?ppuTick@@YAXPEAUppu@@@Z+2178
	DD	imagerel $unwind$?ppuTick@@YAXPEAUppu@@@Z
$pdata$?push@@YAXEPEAUcpu@@@Z DD imagerel ?push@@YAXEPEAUcpu@@@Z
	DD	imagerel ?push@@YAXEPEAUcpu@@@Z+68
	DD	imagerel $unwind$?push@@YAXEPEAUcpu@@@Z
$pdata$?pop@@YAEPEAUcpu@@@Z DD imagerel ?pop@@YAEPEAUcpu@@@Z
	DD	imagerel ?pop@@YAEPEAUcpu@@@Z+68
	DD	imagerel $unwind$?pop@@YAEPEAUcpu@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?crossedPageCheck@@YAHGG@Z DD imagerel $LN5
	DD	imagerel $LN5+63
	DD	imagerel $unwind$?crossedPageCheck@@YAHGG@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?catchUpPpu@@YAXPEAUcpu@@@Z DD imagerel $LN6
	DD	imagerel $LN6+83
	DD	imagerel $unwind$?catchUpPpu@@YAXPEAUcpu@@@Z
$pdata$?adc@@YAEGPEAUcpu@@E@Z DD imagerel $LN7
	DD	imagerel $LN7+291
	DD	imagerel $unwind$?adc@@YAEGPEAUcpu@@E@Z
$pdata$?AND@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+127
	DD	imagerel $unwind$?AND@@YAEGPEAUcpu@@E@Z
$pdata$?asl@@YAEGPEAUcpu@@E@Z DD imagerel $LN9
	DD	imagerel $LN9+276
	DD	imagerel $unwind$?asl@@YAEGPEAUcpu@@E@Z
$pdata$?bcc@@YAEGPEAUcpu@@E@Z DD imagerel $LN6
	DD	imagerel $LN6+120
	DD	imagerel $unwind$?bcc@@YAEGPEAUcpu@@E@Z
$pdata$?bcs@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bcs@@YAEGPEAUcpu@@E@Z
$pdata$?beq@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?beq@@YAEGPEAUcpu@@E@Z
$pdata$?bit@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+157
	DD	imagerel $unwind$?bit@@YAEGPEAUcpu@@E@Z
$pdata$?bmi@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bmi@@YAEGPEAUcpu@@E@Z
$pdata$?bne@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bne@@YAEGPEAUcpu@@E@Z
$pdata$?bpl@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bpl@@YAEGPEAUcpu@@E@Z
$pdata$?brk@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+178
	DD	imagerel $unwind$?brk@@YAEGPEAUcpu@@E@Z
$pdata$?bvc@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bvc@@YAEGPEAUcpu@@E@Z
$pdata$?bvs@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bvs@@YAEGPEAUcpu@@E@Z
$pdata$?clc@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?clc@@YAEGPEAUcpu@@E@Z
$pdata$?cld@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?cld@@YAEGPEAUcpu@@E@Z
$pdata$?cli@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?cli@@YAEGPEAUcpu@@E@Z
$pdata$?clv@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?clv@@YAEGPEAUcpu@@E@Z
$pdata$?cmp@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+171
	DD	imagerel $unwind$?cmp@@YAEGPEAUcpu@@E@Z
$pdata$?cpx@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+163
	DD	imagerel $unwind$?cpx@@YAEGPEAUcpu@@E@Z
$pdata$?cpy@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+163
	DD	imagerel $unwind$?cpy@@YAEGPEAUcpu@@E@Z
$pdata$?dec@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+124
	DD	imagerel $unwind$?dec@@YAEGPEAUcpu@@E@Z
$pdata$?dex@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?dex@@YAEGPEAUcpu@@E@Z
$pdata$?dey@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?dey@@YAEGPEAUcpu@@E@Z
$pdata$?eor@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+127
	DD	imagerel $unwind$?eor@@YAEGPEAUcpu@@E@Z
$pdata$?inc@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+124
	DD	imagerel $unwind$?inc@@YAEGPEAUcpu@@E@Z
$pdata$?inx@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?inx@@YAEGPEAUcpu@@E@Z
$pdata$?iny@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?iny@@YAEGPEAUcpu@@E@Z
$pdata$?jsr@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$?jsr@@YAEGPEAUcpu@@E@Z
$pdata$?lda@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$?lda@@YAEGPEAUcpu@@E@Z
$pdata$?ldx@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+112
	DD	imagerel $unwind$?ldx@@YAEGPEAUcpu@@E@Z
$pdata$?ldy@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+112
	DD	imagerel $unwind$?ldy@@YAEGPEAUcpu@@E@Z
$pdata$?lsr@@YAEGPEAUcpu@@E@Z DD imagerel $LN9
	DD	imagerel $LN9+275
	DD	imagerel $unwind$?lsr@@YAEGPEAUcpu@@E@Z
$pdata$?ora@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+127
	DD	imagerel $unwind$?ora@@YAEGPEAUcpu@@E@Z
$pdata$?pha@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?pha@@YAEGPEAUcpu@@E@Z
$pdata$?php@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?php@@YAEGPEAUcpu@@E@Z
$pdata$?pla@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$?pla@@YAEGPEAUcpu@@E@Z
$pdata$?plp@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?plp@@YAEGPEAUcpu@@E@Z
$pdata$?rol@@YAEGPEAUcpu@@E@Z DD imagerel $LN11
	DD	imagerel $LN11+341
	DD	imagerel $unwind$?rol@@YAEGPEAUcpu@@E@Z
$pdata$?ror@@YAEGPEAUcpu@@E@Z DD imagerel $LN11
	DD	imagerel $LN11+339
	DD	imagerel $unwind$?ror@@YAEGPEAUcpu@@E@Z
$pdata$?rti@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+105
	DD	imagerel $unwind$?rti@@YAEGPEAUcpu@@E@Z
$pdata$?rts@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$?rts@@YAEGPEAUcpu@@E@Z
$pdata$?sbc@@YAEGPEAUcpu@@E@Z DD imagerel $LN7
	DD	imagerel $LN7+296
	DD	imagerel $unwind$?sbc@@YAEGPEAUcpu@@E@Z
$pdata$?sec@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?sec@@YAEGPEAUcpu@@E@Z
$pdata$?sed@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?sed@@YAEGPEAUcpu@@E@Z
$pdata$?sei@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?sei@@YAEGPEAUcpu@@E@Z
$pdata$?sta@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?sta@@YAEGPEAUcpu@@E@Z
$pdata$?stx@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$?stx@@YAEGPEAUcpu@@E@Z
$pdata$?sty@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$?sty@@YAEGPEAUcpu@@E@Z
$pdata$?tax@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+94
	DD	imagerel $unwind$?tax@@YAEGPEAUcpu@@E@Z
$pdata$?tay@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+94
	DD	imagerel $unwind$?tay@@YAEGPEAUcpu@@E@Z
$pdata$?tsx@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$?tsx@@YAEGPEAUcpu@@E@Z
$pdata$?txa@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+92
	DD	imagerel $unwind$?txa@@YAEGPEAUcpu@@E@Z
$pdata$?tya@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+92
	DD	imagerel $unwind$?tya@@YAEGPEAUcpu@@E@Z
$pdata$?alr@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?alr@@YAEGPEAUcpu@@E@Z
$pdata$?anc@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+103
	DD	imagerel $unwind$?anc@@YAEGPEAUcpu@@E@Z
$pdata$?arr@@YAEGPEAUcpu@@E@Z DD imagerel $LN9
	DD	imagerel $LN9+262
	DD	imagerel $unwind$?arr@@YAEGPEAUcpu@@E@Z
$pdata$?axs@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+190
	DD	imagerel $unwind$?axs@@YAEGPEAUcpu@@E@Z
$pdata$?dcp@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?dcp@@YAEGPEAUcpu@@E@Z
$pdata$?isc@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?isc@@YAEGPEAUcpu@@E@Z
$pdata$?lax@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?lax@@YAEGPEAUcpu@@E@Z
$pdata$?rla@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?rla@@YAEGPEAUcpu@@E@Z
$pdata$?rra@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?rra@@YAEGPEAUcpu@@E@Z
$pdata$?sax@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$?sax@@YAEGPEAUcpu@@E@Z
$pdata$?shy@@YAEGPEAUcpu@@E@Z DD imagerel $LN4
	DD	imagerel $LN4+127
	DD	imagerel $unwind$?shy@@YAEGPEAUcpu@@E@Z
$pdata$?slo@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?slo@@YAEGPEAUcpu@@E@Z
$pdata$?sre@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?sre@@YAEGPEAUcpu@@E@Z
$pdata$?nmi_irq@@YAEGPEAUcpu@@E@Z DD imagerel ?nmi_irq@@YAEGPEAUcpu@@E@Z
	DD	imagerel ?nmi_irq@@YAEGPEAUcpu@@E@Z+211
	DD	imagerel $unwind$?nmi_irq@@YAEGPEAUcpu@@E@Z
$pdata$?cpuTick@@YAEPEAUcpu@@PEAUinput@@@Z DD imagerel ?cpuTick@@YAEPEAUcpu@@PEAUinput@@@Z
	DD	imagerel ?cpuTick@@YAEPEAUcpu@@PEAUinput@@@Z+1712
	DD	imagerel $unwind$?cpuTick@@YAEPEAUcpu@@PEAUinput@@@Z
$pdata$?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z DD imagerel ?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z
	DD	imagerel ?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z+108
	DD	imagerel $unwind$?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z
$pdata$?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z DD imagerel ?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z
	DD	imagerel ?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z+262
	DD	imagerel $unwind$?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z
$pdata$?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z DD imagerel ?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z
	DD	imagerel ?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z+165
	DD	imagerel $unwind$?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z
$pdata$?nromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z DD imagerel $LN7
	DD	imagerel $LN7+241
	DD	imagerel $unwind$?nromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z
$pdata$?mmc1Init@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z DD imagerel $LN3
	DD	imagerel $LN3+156
	DD	imagerel $unwind$?mmc1Init@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z
$pdata$?unromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z DD imagerel $LN3
	DD	imagerel $LN3+156
	DD	imagerel $unwind$?unromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z
$pdata$?axromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z DD imagerel $LN3
	DD	imagerel $LN3+116
	DD	imagerel $unwind$?axromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z
$pdata$?mmc1Update@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z DD imagerel $LN37
	DD	imagerel $LN37+1187
	DD	imagerel $unwind$?mmc1Update@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z
$pdata$?unromUpdate@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z DD imagerel $LN3
	DD	imagerel $LN3+105
	DD	imagerel $unwind$?unromUpdate@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z
$pdata$?axromUpdate@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z DD imagerel $LN5
	DD	imagerel $LN5+150
	DD	imagerel $unwind$?axromUpdate@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z
$pdata$?loadCartridge@@YAXPEAUnes@@PEAD@Z DD imagerel ?loadCartridge@@YAXPEAUnes@@PEAD@Z
	DD	imagerel ?loadCartridge@@YAXPEAUnes@@PEAD@Z+835
	DD	imagerel $unwind$?loadCartridge@@YAXPEAUnes@@PEAD@Z
$pdata$?power@@YAXPEAUnes@@@Z DD imagerel ?power@@YAXPEAUnes@@@Z
	DD	imagerel ?power@@YAXPEAUnes@@@Z+405
	DD	imagerel $unwind$?power@@YAXPEAUnes@@@Z
$pdata$?reset@@YAXPEAUnes@@@Z DD imagerel ?reset@@YAXPEAUnes@@@Z
	DD	imagerel ?reset@@YAXPEAUnes@@@Z+77
	DD	imagerel $unwind$?reset@@YAXPEAUnes@@@Z
pdata	ENDS
;	COMDAT __real@5f800000
CONST	SEGMENT
__real@5f800000 DD 05f800000r			; 1.84467e+19
CONST	ENDS
;	COMDAT __real@49da7a66
CONST	SEGMENT
__real@49da7a66 DD 049da7a66r			; 1.78977e+06
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?crossedPageCheck@@YAHGG@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
xdata	SEGMENT
$unwind$WinMain DD 033419H
	DD	02ae0122H
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	01560H
$unwind$?getMilliSeconds@@YAM_K@Z DD 010901H
	DD	08209H
$unwind$?cpyMemory@@YAXPEAE0G@Z DD 011401H
	DD	02214H
$unwind$?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z DD 032d19H
	DD	046011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	0220H
$unwind$?LoadFile@@YAPEAXPEADPEAI@Z DD 010e01H
	DD	0c20eH
$unwind$?readPpuRegister@@YAEG@Z DD 010901H
	DD	0a209H
$unwind$?writePpuRegister@@YAXEG@Z DD 010d01H
	DD	0e20dH
$unwind$?write8@@YAXEG_K@Z DD 011201H
	DD	02212H
$unwind$?read8@@YAEG_K@Z DD 010e01H
	DD	0220eH
$unwind$?ppuMemoryMirror@@YAGG@Z DD 010901H
	DD	02209H
$unwind$?readCpu8@@YAEGPEAUcpu@@@Z DD 010e01H
	DD	0620eH
$unwind$?readCpu16@@YAGGPEAUcpu@@@Z DD 010e01H
	DD	0620eH
$unwind$?bugReadCpu16@@YAGGPEAUcpu@@@Z DD 010e01H
	DD	0620eH
$unwind$?writeCpu8@@YAXEGPEAUcpu@@@Z DD 011201H
	DD	06212H
$unwind$?getNametableBank@@YAPEAEGPEAUppu@@@Z DD 010e01H
	DD	0220eH
$unwind$?readNametable@@YAEGPEAUppu@@@Z DD 010e01H
	DD	0620eH
$unwind$?writeNametable@@YAXEGPEAUppu@@@Z DD 011201H
	DD	06212H
$unwind$?readPpu8@@YAEGPEAUppu@@@Z DD 010e01H
	DD	0620eH
$unwind$?writePpu8@@YAXEGPEAUppu@@@Z DD 011201H
	DD	04212H
$unwind$?drawPixel@@YAXPEAUppu@@GGPEAE@Z DD 011901H
	DD	02219H
$unwind$?scrollIncVert@@YAXPEAUvram_io@@@Z DD 010901H
	DD	02209H
$unwind$?loadFutureData@@YAXPEAUppu@@@Z DD 010901H
	DD	06209H
$unwind$?clearSecondaryOam@@YAXPEAUppu@@@Z DD 010901H
	DD	02209H
$unwind$?clearPreparedSprites@@YAXPEAUppu@@@Z DD 010901H
	DD	02209H
$unwind$?evaluateSecondaryOam@@YAXPEAUppu@@@Z DD 031a19H
	DD	07007e20bH
	DD	06006H
	DD	imagerel __GSHandlerCheck
	DD	068H
$unwind$?prepareSprites@@YAXPEAUppu@@@Z DD 030b01H
	DD	07007220bH
	DD	06006H
$unwind$?ppuTick@@YAXPEAUppu@@@Z DD 020d01H
	DD	07006f20dH
$unwind$?push@@YAXEPEAUcpu@@@Z DD 010d01H
	DD	0420dH
$unwind$?pop@@YAEPEAUcpu@@@Z DD 010901H
	DD	06209H
$unwind$?catchUpPpu@@YAXPEAUcpu@@@Z DD 010901H
	DD	06209H
$unwind$?adc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?AND@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?asl@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bcc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bcs@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?beq@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bit@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bmi@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bne@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bpl@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?brk@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bvc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bvs@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?clc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?cld@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?cli@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?clv@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?cmp@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?cpx@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?cpy@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?dec@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?dex@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?dey@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?eor@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?inc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?inx@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?iny@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?jsr@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?lda@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?ldx@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?ldy@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?lsr@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?ora@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?pha@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?php@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?pla@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?plp@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?rol@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?ror@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?rti@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?rts@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?sbc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?sec@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?sed@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?sei@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?sta@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?stx@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?sty@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?tax@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?tay@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?tsx@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?txa@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?tya@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?alr@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?anc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?arr@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?axs@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?dcp@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?isc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?lax@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?rla@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?rra@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?sax@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?shy@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?slo@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?sre@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?nmi_irq@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?cpuTick@@YAEPEAUcpu@@PEAUinput@@@Z DD 042519H
	DD	01f0113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z DD 012219H
	DD	08213H
	DD	imagerel __GSHandlerCheck
	DD	030H
$unwind$?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z DD 011401H
	DD	06214H
$unwind$?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z DD 011a01H
	DD	0e21aH
$unwind$?nromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z DD 011301H
	DD	08213H
$unwind$?mmc1Init@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z DD 011301H
	DD	08213H
$unwind$?unromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z DD 011301H
	DD	08213H
$unwind$?axromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z DD 011301H
	DD	06213H
$unwind$?mmc1Update@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z DD 011301H
	DD	0e213H
$unwind$?unromUpdate@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z DD 011301H
	DD	06213H
$unwind$?axromUpdate@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z DD 011301H
	DD	06213H
$unwind$?loadCartridge@@YAXPEAUnes@@PEAD@Z DD 010e01H
	DD	0e20eH
$unwind$?power@@YAXPEAUnes@@@Z DD 042619H
	DD	026b0114H
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	01340H
$unwind$?reset@@YAXPEAUnes@@@Z DD 010901H
	DD	04209H
xdata	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Nes$ = 48
?reset@@YAXPEAUnes@@@Z PROC				; reset

; 690  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 691  :     Nes->Cpu.PrgCounter = readCpu16(RESET_VEC, &Nes->Cpu);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR Nes$[rsp]
  0000e	48 8b d0	 mov	 rdx, rax
  00011	66 b9 fc ff	 mov	 cx, 65532		; 0000fffcH
  00015	e8 00 00 00 00	 call	 ?readCpu16@@YAGGPEAUcpu@@@Z ; readCpu16
  0001a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Nes$[rsp]
  0001f	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 692  : 
; 693  :     // NOTE: The status after reset was taken from nesdev
; 694  :     Nes->Cpu.StackPtr -= 3;

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR Nes$[rsp]
  00028	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0002c	83 e8 03	 sub	 eax, 3
  0002f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Nes$[rsp]
  00034	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 695  :     setInterrupt(&Nes->Cpu.Flags);

  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR Nes$[rsp]
  0003c	48 83 c0 03	 add	 rax, 3
  00040	48 8b c8	 mov	 rcx, rax
  00043	e8 00 00 00 00	 call	 ?setInterrupt@@YAXPEAE@Z ; setInterrupt

; 696  : 
; 697  :     /*
; 698  :     PpuReg->Ctrl1 = 0;
; 699  :     PpuReg->Ctrl2 = 0;
; 700  :     PpuReg->ScrollAddress = 0;
; 701  :     PpuReg->VRamAddress = 0;
; 702  : 
; 703  :     vram_io *PpuIO = &Nes->Ppu.VRamIO;
; 704  :     PpuIO->TempVRamAdrs = 0;
; 705  :     PpuIO->LatchWrite = 0;
; 706  :     PpuIO->FineX = 0;
; 707  :     */
; 708  :     }

  00048	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004c	c3		 ret	 0
?reset@@YAXPEAUnes@@@Z ENDP				; reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
tv65 = 32
tv77 = 36
MemoryBase$1 = 40
BasePixel$2 = 48
$T3 = 64
$T4 = 176
__$ArrayPad$ = 4928
Nes$ = 4976
?power@@YAXPEAUnes@@@Z PROC				; power

; 666  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	b8 58 13 00 00	 mov	 eax, 4952		; 00001358H
  0000c	e8 00 00 00 00	 call	 __chkstk
  00011	48 2b e0	 sub	 rsp, rax
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 40
	13 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 667  :     PowerOn = !PowerOn;

  00026	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PowerOn@@3HA, 0
  0002d	75 0a		 jne	 SHORT $LN5@power
  0002f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv65[rsp], 1
  00037	eb 08		 jmp	 SHORT $LN6@power
$LN5@power:
  00039	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv65[rsp], 0
$LN6@power:
  00041	8b 44 24 20	 mov	 eax, DWORD PTR tv65[rsp]
  00045	89 05 00 00 00
	00		 mov	 DWORD PTR ?PowerOn@@3HA, eax

; 668  : 
; 669  :     if(PowerOn)

  0004b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PowerOn@@3HA, 0
  00052	74 64		 je	 SHORT $LN2@power

; 670  :     {
; 671  :         loadCartridge(Nes, RomFileName);

  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?RomFileName@@3PADA
  0005b	48 8b 8c 24 70
	13 00 00	 mov	 rcx, QWORD PTR Nes$[rsp]
  00063	e8 00 00 00 00	 call	 ?loadCartridge@@YAXPEAUnes@@PEAD@Z ; loadCartridge

; 672  :         Nes->Cpu.PrgCounter = (read8(RESET_VEC+1, Nes->Cpu.MemoryBase) << 8) | read8(RESET_VEC, Nes->Cpu.MemoryBase);

  00068	48 8b 84 24 70
	13 00 00	 mov	 rax, QWORD PTR Nes$[rsp]
  00070	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00074	66 b9 fd ff	 mov	 cx, 65533		; 0000fffdH
  00078	e8 00 00 00 00	 call	 ?read8@@YAEG_K@Z	; read8
  0007d	0f b6 c0	 movzx	 eax, al
  00080	c1 e0 08	 shl	 eax, 8
  00083	89 44 24 24	 mov	 DWORD PTR tv77[rsp], eax
  00087	48 8b 8c 24 70
	13 00 00	 mov	 rcx, QWORD PTR Nes$[rsp]
  0008f	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00093	66 b9 fc ff	 mov	 cx, 65532		; 0000fffcH
  00097	e8 00 00 00 00	 call	 ?read8@@YAEG_K@Z	; read8
  0009c	0f b6 c0	 movzx	 eax, al
  0009f	8b 4c 24 24	 mov	 ecx, DWORD PTR tv77[rsp]
  000a3	0b c8		 or	 ecx, eax
  000a5	8b c1		 mov	 eax, ecx
  000a7	48 8b 8c 24 70
	13 00 00	 mov	 rcx, QWORD PTR Nes$[rsp]
  000af	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 673  :     }
; 674  :     else

  000b3	e9 c3 00 00 00	 jmp	 $LN3@power
$LN2@power:

; 675  :     {
; 676  :         uint64 MemoryBase = Nes->Cpu.MemoryBase;

  000b8	48 8b 84 24 70
	13 00 00	 mov	 rax, QWORD PTR Nes$[rsp]
  000c0	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000c4	48 89 44 24 28	 mov	 QWORD PTR MemoryBase$1[rsp], rax

; 677  :         Nes->Cpu = {};

  000c9	48 8d 44 24 40	 lea	 rax, QWORD PTR $T3[rsp]
  000ce	48 8b f8	 mov	 rdi, rax
  000d1	33 c0		 xor	 eax, eax
  000d3	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  000d8	f3 aa		 rep stosb
  000da	48 8d 44 24 40	 lea	 rax, QWORD PTR $T3[rsp]
  000df	48 8b bc 24 70
	13 00 00	 mov	 rdi, QWORD PTR Nes$[rsp]
  000e7	48 8b f0	 mov	 rsi, rax
  000ea	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  000ef	f3 a4		 rep movsb

; 678  :         Nes->Cpu.MemoryBase = MemoryBase;

  000f1	48 8b 84 24 70
	13 00 00	 mov	 rax, QWORD PTR Nes$[rsp]
  000f9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR MemoryBase$1[rsp]
  000fe	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 679  : 
; 680  :         MemoryBase = Nes->Ppu.MemoryBase;

  00102	48 8b 84 24 70
	13 00 00	 mov	 rax, QWORD PTR Nes$[rsp]
  0010a	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0010e	48 89 44 24 28	 mov	 QWORD PTR MemoryBase$1[rsp], rax

; 681  :         uint32 *BasePixel = Nes->Ppu.BasePixel;

  00113	48 8b 84 24 70
	13 00 00	 mov	 rax, QWORD PTR Nes$[rsp]
  0011b	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  0011f	48 89 44 24 30	 mov	 QWORD PTR BasePixel$2[rsp], rax

; 682  :         Nes->Ppu = {};

  00124	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR $T4[rsp]
  0012c	48 8b f8	 mov	 rdi, rax
  0012f	33 c0		 xor	 eax, eax
  00131	b9 90 12 00 00	 mov	 ecx, 4752		; 00001290H
  00136	f3 aa		 rep stosb
  00138	48 8b 84 24 70
	13 00 00	 mov	 rax, QWORD PTR Nes$[rsp]
  00140	48 83 c0 70	 add	 rax, 112		; 00000070H
  00144	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR $T4[rsp]
  0014c	48 8b f8	 mov	 rdi, rax
  0014f	48 8b f1	 mov	 rsi, rcx
  00152	b9 90 12 00 00	 mov	 ecx, 4752		; 00001290H
  00157	f3 a4		 rep movsb

; 683  :         Nes->Ppu.MemoryBase = MemoryBase;

  00159	48 8b 84 24 70
	13 00 00	 mov	 rax, QWORD PTR Nes$[rsp]
  00161	48 8b 4c 24 28	 mov	 rcx, QWORD PTR MemoryBase$1[rsp]
  00166	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 684  :         Nes->Ppu.BasePixel = BasePixel;

  0016a	48 8b 84 24 70
	13 00 00	 mov	 rax, QWORD PTR Nes$[rsp]
  00172	48 8b 4c 24 30	 mov	 rcx, QWORD PTR BasePixel$2[rsp]
  00177	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx
$LN3@power:

; 685  :     }
; 686  : }

  0017b	48 8b 8c 24 40
	13 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00183	48 33 cc	 xor	 rcx, rsp
  00186	e8 00 00 00 00	 call	 __security_check_cookie
  0018b	48 81 c4 58 13
	00 00		 add	 rsp, 4952		; 00001358H
  00192	5f		 pop	 rdi
  00193	5e		 pop	 rsi
  00194	c3		 ret	 0
?power@@YAXPEAUnes@@@Z ENDP				; power
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Flags6$1 = 32
Cartridge$ = 40
Flags7$2 = 48
RomData$3 = 56
tv143 = 64
tv148 = 68
tv153 = 72
tv158 = 76
Ppu$ = 80
Cpu$ = 88
tv199 = 96
Nes$ = 128
FileName$ = 136
?loadCartridge@@YAXPEAUnes@@PEAD@Z PROC			; loadCartridge

; 604  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 605  :     cartridge *Cartridge = &Nes->Cartridge;

  0000e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Nes$[rsp]
  00016	48 05 00 13 00
	00		 add	 rax, 4864		; 00001300H
  0001c	48 89 44 24 28	 mov	 QWORD PTR Cartridge$[rsp], rax

; 606  :     cpu *Cpu = &Nes->Cpu;

  00021	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Nes$[rsp]
  00029	48 89 44 24 58	 mov	 QWORD PTR Cpu$[rsp], rax

; 607  :     ppu *Ppu = &Nes->Ppu;

  0002e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Nes$[rsp]
  00036	48 83 c0 70	 add	 rax, 112		; 00000070H
  0003a	48 89 44 24 50	 mov	 QWORD PTR Ppu$[rsp], rax

; 608  :         
; 609  :     // Reading rom file
; 610  :     Cartridge->FileName = FileName;

  0003f	48 8b 44 24 28	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00044	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR FileName$[rsp]
  0004c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 611  :     Cartridge->FileSize;
; 612  :     Cartridge->Data = (uint8 *)LoadFile(FileName, &Cartridge->FileSize);

  0004f	48 8b 44 24 28	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00054	48 83 c0 08	 add	 rax, 8
  00058	48 8b d0	 mov	 rdx, rax
  0005b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR FileName$[rsp]
  00063	e8 00 00 00 00	 call	 ?LoadFile@@YAPEAXPEADPEAI@Z ; LoadFile
  00068	48 8b 4c 24 28	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  0006d	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 613  : 
; 614  :     if(Cartridge->FileSize == 0)

  00071	48 8b 44 24 28	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00076	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0007a	75 14		 jne	 SHORT $LN2@loadCartri

; 615  :     {
; 616  :         PowerOn = false;

  0007c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PowerOn@@3HA, 0

; 617  :         return;

  00086	e9 b3 02 00 00	 jmp	 $LN1@loadCartri

; 618  :     }
; 619  :     else

  0008b	e9 ae 02 00 00	 jmp	 $LN3@loadCartri
$LN2@loadCartri:

; 620  :     {
; 621  :         PowerOn = true;

  00090	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?PowerOn@@3HA, 1

; 622  :     
; 623  :         uint8 * RomData = Cartridge->Data;

  0009a	48 8b 44 24 28	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0009f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a3	48 89 44 24 38	 mov	 QWORD PTR RomData$3[rsp], rax

; 624  :         
; 625  :         // NOTE: Check for correct header
; 626  :         if(RomData[0] != 'N' || RomData[1] != 'E' || RomData[2] != 'S' || RomData[3] != 0x1A)

  000a8	b8 01 00 00 00	 mov	 eax, 1
  000ad	48 6b c0 00	 imul	 rax, rax, 0
  000b1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR RomData$3[rsp]
  000b6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ba	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  000bd	75 45		 jne	 SHORT $LN5@loadCartri
  000bf	b8 01 00 00 00	 mov	 eax, 1
  000c4	48 6b c0 01	 imul	 rax, rax, 1
  000c8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR RomData$3[rsp]
  000cd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000d1	83 f8 45	 cmp	 eax, 69			; 00000045H
  000d4	75 2e		 jne	 SHORT $LN5@loadCartri
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 02	 imul	 rax, rax, 2
  000df	48 8b 4c 24 38	 mov	 rcx, QWORD PTR RomData$3[rsp]
  000e4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000e8	83 f8 53	 cmp	 eax, 83			; 00000053H
  000eb	75 17		 jne	 SHORT $LN5@loadCartri
  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	48 6b c0 03	 imul	 rax, rax, 3
  000f6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR RomData$3[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	83 f8 1a	 cmp	 eax, 26
  00102	74 12		 je	 SHORT $LN4@loadCartri
$LN5@loadCartri:

; 627  :             Assert(0);   

  00104	33 c0		 xor	 eax, eax
  00106	83 f8 01	 cmp	 eax, 1
  00109	74 0b		 je	 SHORT $LN6@loadCartri
  0010b	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN6@loadCartri:
$LN4@loadCartri:

; 628  : 
; 629  :         // NOTE: Read header
; 630  :         Cartridge->PrgBankCount = RomData[4];

  00116	b8 01 00 00 00	 mov	 eax, 1
  0011b	48 6b c0 04	 imul	 rax, rax, 4
  0011f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00124	48 8b 54 24 38	 mov	 rdx, QWORD PTR RomData$3[rsp]
  00129	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  0012d	88 41 18	 mov	 BYTE PTR [rcx+24], al

; 631  :         Cartridge->ChrBankCount = RomData[5];

  00130	b8 01 00 00 00	 mov	 eax, 1
  00135	48 6b c0 05	 imul	 rax, rax, 5
  00139	48 8b 4c 24 28	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  0013e	48 8b 54 24 38	 mov	 rdx, QWORD PTR RomData$3[rsp]
  00143	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00147	88 41 28	 mov	 BYTE PTR [rcx+40], al

; 632  :         uint8 Flags6            = RomData[6];        

  0014a	b8 01 00 00 00	 mov	 eax, 1
  0014f	48 6b c0 06	 imul	 rax, rax, 6
  00153	48 8b 4c 24 38	 mov	 rcx, QWORD PTR RomData$3[rsp]
  00158	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0015c	88 44 24 20	 mov	 BYTE PTR Flags6$1[rsp], al

; 633  :         uint8 Flags7            = RomData[7];

  00160	b8 01 00 00 00	 mov	 eax, 1
  00165	48 6b c0 07	 imul	 rax, rax, 7
  00169	48 8b 4c 24 38	 mov	 rcx, QWORD PTR RomData$3[rsp]
  0016e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00172	88 44 24 30	 mov	 BYTE PTR Flags7$2[rsp], al

; 634  :         Cartridge->PrgRamSize   = RomData[8];

  00176	b8 01 00 00 00	 mov	 eax, 1
  0017b	48 6b c0 08	 imul	 rax, rax, 8
  0017f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00184	48 8b 54 24 38	 mov	 rdx, QWORD PTR RomData$3[rsp]
  00189	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  0018d	88 41 38	 mov	 BYTE PTR [rcx+56], al

; 635  :         
; 636  :         Cartridge->UseVertMirror       = (Flags6 & (1)) != 0;

  00190	0f b6 44 24 20	 movzx	 eax, BYTE PTR Flags6$1[rsp]
  00195	83 e0 01	 and	 eax, 1
  00198	85 c0		 test	 eax, eax
  0019a	74 0a		 je	 SHORT $LN14@loadCartri
  0019c	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv143[rsp], 1
  001a4	eb 08		 jmp	 SHORT $LN15@loadCartri
$LN14@loadCartri:
  001a6	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv143[rsp], 0
$LN15@loadCartri:
  001ae	48 8b 44 24 28	 mov	 rax, QWORD PTR Cartridge$[rsp]
  001b3	8b 4c 24 40	 mov	 ecx, DWORD PTR tv143[rsp]
  001b7	89 48 3c	 mov	 DWORD PTR [rax+60], ecx

; 637  :         Cartridge->HasBatteryRam       = (Flags6 & (1 << 1)) != 0;

  001ba	0f b6 44 24 20	 movzx	 eax, BYTE PTR Flags6$1[rsp]
  001bf	83 e0 02	 and	 eax, 2
  001c2	85 c0		 test	 eax, eax
  001c4	74 0a		 je	 SHORT $LN16@loadCartri
  001c6	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv148[rsp], 1
  001ce	eb 08		 jmp	 SHORT $LN17@loadCartri
$LN16@loadCartri:
  001d0	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv148[rsp], 0
$LN17@loadCartri:
  001d8	48 8b 44 24 28	 mov	 rax, QWORD PTR Cartridge$[rsp]
  001dd	8b 4c 24 44	 mov	 ecx, DWORD PTR tv148[rsp]
  001e1	89 48 40	 mov	 DWORD PTR [rax+64], ecx

; 638  :         Cartridge->HasTrainer          = (Flags6 & (1 << 2)) != 0;

  001e4	0f b6 44 24 20	 movzx	 eax, BYTE PTR Flags6$1[rsp]
  001e9	83 e0 04	 and	 eax, 4
  001ec	85 c0		 test	 eax, eax
  001ee	74 0a		 je	 SHORT $LN18@loadCartri
  001f0	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv153[rsp], 1
  001f8	eb 08		 jmp	 SHORT $LN19@loadCartri
$LN18@loadCartri:
  001fa	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
$LN19@loadCartri:
  00202	48 8b 44 24 28	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00207	8b 4c 24 48	 mov	 ecx, DWORD PTR tv153[rsp]
  0020b	89 48 44	 mov	 DWORD PTR [rax+68], ecx

; 639  :         Cartridge->UseFourScreenMirror = (Flags6 & (1 << 3)) != 0;

  0020e	0f b6 44 24 20	 movzx	 eax, BYTE PTR Flags6$1[rsp]
  00213	83 e0 08	 and	 eax, 8
  00216	85 c0		 test	 eax, eax
  00218	74 0a		 je	 SHORT $LN20@loadCartri
  0021a	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv158[rsp], 1
  00222	eb 08		 jmp	 SHORT $LN21@loadCartri
$LN20@loadCartri:
  00224	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv158[rsp], 0
$LN21@loadCartri:
  0022c	48 8b 44 24 28	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00231	8b 4c 24 4c	 mov	 ecx, DWORD PTR tv158[rsp]
  00235	89 48 48	 mov	 DWORD PTR [rax+72], ecx

; 640  :         Cartridge->MapperNum           = (Flags7 & 0xF0) | (Flags6 >> 4);

  00238	0f b6 44 24 30	 movzx	 eax, BYTE PTR Flags7$2[rsp]
  0023d	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00242	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Flags6$1[rsp]
  00247	c1 f9 04	 sar	 ecx, 4
  0024a	0b c1		 or	 eax, ecx
  0024c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00251	88 41 39	 mov	 BYTE PTR [rcx+57], al

; 641  : 
; 642  :         Assert(Cartridge->UseFourScreenMirror == 0);

  00254	48 8b 44 24 28	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00259	83 78 48 00	 cmp	 DWORD PTR [rax+72], 0
  0025d	74 0b		 je	 SHORT $LN7@loadCartri
  0025f	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN7@loadCartri:

; 643  :         
; 644  :         if(Cartridge->UseFourScreenMirror)

  0026a	48 8b 44 24 28	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0026f	83 78 48 00	 cmp	 DWORD PTR [rax+72], 0
  00273	74 14		 je	 SHORT $LN8@loadCartri

; 645  :             Nes->Ppu.MirrorType = FOUR_SCREEN_MIRROR;

  00275	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Nes$[rsp]
  0027d	c7 80 84 00 00
	00 04 00 00 00	 mov	 DWORD PTR [rax+132], 4
  00287	eb 31		 jmp	 SHORT $LN9@loadCartri
$LN8@loadCartri:

; 646  :         else if(Cartridge->UseVertMirror)

  00289	48 8b 44 24 28	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0028e	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00292	74 14		 je	 SHORT $LN10@loadCartri

; 647  :             Nes->Ppu.MirrorType = VERTICAL_MIRROR;

  00294	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Nes$[rsp]
  0029c	c7 80 84 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+132], 2

; 648  :         else

  002a6	eb 12		 jmp	 SHORT $LN11@loadCartri
$LN10@loadCartri:

; 649  :             Nes->Ppu.MirrorType = HORIZONTAL_MIRROR;      

  002a8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Nes$[rsp]
  002b0	c7 80 84 00 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+132], 3
$LN11@loadCartri:
$LN9@loadCartri:

; 650  :         
; 651  :         Cartridge->PrgData = RomData + 16; // PrgData starts after the header info(16 bytes)

  002ba	48 8b 44 24 38	 mov	 rax, QWORD PTR RomData$3[rsp]
  002bf	48 83 c0 10	 add	 rax, 16
  002c3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  002c8	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 652  : 
; 653  :         if(Cartridge->HasTrainer)

  002cc	48 8b 44 24 28	 mov	 rax, QWORD PTR Cartridge$[rsp]
  002d1	83 78 44 00	 cmp	 DWORD PTR [rax+68], 0
  002d5	74 18		 je	 SHORT $LN12@loadCartri

; 654  :         {
; 655  :             Cartridge->PrgData += 512; // Trainer size 512 bytes

  002d7	48 8b 44 24 28	 mov	 rax, QWORD PTR Cartridge$[rsp]
  002dc	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  002e0	48 05 00 02 00
	00		 add	 rax, 512		; 00000200H
  002e6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  002eb	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
$LN12@loadCartri:

; 656  :         }
; 657  : 
; 658  :         Cartridge->ChrData = Cartridge->PrgData + (Cartridge->PrgBankCount * Kilobytes(16));

  002ef	48 8b 44 24 28	 mov	 rax, QWORD PTR Cartridge$[rsp]
  002f4	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  002f8	48 69 c0 00 40
	00 00		 imul	 rax, rax, 16384		; 00004000H
  002ff	48 8b 4c 24 28	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00304	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00308	48 8b 4c 24 28	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  0030d	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 659  : 
; 660  :         mapperInit[Cartridge->MapperNum](Cartridge, Cpu, Ppu);

  00311	48 8b 44 24 28	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00316	0f b6 40 39	 movzx	 eax, BYTE PTR [rax+57]
  0031a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mapperInit@@3PAP6AXPEAUcartridge@@PEAUcpu@@PEAUppu@@@ZA ; mapperInit
  00321	48 89 4c 24 60	 mov	 QWORD PTR tv199[rsp], rcx
  00326	4c 8b 44 24 50	 mov	 r8, QWORD PTR Ppu$[rsp]
  0032b	48 8b 54 24 58	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00330	48 8b 4c 24 28	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00335	4c 8b 4c 24 60	 mov	 r9, QWORD PTR tv199[rsp]
  0033a	41 ff 14 c1	 call	 QWORD PTR [r9+rax*8]
$LN3@loadCartri:
$LN1@loadCartri:

; 661  :     }
; 662  : }

  0033e	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00342	c3		 ret	 0
?loadCartridge@@YAXPEAUnes@@PEAD@Z ENDP			; loadCartridge
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
SelectedBank$ = 32
MemoryPrgBank$ = 36
BankToCpy$ = 40
Cartridge$ = 64
Cpu$ = 72
Ppu$ = 80
?axromUpdate@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z PROC ; axromUpdate

; 579  : {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 580  :     uint16 MemoryPrgBank = 0x8000;

  00013	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00018	66 89 44 24 24	 mov	 WORD PTR MemoryPrgBank$[rsp], ax

; 581  :     
; 582  :     uint8 SelectedBank = Cpu->MapperReg & 7;

  0001d	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00022	0f b6 40 10	 movzx	 eax, BYTE PTR [rax+16]
  00026	83 e0 07	 and	 eax, 7
  00029	88 44 24 20	 mov	 BYTE PTR SelectedBank$[rsp], al

; 583  :     uint8 *BankToCpy = Cartridge->PrgData + (SelectedBank * Kilobytes(32));

  0002d	0f b6 44 24 20	 movzx	 eax, BYTE PTR SelectedBank$[rsp]
  00032	48 69 c0 00 80
	00 00		 imul	 rax, rax, 32768		; 00008000H
  00039	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  0003e	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00042	48 89 44 24 28	 mov	 QWORD PTR BankToCpy$[rsp], rax

; 584  :     
; 585  :     cpyMemory((uint8 *)MemoryPrgBank + Cpu->MemoryBase, BankToCpy, Kilobytes(32));

  00047	0f b7 44 24 24	 movzx	 eax, WORD PTR MemoryPrgBank$[rsp]
  0004c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00051	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00055	66 41 b8 00 80	 mov	 r8w, 32768		; 00008000H
  0005a	48 8b 54 24 28	 mov	 rdx, QWORD PTR BankToCpy$[rsp]
  0005f	48 8b c8	 mov	 rcx, rax
  00062	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 586  : 
; 587  :     // Nametable Single Screen bank select
; 588  :     if(Cpu->MapperReg & 0x10)

  00067	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0006c	0f b6 40 10	 movzx	 eax, BYTE PTR [rax+16]
  00070	83 e0 10	 and	 eax, 16
  00073	85 c0		 test	 eax, eax
  00075	74 0e		 je	 SHORT $LN2@axromUpdat

; 589  :     {
; 590  :         Ppu->MirrorType = SINGLE_SCREEN_BANK_B;   

  00077	48 8b 44 24 50	 mov	 rax, QWORD PTR Ppu$[rsp]
  0007c	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [rax+20], 1

; 591  :     }
; 592  :     else

  00083	eb 0c		 jmp	 SHORT $LN3@axromUpdat
$LN2@axromUpdat:

; 593  :     {
; 594  :         Ppu->MirrorType = SINGLE_SCREEN_BANK_A;

  00085	48 8b 44 24 50	 mov	 rax, QWORD PTR Ppu$[rsp]
  0008a	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0
$LN3@axromUpdat:

; 595  :     }
; 596  : }

  00091	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00095	c3		 ret	 0
?axromUpdate@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ENDP ; axromUpdate
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
BankNumber$ = 32
MemPrgBank1$ = 36
BankToCpy$ = 40
Cartridge$ = 64
Cpu$ = 72
Ppu$ = 80
?unromUpdate@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z PROC ; unromUpdate

; 570  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 571  :     uint16 MemPrgBank1 = 0x8000;

  00013	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00018	66 89 44 24 24	 mov	 WORD PTR MemPrgBank1$[rsp], ax

; 572  :     uint8 BankNumber = Cpu->MapperReg;

  0001d	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00022	0f b6 40 10	 movzx	 eax, BYTE PTR [rax+16]
  00026	88 44 24 20	 mov	 BYTE PTR BankNumber$[rsp], al

; 573  :     
; 574  :     uint8 * BankToCpy = Cartridge->PrgData + (BankNumber * Kilobytes(16));

  0002a	0f b6 44 24 20	 movzx	 eax, BYTE PTR BankNumber$[rsp]
  0002f	48 69 c0 00 40
	00 00		 imul	 rax, rax, 16384		; 00004000H
  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  0003b	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0003f	48 89 44 24 28	 mov	 QWORD PTR BankToCpy$[rsp], rax

; 575  :     cpyMemory((uint8 *)MemPrgBank1 + Cpu->MemoryBase, BankToCpy, Kilobytes(16));

  00044	0f b7 44 24 24	 movzx	 eax, WORD PTR MemPrgBank1$[rsp]
  00049	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0004e	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00052	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  00057	48 8b 54 24 28	 mov	 rdx, QWORD PTR BankToCpy$[rsp]
  0005c	48 8b c8	 mov	 rcx, rax
  0005f	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 576  : }

  00064	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00068	c3		 ret	 0
?unromUpdate@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ENDP ; unromUpdate
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
DataReg$1 = 32
Mirror$2 = 33
SizeToCpy$3 = 34
bit13Set$4 = 36
bit14Set$5 = 40
tv67 = 44
tv71 = 48
tv79 = 52
tv140 = 56
tv145 = 60
BankToCpy$6 = 64
PrgRomBank1$ = 72
PrgRomBank2$ = 76
IsClearBitSet$7 = 80
IsLargePrg$ = 84
IsLargeChr$ = 88
BankToCpy$8 = 96
BankToCpy$9 = 104
Cartridge$ = 128
Cpu$ = 136
Ppu$ = 144
?mmc1Update@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z PROC ; mmc1Update

; 464  : {

$LN37:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 465  :     uint16 PrgRomBank1 = 0x8000;

  00013	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00018	66 89 44 24 48	 mov	 WORD PTR PrgRomBank1$[rsp], ax

; 466  :     uint16 PrgRomBank2 = 0xC000;

  0001d	b8 00 c0 00 00	 mov	 eax, 49152		; 0000c000H
  00022	66 89 44 24 4c	 mov	 WORD PTR PrgRomBank2$[rsp], ax

; 467  : 
; 468  :     bool32 IsLargePrg = (Cartridge->PrgBankCount > 16);

  00027	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0002f	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  00033	83 f8 10	 cmp	 eax, 16
  00036	7e 0a		 jle	 SHORT $LN27@mmc1Update
  00038	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  00040	eb 08		 jmp	 SHORT $LN28@mmc1Update
$LN27@mmc1Update:
  00042	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN28@mmc1Update:
  0004a	8b 44 24 2c	 mov	 eax, DWORD PTR tv67[rsp]
  0004e	89 44 24 54	 mov	 DWORD PTR IsLargePrg$[rsp], eax

; 469  :     bool32 IsLargeChr = (Cartridge->ChrBankCount > 1);

  00052	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0005a	0f b6 40 28	 movzx	 eax, BYTE PTR [rax+40]
  0005e	83 f8 01	 cmp	 eax, 1
  00061	7e 0a		 jle	 SHORT $LN29@mmc1Update
  00063	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv71[rsp], 1
  0006b	eb 08		 jmp	 SHORT $LN30@mmc1Update
$LN29@mmc1Update:
  0006d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
$LN30@mmc1Update:
  00075	8b 44 24 30	 mov	 eax, DWORD PTR tv71[rsp]
  00079	89 44 24 58	 mov	 DWORD PTR IsLargeChr$[rsp], eax

; 470  : 
; 471  :     // TODO: Figure a way to deal with these static values
; 472  :     static uint8 PrgRomMode;
; 473  :     static uint8 ChrRomMode;
; 474  :     
; 475  :     if(Cpu->MapperWrite)

  0007d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  00085	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  00089	0f 84 0f 04 00
	00		 je	 $LN2@mmc1Update

; 476  :     {
; 477  :         Cpu->MapperWrite = false;

  0008f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  00097	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 478  :         
; 479  :         bool32 IsClearBitSet = (Cpu->MapperReg & (1 << 7)) != 0;

  0009e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  000a6	0f b6 40 10	 movzx	 eax, BYTE PTR [rax+16]
  000aa	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000af	85 c0		 test	 eax, eax
  000b1	74 0a		 je	 SHORT $LN31@mmc1Update
  000b3	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  000bb	eb 08		 jmp	 SHORT $LN32@mmc1Update
$LN31@mmc1Update:
  000bd	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN32@mmc1Update:
  000c5	8b 44 24 34	 mov	 eax, DWORD PTR tv79[rsp]
  000c9	89 44 24 50	 mov	 DWORD PTR IsClearBitSet$7[rsp], eax

; 480  :         if(IsClearBitSet)

  000cd	83 7c 24 50 00	 cmp	 DWORD PTR IsClearBitSet$7[rsp], 0
  000d2	74 29		 je	 SHORT $LN3@mmc1Update

; 481  :         {
; 482  :             Cpu->MapperWriteCount = 0;

  000d4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  000dc	c6 40 18 00	 mov	 BYTE PTR [rax+24], 0

; 483  :             Cpu->MapperReg = 0;

  000e0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  000e8	c6 40 10 00	 mov	 BYTE PTR [rax+16], 0

; 484  :             Cartridge->MapperInternalReg = 0;

  000ec	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Cartridge$[rsp]
  000f4	c6 40 4c 00	 mov	 BYTE PTR [rax+76], 0

; 485  :         }
; 486  :         else

  000f8	e9 a1 03 00 00	 jmp	 $LN4@mmc1Update
$LN3@mmc1Update:

; 487  :         {
; 488  :             ++Cpu->MapperWriteCount;

  000fd	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  00105	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  00109	fe c0		 inc	 al
  0010b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00113	88 41 18	 mov	 BYTE PTR [rcx+24], al

; 489  :             
; 490  :             Cartridge->MapperInternalReg = (Cartridge->MapperInternalReg << 1);

  00116	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0011e	0f b6 40 4c	 movzx	 eax, BYTE PTR [rax+76]
  00122	d1 e0		 shl	 eax, 1
  00124	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  0012c	88 41 4c	 mov	 BYTE PTR [rcx+76], al

; 491  :             Cartridge->MapperInternalReg |= (Cpu->MapperReg & 1);

  0012f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  00137	0f b6 40 10	 movzx	 eax, BYTE PTR [rax+16]
  0013b	83 e0 01	 and	 eax, 1
  0013e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00146	0f b6 49 4c	 movzx	 ecx, BYTE PTR [rcx+76]
  0014a	0b c8		 or	 ecx, eax
  0014c	8b c1		 mov	 eax, ecx
  0014e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00156	88 41 4c	 mov	 BYTE PTR [rcx+76], al

; 492  :             
; 493  :             if(Cpu->MapperWriteCount == 5) // On 5th write

  00159	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  00161	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  00165	83 f8 05	 cmp	 eax, 5
  00168	0f 85 30 03 00
	00		 jne	 $LN5@mmc1Update

; 494  :             {
; 495  :                 uint8 DataReg = Cartridge->MapperInternalReg;

  0016e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00176	0f b6 40 4c	 movzx	 eax, BYTE PTR [rax+76]
  0017a	88 44 24 20	 mov	 BYTE PTR DataReg$1[rsp], al

; 496  :                 
; 497  :                 bool32 bit13Set = (Cpu->MapperWriteAddress & (1 << 13)) != 0;

  0017e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  00186	0f b7 40 12	 movzx	 eax, WORD PTR [rax+18]
  0018a	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  0018f	85 c0		 test	 eax, eax
  00191	74 0a		 je	 SHORT $LN33@mmc1Update
  00193	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv140[rsp], 1
  0019b	eb 08		 jmp	 SHORT $LN34@mmc1Update
$LN33@mmc1Update:
  0019d	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv140[rsp], 0
$LN34@mmc1Update:
  001a5	8b 44 24 38	 mov	 eax, DWORD PTR tv140[rsp]
  001a9	89 44 24 24	 mov	 DWORD PTR bit13Set$4[rsp], eax

; 498  :                 bool32 bit14Set = (Cpu->MapperWriteAddress & (1 << 14)) != 0;

  001ad	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  001b5	0f b7 40 12	 movzx	 eax, WORD PTR [rax+18]
  001b9	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  001be	85 c0		 test	 eax, eax
  001c0	74 0a		 je	 SHORT $LN35@mmc1Update
  001c2	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv145[rsp], 1
  001ca	eb 08		 jmp	 SHORT $LN36@mmc1Update
$LN35@mmc1Update:
  001cc	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN36@mmc1Update:
  001d4	8b 44 24 3c	 mov	 eax, DWORD PTR tv145[rsp]
  001d8	89 44 24 28	 mov	 DWORD PTR bit14Set$5[rsp], eax

; 499  : 
; 500  :                 if(!bit13Set && !bit14Set)     // Control Reg

  001dc	83 7c 24 24 00	 cmp	 DWORD PTR bit13Set$4[rsp], 0
  001e1	0f 85 a1 00 00
	00		 jne	 $LN6@mmc1Update
  001e7	83 7c 24 28 00	 cmp	 DWORD PTR bit14Set$5[rsp], 0
  001ec	0f 85 96 00 00
	00		 jne	 $LN6@mmc1Update

; 501  :                 {
; 502  :                     uint8 Mirror = DataReg & 3;

  001f2	0f b6 44 24 20	 movzx	 eax, BYTE PTR DataReg$1[rsp]
  001f7	83 e0 03	 and	 eax, 3
  001fa	88 44 24 21	 mov	 BYTE PTR Mirror$2[rsp], al

; 503  :                     if(Mirror == 0)

  001fe	0f b6 44 24 21	 movzx	 eax, BYTE PTR Mirror$2[rsp]
  00203	85 c0		 test	 eax, eax
  00205	75 0f		 jne	 SHORT $LN8@mmc1Update

; 504  :                         Ppu->MirrorType = SINGLE_SCREEN_BANK_A;

  00207	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0020f	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0
$LN8@mmc1Update:

; 505  :                     if(Mirror == 1)

  00216	0f b6 44 24 21	 movzx	 eax, BYTE PTR Mirror$2[rsp]
  0021b	83 f8 01	 cmp	 eax, 1
  0021e	75 0f		 jne	 SHORT $LN9@mmc1Update

; 506  :                         Ppu->MirrorType = SINGLE_SCREEN_BANK_B;

  00220	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00228	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [rax+20], 1
$LN9@mmc1Update:

; 507  :                     if(Mirror == 2)

  0022f	0f b6 44 24 21	 movzx	 eax, BYTE PTR Mirror$2[rsp]
  00234	83 f8 02	 cmp	 eax, 2
  00237	75 0f		 jne	 SHORT $LN10@mmc1Update

; 508  :                         Ppu->MirrorType = VERTICAL_MIRROR;

  00239	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00241	c7 40 14 02 00
	00 00		 mov	 DWORD PTR [rax+20], 2
$LN10@mmc1Update:

; 509  :                     if(Mirror == 3)

  00248	0f b6 44 24 21	 movzx	 eax, BYTE PTR Mirror$2[rsp]
  0024d	83 f8 03	 cmp	 eax, 3
  00250	75 0f		 jne	 SHORT $LN11@mmc1Update

; 510  :                         Ppu->MirrorType = HORIZONTAL_MIRROR;

  00252	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0025a	c7 40 14 03 00
	00 00		 mov	 DWORD PTR [rax+20], 3
$LN11@mmc1Update:

; 511  :                                         
; 512  :                     PrgRomMode = (DataReg & 12) >> 2;

  00261	0f b6 44 24 20	 movzx	 eax, BYTE PTR DataReg$1[rsp]
  00266	83 e0 0c	 and	 eax, 12
  00269	c1 f8 02	 sar	 eax, 2
  0026c	88 05 00 00 00
	00		 mov	 BYTE PTR ?PrgRomMode@?1??mmc1Update@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z@4EA, al

; 513  :                     ChrRomMode = (DataReg & (1 << 4)) >> 4;

  00272	0f b6 44 24 20	 movzx	 eax, BYTE PTR DataReg$1[rsp]
  00277	83 e0 10	 and	 eax, 16
  0027a	c1 f8 04	 sar	 eax, 4
  0027d	88 05 00 00 00
	00		 mov	 BYTE PTR ?ChrRomMode@?1??mmc1Update@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z@4EA, al
  00283	e9 f2 01 00 00	 jmp	 $LN7@mmc1Update
$LN6@mmc1Update:

; 514  :                 }
; 515  :                 else if(bit13Set && !bit14Set) // CHR Bank 0

  00288	83 7c 24 24 00	 cmp	 DWORD PTR bit13Set$4[rsp], 0
  0028d	74 72		 je	 SHORT $LN12@mmc1Update
  0028f	83 7c 24 28 00	 cmp	 DWORD PTR bit14Set$5[rsp], 0
  00294	75 6b		 jne	 SHORT $LN12@mmc1Update

; 516  :                 {
; 517  :                     uint8 SizeToCpy = 0;

  00296	c6 44 24 22 00	 mov	 BYTE PTR SizeToCpy$3[rsp], 0

; 518  :                     
; 519  :                     if(ChrRomMode == 1) // 8kb mode Low bit ignored

  0029b	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ChrRomMode@?1??mmc1Update@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z@4EA
  002a2	83 f8 01	 cmp	 eax, 1
  002a5	75 12		 jne	 SHORT $LN14@mmc1Update

; 520  :                     {
; 521  :                         DataReg = DataReg >> 1;

  002a7	0f b6 44 24 20	 movzx	 eax, BYTE PTR DataReg$1[rsp]
  002ac	d1 f8		 sar	 eax, 1
  002ae	88 44 24 20	 mov	 BYTE PTR DataReg$1[rsp], al

; 522  :                         SizeToCpy = Kilobytes(8);

  002b2	c6 44 24 22 00	 mov	 BYTE PTR SizeToCpy$3[rsp], 0

; 523  :                     }
; 524  :                     else

  002b7	eb 05		 jmp	 SHORT $LN15@mmc1Update
$LN14@mmc1Update:

; 525  :                     {
; 526  :                         SizeToCpy = Kilobytes(4);

  002b9	c6 44 24 22 00	 mov	 BYTE PTR SizeToCpy$3[rsp], 0
$LN15@mmc1Update:

; 527  :                     }
; 528  :                     uint8 * BankToCpy = Cartridge->ChrData + (DataReg * SizeToCpy);              

  002be	0f b6 44 24 20	 movzx	 eax, BYTE PTR DataReg$1[rsp]
  002c3	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR SizeToCpy$3[rsp]
  002c8	0f af c1	 imul	 eax, ecx
  002cb	48 98		 cdqe
  002cd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  002d5	48 03 41 30	 add	 rax, QWORD PTR [rcx+48]
  002d9	48 89 44 24 60	 mov	 QWORD PTR BankToCpy$8[rsp], rax

; 529  :                     cpyMemory((uint8 *)Ppu->MemoryBase, BankToCpy, SizeToCpy);

  002de	0f b6 44 24 22	 movzx	 eax, BYTE PTR SizeToCpy$3[rsp]
  002e3	44 0f b7 c0	 movzx	 r8d, ax
  002e7	48 8b 54 24 60	 mov	 rdx, QWORD PTR BankToCpy$8[rsp]
  002ec	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  002f4	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  002f7	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory
  002fc	e9 79 01 00 00	 jmp	 $LN13@mmc1Update
$LN12@mmc1Update:

; 530  :                 }
; 531  :                 else if(!bit13Set && bit14Set) // CHR Bank 1

  00301	83 7c 24 24 00	 cmp	 DWORD PTR bit13Set$4[rsp], 0
  00306	75 58		 jne	 SHORT $LN16@mmc1Update
  00308	83 7c 24 28 00	 cmp	 DWORD PTR bit14Set$5[rsp], 0
  0030d	74 51		 je	 SHORT $LN16@mmc1Update

; 532  :                 {
; 533  :                     if(ChrRomMode == 1) // 4kb mode

  0030f	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ChrRomMode@?1??mmc1Update@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z@4EA
  00316	83 f8 01	 cmp	 eax, 1
  00319	75 40		 jne	 SHORT $LN18@mmc1Update

; 534  :                     {
; 535  :                         uint8 * BankToCpy = Cartridge->ChrData + (DataReg * Kilobytes(4));              

  0031b	0f b6 44 24 20	 movzx	 eax, BYTE PTR DataReg$1[rsp]
  00320	48 69 c0 00 10
	00 00		 imul	 rax, rax, 4096		; 00001000H
  00327	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  0032f	48 03 41 30	 add	 rax, QWORD PTR [rcx+48]
  00333	48 89 44 24 68	 mov	 QWORD PTR BankToCpy$9[rsp], rax

; 536  :                         cpyMemory((uint8 *)Ppu->MemoryBase + 0x1000, BankToCpy, Kilobytes(4));

  00338	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00340	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00343	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00349	66 41 b8 00 10	 mov	 r8w, 4096		; 00001000H
  0034e	48 8b 54 24 68	 mov	 rdx, QWORD PTR BankToCpy$9[rsp]
  00353	48 8b c8	 mov	 rcx, rax
  00356	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory
$LN18@mmc1Update:

; 537  :                     }
; 538  :                 }

  0035b	e9 1a 01 00 00	 jmp	 $LN17@mmc1Update
$LN16@mmc1Update:

; 539  :                 else if(bit13Set && bit14Set) // PRG bank

  00360	83 7c 24 24 00	 cmp	 DWORD PTR bit13Set$4[rsp], 0
  00365	0f 84 0f 01 00
	00		 je	 $LN19@mmc1Update
  0036b	83 7c 24 28 00	 cmp	 DWORD PTR bit14Set$5[rsp], 0
  00370	0f 84 04 01 00
	00		 je	 $LN19@mmc1Update

; 540  :                 {
; 541  :                     uint8 * BankToCpy;
; 542  :                     if(PrgRomMode == 0 || PrgRomMode == 1) // 32kib Mode

  00376	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?PrgRomMode@?1??mmc1Update@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z@4EA
  0037d	85 c0		 test	 eax, eax
  0037f	74 0c		 je	 SHORT $LN22@mmc1Update
  00381	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?PrgRomMode@?1??mmc1Update@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z@4EA
  00388	83 f8 01	 cmp	 eax, 1
  0038b	75 51		 jne	 SHORT $LN20@mmc1Update
$LN22@mmc1Update:

; 543  :                     {
; 544  :                         DataReg = DataReg >> 1;

  0038d	0f b6 44 24 20	 movzx	 eax, BYTE PTR DataReg$1[rsp]
  00392	d1 f8		 sar	 eax, 1
  00394	88 44 24 20	 mov	 BYTE PTR DataReg$1[rsp], al

; 545  :                         BankToCpy = Cartridge->PrgData + (DataReg * Kilobytes(32));              

  00398	0f b6 44 24 20	 movzx	 eax, BYTE PTR DataReg$1[rsp]
  0039d	48 69 c0 00 80
	00 00		 imul	 rax, rax, 32768		; 00008000H
  003a4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  003ac	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  003b0	48 89 44 24 40	 mov	 QWORD PTR BankToCpy$6[rsp], rax

; 546  :                         cpyMemory((uint8 *)Cpu->MemoryBase + 0x8000, BankToCpy, Kilobytes(32));

  003b5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  003bd	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  003c1	48 05 00 80 00
	00		 add	 rax, 32768		; 00008000H
  003c7	66 41 b8 00 80	 mov	 r8w, 32768		; 00008000H
  003cc	48 8b 54 24 40	 mov	 rdx, QWORD PTR BankToCpy$6[rsp]
  003d1	48 8b c8	 mov	 rcx, rax
  003d4	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory
  003d9	e9 9c 00 00 00	 jmp	 $LN21@mmc1Update
$LN20@mmc1Update:

; 547  :                     }
; 548  :                     else if(PrgRomMode == 2) // 16kb low bank

  003de	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?PrgRomMode@?1??mmc1Update@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z@4EA
  003e5	83 f8 02	 cmp	 eax, 2
  003e8	75 43		 jne	 SHORT $LN23@mmc1Update

; 549  :                     {
; 550  :                         BankToCpy = Cartridge->PrgData + (DataReg * Kilobytes(32));              

  003ea	0f b6 44 24 20	 movzx	 eax, BYTE PTR DataReg$1[rsp]
  003ef	48 69 c0 00 80
	00 00		 imul	 rax, rax, 32768		; 00008000H
  003f6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  003fe	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00402	48 89 44 24 40	 mov	 QWORD PTR BankToCpy$6[rsp], rax

; 551  :                         cpyMemory((uint8 *)Cpu->MemoryBase + 0x8000, BankToCpy, Kilobytes(16));

  00407	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  0040f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00413	48 05 00 80 00
	00		 add	 rax, 32768		; 00008000H
  00419	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  0041e	48 8b 54 24 40	 mov	 rdx, QWORD PTR BankToCpy$6[rsp]
  00423	48 8b c8	 mov	 rcx, rax
  00426	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory
  0042b	eb 4d		 jmp	 SHORT $LN24@mmc1Update
$LN23@mmc1Update:

; 552  :                         
; 553  :                     }
; 554  :                     else if(PrgRomMode == 3) // 16kb high bank

  0042d	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?PrgRomMode@?1??mmc1Update@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z@4EA
  00434	83 f8 03	 cmp	 eax, 3
  00437	75 41		 jne	 SHORT $LN25@mmc1Update

; 555  :                     {
; 556  :                         BankToCpy = Cartridge->PrgData + (DataReg * Kilobytes(32));              

  00439	0f b6 44 24 20	 movzx	 eax, BYTE PTR DataReg$1[rsp]
  0043e	48 69 c0 00 80
	00 00		 imul	 rax, rax, 32768		; 00008000H
  00445	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  0044d	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00451	48 89 44 24 40	 mov	 QWORD PTR BankToCpy$6[rsp], rax

; 557  :                         cpyMemory((uint8 *)Cpu->MemoryBase + 0xC000, BankToCpy, Kilobytes(16));

  00456	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  0045e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00462	48 05 00 c0 00
	00		 add	 rax, 49152		; 0000c000H
  00468	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  0046d	48 8b 54 24 40	 mov	 rdx, QWORD PTR BankToCpy$6[rsp]
  00472	48 8b c8	 mov	 rcx, rax
  00475	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory
$LN25@mmc1Update:
$LN24@mmc1Update:
$LN21@mmc1Update:
$LN19@mmc1Update:
$LN17@mmc1Update:
$LN13@mmc1Update:
$LN7@mmc1Update:

; 558  :                     }
; 559  :                 }
; 560  :                 
; 561  :                 Cpu->MapperWriteCount = 0;

  0047a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  00482	c6 40 18 00	 mov	 BYTE PTR [rax+24], 0

; 562  :                 Cpu->MapperReg = 0;

  00486	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  0048e	c6 40 10 00	 mov	 BYTE PTR [rax+16], 0

; 563  :                 Cartridge->MapperInternalReg = 0;

  00492	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0049a	c6 40 4c 00	 mov	 BYTE PTR [rax+76], 0
$LN5@mmc1Update:
$LN4@mmc1Update:
$LN2@mmc1Update:

; 564  :             }
; 565  :         }
; 566  :     }
; 567  : }

  0049e	48 83 c4 78	 add	 rsp, 120		; 00000078H
  004a2	c3		 ret	 0
?mmc1Update@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ENDP ; mmc1Update
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Cartridge$ = 8
Cpu$ = 16
Ppu$ = 24
?nromUpdate@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z PROC ; nromUpdate

; 459  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 460  :     Assert(0);

  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 0b		 je	 SHORT $LN2@nromUpdate
  00016	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@nromUpdate:

; 461  : }

  00021	c3		 ret	 0
?nromUpdate@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ENDP ; nromUpdate
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
MemoryPrgBank$ = 32
BankToCpy$ = 40
Cartridge$ = 64
Cpu$ = 72
Ppu$ = 80
?axromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z PROC	; axromInit

; 443  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 444  :     uint16 MemoryPrgBank = 0x8000;

  00013	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00018	66 89 44 24 20	 mov	 WORD PTR MemoryPrgBank$[rsp], ax

; 445  :     uint8 *BankToCpy = Cartridge->PrgData + ((Cartridge->PrgBankCount) * Kilobytes(16)) - Kilobytes(32);

  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00022	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  00026	48 69 c0 00 40
	00 00		 imul	 rax, rax, 16384		; 00004000H
  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00032	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00036	48 8d 84 01 00
	80 ff ff	 lea	 rax, QWORD PTR [rcx+rax-32768]
  0003e	48 89 44 24 28	 mov	 QWORD PTR BankToCpy$[rsp], rax

; 446  :     cpyMemory((uint8 *)MemoryPrgBank + Cpu->MemoryBase, BankToCpy, Kilobytes(32));

  00043	0f b7 44 24 20	 movzx	 eax, WORD PTR MemoryPrgBank$[rsp]
  00048	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0004d	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00051	66 41 b8 00 80	 mov	 r8w, 32768		; 00008000H
  00056	48 8b 54 24 28	 mov	 rdx, QWORD PTR BankToCpy$[rsp]
  0005b	48 8b c8	 mov	 rcx, rax
  0005e	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 447  : 
; 448  :     Ppu->MirrorType = SINGLE_SCREEN_BANK_A;

  00063	48 8b 44 24 50	 mov	 rax, QWORD PTR Ppu$[rsp]
  00068	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 449  : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
?axromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ENDP	; axromInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
MemPrgBank1$ = 32
MemPrgBank2$ = 36
BankToCpy1$ = 40
BankToCpy2$ = 48
Cartridge$ = 80
Cpu$ = 88
Ppu$ = 96
?unromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z PROC	; unromInit

; 431  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 432  :     uint16 MemPrgBank1 = 0x8000;

  00013	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00018	66 89 44 24 20	 mov	 WORD PTR MemPrgBank1$[rsp], ax

; 433  :     uint16 MemPrgBank2 = 0xC000;

  0001d	b8 00 c0 00 00	 mov	 eax, 49152		; 0000c000H
  00022	66 89 44 24 24	 mov	 WORD PTR MemPrgBank2$[rsp], ax

; 434  : 
; 435  :     uint8 * BankToCpy1 = Cartridge->PrgData;

  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0002c	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00030	48 89 44 24 28	 mov	 QWORD PTR BankToCpy1$[rsp], rax

; 436  :     uint8 * BankToCpy2 = Cartridge->PrgData + ((Cartridge->PrgBankCount - 1) * Kilobytes(16));

  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0003a	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  0003e	ff c8		 dec	 eax
  00040	48 98		 cdqe
  00042	48 69 c0 00 40
	00 00		 imul	 rax, rax, 16384		; 00004000H
  00049	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  0004e	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00052	48 89 44 24 30	 mov	 QWORD PTR BankToCpy2$[rsp], rax

; 437  :            
; 438  :     cpyMemory((uint8 *)MemPrgBank1 + Cpu->MemoryBase, BankToCpy1, Kilobytes(16));

  00057	0f b7 44 24 20	 movzx	 eax, WORD PTR MemPrgBank1$[rsp]
  0005c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00061	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00065	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  0006a	48 8b 54 24 28	 mov	 rdx, QWORD PTR BankToCpy1$[rsp]
  0006f	48 8b c8	 mov	 rcx, rax
  00072	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 439  :     cpyMemory((uint8 *)MemPrgBank2 + Cpu->MemoryBase, BankToCpy2, Kilobytes(16));

  00077	0f b7 44 24 24	 movzx	 eax, WORD PTR MemPrgBank2$[rsp]
  0007c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00081	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00085	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  0008a	48 8b 54 24 30	 mov	 rdx, QWORD PTR BankToCpy2$[rsp]
  0008f	48 8b c8	 mov	 rcx, rax
  00092	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 440  : }

  00097	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009b	c3		 ret	 0
?unromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ENDP	; unromInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
MemPrgBank1$ = 32
MemPrgBank2$ = 36
BankToCpy1$ = 40
BankToCpy2$ = 48
Cartridge$ = 80
Cpu$ = 88
Ppu$ = 96
?mmc1Init@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z PROC	; mmc1Init

; 419  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 420  :     uint16 MemPrgBank1 = 0x8000;

  00013	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00018	66 89 44 24 20	 mov	 WORD PTR MemPrgBank1$[rsp], ax

; 421  :     uint16 MemPrgBank2 = 0xC000;

  0001d	b8 00 c0 00 00	 mov	 eax, 49152		; 0000c000H
  00022	66 89 44 24 24	 mov	 WORD PTR MemPrgBank2$[rsp], ax

; 422  : 
; 423  :     uint8 * BankToCpy1 = Cartridge->PrgData;

  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0002c	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00030	48 89 44 24 28	 mov	 QWORD PTR BankToCpy1$[rsp], rax

; 424  :     uint8 * BankToCpy2 = Cartridge->PrgData + ((Cartridge->PrgBankCount - 1) * Kilobytes(16));

  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0003a	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  0003e	ff c8		 dec	 eax
  00040	48 98		 cdqe
  00042	48 69 c0 00 40
	00 00		 imul	 rax, rax, 16384		; 00004000H
  00049	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  0004e	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00052	48 89 44 24 30	 mov	 QWORD PTR BankToCpy2$[rsp], rax

; 425  :            
; 426  :     cpyMemory((uint8 *)MemPrgBank1 + Cpu->MemoryBase, BankToCpy1, Kilobytes(16));

  00057	0f b7 44 24 20	 movzx	 eax, WORD PTR MemPrgBank1$[rsp]
  0005c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00061	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00065	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  0006a	48 8b 54 24 28	 mov	 rdx, QWORD PTR BankToCpy1$[rsp]
  0006f	48 8b c8	 mov	 rcx, rax
  00072	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 427  :     cpyMemory((uint8 *)MemPrgBank2 + Cpu->MemoryBase, BankToCpy2, Kilobytes(16));

  00077	0f b7 44 24 24	 movzx	 eax, WORD PTR MemPrgBank2$[rsp]
  0007c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00081	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00085	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  0008a	48 8b 54 24 30	 mov	 rdx, QWORD PTR BankToCpy2$[rsp]
  0008f	48 8b c8	 mov	 rcx, rax
  00092	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 428  :  }

  00097	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009b	c3		 ret	 0
?mmc1Init@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ENDP	; mmc1Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
MemPrgBank1$ = 32
MemPrgBank2$ = 36
BankToCpy1$ = 40
BankToCpy2$ = 48
Cartridge$ = 80
Cpu$ = 88
Ppu$ = 96
?nromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z PROC	; nromInit

; 390  : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 391  :     uint16 MemPrgBank1 = 0x8000;

  00013	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00018	66 89 44 24 20	 mov	 WORD PTR MemPrgBank1$[rsp], ax

; 392  :     uint16 MemPrgBank2 = 0xC000;

  0001d	b8 00 c0 00 00	 mov	 eax, 49152		; 0000c000H
  00022	66 89 44 24 24	 mov	 WORD PTR MemPrgBank2$[rsp], ax

; 393  : 
; 394  :     uint8 * BankToCpy1;
; 395  :     uint8 * BankToCpy2;
; 396  :         
; 397  :     if(Cartridge->PrgBankCount == 1)

  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0002c	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  00030	83 f8 01	 cmp	 eax, 1
  00033	75 1e		 jne	 SHORT $LN2@nromInit

; 398  :     {
; 399  :         BankToCpy1 = Cartridge->PrgData;

  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0003a	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0003e	48 89 44 24 28	 mov	 QWORD PTR BankToCpy1$[rsp], rax

; 400  :         BankToCpy2 = Cartridge->PrgData;

  00043	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00048	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0004c	48 89 44 24 30	 mov	 QWORD PTR BankToCpy2$[rsp], rax
  00051	eb 30		 jmp	 SHORT $LN3@nromInit
$LN2@nromInit:

; 401  :     }
; 402  :     else if(Cartridge->PrgBankCount == 2)

  00053	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00058	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  0005c	83 f8 02	 cmp	 eax, 2
  0005f	75 22		 jne	 SHORT $LN4@nromInit

; 403  :     {
; 404  :         BankToCpy1 = Cartridge->PrgData;

  00061	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00066	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0006a	48 89 44 24 28	 mov	 QWORD PTR BankToCpy1$[rsp], rax

; 405  :         BankToCpy2 = Cartridge->PrgData + Kilobytes(16);

  0006f	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00074	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00078	48 05 00 40 00
	00		 add	 rax, 16384		; 00004000H
  0007e	48 89 44 24 30	 mov	 QWORD PTR BankToCpy2$[rsp], rax
$LN4@nromInit:
$LN3@nromInit:

; 406  :     }
; 407  :         
; 408  :     cpyMemory((uint8 *)MemPrgBank1 + Cpu->MemoryBase, BankToCpy1, Kilobytes(16));

  00083	0f b7 44 24 20	 movzx	 eax, WORD PTR MemPrgBank1$[rsp]
  00088	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0008d	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00091	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  00096	48 8b 54 24 28	 mov	 rdx, QWORD PTR BankToCpy1$[rsp]
  0009b	48 8b c8	 mov	 rcx, rax
  0009e	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 409  :     cpyMemory((uint8 *)MemPrgBank2 + Cpu->MemoryBase, BankToCpy2, Kilobytes(16));

  000a3	0f b7 44 24 24	 movzx	 eax, WORD PTR MemPrgBank2$[rsp]
  000a8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Cpu$[rsp]
  000ad	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  000b1	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  000b6	48 8b 54 24 30	 mov	 rdx, QWORD PTR BankToCpy2$[rsp]
  000bb	48 8b c8	 mov	 rcx, rax
  000be	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 410  : 
; 411  :     // Map CHR Data to Ppu
; 412  :     if(Cartridge->ChrBankCount == 1)

  000c3	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  000c8	0f b6 40 28	 movzx	 eax, BYTE PTR [rax+40]
  000cc	83 f8 01	 cmp	 eax, 1
  000cf	75 1b		 jne	 SHORT $LN5@nromInit

; 413  :     {
; 414  :         cpyMemory((uint8 *)Ppu->MemoryBase, Cartridge->ChrData, Kilobytes(8));

  000d1	66 41 b8 00 20	 mov	 r8w, 8192		; 00002000H
  000d6	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  000db	48 8b 50 30	 mov	 rdx, QWORD PTR [rax+48]
  000df	48 8b 44 24 60	 mov	 rax, QWORD PTR Ppu$[rsp]
  000e4	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000e7	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory
$LN5@nromInit:

; 415  :     }
; 416  : }

  000ec	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f0	c3		 ret	 0
?nromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ENDP	; nromInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Ppu$ = 8
MemoryBase$ = 16
BasePixel$ = 24
?initPpu@@YAXPEAUppu@@_KPEAI@Z PROC			; initPpu

; 382  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 383  :     OamData = Ppu->Oam;

  0000f	48 8b 44 24 08	 mov	 rax, QWORD PTR Ppu$[rsp]
  00014	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  0001a	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?OamData@@3PEAEEA, rax

; 384  : 
; 385  :     Ppu->MemoryBase = MemoryBase;

  00021	48 8b 44 24 08	 mov	 rax, QWORD PTR Ppu$[rsp]
  00026	48 8b 4c 24 10	 mov	 rcx, QWORD PTR MemoryBase$[rsp]
  0002b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 386  :     Ppu->BasePixel = BasePixel;

  0002e	48 8b 44 24 08	 mov	 rax, QWORD PTR Ppu$[rsp]
  00033	48 8b 4c 24 18	 mov	 rcx, QWORD PTR BasePixel$[rsp]
  00038	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 387  : }

  0003c	c3		 ret	 0
?initPpu@@YAXPEAUppu@@_KPEAI@Z ENDP			; initPpu
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Cpu$ = 8
MemoryBase$ = 16
?initCpu@@YAXPEAUcpu@@_K@Z PROC				; initCpu

; 376  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 377  :     Cpu->MemoryBase = MemoryBase;

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR Cpu$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR MemoryBase$[rsp]
  00014	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 378  : }

  00018	c3		 ret	 0
?initCpu@@YAXPEAUcpu@@_K@Z ENDP				; initCpu
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
BackBuffer$ = 128
DeviceContext$ = 136
WindowWidth$ = 144
WindowHeight$ = 152
?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z PROC ; drawScreenBuffer

; 364  : {                

  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000c	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00011	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00016	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 365  :     StretchDIBits(DeviceContext,

  0001a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  00022	0f b7 8c 24 98
	00 00 00	 movzx	 ecx, WORD PTR WindowHeight$[rsp]
  0002a	0f b7 94 24 90
	00 00 00	 movzx	 edx, WORD PTR WindowWidth$[rsp]
  00032	c7 44 24 60 20
	00 cc 00	 mov	 DWORD PTR [rsp+96], 13369376 ; 00cc0020H
  0003a	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR [rsp+88], 0
  00042	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00047	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  0004f	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00053	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00058	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  00060	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00063	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00067	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  0006f	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00072	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00076	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  0007e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00086	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0008a	44 8b ca	 mov	 r9d, edx
  0008d	45 33 c0	 xor	 r8d, r8d
  00090	33 d2		 xor	 edx, edx
  00092	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR DeviceContext$[rsp]
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_StretchDIBits

; 366  :                   0, 0, WindowWidth, WindowHeight,
; 367  :                   0, 0, BackBuffer->Width, BackBuffer->Height,
; 368  :                   BackBuffer->Memory,
; 369  :                   &BackBuffer->Info,
; 370  :                   DIB_RGB_COLORS, SRCCOPY);
; 371  : }

  000a0	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000a4	c3		 ret	 0
?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z ENDP ; drawScreenBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
MemorySize$ = 32
Buffer$ = 64
Width$ = 72
Height$ = 80
?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z PROC	; createBackBuffer

; 340  : {

  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 341  :     if(Buffer->Memory)

  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  00019	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  0001e	74 17		 je	 SHORT $LN2@createBack

; 342  :     {
; 343  :         VirtualFree(Buffer->Memory, 0, MEM_RELEASE);

  00020	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00026	33 d2		 xor	 edx, edx
  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  0002d	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualFree
$LN2@createBack:

; 344  :     }
; 345  : 
; 346  :     Buffer->Width = Width;

  00037	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  00041	89 41 38	 mov	 DWORD PTR [rcx+56], eax

; 347  :     Buffer->Height = Height;

  00044	0f b7 44 24 50	 movzx	 eax, WORD PTR Height$[rsp]
  00049	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  0004e	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 348  :     Buffer->BytesPerPixel = 4; // TODO: Check if this is wrong. Should it be 3 instead? No alpha value

  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  00056	c7 40 44 04 00
	00 00		 mov	 DWORD PTR [rax+68], 4

; 349  : 
; 350  :     Buffer->Info.bmiHeader.biSize = sizeof(Buffer->Info.bmiHeader);

  0005d	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  00062	c7 00 28 00 00
	00		 mov	 DWORD PTR [rax], 40	; 00000028H

; 351  :     Buffer->Info.bmiHeader.biWidth = Width;

  00068	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  0006d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  00072	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 352  :     Buffer->Info.bmiHeader.biHeight = -Height; // Negative tells windows that we raster top to bottom

  00075	0f b7 44 24 50	 movzx	 eax, WORD PTR Height$[rsp]
  0007a	f7 d8		 neg	 eax
  0007c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  00081	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 353  :     Buffer->Info.bmiHeader.biPlanes = 1;

  00084	b8 01 00 00 00	 mov	 eax, 1
  00089	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  0008e	66 89 41 0c	 mov	 WORD PTR [rcx+12], ax

; 354  :     Buffer->Info.bmiHeader.biBitCount = 32;

  00092	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  0009c	66 89 41 0e	 mov	 WORD PTR [rcx+14], ax

; 355  :     Buffer->Info.bmiHeader.biCompression = BI_RGB;

  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  000a5	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 356  : 
; 357  :     int MemorySize = Width * Height * Buffer->BytesPerPixel;

  000ac	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  000b1	0f b7 4c 24 50	 movzx	 ecx, WORD PTR Height$[rsp]
  000b6	0f af c1	 imul	 eax, ecx
  000b9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000be	0f af 41 44	 imul	 eax, DWORD PTR [rcx+68]
  000c2	89 44 24 20	 mov	 DWORD PTR MemorySize$[rsp], eax

; 358  :     Buffer->Memory = VirtualAlloc(0, MemorySize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE); 

  000c6	48 63 44 24 20	 movsxd	 rax, DWORD PTR MemorySize$[rsp]
  000cb	41 b9 04 00 00
	00		 mov	 r9d, 4
  000d1	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  000d7	48 8b d0	 mov	 rdx, rax
  000da	33 c9		 xor	 ecx, ecx
  000dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  000e2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000e7	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 359  :     Buffer->Pitch = Width * Buffer->BytesPerPixel;

  000eb	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  000f0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000f5	0f af 41 44	 imul	 eax, DWORD PTR [rcx+68]
  000f9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000fe	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 360  : }

  00101	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00105	c3		 ret	 0
?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z ENDP	; createBackBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
ClientRect$ = 32
__$ArrayPad$ = 48
Window$ = 80
Width$ = 88
Height$ = 96
?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z PROC		; getWindowSize

; 332  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 333  :     RECT ClientRect;
; 334  :     GetClientRect(Window, &ClientRect);

  00022	48 8d 54 24 20	 lea	 rdx, QWORD PTR ClientRect$[rsp]
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Window$[rsp]
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetClientRect

; 335  :     *Width = ClientRect.right - ClientRect.left;

  00032	8b 44 24 20	 mov	 eax, DWORD PTR ClientRect$[rsp]
  00036	8b 4c 24 28	 mov	 ecx, DWORD PTR ClientRect$[rsp+8]
  0003a	2b c8		 sub	 ecx, eax
  0003c	8b c1		 mov	 eax, ecx
  0003e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Width$[rsp]
  00043	66 89 01	 mov	 WORD PTR [rcx], ax

; 336  :     *Height = ClientRect.bottom - ClientRect.top;

  00046	8b 44 24 24	 mov	 eax, DWORD PTR ClientRect$[rsp+4]
  0004a	8b 4c 24 2c	 mov	 ecx, DWORD PTR ClientRect$[rsp+12]
  0004e	2b c8		 sub	 ecx, eax
  00050	8b c1		 mov	 eax, ecx
  00052	48 8b 4c 24 60	 mov	 rcx, QWORD PTR Height$[rsp]
  00057	66 89 01	 mov	 WORD PTR [rcx], ax

; 337  : }

  0005a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0005f	48 33 cc	 xor	 rcx, rsp
  00062	e8 00 00 00 00	 call	 __security_check_cookie
  00067	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006b	c3		 ret	 0
?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z ENDP		; getWindowSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Address$ = 32
CyclesElapsed$ = 36
Instruction$ = 37
idx$1 = 38
AddressMode$ = 39
InstrData$ = 40
InstrLength$ = 44
InstrCycles$ = 45
RelOffset$2 = 46
ZeroAddress$3 = 47
AddedAddress$4 = 48
ZeroAddress$5 = 49
AdditionalCycles$6 = 50
i$7 = 52
CrossedPage$ = 56
IndirectAddress$8 = 60
tv158 = 64
$T9 = 72
$T10 = 80
InstrName$ = 88
tv328 = 96
LogCpu$ = 112
__$ArrayPad$ = 224
Cpu$ = 272
NewInput$ = 280
?cpuTick@@YAEPEAUcpu@@PEAUinput@@@Z PROC		; cpuTick

; 202  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 203  :     uint8 CyclesElapsed = 0;

  00025	c6 44 24 24 00	 mov	 BYTE PTR CyclesElapsed$[rsp], 0

; 204  : 
; 205  :     Cpu->PotentialCatchUp = 0;

  0002a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  00032	c6 40 6d 00	 mov	 BYTE PTR [rax+109], 0

; 206  :     
; 207  :     uint16 Address = 0;

  00036	33 c0		 xor	 eax, eax
  00038	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 208  :     bool32 CrossedPage = 0;

  0003d	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR CrossedPage$[rsp], 0

; 209  :     
; 210  :     uint8 Instruction;
; 211  :     uint8 AddressMode;
; 212  :     uint8 InstrLength;
; 213  :     char *InstrName;
; 214  :     uint8 InstrCycles;
; 215  :     uint8 InstrData[3]; // Stores data for each instruction
; 216  : 
; 217  :     // NOTE: Logging: Save Cpu before changes. Print out later
; 218  :     cpu LogCpu = *Cpu;

  00045	48 8d 44 24 70	 lea	 rax, QWORD PTR LogCpu$[rsp]
  0004a	48 8b f8	 mov	 rdi, rax
  0004d	48 8b b4 24 10
	01 00 00	 mov	 rsi, QWORD PTR Cpu$[rsp]
  00055	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  0005a	f3 a4		 rep movsb

; 219  : 
; 220  :     if(Cpu->PadStrobe)

  0005c	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  00064	83 78 1c 00	 cmp	 DWORD PTR [rax+28], 0
  00068	74 3f		 je	 SHORT $LN10@cpuTick

; 221  :     {
; 222  :         for(uint8 idx = 0; idx < input::BUTTON_NUM; ++idx)

  0006a	c6 44 24 26 00	 mov	 BYTE PTR idx$1[rsp], 0
  0006f	eb 0b		 jmp	 SHORT $LN4@cpuTick
$LN2@cpuTick:
  00071	0f b6 44 24 26	 movzx	 eax, BYTE PTR idx$1[rsp]
  00076	fe c0		 inc	 al
  00078	88 44 24 26	 mov	 BYTE PTR idx$1[rsp], al
$LN4@cpuTick:
  0007c	0f b6 44 24 26	 movzx	 eax, BYTE PTR idx$1[rsp]
  00081	83 f8 08	 cmp	 eax, 8
  00084	7d 23		 jge	 SHORT $LN3@cpuTick

; 223  :             Cpu->InputPad1.buttons[idx] = NewInput->buttons[idx];

  00086	0f b6 44 24 26	 movzx	 eax, BYTE PTR idx$1[rsp]
  0008b	0f b6 4c 24 26	 movzx	 ecx, BYTE PTR idx$1[rsp]
  00090	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00098	48 8b bc 24 18
	01 00 00	 mov	 rdi, QWORD PTR NewInput$[rsp]
  000a0	8b 04 87	 mov	 eax, DWORD PTR [rdi+rax*4]
  000a3	89 44 8a 20	 mov	 DWORD PTR [rdx+rcx*4+32], eax
  000a7	eb c8		 jmp	 SHORT $LN2@cpuTick
$LN3@cpuTick:
$LN10@cpuTick:

; 224  :     }
; 225  :     
; 226  :     if(Cpu->StartNmi)

  000a9	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  000b1	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  000b5	0f 84 8c 00 00
	00		 je	 $LN11@cpuTick

; 227  :     {
; 228  :         NmiTriggered = true;

  000bb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?NmiTriggered@@3HA, 1 ; NmiTriggered

; 229  :         Cpu->StartNmi = false;

  000c5	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  000cd	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0

; 230  :                 
; 231  :         LogCpu.PrgCounter = NMI_VEC;

  000d4	b8 fa ff 00 00	 mov	 eax, 65530		; 0000fffaH
  000d9	66 89 44 24 76	 mov	 WORD PTR LogCpu$[rsp+6], ax

; 232  :         Address = NMI_VEC;

  000de	b8 fa ff 00 00	 mov	 eax, 65530		; 0000fffaH
  000e3	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 233  :         AddressMode = IMPL;

  000e8	c6 44 24 27 09	 mov	 BYTE PTR AddressMode$[rsp], 9

; 234  :         InstrLength = 0;

  000ed	c6 44 24 2c 00	 mov	 BYTE PTR InstrLength$[rsp], 0

; 235  :         InstrName = "NMI";

  000f2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG89185
  000f9	48 89 44 24 58	 mov	 QWORD PTR InstrName$[rsp], rax

; 236  :         InstrCycles = 7;

  000fe	c6 44 24 2d 07	 mov	 BYTE PTR InstrCycles$[rsp], 7

; 237  :         InstrData[0] = 0;

  00103	b8 01 00 00 00	 mov	 eax, 1
  00108	48 6b c0 00	 imul	 rax, rax, 0
  0010c	48 89 44 24 48	 mov	 QWORD PTR $T9[rsp], rax
  00111	48 83 7c 24 48
	03		 cmp	 QWORD PTR $T9[rsp], 3
  00117	73 02		 jae	 SHORT $LN32@cpuTick
  00119	eb 05		 jmp	 SHORT $LN33@cpuTick
$LN32@cpuTick:
  0011b	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN33@cpuTick:
  00120	48 8b 44 24 48	 mov	 rax, QWORD PTR $T9[rsp]
  00125	c6 44 04 28 00	 mov	 BYTE PTR InstrData$[rsp+rax], 0

; 238  : 
; 239  :         nmi_irq(Address, Cpu, AddressMode);

  0012a	44 0f b6 44 24
	27		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00130	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00138	0f b7 4c 24 20	 movzx	 ecx, WORD PTR Address$[rsp]
  0013d	e8 00 00 00 00	 call	 ?nmi_irq@@YAEGPEAUcpu@@E@Z ; nmi_irq
  00142	e9 0f 05 00 00	 jmp	 $LN12@cpuTick
$LN11@cpuTick:

; 240  :     }
; 241  :     else if(IrqTriggered)

  00147	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IrqTriggered@@3HA, 0 ; IrqTriggered
  0014e	74 67		 je	 SHORT $LN13@cpuTick

; 242  :     {
; 243  :         LogCpu.PrgCounter = readCpu16(IRQ_BRK_VEC, Cpu);

  00150	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00158	66 b9 fe ff	 mov	 cx, 65534		; 0000fffeH
  0015c	e8 00 00 00 00	 call	 ?readCpu16@@YAGGPEAUcpu@@@Z ; readCpu16
  00161	66 89 44 24 76	 mov	 WORD PTR LogCpu$[rsp+6], ax

; 244  :         Address = IRQ_BRK_VEC;

  00166	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  0016b	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 245  :         AddressMode = IMPL;

  00170	c6 44 24 27 09	 mov	 BYTE PTR AddressMode$[rsp], 9

; 246  :         InstrLength = 0;

  00175	c6 44 24 2c 00	 mov	 BYTE PTR InstrLength$[rsp], 0

; 247  :         InstrName = "IRQ";

  0017a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG89188
  00181	48 89 44 24 58	 mov	 QWORD PTR InstrName$[rsp], rax

; 248  :         InstrCycles = 7;

  00186	c6 44 24 2d 07	 mov	 BYTE PTR InstrCycles$[rsp], 7

; 249  :         InstrData[0] = 0;

  0018b	b8 01 00 00 00	 mov	 eax, 1
  00190	48 6b c0 00	 imul	 rax, rax, 0
  00194	48 89 44 24 50	 mov	 QWORD PTR $T10[rsp], rax
  00199	48 83 7c 24 50
	03		 cmp	 QWORD PTR $T10[rsp], 3
  0019f	73 02		 jae	 SHORT $LN34@cpuTick
  001a1	eb 05		 jmp	 SHORT $LN35@cpuTick
$LN34@cpuTick:
  001a3	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN35@cpuTick:
  001a8	48 8b 44 24 50	 mov	 rax, QWORD PTR $T10[rsp]
  001ad	c6 44 04 28 00	 mov	 BYTE PTR InstrData$[rsp+rax], 0

; 250  :     }
; 251  :     else

  001b2	e9 9f 04 00 00	 jmp	 $LN14@cpuTick
$LN13@cpuTick:

; 252  :     {    
; 253  :         Instruction = readCpu8(Cpu->PrgCounter, Cpu);

  001b7	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR Cpu$[rsp]
  001bf	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  001c7	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  001cb	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  001d0	88 44 24 25	 mov	 BYTE PTR Instruction$[rsp], al

; 254  :         AddressMode = instAddressMode[Instruction];

  001d4	0f b6 44 24 25	 movzx	 eax, BYTE PTR Instruction$[rsp]
  001d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instAddressMode@@3PAEA
  001e0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001e4	88 44 24 27	 mov	 BYTE PTR AddressMode$[rsp], al

; 255  :         InstrLength = instLength[Instruction];

  001e8	0f b6 44 24 25	 movzx	 eax, BYTE PTR Instruction$[rsp]
  001ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instLength@@3PAEA
  001f4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f8	88 44 24 2c	 mov	 BYTE PTR InstrLength$[rsp], al

; 256  :         InstrName = instName[Instruction];

  001fc	0f b6 44 24 25	 movzx	 eax, BYTE PTR Instruction$[rsp]
  00201	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instName@@3PAPEADA
  00208	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0020c	48 89 44 24 58	 mov	 QWORD PTR InstrName$[rsp], rax

; 257  :         InstrCycles = instCycles[Instruction];

  00211	0f b6 44 24 25	 movzx	 eax, BYTE PTR Instruction$[rsp]
  00216	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instCycles@@3PAEA
  0021d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00221	88 44 24 2d	 mov	 BYTE PTR InstrCycles$[rsp], al

; 258  : 
; 259  :         for(int i = 0; i < InstrLength; ++i)

  00225	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$7[rsp], 0
  0022d	eb 0a		 jmp	 SHORT $LN7@cpuTick
$LN5@cpuTick:
  0022f	8b 44 24 34	 mov	 eax, DWORD PTR i$7[rsp]
  00233	ff c0		 inc	 eax
  00235	89 44 24 34	 mov	 DWORD PTR i$7[rsp], eax
$LN7@cpuTick:
  00239	0f b6 44 24 2c	 movzx	 eax, BYTE PTR InstrLength$[rsp]
  0023e	39 44 24 34	 cmp	 DWORD PTR i$7[rsp], eax
  00242	7d 2b		 jge	 SHORT $LN6@cpuTick

; 260  :         {
; 261  :             InstrData[i] = readCpu8(Cpu->PrgCounter + i, Cpu); 

  00244	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  0024c	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00250	03 44 24 34	 add	 eax, DWORD PTR i$7[rsp]
  00254	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0025c	0f b7 c8	 movzx	 ecx, ax
  0025f	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00264	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$7[rsp]
  00269	88 44 0c 28	 mov	 BYTE PTR InstrData$[rsp+rcx], al

; 262  :         }

  0026d	eb c0		 jmp	 SHORT $LN5@cpuTick
$LN6@cpuTick:

; 263  :             
; 264  :         switch(AddressMode)

  0026f	0f b6 44 24 27	 movzx	 eax, BYTE PTR AddressMode$[rsp]
  00274	89 44 24 40	 mov	 DWORD PTR tv158[rsp], eax
  00278	83 7c 24 40 0d	 cmp	 DWORD PTR tv158[rsp], 13
  0027d	0f 87 1f 03 00
	00		 ja	 $LN8@cpuTick
  00283	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv158[rsp]
  00288	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0028f	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN36@cpuTick[rcx+rax*4]
  00296	48 03 c1	 add	 rax, rcx
  00299	ff e0		 jmp	 rax

; 265  :         {
; 266  :             case ACM:
; 267  :                 break;            

  0029b	e9 02 03 00 00	 jmp	 $LN8@cpuTick

; 268  :             case IMPL:
; 269  :                 break;

  002a0	e9 fd 02 00 00	 jmp	 $LN8@cpuTick
$LN17@cpuTick:

; 270  :             case IMED:
; 271  :                 Address = Cpu->PrgCounter + 1;

  002a5	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  002ad	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  002b1	ff c0		 inc	 eax
  002b3	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 272  :                 break;

  002b8	e9 e5 02 00 00	 jmp	 $LN8@cpuTick
$LN18@cpuTick:

; 273  :             case ZERO:
; 274  :                 Address = (uint16)InstrData[1];

  002bd	b8 01 00 00 00	 mov	 eax, 1
  002c2	48 6b c0 01	 imul	 rax, rax, 1
  002c6	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  002cb	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 275  :                 Cpu->PotentialCatchUp = 2;

  002d0	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  002d8	c6 40 6d 02	 mov	 BYTE PTR [rax+109], 2

; 276  :                 break;

  002dc	e9 c1 02 00 00	 jmp	 $LN8@cpuTick
$LN19@cpuTick:

; 277  :             case ZERX:
; 278  :                 Address = ((uint16)InstrData[1] + Cpu->X) & 0xFF;

  002e1	b8 01 00 00 00	 mov	 eax, 1
  002e6	48 6b c0 01	 imul	 rax, rax, 1
  002ea	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  002ef	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  002f7	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  002fb	03 c1		 add	 eax, ecx
  002fd	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00302	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 279  :                 Cpu->PotentialCatchUp = 3;

  00307	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  0030f	c6 40 6d 03	 mov	 BYTE PTR [rax+109], 3

; 280  :                 break;

  00313	e9 8a 02 00 00	 jmp	 $LN8@cpuTick
$LN20@cpuTick:

; 281  :             case ZERY:
; 282  :                 Address = ((uint16)InstrData[1] + Cpu->Y) & 0xFF;

  00318	b8 01 00 00 00	 mov	 eax, 1
  0031d	48 6b c0 01	 imul	 rax, rax, 1
  00321	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  00326	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0032e	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  00332	03 c1		 add	 eax, ecx
  00334	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00339	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 283  :                 Cpu->PotentialCatchUp = 3;

  0033e	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  00346	c6 40 6d 03	 mov	 BYTE PTR [rax+109], 3

; 284  :                 break;

  0034a	e9 53 02 00 00	 jmp	 $LN8@cpuTick
$LN21@cpuTick:

; 285  :             case ABS:
; 286  :                 Address = ((uint16)InstrData[2] << 8) | InstrData[1];

  0034f	b8 01 00 00 00	 mov	 eax, 1
  00354	48 6b c0 02	 imul	 rax, rax, 2
  00358	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  0035d	c1 e0 08	 shl	 eax, 8
  00360	b9 01 00 00 00	 mov	 ecx, 1
  00365	48 6b c9 01	 imul	 rcx, rcx, 1
  00369	0f b6 4c 0c 28	 movzx	 ecx, BYTE PTR InstrData$[rsp+rcx]
  0036e	0b c1		 or	 eax, ecx
  00370	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 287  :                 Cpu->PotentialCatchUp = 3;

  00375	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  0037d	c6 40 6d 03	 mov	 BYTE PTR [rax+109], 3

; 288  :                 break;

  00381	e9 1c 02 00 00	 jmp	 $LN8@cpuTick
$LN22@cpuTick:

; 289  :             case ABSX:
; 290  :                 Address = (((uint16)InstrData[2] << 8) | InstrData[1]) + Cpu->X;

  00386	b8 01 00 00 00	 mov	 eax, 1
  0038b	48 6b c0 02	 imul	 rax, rax, 2
  0038f	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  00394	c1 e0 08	 shl	 eax, 8
  00397	b9 01 00 00 00	 mov	 ecx, 1
  0039c	48 6b c9 01	 imul	 rcx, rcx, 1
  003a0	0f b6 4c 0c 28	 movzx	 ecx, BYTE PTR InstrData$[rsp+rcx]
  003a5	0b c1		 or	 eax, ecx
  003a7	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  003af	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  003b3	03 c1		 add	 eax, ecx
  003b5	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 291  :                 CrossedPage = crossedPageCheck(Address - Cpu->X, Address);

  003ba	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  003bf	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  003c7	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  003cb	2b c1		 sub	 eax, ecx
  003cd	0f b7 54 24 20	 movzx	 edx, WORD PTR Address$[rsp]
  003d2	0f b7 c8	 movzx	 ecx, ax
  003d5	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  003da	89 44 24 38	 mov	 DWORD PTR CrossedPage$[rsp], eax

; 292  :                 Cpu->PotentialCatchUp = 4;

  003de	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  003e6	c6 40 6d 04	 mov	 BYTE PTR [rax+109], 4

; 293  :                 break;

  003ea	e9 b3 01 00 00	 jmp	 $LN8@cpuTick
$LN23@cpuTick:

; 294  :             case ABSY:
; 295  :                 Address = (((uint16)InstrData[2] << 8) | InstrData[1]) + Cpu->Y;

  003ef	b8 01 00 00 00	 mov	 eax, 1
  003f4	48 6b c0 02	 imul	 rax, rax, 2
  003f8	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  003fd	c1 e0 08	 shl	 eax, 8
  00400	b9 01 00 00 00	 mov	 ecx, 1
  00405	48 6b c9 01	 imul	 rcx, rcx, 1
  00409	0f b6 4c 0c 28	 movzx	 ecx, BYTE PTR InstrData$[rsp+rcx]
  0040e	0b c1		 or	 eax, ecx
  00410	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00418	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  0041c	03 c1		 add	 eax, ecx
  0041e	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 296  :                 CrossedPage = crossedPageCheck(Address - Cpu->Y, Address);

  00423	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  00428	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00430	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  00434	2b c1		 sub	 eax, ecx
  00436	0f b7 54 24 20	 movzx	 edx, WORD PTR Address$[rsp]
  0043b	0f b7 c8	 movzx	 ecx, ax
  0043e	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  00443	89 44 24 38	 mov	 DWORD PTR CrossedPage$[rsp], eax

; 297  :                 Cpu->PotentialCatchUp = 4;

  00447	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  0044f	c6 40 6d 04	 mov	 BYTE PTR [rax+109], 4

; 298  :                 break;

  00453	e9 4a 01 00 00	 jmp	 $LN8@cpuTick
$LN24@cpuTick:

; 299  :             case REL:
; 300  :             {
; 301  :                 int8 RelOffset = InstrData[1];

  00458	b8 01 00 00 00	 mov	 eax, 1
  0045d	48 6b c0 01	 imul	 rax, rax, 1
  00461	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  00466	88 44 24 2e	 mov	 BYTE PTR RelOffset$2[rsp], al

; 302  :                 Address = Cpu->PrgCounter + 2 + RelOffset;

  0046a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  00472	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00476	0f be 4c 24 2e	 movsx	 ecx, BYTE PTR RelOffset$2[rsp]
  0047b	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  0047f	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 303  :                 break;

  00484	e9 19 01 00 00	 jmp	 $LN8@cpuTick
$LN25@cpuTick:

; 304  :             }
; 305  :             case INDX:
; 306  :             {
; 307  :                 // Always reading from zero page
; 308  :                 uint8 ZeroAddress = InstrData[1];

  00489	b8 01 00 00 00	 mov	 eax, 1
  0048e	48 6b c0 01	 imul	 rax, rax, 1
  00492	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  00497	88 44 24 2f	 mov	 BYTE PTR ZeroAddress$3[rsp], al

; 309  :                 uint8 AddedAddress = (ZeroAddress + Cpu->X) & 0xFF;

  0049b	0f b6 44 24 2f	 movzx	 eax, BYTE PTR ZeroAddress$3[rsp]
  004a0	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  004a8	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  004ac	03 c1		 add	 eax, ecx
  004ae	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004b3	88 44 24 30	 mov	 BYTE PTR AddedAddress$4[rsp], al

; 310  :                 Address = bugReadCpu16(AddedAddress, Cpu);

  004b7	0f b6 44 24 30	 movzx	 eax, BYTE PTR AddedAddress$4[rsp]
  004bc	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR Cpu$[rsp]
  004c4	0f b7 c8	 movzx	 ecx, ax
  004c7	e8 00 00 00 00	 call	 ?bugReadCpu16@@YAGGPEAUcpu@@@Z ; bugReadCpu16
  004cc	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 311  :                 Cpu->PotentialCatchUp = 5;

  004d1	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  004d9	c6 40 6d 05	 mov	 BYTE PTR [rax+109], 5

; 312  :                 break;

  004dd	e9 c0 00 00 00	 jmp	 $LN8@cpuTick
$LN26@cpuTick:

; 313  :             }
; 314  :             case INDY:
; 315  :             {                
; 316  :                 uint8 ZeroAddress = InstrData[1];

  004e2	b8 01 00 00 00	 mov	 eax, 1
  004e7	48 6b c0 01	 imul	 rax, rax, 1
  004eb	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  004f0	88 44 24 31	 mov	 BYTE PTR ZeroAddress$5[rsp], al

; 317  :                 Address = bugReadCpu16(ZeroAddress, Cpu) + Cpu->Y;

  004f4	0f b6 44 24 31	 movzx	 eax, BYTE PTR ZeroAddress$5[rsp]
  004f9	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00501	0f b7 c8	 movzx	 ecx, ax
  00504	e8 00 00 00 00	 call	 ?bugReadCpu16@@YAGGPEAUcpu@@@Z ; bugReadCpu16
  00509	0f b7 c0	 movzx	 eax, ax
  0050c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00514	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  00518	03 c1		 add	 eax, ecx
  0051a	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 318  :                 CrossedPage = crossedPageCheck(Address - Cpu->Y, Address);

  0051f	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  00524	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0052c	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  00530	2b c1		 sub	 eax, ecx
  00532	0f b7 54 24 20	 movzx	 edx, WORD PTR Address$[rsp]
  00537	0f b7 c8	 movzx	 ecx, ax
  0053a	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0053f	89 44 24 38	 mov	 DWORD PTR CrossedPage$[rsp], eax

; 319  :                 Cpu->PotentialCatchUp = 5;

  00543	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  0054b	c6 40 6d 05	 mov	 BYTE PTR [rax+109], 5

; 320  :                 break;

  0054f	eb 51		 jmp	 SHORT $LN8@cpuTick
$LN27@cpuTick:

; 321  :             }
; 322  :             case INDI:
; 323  :             {
; 324  :                 uint16 IndirectAddress = ((uint16)InstrData[2] << 8) | InstrData[1];

  00551	b8 01 00 00 00	 mov	 eax, 1
  00556	48 6b c0 02	 imul	 rax, rax, 2
  0055a	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  0055f	c1 e0 08	 shl	 eax, 8
  00562	b9 01 00 00 00	 mov	 ecx, 1
  00567	48 6b c9 01	 imul	 rcx, rcx, 1
  0056b	0f b6 4c 0c 28	 movzx	 ecx, BYTE PTR InstrData$[rsp+rcx]
  00570	0b c1		 or	 eax, ecx
  00572	66 89 44 24 3c	 mov	 WORD PTR IndirectAddress$8[rsp], ax

; 325  :                 Address = bugReadCpu16(IndirectAddress, Cpu);

  00577	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0057f	0f b7 4c 24 3c	 movzx	 ecx, WORD PTR IndirectAddress$8[rsp]
  00584	e8 00 00 00 00	 call	 ?bugReadCpu16@@YAGGPEAUcpu@@@Z ; bugReadCpu16
  00589	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 326  :                 break;

  0058e	eb 12		 jmp	 SHORT $LN8@cpuTick
$LN28@cpuTick:

; 327  :             }
; 328  :             case NUL:
; 329  :             {
; 330  :                 Assert(0);

  00590	33 c0		 xor	 eax, eax
  00592	83 f8 01	 cmp	 eax, 1
  00595	74 0b		 je	 SHORT $LN29@cpuTick
  00597	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN29@cpuTick:
$LN8@cpuTick:

; 331  :                 break;
; 332  :             }        
; 333  :         }
; 334  : 
; 335  :         Cpu->StartNmi = TriggerNmi;

  005a2	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  005aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?TriggerNmi@@3HA ; TriggerNmi
  005b0	89 48 68	 mov	 DWORD PTR [rax+104], ecx

; 336  :         TriggerNmi = false;

  005b3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?TriggerNmi@@3HA, 0 ; TriggerNmi

; 337  :         
; 338  :         Cpu->PrgCounter += InstrLength;

  005bd	0f b6 44 24 2c	 movzx	 eax, BYTE PTR InstrLength$[rsp]
  005c2	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  005ca	0f b7 49 06	 movzx	 ecx, WORD PTR [rcx+6]
  005ce	03 c8		 add	 ecx, eax
  005d0	8b c1		 mov	 eax, ecx
  005d2	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  005da	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 339  :         CyclesElapsed += InstrCycles;

  005de	0f b6 44 24 2d	 movzx	 eax, BYTE PTR InstrCycles$[rsp]
  005e3	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR CyclesElapsed$[rsp]
  005e8	03 c8		 add	 ecx, eax
  005ea	8b c1		 mov	 eax, ecx
  005ec	88 44 24 24	 mov	 BYTE PTR CyclesElapsed$[rsp], al

; 340  : 
; 341  :         // NOTE: This is where the operation is executed, returning extra cycles, for branch ops
; 342  :         if(CrossedPage)

  005f0	83 7c 24 38 00	 cmp	 DWORD PTR CrossedPage$[rsp], 0
  005f5	74 1d		 je	 SHORT $LN30@cpuTick

; 343  :         {
; 344  :             CyclesElapsed += instBoundaryCheck[Instruction];

  005f7	0f b6 44 24 25	 movzx	 eax, BYTE PTR Instruction$[rsp]
  005fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instBoundaryCheck@@3PAEA
  00603	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00607	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR CyclesElapsed$[rsp]
  0060c	03 c8		 add	 ecx, eax
  0060e	8b c1		 mov	 eax, ecx
  00610	88 44 24 24	 mov	 BYTE PTR CyclesElapsed$[rsp], al
$LN30@cpuTick:

; 345  :         }
; 346  :         
; 347  :         uint8 AdditionalCycles = instrOps[Instruction](Address, Cpu, AddressMode);

  00614	0f b6 44 24 25	 movzx	 eax, BYTE PTR Instruction$[rsp]
  00619	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instrOps@@3PAP6AEGPEAUcpu@@E@ZA ; instrOps
  00620	48 89 4c 24 60	 mov	 QWORD PTR tv328[rsp], rcx
  00625	44 0f b6 44 24
	27		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0062b	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00633	0f b7 4c 24 20	 movzx	 ecx, WORD PTR Address$[rsp]
  00638	48 8b 7c 24 60	 mov	 rdi, QWORD PTR tv328[rsp]
  0063d	ff 14 c7	 call	 QWORD PTR [rdi+rax*8]
  00640	88 44 24 32	 mov	 BYTE PTR AdditionalCycles$6[rsp], al

; 348  :         CyclesElapsed += AdditionalCycles;

  00644	0f b6 44 24 32	 movzx	 eax, BYTE PTR AdditionalCycles$6[rsp]
  00649	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR CyclesElapsed$[rsp]
  0064e	03 c8		 add	 ecx, eax
  00650	8b c1		 mov	 eax, ecx
  00652	88 44 24 24	 mov	 BYTE PTR CyclesElapsed$[rsp], al
$LN14@cpuTick:
$LN12@cpuTick:

; 349  : 
; 350  :     }
; 351  : #if 0
; 352  :     char LogInstrData[16];
; 353  :     if(InstrLength == 3)
; 354  :         sprintf(LogInstrData, "%2X %2X %2X", InstrData[0], InstrData[1], InstrData[2]);
; 355  :     else if(InstrLength == 2)
; 356  :         sprintf(LogInstrData, "%2X %2X   ", InstrData[0], InstrData[1]);
; 357  :     else
; 358  :         sprintf(LogInstrData, "%2X      ", InstrData[0]);
; 359  : 
; 360  :     char LogOpInfo[64];
; 361  : //    sprintf(LogOpInfo, ""
; 362  :     
; 363  :     char LogCpuInfo[64];
; 364  :     sprintf(LogCpuInfo, "A:%2X X:%2X Y:%2X P:%2X SP:%2X  CYC: %d",
; 365  :             LogCpu.A, LogCpu.X, LogCpu.Y, LogCpu.Flags, LogCpu.StackPtr, CyclesElapsed);
; 366  : 
; 367  :     // NOTE: CPU Log options
; 368  :     char LogBuffer[1024];
; 369  :     sprintf(LogBuffer, "%4X %s    %s\n", LogCpu.PrgCounter, LogInstrData, LogCpuInfo);
; 370  :     OutputDebugString(LogBuffer);
; 371  : #endif
; 372  :     
; 373  :     return(CyclesElapsed);

  00656	0f b6 44 24 24	 movzx	 eax, BYTE PTR CyclesElapsed$[rsp]
$LN31@cpuTick:

; 374  : }

  0065b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00663	48 33 cc	 xor	 rcx, rsp
  00666	e8 00 00 00 00	 call	 __security_check_cookie
  0066b	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00672	5f		 pop	 rdi
  00673	5e		 pop	 rsi
  00674	c3		 ret	 0
  00675	0f 1f 00	 npad	 3
$LN36@cpuTick:
  00678	00 00 00 00	 DD	 $LN28@cpuTick
  0067c	00 00 00 00	 DD	 $LN8@cpuTick
  00680	00 00 00 00	 DD	 $LN17@cpuTick
  00684	00 00 00 00	 DD	 $LN18@cpuTick
  00688	00 00 00 00	 DD	 $LN19@cpuTick
  0068c	00 00 00 00	 DD	 $LN20@cpuTick
  00690	00 00 00 00	 DD	 $LN21@cpuTick
  00694	00 00 00 00	 DD	 $LN22@cpuTick
  00698	00 00 00 00	 DD	 $LN23@cpuTick
  0069c	00 00 00 00	 DD	 $LN8@cpuTick
  006a0	00 00 00 00	 DD	 $LN24@cpuTick
  006a4	00 00 00 00	 DD	 $LN25@cpuTick
  006a8	00 00 00 00	 DD	 $LN26@cpuTick
  006ac	00 00 00 00	 DD	 $LN27@cpuTick
?cpuTick@@YAEPEAUcpu@@PEAUinput@@@Z ENDP		; cpuTick
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
tv89 = 36
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?nmi_irq@@YAEGPEAUcpu@@E@Z PROC				; nmi_irq

; 181  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 182  :     uint8 HighByte = (uint8)(Cpu->PrgCounter >> 8);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0001c	c1 f8 08	 sar	 eax, 8
  0001f	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 183  :     uint8 LowByte = (uint8)Cpu->PrgCounter; 

  00023	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  0002c	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 184  :     push(HighByte, Cpu);

  00030	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00035	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR HighByte$[rsp]
  0003a	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 185  :     push(LowByte, Cpu);

  0003f	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00044	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  00049	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 186  : 
; 187  :     clearBreak(&Cpu->Flags);

  0004e	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00053	48 83 c0 03	 add	 rax, 3
  00057	48 8b c8	 mov	 rcx, rax
  0005a	e8 00 00 00 00	 call	 ?clearBreak@@YAXPEAE@Z	; clearBreak

; 188  :     push(Cpu->Flags, Cpu); 

  0005f	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00064	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00069	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  0006d	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 189  :     setInterrupt(&Cpu->Flags);

  00072	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00077	48 83 c0 03	 add	 rax, 3
  0007b	48 8b c8	 mov	 rcx, rax
  0007e	e8 00 00 00 00	 call	 ?setInterrupt@@YAXPEAE@Z ; setInterrupt

; 190  : 
; 191  :     Cpu->PrgCounter = (read8(Address+1, Cpu->MemoryBase) << 8) | read8(Address, Cpu->MemoryBase);

  00083	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00088	ff c0		 inc	 eax
  0008a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0008f	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00093	0f b7 c8	 movzx	 ecx, ax
  00096	e8 00 00 00 00	 call	 ?read8@@YAEG_K@Z	; read8
  0009b	0f b6 c0	 movzx	 eax, al
  0009e	c1 e0 08	 shl	 eax, 8
  000a1	89 44 24 24	 mov	 DWORD PTR tv89[rsp], eax
  000a5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  000aa	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  000ae	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  000b3	e8 00 00 00 00	 call	 ?read8@@YAEG_K@Z	; read8
  000b8	0f b6 c0	 movzx	 eax, al
  000bb	8b 4c 24 24	 mov	 ecx, DWORD PTR tv89[rsp]
  000bf	0b c8		 or	 ecx, eax
  000c1	8b c1		 mov	 eax, ecx
  000c3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  000c8	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 192  :     return(0);

  000cc	32 c0		 xor	 al, al

; 193  : }

  000ce	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d2	c3		 ret	 0
?nmi_irq@@YAEGPEAUcpu@@E@Z ENDP				; nmi_irq
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?xaa@@YAEGPEAUcpu@@E@Z PROC				; xaa

; 814  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 815  : //    Assert(0);
; 816  :     return(0);

  0000f	32 c0		 xor	 al, al

; 817  : }

  00011	c3		 ret	 0
?xaa@@YAEGPEAUcpu@@E@Z ENDP				; xaa
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?tas@@YAEGPEAUcpu@@E@Z PROC				; tas

; 808  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 809  :     ///  Assert(0);
; 810  :     return(0);

  0000f	32 c0		 xor	 al, al

; 811  : }

  00011	c3		 ret	 0
?tas@@YAEGPEAUcpu@@E@Z ENDP				; tas
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?sre@@YAEGPEAUcpu@@E@Z PROC				; sre

; 802  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 803  :     lsr(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?lsr@@YAEGPEAUcpu@@E@Z	; lsr

; 804  :     eor(Address, Cpu, AddressMode);

  00028	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0002e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00033	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00038	e8 00 00 00 00	 call	 ?eor@@YAEGPEAUcpu@@E@Z	; eor

; 805  :     return(0);

  0003d	32 c0		 xor	 al, al

; 806  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
?sre@@YAEGPEAUcpu@@E@Z ENDP				; sre
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?slo@@YAEGPEAUcpu@@E@Z PROC				; slo

; 796  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 797  :     asl(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?asl@@YAEGPEAUcpu@@E@Z	; asl

; 798  :     ora(Address, Cpu, AddressMode);

  00028	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0002e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00033	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00038	e8 00 00 00 00	 call	 ?ora@@YAEGPEAUcpu@@E@Z	; ora

; 799  :     return(0);

  0003d	32 c0		 xor	 al, al

; 800  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
?slo@@YAEGPEAUcpu@@E@Z ENDP				; slo
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
ReadValue$ = 32
Value$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?shy@@YAEGPEAUcpu@@E@Z PROC				; shy

; 787  : {

$LN4:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 788  :     uint8 Value = (Cpu->Y & ((Address >> 8) + 1)) & 0xFF;

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	c1 f9 08	 sar	 ecx, 8
  00024	ff c1		 inc	 ecx
  00026	23 c1		 and	 eax, ecx
  00028	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0002d	88 44 24 21	 mov	 BYTE PTR Value$[rsp], al

; 789  :     uint8 ReadValue = readCpu8((Cpu->PrgCounter + 1), Cpu);

  00031	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00036	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0003a	ff c0		 inc	 eax
  0003c	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00041	0f b7 c8	 movzx	 ecx, ax
  00044	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00049	88 44 24 20	 mov	 BYTE PTR ReadValue$[rsp], al

; 790  :     
; 791  :     if((Cpu->X + ReadValue) <= 0xFF)

  0004d	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00052	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00056	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR ReadValue$[rsp]
  0005b	03 c1		 add	 eax, ecx
  0005d	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00062	7f 14		 jg	 SHORT $LN2@shy

; 792  :         writeCpu8(Value, Address, Cpu);

  00064	4c 8b 44 24 48	 mov	 r8, QWORD PTR Cpu$[rsp]
  00069	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0006e	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR Value$[rsp]
  00073	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8
$LN2@shy:

; 793  :     return(0);

  00078	32 c0		 xor	 al, al

; 794  : }

  0007a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007e	c3		 ret	 0
?shy@@YAEGPEAUcpu@@E@Z ENDP				; shy
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?shx@@YAEGPEAUcpu@@E@Z PROC				; shx

; 752  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 753  : 
; 754  :     return(0);

  0000f	32 c0		 xor	 al, al

; 755  : }

  00011	c3		 ret	 0
?shx@@YAEGPEAUcpu@@E@Z ENDP				; shx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?sax@@YAEGPEAUcpu@@E@Z PROC				; sax

; 746  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 747  :     uint8 Value = Cpu->A & Cpu->X;

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00020	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00024	23 c1		 and	 eax, ecx
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 748  :     writeCpu8(Value, Address, Cpu);    

  0002a	4c 8b 44 24 48	 mov	 r8, QWORD PTR Cpu$[rsp]
  0002f	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  00034	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00039	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8

; 749  :     return(0);

  0003e	32 c0		 xor	 al, al

; 750  : }

  00040	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00044	c3		 ret	 0
?sax@@YAEGPEAUcpu@@E@Z ENDP				; sax
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?rra@@YAEGPEAUcpu@@E@Z PROC				; rra

; 740  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 741  :     ror(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?ror@@YAEGPEAUcpu@@E@Z	; ror

; 742  :     adc(Address, Cpu, AddressMode);

  00028	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0002e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00033	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00038	e8 00 00 00 00	 call	 ?adc@@YAEGPEAUcpu@@E@Z	; adc

; 743  :     return(0);

  0003d	32 c0		 xor	 al, al

; 744  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
?rra@@YAEGPEAUcpu@@E@Z ENDP				; rra
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?rla@@YAEGPEAUcpu@@E@Z PROC				; rla

; 734  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 735  :     rol(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?rol@@YAEGPEAUcpu@@E@Z	; rol

; 736  :     AND(Address, Cpu, AddressMode);

  00028	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0002e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00033	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00038	e8 00 00 00 00	 call	 ?AND@@YAEGPEAUcpu@@E@Z	; AND

; 737  :     return(0);

  0003d	32 c0		 xor	 al, al

; 738  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
?rla@@YAEGPEAUcpu@@E@Z ENDP				; rla
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?lax@@YAEGPEAUcpu@@E@Z PROC				; lax

; 728  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 729  :     lda(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?lda@@YAEGPEAUcpu@@E@Z	; lda

; 730  :     ldx(Address, Cpu, AddressMode);

  00028	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0002e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00033	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00038	e8 00 00 00 00	 call	 ?ldx@@YAEGPEAUcpu@@E@Z	; ldx

; 731  :     return(0);

  0003d	32 c0		 xor	 al, al

; 732  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
?lax@@YAEGPEAUcpu@@E@Z ENDP				; lax
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?las@@YAEGPEAUcpu@@E@Z PROC				; las

; 724  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 725  :     return(0); 

  0000f	32 c0		 xor	 al, al

; 726  : }

  00011	c3		 ret	 0
?las@@YAEGPEAUcpu@@E@Z ENDP				; las
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?kil@@YAEGPEAUcpu@@E@Z PROC				; kil

; 719  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 720  :     //Assert(0);
; 721  :     return(0);

  0000f	32 c0		 xor	 al, al

; 722  : }

  00011	c3		 ret	 0
?kil@@YAEGPEAUcpu@@E@Z ENDP				; kil
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?isc@@YAEGPEAUcpu@@E@Z PROC				; isc

; 713  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 714  :     inc(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?inc@@YAEGPEAUcpu@@E@Z	; inc

; 715  :     sbc(Address, Cpu, AddressMode);

  00028	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0002e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00033	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00038	e8 00 00 00 00	 call	 ?sbc@@YAEGPEAUcpu@@E@Z	; sbc

; 716  :     return(0);

  0003d	32 c0		 xor	 al, al

; 717  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
?isc@@YAEGPEAUcpu@@E@Z ENDP				; isc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?dcp@@YAEGPEAUcpu@@E@Z PROC				; dcp

; 707  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 708  :     dec(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?dec@@YAEGPEAUcpu@@E@Z	; dec

; 709  :     cmp(Address, Cpu, AddressMode);

  00028	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0002e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00033	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00038	e8 00 00 00 00	 call	 ?cmp@@YAEGPEAUcpu@@E@Z	; cmp

; 710  :     return(0);

  0003d	32 c0		 xor	 al, al

; 711  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
?dcp@@YAEGPEAUcpu@@E@Z ENDP				; dcp
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
ANDValue$ = 32
Value$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?axs@@YAEGPEAUcpu@@E@Z PROC				; axs

; 690  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 691  :     uint8 Value = readCpu8(Address, Cpu);

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00018	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0001d	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00022	88 44 24 21	 mov	 BYTE PTR Value$[rsp], al

; 692  : 
; 693  :     uint8 ANDValue = (Cpu->A & Cpu->X);

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00033	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00037	23 c1		 and	 eax, ecx
  00039	88 44 24 20	 mov	 BYTE PTR ANDValue$[rsp], al

; 694  :     Cpu->X = ANDValue - Value;

  0003d	0f b6 44 24 20	 movzx	 eax, BYTE PTR ANDValue$[rsp]
  00042	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR Value$[rsp]
  00047	2b c1		 sub	 eax, ecx
  00049	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0004e	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 695  : 
; 696  :     if(ANDValue >= Value)

  00051	0f b6 44 24 20	 movzx	 eax, BYTE PTR ANDValue$[rsp]
  00056	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR Value$[rsp]
  0005b	3b c1		 cmp	 eax, ecx
  0005d	7c 13		 jl	 SHORT $LN2@axs

; 697  :         setCarry(&Cpu->Flags);

  0005f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00064	48 83 c0 03	 add	 rax, 3
  00068	48 8b c8	 mov	 rcx, rax
  0006b	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 698  :     else

  00070	eb 11		 jmp	 SHORT $LN3@axs
$LN2@axs:

; 699  :         clearCarry(&Cpu->Flags);

  00072	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00077	48 83 c0 03	 add	 rax, 3
  0007b	48 8b c8	 mov	 rcx, rax
  0007e	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN3@axs:

; 700  :     
; 701  :     setZero(Cpu->X, &Cpu->Flags);

  00083	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00088	48 83 c0 03	 add	 rax, 3
  0008c	48 8b d0	 mov	 rdx, rax
  0008f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00094	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00098	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 702  :     setNegative(Cpu->X, &Cpu->Flags);

  0009d	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000a2	48 83 c0 03	 add	 rax, 3
  000a6	48 8b d0	 mov	 rdx, rax
  000a9	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000ae	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  000b2	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 703  :     
; 704  :     return(0);

  000b7	32 c0		 xor	 al, al

; 705  : }

  000b9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bd	c3		 ret	 0
?axs@@YAEGPEAUcpu@@E@Z ENDP				; axs
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
bit6$ = 32
bit5$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?arr@@YAEGPEAUcpu@@E@Z PROC				; arr

; 666  : {

$LN9:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 667  :     AND(Address, Cpu, AddressMode);    

  00013	44 0f b6 44 24
	50		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?AND@@YAEGPEAUcpu@@E@Z	; AND

; 668  :     ror(Address, Cpu, ACM);

  00028	41 b0 01	 mov	 r8b, 1
  0002b	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00030	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00035	e8 00 00 00 00	 call	 ?ror@@YAEGPEAUcpu@@E@Z	; ror

; 669  : 
; 670  :     uint8 bit5 = Cpu->A & (1<<5);

  0003a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00042	83 e0 20	 and	 eax, 32			; 00000020H
  00045	88 44 24 21	 mov	 BYTE PTR bit5$[rsp], al

; 671  :     uint8 bit6 = Cpu->A & (1<<6);

  00049	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00051	83 e0 40	 and	 eax, 64			; 00000040H
  00054	88 44 24 20	 mov	 BYTE PTR bit6$[rsp], al

; 672  : 
; 673  :     if(bit6)

  00058	0f b6 44 24 20	 movzx	 eax, BYTE PTR bit6$[rsp]
  0005d	85 c0		 test	 eax, eax
  0005f	74 13		 je	 SHORT $LN2@arr

; 674  :         setCarry(&Cpu->Flags);

  00061	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00066	48 83 c0 03	 add	 rax, 3
  0006a	48 8b c8	 mov	 rcx, rax
  0006d	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 675  :     else

  00072	eb 11		 jmp	 SHORT $LN3@arr
$LN2@arr:

; 676  :         clearCarry(&Cpu->Flags);

  00074	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00079	48 83 c0 03	 add	 rax, 3
  0007d	48 8b c8	 mov	 rcx, rax
  00080	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN3@arr:

; 677  : 
; 678  :     if((bit5 && !bit6) || (!bit5 && bit6))

  00085	0f b6 44 24 21	 movzx	 eax, BYTE PTR bit5$[rsp]
  0008a	85 c0		 test	 eax, eax
  0008c	74 09		 je	 SHORT $LN7@arr
  0008e	0f b6 44 24 20	 movzx	 eax, BYTE PTR bit6$[rsp]
  00093	85 c0		 test	 eax, eax
  00095	74 12		 je	 SHORT $LN6@arr
$LN7@arr:
  00097	0f b6 44 24 21	 movzx	 eax, BYTE PTR bit5$[rsp]
  0009c	85 c0		 test	 eax, eax
  0009e	75 1c		 jne	 SHORT $LN4@arr
  000a0	0f b6 44 24 20	 movzx	 eax, BYTE PTR bit6$[rsp]
  000a5	85 c0		 test	 eax, eax
  000a7	74 13		 je	 SHORT $LN4@arr
$LN6@arr:

; 679  :         setOverflow(&Cpu->Flags);

  000a9	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000ae	48 83 c0 03	 add	 rax, 3
  000b2	48 8b c8	 mov	 rcx, rax
  000b5	e8 00 00 00 00	 call	 ?setOverflow@@YAXPEAE@Z	; setOverflow

; 680  :     else

  000ba	eb 11		 jmp	 SHORT $LN5@arr
$LN4@arr:

; 681  :         clearOverflow(&Cpu->Flags);

  000bc	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000c1	48 83 c0 03	 add	 rax, 3
  000c5	48 8b c8	 mov	 rcx, rax
  000c8	e8 00 00 00 00	 call	 ?clearOverflow@@YAXPEAE@Z ; clearOverflow
$LN5@arr:

; 682  :         
; 683  :     setZero(Cpu->A, &Cpu->Flags);

  000cd	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000d2	48 83 c0 03	 add	 rax, 3
  000d6	48 8b d0	 mov	 rdx, rax
  000d9	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000de	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000e1	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 684  :     setNegative(Cpu->A, &Cpu->Flags);

  000e6	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000eb	48 83 c0 03	 add	 rax, 3
  000ef	48 8b d0	 mov	 rdx, rax
  000f2	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000f7	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000fa	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 685  : 
; 686  :     
; 687  :     return(0);

  000ff	32 c0		 xor	 al, al

; 688  : }

  00101	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00105	c3		 ret	 0
?arr@@YAEGPEAUcpu@@E@Z ENDP				; arr
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?anc@@YAEGPEAUcpu@@E@Z PROC				; anc

; 655  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 656  :     AND(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?AND@@YAEGPEAUcpu@@E@Z	; AND

; 657  :     
; 658  :     if(isBitSet(NEGATIVE_BIT, Cpu->Flags))

  00028	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00031	b1 80		 mov	 cl, 128			; 00000080H
  00033	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00038	85 c0		 test	 eax, eax
  0003a	74 13		 je	 SHORT $LN2@anc

; 659  :         setCarry(&Cpu->Flags);

  0003c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	48 83 c0 03	 add	 rax, 3
  00045	48 8b c8	 mov	 rcx, rax
  00048	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 660  :     else

  0004d	eb 11		 jmp	 SHORT $LN3@anc
$LN2@anc:

; 661  :         clearCarry(&Cpu->Flags);

  0004f	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00054	48 83 c0 03	 add	 rax, 3
  00058	48 8b c8	 mov	 rcx, rax
  0005b	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN3@anc:

; 662  :     
; 663  :     return(0);

  00060	32 c0		 xor	 al, al

; 664  : }

  00062	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00066	c3		 ret	 0
?anc@@YAEGPEAUcpu@@E@Z ENDP				; anc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?alr@@YAEGPEAUcpu@@E@Z PROC				; alr

; 649  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 650  :     AND(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?AND@@YAEGPEAUcpu@@E@Z	; AND

; 651  :     lsr(Address, Cpu, ACM);

  00028	41 b0 01	 mov	 r8b, 1
  0002b	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00030	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00035	e8 00 00 00 00	 call	 ?lsr@@YAEGPEAUcpu@@E@Z	; lsr

; 652  :     return(0);

  0003a	32 c0		 xor	 al, al

; 653  : }

  0003c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00040	c3		 ret	 0
?alr@@YAEGPEAUcpu@@E@Z ENDP				; alr
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?ahx@@YAEGPEAUcpu@@E@Z PROC				; ahx

; 644  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 645  :     //Assert(0);
; 646  :     return(0);

  0000f	32 c0		 xor	 al, al

; 647  : }

  00011	c3		 ret	 0
?ahx@@YAEGPEAUcpu@@E@Z ENDP				; ahx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?txs@@YAEGPEAUcpu@@E@Z PROC				; txs

; 636  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 637  :     Cpu->StackPtr = Cpu->X;

  0000f	48 8b 44 24 10	 mov	 rax, QWORD PTR Cpu$[rsp]
  00014	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00019	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0001d	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 638  :     return(0);

  00020	32 c0		 xor	 al, al

; 639  : }

  00022	c3		 ret	 0
?txs@@YAEGPEAUcpu@@E@Z ENDP				; txs
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?tya@@YAEGPEAUcpu@@E@Z PROC				; tya

; 629  : {   

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 630  :     Cpu->A = Cpu->Y;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0001d	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  00021	88 08		 mov	 BYTE PTR [rax], cl

; 631  :     setZero(Cpu->A, &Cpu->Flags);

  00023	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	48 83 c0 03	 add	 rax, 3
  0002c	48 8b d0	 mov	 rdx, rax
  0002f	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00034	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00037	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 632  :     setNegative(Cpu->A, &Cpu->Flags);

  0003c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	48 83 c0 03	 add	 rax, 3
  00045	48 8b d0	 mov	 rdx, rax
  00048	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004d	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00050	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 633  :     return(0);

  00055	32 c0		 xor	 al, al

; 634  : }

  00057	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005b	c3		 ret	 0
?tya@@YAEGPEAUcpu@@E@Z ENDP				; tya
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?txa@@YAEGPEAUcpu@@E@Z PROC				; txa

; 622  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 623  :     Cpu->A = Cpu->X;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0001d	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00021	88 08		 mov	 BYTE PTR [rax], cl

; 624  :     setZero(Cpu->A, &Cpu->Flags);

  00023	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	48 83 c0 03	 add	 rax, 3
  0002c	48 8b d0	 mov	 rdx, rax
  0002f	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00034	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00037	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 625  :     setNegative(Cpu->A, &Cpu->Flags);

  0003c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	48 83 c0 03	 add	 rax, 3
  00045	48 8b d0	 mov	 rdx, rax
  00048	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004d	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00050	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 626  :     return(0);

  00055	32 c0		 xor	 al, al

; 627  : }

  00057	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005b	c3		 ret	 0
?txa@@YAEGPEAUcpu@@E@Z ENDP				; txa
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?tsx@@YAEGPEAUcpu@@E@Z PROC				; tsx

; 615  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 616  :     Cpu->X = Cpu->StackPtr;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0001d	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00021	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 617  :     setZero(Cpu->X, &Cpu->Flags);

  00024	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00029	48 83 c0 03	 add	 rax, 3
  0002d	48 8b d0	 mov	 rdx, rax
  00030	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00035	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00039	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 618  :     setNegative(Cpu->X, &Cpu->Flags);

  0003e	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00043	48 83 c0 03	 add	 rax, 3
  00047	48 8b d0	 mov	 rdx, rax
  0004a	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004f	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00053	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 619  :     return(0);

  00058	32 c0		 xor	 al, al

; 620  : }

  0005a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005e	c3		 ret	 0
?tsx@@YAEGPEAUcpu@@E@Z ENDP				; tsx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?tay@@YAEGPEAUcpu@@E@Z PROC				; tay

; 608  : {    

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 609  :     Cpu->Y = Cpu->A;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0001d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00020	88 48 02	 mov	 BYTE PTR [rax+2], cl

; 610  :     setZero(Cpu->Y, &Cpu->Flags);

  00023	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	48 83 c0 03	 add	 rax, 3
  0002c	48 8b d0	 mov	 rdx, rax
  0002f	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00034	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00038	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 611  :     setNegative(Cpu->Y, &Cpu->Flags);

  0003d	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00042	48 83 c0 03	 add	 rax, 3
  00046	48 8b d0	 mov	 rdx, rax
  00049	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004e	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00052	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 612  :     return(0);

  00057	32 c0		 xor	 al, al

; 613  : }

  00059	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005d	c3		 ret	 0
?tay@@YAEGPEAUcpu@@E@Z ENDP				; tay
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?tax@@YAEGPEAUcpu@@E@Z PROC				; tax

; 601  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 602  :     Cpu->X = Cpu->A;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0001d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00020	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 603  :     setZero(Cpu->X, &Cpu->Flags);

  00023	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	48 83 c0 03	 add	 rax, 3
  0002c	48 8b d0	 mov	 rdx, rax
  0002f	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00034	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00038	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 604  :     setNegative(Cpu->X, &Cpu->Flags);

  0003d	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00042	48 83 c0 03	 add	 rax, 3
  00046	48 8b d0	 mov	 rdx, rax
  00049	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004e	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00052	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 605  :     return(0);

  00057	32 c0		 xor	 al, al

; 606  : }

  00059	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005d	c3		 ret	 0
?tax@@YAEGPEAUcpu@@E@Z ENDP				; tax
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?sty@@YAEGPEAUcpu@@E@Z PROC				; sty

; 596  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 597  :     writeCpu8(Cpu->Y, Address, Cpu);

  00013	4c 8b 44 24 38	 mov	 r8, QWORD PTR Cpu$[rsp]
  00018	0f b7 54 24 30	 movzx	 edx, WORD PTR Address$[rsp]
  0001d	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00022	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00026	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8

; 598  :     return(0);

  0002b	32 c0		 xor	 al, al

; 599  : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
?sty@@YAEGPEAUcpu@@E@Z ENDP				; sty
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?stx@@YAEGPEAUcpu@@E@Z PROC				; stx

; 591  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 592  :     writeCpu8(Cpu->X, Address, Cpu);

  00013	4c 8b 44 24 38	 mov	 r8, QWORD PTR Cpu$[rsp]
  00018	0f b7 54 24 30	 movzx	 edx, WORD PTR Address$[rsp]
  0001d	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00022	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00026	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8

; 593  :     return(0);

  0002b	32 c0		 xor	 al, al

; 594  : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
?stx@@YAEGPEAUcpu@@E@Z ENDP				; stx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?sta@@YAEGPEAUcpu@@E@Z PROC				; sta

; 586  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 587  :     writeCpu8(Cpu->A, Address, Cpu);

  00013	4c 8b 44 24 38	 mov	 r8, QWORD PTR Cpu$[rsp]
  00018	0f b7 54 24 30	 movzx	 edx, WORD PTR Address$[rsp]
  0001d	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00022	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00025	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8

; 588  :     return(0);

  0002a	32 c0		 xor	 al, al

; 589  : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
?sta@@YAEGPEAUcpu@@E@Z ENDP				; sta
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?sei@@YAEGPEAUcpu@@E@Z PROC				; sei

; 581  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 582  :     setInterrupt(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?setInterrupt@@YAXPEAE@Z ; setInterrupt

; 583  :     return(0);

  00024	32 c0		 xor	 al, al

; 584  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?sei@@YAEGPEAUcpu@@E@Z ENDP				; sei
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?sed@@YAEGPEAUcpu@@E@Z PROC				; sed

; 576  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 577  :     setDecimal(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?setDecimal@@YAXPEAE@Z	; setDecimal

; 578  :     return(0);

  00024	32 c0		 xor	 al, al

; 579  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?sed@@YAEGPEAUcpu@@E@Z ENDP				; sed
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?sec@@YAEGPEAUcpu@@E@Z PROC				; sec

; 571  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 572  :     setCarry(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 573  :     return(0);

  00024	32 c0		 xor	 al, al

; 574  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?sec@@YAEGPEAUcpu@@E@Z ENDP				; sec
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
A$ = 32
B$ = 33
C$ = 34
Sum$ = 36
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?sbc@@YAEGPEAUcpu@@E@Z PROC				; sbc

; 544  : {

$LN7:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 545  :     catchUpPpu(Cpu);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?catchUpPpu@@YAXPEAUcpu@@@Z ; catchUpPpu

; 546  :     uint8 A = Cpu->A;

  0001d	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00022	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00025	88 44 24 20	 mov	 BYTE PTR A$[rsp], al

; 547  :     uint8 B = ~readCpu8(Address, Cpu); // NOTE: Using the inverse

  00029	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0002e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00033	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00038	0f b6 c0	 movzx	 eax, al
  0003b	f7 d0		 not	 eax
  0003d	88 44 24 21	 mov	 BYTE PTR B$[rsp], al

; 548  :     uint8 C = isBitSet(CARRY_BIT, Cpu->Flags);

  00041	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00046	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  0004a	b1 01		 mov	 cl, 1
  0004c	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00051	88 44 24 22	 mov	 BYTE PTR C$[rsp], al

; 549  : 
; 550  :     uint16 Sum = (uint16)A + (uint16)B + (uint16)C;

  00055	0f b6 44 24 20	 movzx	 eax, BYTE PTR A$[rsp]
  0005a	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR B$[rsp]
  0005f	03 c1		 add	 eax, ecx
  00061	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR C$[rsp]
  00066	03 c1		 add	 eax, ecx
  00068	66 89 44 24 24	 mov	 WORD PTR Sum$[rsp], ax

; 551  : 
; 552  :     // Overflow check, taken from the web. One day find out how this works
; 553  :     if(((A ^ Sum) & (B ^ Sum) & 0x80) == 0x80)

  0006d	0f b6 44 24 20	 movzx	 eax, BYTE PTR A$[rsp]
  00072	0f b7 4c 24 24	 movzx	 ecx, WORD PTR Sum$[rsp]
  00077	33 c1		 xor	 eax, ecx
  00079	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR B$[rsp]
  0007e	0f b7 54 24 24	 movzx	 edx, WORD PTR Sum$[rsp]
  00083	33 ca		 xor	 ecx, edx
  00085	23 c1		 and	 eax, ecx
  00087	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0008c	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00091	75 13		 jne	 SHORT $LN2@sbc

; 554  :         setOverflow(&Cpu->Flags);

  00093	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00098	48 83 c0 03	 add	 rax, 3
  0009c	48 8b c8	 mov	 rcx, rax
  0009f	e8 00 00 00 00	 call	 ?setOverflow@@YAXPEAE@Z	; setOverflow

; 555  :     else

  000a4	eb 11		 jmp	 SHORT $LN3@sbc
$LN2@sbc:

; 556  :         clearOverflow(&Cpu->Flags);

  000a6	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000ab	48 83 c0 03	 add	 rax, 3
  000af	48 8b c8	 mov	 rcx, rax
  000b2	e8 00 00 00 00	 call	 ?clearOverflow@@YAXPEAE@Z ; clearOverflow
$LN3@sbc:

; 557  : 
; 558  :     if(Sum & 0x100)

  000b7	0f b7 44 24 24	 movzx	 eax, WORD PTR Sum$[rsp]
  000bc	25 00 01 00 00	 and	 eax, 256		; 00000100H
  000c1	85 c0		 test	 eax, eax
  000c3	74 13		 je	 SHORT $LN4@sbc

; 559  :         setCarry(&Cpu->Flags);

  000c5	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000ca	48 83 c0 03	 add	 rax, 3
  000ce	48 8b c8	 mov	 rcx, rax
  000d1	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 560  :     else

  000d6	eb 11		 jmp	 SHORT $LN5@sbc
$LN4@sbc:

; 561  :         clearCarry(&Cpu->Flags);

  000d8	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000dd	48 83 c0 03	 add	 rax, 3
  000e1	48 8b c8	 mov	 rcx, rax
  000e4	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN5@sbc:

; 562  : 
; 563  :     setZero(Sum, &Cpu->Flags);

  000e9	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000ee	48 83 c0 03	 add	 rax, 3
  000f2	48 8b d0	 mov	 rdx, rax
  000f5	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Sum$[rsp]
  000fa	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 564  :     setNegative(Sum, &Cpu->Flags);

  000ff	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00104	48 83 c0 03	 add	 rax, 3
  00108	48 8b d0	 mov	 rdx, rax
  0010b	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Sum$[rsp]
  00110	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 565  : 
; 566  :     Cpu->A = (uint8)Sum;

  00115	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0011a	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Sum$[rsp]
  0011f	88 08		 mov	 BYTE PTR [rax], cl

; 567  : 
; 568  :     return(0);

  00121	32 c0		 xor	 al, al

; 569  : }

  00123	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00127	c3		 ret	 0
?sbc@@YAEGPEAUcpu@@E@Z ENDP				; sbc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
ReturnAddress$ = 36
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?rts@@YAEGPEAUcpu@@E@Z PROC				; rts

; 536  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 537  :     uint8 LowByte = pop(Cpu);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  0001d	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 538  :     uint8 HighByte = pop(Cpu);

  00021	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00026	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  0002b	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 539  :     uint16 ReturnAddress = ((uint16)HighByte << 8) | (uint16)LowByte;

  0002f	0f b6 44 24 20	 movzx	 eax, BYTE PTR HighByte$[rsp]
  00034	c1 e0 08	 shl	 eax, 8
  00037	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  0003c	0b c1		 or	 eax, ecx
  0003e	66 89 44 24 24	 mov	 WORD PTR ReturnAddress$[rsp], ax

; 540  :     Cpu->PrgCounter = ReturnAddress + 1;

  00043	0f b7 44 24 24	 movzx	 eax, WORD PTR ReturnAddress$[rsp]
  00048	ff c0		 inc	 eax
  0004a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0004f	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 541  :     return(0);

  00053	32 c0		 xor	 al, al

; 542  : }

  00055	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00059	c3		 ret	 0
?rts@@YAEGPEAUcpu@@E@Z ENDP				; rts
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Flags$ = 32
HighByte$ = 33
LowByte$ = 34
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?rti@@YAEGPEAUcpu@@E@Z PROC				; rti

; 526  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 527  :     uint8 Flags = pop(Cpu);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  0001d	88 44 24 20	 mov	 BYTE PTR Flags$[rsp], al

; 528  :     Cpu->Flags = Flags;

  00021	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00026	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Flags$[rsp]
  0002b	88 48 03	 mov	 BYTE PTR [rax+3], cl

; 529  :     
; 530  :     uint8 LowByte = pop(Cpu);

  0002e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00033	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  00038	88 44 24 22	 mov	 BYTE PTR LowByte$[rsp], al

; 531  :     uint8 HighByte = pop(Cpu);

  0003c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00041	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  00046	88 44 24 21	 mov	 BYTE PTR HighByte$[rsp], al

; 532  :     Cpu->PrgCounter = ((uint16)HighByte << 8) | (uint16)LowByte;

  0004a	0f b6 44 24 21	 movzx	 eax, BYTE PTR HighByte$[rsp]
  0004f	c1 e0 08	 shl	 eax, 8
  00052	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  00057	0b c1		 or	 eax, ecx
  00059	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0005e	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 533  :     return(0);

  00062	32 c0		 xor	 al, al

; 534  : }

  00064	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00068	c3		 ret	 0
?rti@@YAEGPEAUcpu@@E@Z ENDP				; rti
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
CarrySet$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?ror@@YAEGPEAUcpu@@E@Z PROC				; ror

; 486  : {

$LN11:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 487  :     uint8 Value = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR Value$[rsp], 0

; 488  :     uint8 CarrySet = isBitSet(CARRY_BIT, Cpu->Flags);

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 01		 mov	 cl, 1
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	88 44 24 21	 mov	 BYTE PTR CarrySet$[rsp], al

; 489  :     
; 490  :     if(AddressMode == ACM)

  0002c	0f b6 44 24 50	 movzx	 eax, BYTE PTR AddressMode$[rsp]
  00031	83 f8 01	 cmp	 eax, 1
  00034	75 68		 jne	 SHORT $LN2@ror

; 491  :     {        
; 492  :         if(Cpu->A & 1)

  00036	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003e	83 e0 01	 and	 eax, 1
  00041	85 c0		 test	 eax, eax
  00043	74 13		 je	 SHORT $LN4@ror

; 493  :             setCarry(&Cpu->Flags);

  00045	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004a	48 83 c0 03	 add	 rax, 3
  0004e	48 8b c8	 mov	 rcx, rax
  00051	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 494  :         else

  00056	eb 11		 jmp	 SHORT $LN5@ror
$LN4@ror:

; 495  :             clearCarry(&Cpu->Flags);

  00058	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005d	48 83 c0 03	 add	 rax, 3
  00061	48 8b c8	 mov	 rcx, rax
  00064	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN5@ror:

; 496  :         
; 497  :         Value = Cpu->A >> 1;

  00069	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0006e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00071	d1 f8		 sar	 eax, 1
  00073	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 498  :         
; 499  :         if(CarrySet)

  00077	0f b6 44 24 21	 movzx	 eax, BYTE PTR CarrySet$[rsp]
  0007c	85 c0		 test	 eax, eax
  0007e	74 0d		 je	 SHORT $LN6@ror

; 500  :             Value = Value | (1 << 7);

  00080	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  00085	0f ba e8 07	 bts	 eax, 7
  00089	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
$LN6@ror:

; 501  :         
; 502  :         Cpu->A = Value;

  0008d	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00092	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00097	88 08		 mov	 BYTE PTR [rax], cl

; 503  :     }
; 504  :     else

  00099	e9 82 00 00 00	 jmp	 $LN3@ror
$LN2@ror:

; 505  :     {
; 506  :         catchUpPpu(Cpu);

  0009e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  000a3	e8 00 00 00 00	 call	 ?catchUpPpu@@YAXPEAUcpu@@@Z ; catchUpPpu

; 507  :         Value = readCpu8(Address, Cpu);

  000a8	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  000ad	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  000b2	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  000b7	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 508  :         if(Value & 1)

  000bb	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000c0	83 e0 01	 and	 eax, 1
  000c3	85 c0		 test	 eax, eax
  000c5	74 13		 je	 SHORT $LN7@ror

; 509  :             setCarry(&Cpu->Flags);

  000c7	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000cc	48 83 c0 03	 add	 rax, 3
  000d0	48 8b c8	 mov	 rcx, rax
  000d3	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 510  :         else

  000d8	eb 11		 jmp	 SHORT $LN8@ror
$LN7@ror:

; 511  :             clearCarry(&Cpu->Flags);

  000da	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000df	48 83 c0 03	 add	 rax, 3
  000e3	48 8b c8	 mov	 rcx, rax
  000e6	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN8@ror:

; 512  :         
; 513  :         Value = Value >> 1;

  000eb	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000f0	d1 f8		 sar	 eax, 1
  000f2	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 514  :         
; 515  :         if(CarrySet)

  000f6	0f b6 44 24 21	 movzx	 eax, BYTE PTR CarrySet$[rsp]
  000fb	85 c0		 test	 eax, eax
  000fd	74 0d		 je	 SHORT $LN9@ror

; 516  :             Value = Value | (1 << 7);

  000ff	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  00104	0f ba e8 07	 bts	 eax, 7
  00108	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
$LN9@ror:

; 517  :         
; 518  :         writeCpu8(Value, Address, Cpu);

  0010c	4c 8b 44 24 48	 mov	 r8, QWORD PTR Cpu$[rsp]
  00111	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  00116	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0011b	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8
$LN3@ror:

; 519  :     }
; 520  :     setZero(Value, &Cpu->Flags);

  00120	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00125	48 83 c0 03	 add	 rax, 3
  00129	48 8b d0	 mov	 rdx, rax
  0012c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00131	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 521  :     setNegative(Value, &Cpu->Flags);

  00136	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0013b	48 83 c0 03	 add	 rax, 3
  0013f	48 8b d0	 mov	 rdx, rax
  00142	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00147	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 522  :     return(0);

  0014c	32 c0		 xor	 al, al

; 523  : }

  0014e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00152	c3		 ret	 0
?ror@@YAEGPEAUcpu@@E@Z ENDP				; ror
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
CarrySet$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?rol@@YAEGPEAUcpu@@E@Z PROC				; rol

; 446  : {    

$LN11:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 447  :     uint8 Value = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR Value$[rsp], 0

; 448  :     uint8 CarrySet = isBitSet(CARRY_BIT, Cpu->Flags);

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 01		 mov	 cl, 1
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	88 44 24 21	 mov	 BYTE PTR CarrySet$[rsp], al

; 449  :     
; 450  :     if(AddressMode == ACM)

  0002c	0f b6 44 24 50	 movzx	 eax, BYTE PTR AddressMode$[rsp]
  00031	83 f8 01	 cmp	 eax, 1
  00034	75 69		 jne	 SHORT $LN2@rol

; 451  :     {        
; 452  :         if(Cpu->A & (1 << 7))

  00036	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003e	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00043	85 c0		 test	 eax, eax
  00045	74 13		 je	 SHORT $LN4@rol

; 453  :             setCarry(&Cpu->Flags);

  00047	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004c	48 83 c0 03	 add	 rax, 3
  00050	48 8b c8	 mov	 rcx, rax
  00053	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 454  :         else

  00058	eb 11		 jmp	 SHORT $LN5@rol
$LN4@rol:

; 455  :             clearCarry(&Cpu->Flags);

  0005a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005f	48 83 c0 03	 add	 rax, 3
  00063	48 8b c8	 mov	 rcx, rax
  00066	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN5@rol:

; 456  :         
; 457  :         Value = Cpu->A << 1;

  0006b	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00070	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00073	d1 e0		 shl	 eax, 1
  00075	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 458  :         
; 459  :         if(CarrySet)

  00079	0f b6 44 24 21	 movzx	 eax, BYTE PTR CarrySet$[rsp]
  0007e	85 c0		 test	 eax, eax
  00080	74 0c		 je	 SHORT $LN6@rol

; 460  :             Value = Value | 1;

  00082	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  00087	83 c8 01	 or	 eax, 1
  0008a	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
$LN6@rol:

; 461  :         
; 462  :         Cpu->A = Value;

  0008e	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00093	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00098	88 08		 mov	 BYTE PTR [rax], cl

; 463  :     }
; 464  :     else

  0009a	e9 83 00 00 00	 jmp	 $LN3@rol
$LN2@rol:

; 465  :     {
; 466  :         catchUpPpu(Cpu);

  0009f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  000a4	e8 00 00 00 00	 call	 ?catchUpPpu@@YAXPEAUcpu@@@Z ; catchUpPpu

; 467  :         Value = readCpu8(Address, Cpu);

  000a9	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  000ae	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  000b3	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  000b8	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 468  :         if(Value & (1 << 7))

  000bc	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000c1	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000c6	85 c0		 test	 eax, eax
  000c8	74 13		 je	 SHORT $LN7@rol

; 469  :             setCarry(&Cpu->Flags);

  000ca	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000cf	48 83 c0 03	 add	 rax, 3
  000d3	48 8b c8	 mov	 rcx, rax
  000d6	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 470  :         else

  000db	eb 11		 jmp	 SHORT $LN8@rol
$LN7@rol:

; 471  :             clearCarry(&Cpu->Flags);

  000dd	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000e2	48 83 c0 03	 add	 rax, 3
  000e6	48 8b c8	 mov	 rcx, rax
  000e9	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN8@rol:

; 472  :         
; 473  :         Value = Value << 1;

  000ee	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000f3	d1 e0		 shl	 eax, 1
  000f5	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 474  :         
; 475  :         if(CarrySet)

  000f9	0f b6 44 24 21	 movzx	 eax, BYTE PTR CarrySet$[rsp]
  000fe	85 c0		 test	 eax, eax
  00100	74 0c		 je	 SHORT $LN9@rol

; 476  :             Value = Value | 1;

  00102	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  00107	83 c8 01	 or	 eax, 1
  0010a	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
$LN9@rol:

; 477  :         
; 478  :         writeCpu8(Value, Address, Cpu);

  0010e	4c 8b 44 24 48	 mov	 r8, QWORD PTR Cpu$[rsp]
  00113	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  00118	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0011d	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8
$LN3@rol:

; 479  :     }
; 480  :     setZero(Value, &Cpu->Flags);

  00122	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00127	48 83 c0 03	 add	 rax, 3
  0012b	48 8b d0	 mov	 rdx, rax
  0012e	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00133	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 481  :     setNegative(Value, &Cpu->Flags);

  00138	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0013d	48 83 c0 03	 add	 rax, 3
  00141	48 8b d0	 mov	 rdx, rax
  00144	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00149	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 482  :     return(0);

  0014e	32 c0		 xor	 al, al

; 483  : }

  00150	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00154	c3		 ret	 0
?rol@@YAEGPEAUcpu@@E@Z ENDP				; rol
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?plp@@YAEGPEAUcpu@@E@Z PROC				; plp

; 441  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 442  :     Cpu->Flags = pop(Cpu);

  00013	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  0001d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00022	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 443  :     return(0);

  00025	32 c0		 xor	 al, al

; 444  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
?plp@@YAEGPEAUcpu@@E@Z ENDP				; plp
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?pla@@YAEGPEAUcpu@@E@Z PROC				; pla

; 434  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 435  :     Cpu->A = pop(Cpu); 

  00013	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  0001d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00022	88 01		 mov	 BYTE PTR [rcx], al

; 436  :     setZero(Cpu->A, &Cpu->Flags);

  00024	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00029	48 83 c0 03	 add	 rax, 3
  0002d	48 8b d0	 mov	 rdx, rax
  00030	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00035	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00038	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 437  :     setNegative(Cpu->A, &Cpu->Flags);

  0003d	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00042	48 83 c0 03	 add	 rax, 3
  00046	48 8b d0	 mov	 rdx, rax
  00049	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004e	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00051	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 438  :     return(0);

  00056	32 c0		 xor	 al, al

; 439  : }

  00058	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005c	c3		 ret	 0
?pla@@YAEGPEAUcpu@@E@Z ENDP				; pla
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?php@@YAEGPEAUcpu@@E@Z PROC				; php

; 427  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 428  :     setBreak(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?setBreak@@YAXPEAE@Z	; setBreak

; 429  :     setBlank(&Cpu->Flags);

  00024	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00029	48 83 c0 03	 add	 rax, 3
  0002d	48 8b c8	 mov	 rcx, rax
  00030	e8 00 00 00 00	 call	 ?setBlank@@YAXPEAE@Z	; setBlank

; 430  :     push(Cpu->Flags, Cpu);

  00035	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0003a	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003f	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  00043	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 431  :     return(0);

  00048	32 c0		 xor	 al, al

; 432  : }

  0004a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004e	c3		 ret	 0
?php@@YAEGPEAUcpu@@E@Z ENDP				; php
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?pha@@YAEGPEAUcpu@@E@Z PROC				; pha

; 422  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 423  :     push(Cpu->A, Cpu);

  00013	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00018	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00020	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 424  :     return(0);

  00025	32 c0		 xor	 al, al

; 425  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
?pha@@YAEGPEAUcpu@@E@Z ENDP				; pha
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?ora@@YAEGPEAUcpu@@E@Z PROC				; ora

; 413  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 414  :     catchUpPpu(Cpu);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?catchUpPpu@@YAXPEAUcpu@@@Z ; catchUpPpu

; 415  :     uint8 Value = readCpu8(Address, Cpu);

  0001d	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00022	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00027	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  0002c	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 416  :     Cpu->A = Cpu->A | Value;

  00030	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00035	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00038	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0003d	0b c1		 or	 eax, ecx
  0003f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00044	88 01		 mov	 BYTE PTR [rcx], al

; 417  :     setZero(Cpu->A, &Cpu->Flags);

  00046	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004b	48 83 c0 03	 add	 rax, 3
  0004f	48 8b d0	 mov	 rdx, rax
  00052	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00057	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0005a	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 418  :     setNegative(Cpu->A, &Cpu->Flags);

  0005f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00064	48 83 c0 03	 add	 rax, 3
  00068	48 8b d0	 mov	 rdx, rax
  0006b	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00070	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00073	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 419  :     return(0);

  00078	32 c0		 xor	 al, al

; 420  : }

  0007a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007e	c3		 ret	 0
?ora@@YAEGPEAUcpu@@E@Z ENDP				; ora
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?nop@@YAEGPEAUcpu@@E@Z PROC				; nop

; 409  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 410  :     return(0);

  0000f	32 c0		 xor	 al, al

; 411  : }

  00011	c3		 ret	 0
?nop@@YAEGPEAUcpu@@E@Z ENDP				; nop
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?lsr@@YAEGPEAUcpu@@E@Z PROC				; lsr

; 382  : {

$LN9:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 383  :     uint8 Value = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR Value$[rsp], 0

; 384  :     if(AddressMode == ACM)

  00018	0f b6 44 24 50	 movzx	 eax, BYTE PTR AddressMode$[rsp]
  0001d	83 f8 01	 cmp	 eax, 1
  00020	75 52		 jne	 SHORT $LN2@lsr

; 385  :     {        
; 386  :         if(Cpu->A & 1)

  00022	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00027	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002a	83 e0 01	 and	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	74 13		 je	 SHORT $LN4@lsr

; 387  :             setCarry(&Cpu->Flags);

  00031	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00036	48 83 c0 03	 add	 rax, 3
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 388  :         else

  00042	eb 11		 jmp	 SHORT $LN5@lsr
$LN4@lsr:

; 389  :             clearCarry(&Cpu->Flags);

  00044	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00049	48 83 c0 03	 add	 rax, 3
  0004d	48 8b c8	 mov	 rcx, rax
  00050	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN5@lsr:

; 390  :         Cpu->A = Cpu->A >> 1;

  00055	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005d	d1 f8		 sar	 eax, 1
  0005f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00064	88 01		 mov	 BYTE PTR [rcx], al

; 391  :         Value = Cpu->A;

  00066	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0006b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006e	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 392  :     }
; 393  :     else

  00072	eb 6c		 jmp	 SHORT $LN3@lsr
$LN2@lsr:

; 394  :     {
; 395  :         catchUpPpu(Cpu);

  00074	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00079	e8 00 00 00 00	 call	 ?catchUpPpu@@YAXPEAUcpu@@@Z ; catchUpPpu

; 396  :         Value = readCpu8(Address, Cpu);

  0007e	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00083	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00088	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  0008d	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 397  :         if(Value & 1)

  00091	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  00096	83 e0 01	 and	 eax, 1
  00099	85 c0		 test	 eax, eax
  0009b	74 13		 je	 SHORT $LN6@lsr

; 398  :             setCarry(&Cpu->Flags);

  0009d	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000a2	48 83 c0 03	 add	 rax, 3
  000a6	48 8b c8	 mov	 rcx, rax
  000a9	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 399  :         else

  000ae	eb 11		 jmp	 SHORT $LN7@lsr
$LN6@lsr:

; 400  :             clearCarry(&Cpu->Flags);

  000b0	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000b5	48 83 c0 03	 add	 rax, 3
  000b9	48 8b c8	 mov	 rcx, rax
  000bc	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN7@lsr:

; 401  :         Value = Value >> 1;

  000c1	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000c6	d1 f8		 sar	 eax, 1
  000c8	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 402  :         writeCpu8(Value, Address, Cpu);

  000cc	4c 8b 44 24 48	 mov	 r8, QWORD PTR Cpu$[rsp]
  000d1	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  000d6	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  000db	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8
$LN3@lsr:

; 403  :     }
; 404  :     setZero(Value, &Cpu->Flags);

  000e0	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000e5	48 83 c0 03	 add	 rax, 3
  000e9	48 8b d0	 mov	 rdx, rax
  000ec	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  000f1	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 405  :     setNegative(Value, &Cpu->Flags);

  000f6	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000fb	48 83 c0 03	 add	 rax, 3
  000ff	48 8b d0	 mov	 rdx, rax
  00102	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00107	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 406  :     return(0);

  0010c	32 c0		 xor	 al, al

; 407  : }

  0010e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00112	c3		 ret	 0
?lsr@@YAEGPEAUcpu@@E@Z ENDP				; lsr
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?ldy@@YAEGPEAUcpu@@E@Z PROC				; ldy

; 373  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 374  :     catchUpPpu(Cpu);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?catchUpPpu@@YAXPEAUcpu@@@Z ; catchUpPpu

; 375  :     uint8 Value = readCpu8(Address, Cpu);

  0001d	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00022	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00027	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  0002c	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 376  :     Cpu->Y = Value;

  00030	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00035	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0003a	88 48 02	 mov	 BYTE PTR [rax+2], cl

; 377  :     setZero(Value, &Cpu->Flags);

  0003d	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00042	48 83 c0 03	 add	 rax, 3
  00046	48 8b d0	 mov	 rdx, rax
  00049	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0004e	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 378  :     setNegative(Value, &Cpu->Flags);

  00053	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00058	48 83 c0 03	 add	 rax, 3
  0005c	48 8b d0	 mov	 rdx, rax
  0005f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00064	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 379  :     return(0);

  00069	32 c0		 xor	 al, al

; 380  : }

  0006b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006f	c3		 ret	 0
?ldy@@YAEGPEAUcpu@@E@Z ENDP				; ldy
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?ldx@@YAEGPEAUcpu@@E@Z PROC				; ldx

; 364  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 365  :     catchUpPpu(Cpu);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?catchUpPpu@@YAXPEAUcpu@@@Z ; catchUpPpu

; 366  :     uint8 Value = readCpu8(Address, Cpu);

  0001d	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00022	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00027	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  0002c	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 367  :     Cpu->X = Value;

  00030	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00035	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0003a	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 368  :     setZero(Value, &Cpu->Flags);

  0003d	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00042	48 83 c0 03	 add	 rax, 3
  00046	48 8b d0	 mov	 rdx, rax
  00049	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0004e	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 369  :     setNegative(Value, &Cpu->Flags);

  00053	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00058	48 83 c0 03	 add	 rax, 3
  0005c	48 8b d0	 mov	 rdx, rax
  0005f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00064	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 370  :     return(0);

  00069	32 c0		 xor	 al, al

; 371  : }

  0006b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006f	c3		 ret	 0
?ldx@@YAEGPEAUcpu@@E@Z ENDP				; ldx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?lda@@YAEGPEAUcpu@@E@Z PROC				; lda

; 355  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 356  :     catchUpPpu(Cpu);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?catchUpPpu@@YAXPEAUcpu@@@Z ; catchUpPpu

; 357  :     uint8 Value = readCpu8(Address, Cpu);

  0001d	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00022	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00027	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  0002c	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 358  :     Cpu->A = Value;

  00030	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00035	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0003a	88 08		 mov	 BYTE PTR [rax], cl

; 359  :     setZero(Value, &Cpu->Flags);

  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	48 83 c0 03	 add	 rax, 3
  00045	48 8b d0	 mov	 rdx, rax
  00048	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0004d	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 360  :     setNegative(Value, &Cpu->Flags);

  00052	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00057	48 83 c0 03	 add	 rax, 3
  0005b	48 8b d0	 mov	 rdx, rax
  0005e	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00063	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 361  :     return(0);

  00068	32 c0		 xor	 al, al

; 362  : }

  0006a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006e	c3		 ret	 0
?lda@@YAEGPEAUcpu@@E@Z ENDP				; lda
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
ReturnAddress$ = 36
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?jsr@@YAEGPEAUcpu@@E@Z PROC				; jsr

; 343  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 344  :     uint16 ReturnAddress = Cpu->PrgCounter - 1;

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0001c	ff c8		 dec	 eax
  0001e	66 89 44 24 24	 mov	 WORD PTR ReturnAddress$[rsp], ax

; 345  :     uint8 HighByte = (uint8)(ReturnAddress >> 8);

  00023	0f b7 44 24 24	 movzx	 eax, WORD PTR ReturnAddress$[rsp]
  00028	c1 f8 08	 sar	 eax, 8
  0002b	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 346  :     uint8 LowByte = (uint8)ReturnAddress; 

  0002f	0f b6 44 24 24	 movzx	 eax, BYTE PTR ReturnAddress$[rsp]
  00034	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 347  : 
; 348  :     push(HighByte, Cpu);

  00038	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0003d	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR HighByte$[rsp]
  00042	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 349  :     push(LowByte, Cpu);

  00047	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0004c	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  00051	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 350  : 
; 351  :     Cpu->PrgCounter = Address;

  00056	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005b	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00060	66 89 48 06	 mov	 WORD PTR [rax+6], cx

; 352  :     return(0);

  00064	32 c0		 xor	 al, al

; 353  : }

  00066	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006a	c3		 ret	 0
?jsr@@YAEGPEAUcpu@@E@Z ENDP				; jsr
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?jmp@@YAEGPEAUcpu@@E@Z PROC				; jmp

; 338  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 339  :     Cpu->PrgCounter = Address;

  0000f	48 8b 44 24 10	 mov	 rax, QWORD PTR Cpu$[rsp]
  00014	0f b7 4c 24 08	 movzx	 ecx, WORD PTR Address$[rsp]
  00019	66 89 48 06	 mov	 WORD PTR [rax+6], cx

; 340  :     return(0);

  0001d	32 c0		 xor	 al, al

; 341  : }

  0001f	c3		 ret	 0
?jmp@@YAEGPEAUcpu@@E@Z ENDP				; jmp
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?iny@@YAEGPEAUcpu@@E@Z PROC				; iny

; 331  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 332  :     ++Cpu->Y;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0001c	fe c0		 inc	 al
  0001e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00023	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 333  :     setZero(Cpu->Y, &Cpu->Flags);

  00026	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	48 83 c0 03	 add	 rax, 3
  0002f	48 8b d0	 mov	 rdx, rax
  00032	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00037	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  0003b	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 334  :     setNegative(Cpu->Y, &Cpu->Flags);

  00040	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00045	48 83 c0 03	 add	 rax, 3
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00055	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 335  :     return(0);

  0005a	32 c0		 xor	 al, al

; 336  : }

  0005c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00060	c3		 ret	 0
?iny@@YAEGPEAUcpu@@E@Z ENDP				; iny
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?inx@@YAEGPEAUcpu@@E@Z PROC				; inx

; 324  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 325  :     ++Cpu->X;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0001c	fe c0		 inc	 al
  0001e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00023	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 326  :     setZero(Cpu->X, &Cpu->Flags);

  00026	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	48 83 c0 03	 add	 rax, 3
  0002f	48 8b d0	 mov	 rdx, rax
  00032	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00037	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  0003b	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 327  :     setNegative(Cpu->X, &Cpu->Flags);

  00040	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00045	48 83 c0 03	 add	 rax, 3
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00055	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 328  :     return(0);

  0005a	32 c0		 xor	 al, al

; 329  : }

  0005c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00060	c3		 ret	 0
?inx@@YAEGPEAUcpu@@E@Z ENDP				; inx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?inc@@YAEGPEAUcpu@@E@Z PROC				; inc

; 315  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 316  :     catchUpPpu(Cpu);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?catchUpPpu@@YAXPEAUcpu@@@Z ; catchUpPpu

; 317  :     uint8 Value = readCpu8(Address, Cpu) + 1;

  0001d	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00022	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00027	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  0002c	0f b6 c0	 movzx	 eax, al
  0002f	ff c0		 inc	 eax
  00031	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 318  :     writeCpu8(Value, Address, Cpu);

  00035	4c 8b 44 24 48	 mov	 r8, QWORD PTR Cpu$[rsp]
  0003a	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00044	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8

; 319  :     setZero(Value, &Cpu->Flags);

  00049	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004e	48 83 c0 03	 add	 rax, 3
  00052	48 8b d0	 mov	 rdx, rax
  00055	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0005a	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 320  :     setNegative(Value, &Cpu->Flags);

  0005f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00064	48 83 c0 03	 add	 rax, 3
  00068	48 8b d0	 mov	 rdx, rax
  0006b	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00070	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 321  :     return(0);

  00075	32 c0		 xor	 al, al

; 322  : }

  00077	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007b	c3		 ret	 0
?inc@@YAEGPEAUcpu@@E@Z ENDP				; inc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?eor@@YAEGPEAUcpu@@E@Z PROC				; eor

; 306  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 307  :     catchUpPpu(Cpu);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?catchUpPpu@@YAXPEAUcpu@@@Z ; catchUpPpu

; 308  :     uint8 Value = readCpu8(Address, Cpu);

  0001d	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00022	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00027	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  0002c	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 309  :     Cpu->A = Cpu->A ^ Value;

  00030	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00035	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00038	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0003d	33 c1		 xor	 eax, ecx
  0003f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00044	88 01		 mov	 BYTE PTR [rcx], al

; 310  :     setZero(Cpu->A, &Cpu->Flags);

  00046	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004b	48 83 c0 03	 add	 rax, 3
  0004f	48 8b d0	 mov	 rdx, rax
  00052	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00057	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0005a	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 311  :     setNegative(Cpu->A, &Cpu->Flags);

  0005f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00064	48 83 c0 03	 add	 rax, 3
  00068	48 8b d0	 mov	 rdx, rax
  0006b	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00070	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00073	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 312  :     return(0);

  00078	32 c0		 xor	 al, al

; 313  : }

  0007a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007e	c3		 ret	 0
?eor@@YAEGPEAUcpu@@E@Z ENDP				; eor
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?dey@@YAEGPEAUcpu@@E@Z PROC				; dey

; 299  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 300  :     --Cpu->Y;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0001c	fe c8		 dec	 al
  0001e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00023	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 301  :     setZero(Cpu->Y, &Cpu->Flags);

  00026	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	48 83 c0 03	 add	 rax, 3
  0002f	48 8b d0	 mov	 rdx, rax
  00032	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00037	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  0003b	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 302  :     setNegative(Cpu->Y, &Cpu->Flags);

  00040	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00045	48 83 c0 03	 add	 rax, 3
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00055	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 303  :     return(0);

  0005a	32 c0		 xor	 al, al

; 304  : }

  0005c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00060	c3		 ret	 0
?dey@@YAEGPEAUcpu@@E@Z ENDP				; dey
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?dex@@YAEGPEAUcpu@@E@Z PROC				; dex

; 292  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 293  :     --Cpu->X;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0001c	fe c8		 dec	 al
  0001e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00023	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 294  :     setZero(Cpu->X, &Cpu->Flags);

  00026	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	48 83 c0 03	 add	 rax, 3
  0002f	48 8b d0	 mov	 rdx, rax
  00032	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00037	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  0003b	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 295  :     setNegative(Cpu->X, &Cpu->Flags);

  00040	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00045	48 83 c0 03	 add	 rax, 3
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00055	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 296  :     return(0);

  0005a	32 c0		 xor	 al, al

; 297  : }

  0005c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00060	c3		 ret	 0
?dex@@YAEGPEAUcpu@@E@Z ENDP				; dex
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?dec@@YAEGPEAUcpu@@E@Z PROC				; dec

; 283  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 284  :     catchUpPpu(Cpu);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?catchUpPpu@@YAXPEAUcpu@@@Z ; catchUpPpu

; 285  :     uint8 Value = readCpu8(Address, Cpu) - 1;

  0001d	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00022	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00027	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  0002c	0f b6 c0	 movzx	 eax, al
  0002f	ff c8		 dec	 eax
  00031	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 286  :     writeCpu8(Value, Address, Cpu);

  00035	4c 8b 44 24 48	 mov	 r8, QWORD PTR Cpu$[rsp]
  0003a	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00044	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8

; 287  :     setZero(Value, &Cpu->Flags);

  00049	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004e	48 83 c0 03	 add	 rax, 3
  00052	48 8b d0	 mov	 rdx, rax
  00055	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0005a	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 288  :     setNegative(Value, &Cpu->Flags);

  0005f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00064	48 83 c0 03	 add	 rax, 3
  00068	48 8b d0	 mov	 rdx, rax
  0006b	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00070	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 289  :     return(0);

  00075	32 c0		 xor	 al, al

; 290  : }

  00077	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007b	c3		 ret	 0
?dec@@YAEGPEAUcpu@@E@Z ENDP				; dec
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
CmpValue$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?cpy@@YAEGPEAUcpu@@E@Z PROC				; cpy

; 269  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 270  :     uint8 Value = readCpu8(Address, Cpu);

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00018	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0001d	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00022	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 271  : 
; 272  :     if(Cpu->Y >= Value)

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0002f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00034	3b c1		 cmp	 eax, ecx
  00036	7c 13		 jl	 SHORT $LN2@cpy

; 273  :         setCarry(&Cpu->Flags);

  00038	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003d	48 83 c0 03	 add	 rax, 3
  00041	48 8b c8	 mov	 rcx, rax
  00044	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 274  :     else

  00049	eb 11		 jmp	 SHORT $LN3@cpy
$LN2@cpy:

; 275  :         clearCarry(&Cpu->Flags);

  0004b	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00050	48 83 c0 03	 add	 rax, 3
  00054	48 8b c8	 mov	 rcx, rax
  00057	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN3@cpy:

; 276  :     
; 277  :     uint8 CmpValue = Cpu->Y - Value;

  0005c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00061	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00065	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0006a	2b c1		 sub	 eax, ecx
  0006c	88 44 24 21	 mov	 BYTE PTR CmpValue$[rsp], al

; 278  :     setZero(CmpValue, &Cpu->Flags);

  00070	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00075	48 83 c0 03	 add	 rax, 3
  00079	48 8b d0	 mov	 rdx, rax
  0007c	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  00081	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 279  :     setNegative(CmpValue, &Cpu->Flags);

  00086	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0008b	48 83 c0 03	 add	 rax, 3
  0008f	48 8b d0	 mov	 rdx, rax
  00092	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  00097	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 280  :     return(0);

  0009c	32 c0		 xor	 al, al

; 281  : }

  0009e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a2	c3		 ret	 0
?cpy@@YAEGPEAUcpu@@E@Z ENDP				; cpy
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
CmpValue$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?cpx@@YAEGPEAUcpu@@E@Z PROC				; cpx

; 255  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 256  :     uint8 Value = readCpu8(Address, Cpu);

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00018	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0001d	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00022	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 257  : 
; 258  :     if(Cpu->X >= Value)

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0002f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00034	3b c1		 cmp	 eax, ecx
  00036	7c 13		 jl	 SHORT $LN2@cpx

; 259  :         setCarry(&Cpu->Flags);

  00038	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003d	48 83 c0 03	 add	 rax, 3
  00041	48 8b c8	 mov	 rcx, rax
  00044	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 260  :     else

  00049	eb 11		 jmp	 SHORT $LN3@cpx
$LN2@cpx:

; 261  :         clearCarry(&Cpu->Flags);

  0004b	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00050	48 83 c0 03	 add	 rax, 3
  00054	48 8b c8	 mov	 rcx, rax
  00057	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN3@cpx:

; 262  :     
; 263  :     uint8 CmpValue = Cpu->X - Value;

  0005c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00061	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00065	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0006a	2b c1		 sub	 eax, ecx
  0006c	88 44 24 21	 mov	 BYTE PTR CmpValue$[rsp], al

; 264  :     setZero(CmpValue, &Cpu->Flags);

  00070	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00075	48 83 c0 03	 add	 rax, 3
  00079	48 8b d0	 mov	 rdx, rax
  0007c	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  00081	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 265  :     setNegative(CmpValue, &Cpu->Flags);

  00086	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0008b	48 83 c0 03	 add	 rax, 3
  0008f	48 8b d0	 mov	 rdx, rax
  00092	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  00097	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 266  :     return(0);

  0009c	32 c0		 xor	 al, al

; 267  : }

  0009e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a2	c3		 ret	 0
?cpx@@YAEGPEAUcpu@@E@Z ENDP				; cpx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
CmpValue$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?cmp@@YAEGPEAUcpu@@E@Z PROC				; cmp

; 240  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 241  :     catchUpPpu(Cpu);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?catchUpPpu@@YAXPEAUcpu@@@Z ; catchUpPpu

; 242  :     uint8 Value = readCpu8(Address, Cpu);

  0001d	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00022	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00027	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  0002c	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 243  : 
; 244  :     if(Cpu->A >= Value)

  00030	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00035	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00038	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0003d	3b c1		 cmp	 eax, ecx
  0003f	7c 13		 jl	 SHORT $LN2@cmp

; 245  :         setCarry(&Cpu->Flags);

  00041	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00046	48 83 c0 03	 add	 rax, 3
  0004a	48 8b c8	 mov	 rcx, rax
  0004d	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 246  :     else

  00052	eb 11		 jmp	 SHORT $LN3@cmp
$LN2@cmp:

; 247  :         clearCarry(&Cpu->Flags);

  00054	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00059	48 83 c0 03	 add	 rax, 3
  0005d	48 8b c8	 mov	 rcx, rax
  00060	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN3@cmp:

; 248  :     
; 249  :     uint8 CmpValue = Cpu->A - Value;

  00065	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0006a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006d	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00072	2b c1		 sub	 eax, ecx
  00074	88 44 24 21	 mov	 BYTE PTR CmpValue$[rsp], al

; 250  :     setZero(CmpValue, &Cpu->Flags);

  00078	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0007d	48 83 c0 03	 add	 rax, 3
  00081	48 8b d0	 mov	 rdx, rax
  00084	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  00089	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 251  :     setNegative(CmpValue, &Cpu->Flags);

  0008e	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00093	48 83 c0 03	 add	 rax, 3
  00097	48 8b d0	 mov	 rdx, rax
  0009a	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  0009f	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 252  :     return(0);

  000a4	32 c0		 xor	 al, al

; 253  : }

  000a6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000aa	c3		 ret	 0
?cmp@@YAEGPEAUcpu@@E@Z ENDP				; cmp
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?clv@@YAEGPEAUcpu@@E@Z PROC				; clv

; 235  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 236  :     clearOverflow(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?clearOverflow@@YAXPEAE@Z ; clearOverflow

; 237  :     return(0);

  00024	32 c0		 xor	 al, al

; 238  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?clv@@YAEGPEAUcpu@@E@Z ENDP				; clv
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?cli@@YAEGPEAUcpu@@E@Z PROC				; cli

; 230  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 231  :     clearInterrupt(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?clearInterrupt@@YAXPEAE@Z ; clearInterrupt

; 232  :     return(0);

  00024	32 c0		 xor	 al, al

; 233  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?cli@@YAEGPEAUcpu@@E@Z ENDP				; cli
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?cld@@YAEGPEAUcpu@@E@Z PROC				; cld

; 225  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 226  :     clearDecimal(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?clearDecimal@@YAXPEAE@Z ; clearDecimal

; 227  :     return(0);

  00024	32 c0		 xor	 al, al

; 228  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?cld@@YAEGPEAUcpu@@E@Z ENDP				; cld
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?clc@@YAEGPEAUcpu@@E@Z PROC				; clc

; 220  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 221  :     clearCarry(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry

; 222  :     return(0);

  00024	32 c0		 xor	 al, al

; 223  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?clc@@YAEGPEAUcpu@@E@Z ENDP				; clc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bvs@@YAEGPEAUcpu@@E@Z PROC				; bvs

; 207  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 208  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 209  :     if(isBitSet(OVERFLOW_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 40		 mov	 cl, 64			; 00000040H
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	74 3b		 je	 SHORT $LN2@bvs

; 210  :     {
; 211  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 212  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bvs

; 213  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bvs:

; 214  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bvs:

; 215  :     }   
; 216  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 217  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bvs@@YAEGPEAUcpu@@E@Z ENDP				; bvs
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bvc@@YAEGPEAUcpu@@E@Z PROC				; bvc

; 194  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 195  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 196  :     if(!isBitSet(OVERFLOW_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 40		 mov	 cl, 64			; 00000040H
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	75 3b		 jne	 SHORT $LN2@bvc

; 197  :     {
; 198  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 199  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bvc

; 200  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bvc:

; 201  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bvc:

; 202  :     }   
; 203  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 204  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bvc@@YAEGPEAUcpu@@E@Z ENDP				; bvc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?brk@@YAEGPEAUcpu@@E@Z PROC				; brk

; 178  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 179  :     uint8 HighByte = (uint8)(Cpu->PrgCounter >> 8);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0001c	c1 f8 08	 sar	 eax, 8
  0001f	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 180  :     uint8 LowByte = (uint8)Cpu->PrgCounter; 

  00023	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  0002c	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 181  :     push(HighByte, Cpu);

  00030	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00035	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR HighByte$[rsp]
  0003a	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 182  :     push(LowByte, Cpu);

  0003f	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00044	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  00049	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 183  : 
; 184  :     setBlank(&Cpu->Flags);

  0004e	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00053	48 83 c0 03	 add	 rax, 3
  00057	48 8b c8	 mov	 rcx, rax
  0005a	e8 00 00 00 00	 call	 ?setBlank@@YAXPEAE@Z	; setBlank

; 185  :     setBreak(&Cpu->Flags);

  0005f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00064	48 83 c0 03	 add	 rax, 3
  00068	48 8b c8	 mov	 rcx, rax
  0006b	e8 00 00 00 00	 call	 ?setBreak@@YAXPEAE@Z	; setBreak

; 186  :     push(Cpu->Flags, Cpu);

  00070	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00075	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0007a	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  0007e	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 187  :     setInterrupt(&Cpu->Flags);

  00083	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00088	48 83 c0 03	 add	 rax, 3
  0008c	48 8b c8	 mov	 rcx, rax
  0008f	e8 00 00 00 00	 call	 ?setInterrupt@@YAXPEAE@Z ; setInterrupt

; 188  : 
; 189  :     Cpu->PrgCounter = readCpu16(IRQ_BRK_VEC, Cpu);

  00094	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00099	66 b9 fe ff	 mov	 cx, 65534		; 0000fffeH
  0009d	e8 00 00 00 00	 call	 ?readCpu16@@YAGGPEAUcpu@@@Z ; readCpu16
  000a2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  000a7	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 190  :     return(0);

  000ab	32 c0		 xor	 al, al

; 191  : }

  000ad	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b1	c3		 ret	 0
?brk@@YAEGPEAUcpu@@E@Z ENDP				; brk
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bpl@@YAEGPEAUcpu@@E@Z PROC				; bpl

; 165  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 166  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 167  :     if(!isBitSet(NEGATIVE_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 80		 mov	 cl, 128			; 00000080H
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	75 3b		 jne	 SHORT $LN2@bpl

; 168  :     {
; 169  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 170  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bpl

; 171  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bpl:

; 172  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bpl:

; 173  :     }   
; 174  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 175  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bpl@@YAEGPEAUcpu@@E@Z ENDP				; bpl
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bne@@YAEGPEAUcpu@@E@Z PROC				; bne

; 152  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 153  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 154  :     if(!isBitSet(ZERO_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 02		 mov	 cl, 2
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	75 3b		 jne	 SHORT $LN2@bne

; 155  :     {
; 156  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 157  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bne

; 158  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bne:

; 159  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bne:

; 160  :     }   
; 161  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 162  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bne@@YAEGPEAUcpu@@E@Z ENDP				; bne
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bmi@@YAEGPEAUcpu@@E@Z PROC				; bmi

; 139  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 140  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 141  :     if(isBitSet(NEGATIVE_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 80		 mov	 cl, 128			; 00000080H
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	74 3b		 je	 SHORT $LN2@bmi

; 142  :     {
; 143  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 144  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bmi

; 145  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bmi:

; 146  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bmi:

; 147  :     }   
; 148  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 149  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bmi@@YAEGPEAUcpu@@E@Z ENDP				; bmi
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bit@@YAEGPEAUcpu@@E@Z PROC				; bit

; 126  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 127  :     catchUpPpu(Cpu);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?catchUpPpu@@YAXPEAUcpu@@@Z ; catchUpPpu

; 128  :     uint8 Value = readCpu8(Address, Cpu);

  0001d	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00022	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00027	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  0002c	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 129  :     if(Value & (1 << 6))

  00030	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  00035	83 e0 40	 and	 eax, 64			; 00000040H
  00038	85 c0		 test	 eax, eax
  0003a	74 13		 je	 SHORT $LN2@bit

; 130  :         setOverflow(&Cpu->Flags);

  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	48 83 c0 03	 add	 rax, 3
  00045	48 8b c8	 mov	 rcx, rax
  00048	e8 00 00 00 00	 call	 ?setOverflow@@YAXPEAE@Z	; setOverflow

; 131  :     else

  0004d	eb 11		 jmp	 SHORT $LN3@bit
$LN2@bit:

; 132  :         clearOverflow(&Cpu->Flags);

  0004f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00054	48 83 c0 03	 add	 rax, 3
  00058	48 8b c8	 mov	 rcx, rax
  0005b	e8 00 00 00 00	 call	 ?clearOverflow@@YAXPEAE@Z ; clearOverflow
$LN3@bit:

; 133  :     setNegative(Value, &Cpu->Flags);

  00060	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00065	48 83 c0 03	 add	 rax, 3
  00069	48 8b d0	 mov	 rdx, rax
  0006c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00071	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 134  :     setZero(Cpu->A & Value, &Cpu->Flags);

  00076	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0007b	48 83 c0 03	 add	 rax, 3
  0007f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00084	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00087	0f b6 54 24 20	 movzx	 edx, BYTE PTR Value$[rsp]
  0008c	23 ca		 and	 ecx, edx
  0008e	48 8b d0	 mov	 rdx, rax
  00091	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 135  :     return(0);

  00096	32 c0		 xor	 al, al

; 136  : }

  00098	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009c	c3		 ret	 0
?bit@@YAEGPEAUcpu@@E@Z ENDP				; bit
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?beq@@YAEGPEAUcpu@@E@Z PROC				; beq

; 113  : {   

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 114  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 115  :     if(isBitSet(ZERO_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 02		 mov	 cl, 2
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	74 3b		 je	 SHORT $LN2@beq

; 116  :     {
; 117  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 118  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@beq

; 119  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@beq:

; 120  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@beq:

; 121  :     }   
; 122  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 123  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?beq@@YAEGPEAUcpu@@E@Z ENDP				; beq
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bcs@@YAEGPEAUcpu@@E@Z PROC				; bcs

; 101  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 102  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 103  :     if(isBitSet(CARRY_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 01		 mov	 cl, 1
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	74 3b		 je	 SHORT $LN2@bcs

; 104  :     {
; 105  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 106  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bcs

; 107  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bcs:

; 108  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bcs:

; 109  :     }   
; 110  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 111  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bcs@@YAEGPEAUcpu@@E@Z ENDP				; bcs
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Test$1 = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bcc@@YAEGPEAUcpu@@E@Z PROC				; bcc

; 85   : {

$LN6:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 86   :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 87   :     
; 88   :     if(!isBitSet(CARRY_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 01		 mov	 cl, 1
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	75 3d		 jne	 SHORT $LN2@bcc

; 89   :     {
; 90   :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 91   :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN4@bcc

; 92   :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN4@bcc:

; 93   :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx

; 94   :     }
; 95   :     else

  00067	eb 05		 jmp	 SHORT $LN3@bcc
$LN2@bcc:

; 96   :         uint8 Test =0;

  00069	c6 44 24 21 00	 mov	 BYTE PTR Test$1[rsp], 0
$LN3@bcc:

; 97   :     return(AddCycles);

  0006e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 98   : }

  00073	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00077	c3		 ret	 0
?bcc@@YAEGPEAUcpu@@E@Z ENDP				; bcc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?asl@@YAEGPEAUcpu@@E@Z PROC				; asl

; 57   : {

$LN9:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 58   :     uint8 Value = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR Value$[rsp], 0

; 59   :     if(AddressMode == ACM)

  00018	0f b6 44 24 50	 movzx	 eax, BYTE PTR AddressMode$[rsp]
  0001d	83 f8 01	 cmp	 eax, 1
  00020	75 51		 jne	 SHORT $LN2@asl

; 60   :     {        
; 61   :         if(Cpu->A & (1 << 7))

  00022	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00027	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002a	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0002f	85 c0		 test	 eax, eax
  00031	74 13		 je	 SHORT $LN4@asl

; 62   :             setCarry(&Cpu->Flags);

  00033	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00038	48 83 c0 03	 add	 rax, 3
  0003c	48 8b c8	 mov	 rcx, rax
  0003f	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 63   :         else

  00044	eb 11		 jmp	 SHORT $LN5@asl
$LN4@asl:

; 64   :             clearCarry(&Cpu->Flags);

  00046	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004b	48 83 c0 03	 add	 rax, 3
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN5@asl:

; 65   :         Value = Cpu->A << 1;

  00057	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005f	d1 e0		 shl	 eax, 1
  00061	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 66   :         Cpu->A = Value;

  00065	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0006a	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0006f	88 08		 mov	 BYTE PTR [rax], cl

; 67   :     }
; 68   :     else

  00071	eb 6e		 jmp	 SHORT $LN3@asl
$LN2@asl:

; 69   :     {
; 70   :         catchUpPpu(Cpu);

  00073	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00078	e8 00 00 00 00	 call	 ?catchUpPpu@@YAXPEAUcpu@@@Z ; catchUpPpu

; 71   :         Value = readCpu8(Address, Cpu);

  0007d	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00082	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00087	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  0008c	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 72   :         if(Value & (1 << 7))

  00090	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  00095	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0009a	85 c0		 test	 eax, eax
  0009c	74 13		 je	 SHORT $LN6@asl

; 73   :             setCarry(&Cpu->Flags);

  0009e	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000a3	48 83 c0 03	 add	 rax, 3
  000a7	48 8b c8	 mov	 rcx, rax
  000aa	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 74   :         else

  000af	eb 11		 jmp	 SHORT $LN7@asl
$LN6@asl:

; 75   :             clearCarry(&Cpu->Flags);

  000b1	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000b6	48 83 c0 03	 add	 rax, 3
  000ba	48 8b c8	 mov	 rcx, rax
  000bd	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN7@asl:

; 76   :         Value = Value << 1;

  000c2	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000c7	d1 e0		 shl	 eax, 1
  000c9	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 77   :         writeCpu8(Value, Address, Cpu);

  000cd	4c 8b 44 24 48	 mov	 r8, QWORD PTR Cpu$[rsp]
  000d2	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  000d7	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  000dc	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8
$LN3@asl:

; 78   :     }
; 79   :     setZero(Value, &Cpu->Flags);

  000e1	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000e6	48 83 c0 03	 add	 rax, 3
  000ea	48 8b d0	 mov	 rdx, rax
  000ed	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  000f2	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 80   :     setNegative(Value, &Cpu->Flags);

  000f7	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000fc	48 83 c0 03	 add	 rax, 3
  00100	48 8b d0	 mov	 rdx, rax
  00103	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00108	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 81   :     return(0);

  0010d	32 c0		 xor	 al, al

; 82   : }

  0010f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00113	c3		 ret	 0
?asl@@YAEGPEAUcpu@@E@Z ENDP				; asl
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?AND@@YAEGPEAUcpu@@E@Z PROC				; AND

; 47   : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 48   :     catchUpPpu(Cpu);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?catchUpPpu@@YAXPEAUcpu@@@Z ; catchUpPpu

; 49   :     uint8 Value = readCpu8(Address, Cpu);

  0001d	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00022	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00027	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  0002c	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 50   :     Cpu->A = Cpu->A & Value;

  00030	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00035	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00038	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0003d	23 c1		 and	 eax, ecx
  0003f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00044	88 01		 mov	 BYTE PTR [rcx], al

; 51   :     setZero(Cpu->A, &Cpu->Flags);

  00046	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004b	48 83 c0 03	 add	 rax, 3
  0004f	48 8b d0	 mov	 rdx, rax
  00052	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00057	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0005a	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 52   :     setNegative(Cpu->A, &Cpu->Flags);

  0005f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00064	48 83 c0 03	 add	 rax, 3
  00068	48 8b d0	 mov	 rdx, rax
  0006b	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00070	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00073	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 53   :     return(0);

  00078	32 c0		 xor	 al, al

; 54   : }

  0007a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007e	c3		 ret	 0
?AND@@YAEGPEAUcpu@@E@Z ENDP				; AND
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
A$ = 32
B$ = 33
C$ = 34
Sum$ = 36
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?adc@@YAEGPEAUcpu@@E@Z PROC				; adc

; 20   : {

$LN7:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 21   :     catchUpPpu(Cpu);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?catchUpPpu@@YAXPEAUcpu@@@Z ; catchUpPpu

; 22   :     uint8 A = Cpu->A;

  0001d	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00022	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00025	88 44 24 20	 mov	 BYTE PTR A$[rsp], al

; 23   :     uint8 B = readCpu8(Address, Cpu);

  00029	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0002e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00033	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00038	88 44 24 21	 mov	 BYTE PTR B$[rsp], al

; 24   :     uint8 C = isBitSet(CARRY_BIT, Cpu->Flags);

  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00045	b1 01		 mov	 cl, 1
  00047	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  0004c	88 44 24 22	 mov	 BYTE PTR C$[rsp], al

; 25   : 
; 26   :     uint16 Sum = (uint16)A + (uint16)B + (uint16)C;

  00050	0f b6 44 24 20	 movzx	 eax, BYTE PTR A$[rsp]
  00055	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR B$[rsp]
  0005a	03 c1		 add	 eax, ecx
  0005c	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR C$[rsp]
  00061	03 c1		 add	 eax, ecx
  00063	66 89 44 24 24	 mov	 WORD PTR Sum$[rsp], ax

; 27   : 
; 28   :     // Overflow check, taken from the web. One day find out how this works
; 29   :     if(((A ^ Sum) & (B ^ Sum) & 0x80) == 0x80)

  00068	0f b6 44 24 20	 movzx	 eax, BYTE PTR A$[rsp]
  0006d	0f b7 4c 24 24	 movzx	 ecx, WORD PTR Sum$[rsp]
  00072	33 c1		 xor	 eax, ecx
  00074	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR B$[rsp]
  00079	0f b7 54 24 24	 movzx	 edx, WORD PTR Sum$[rsp]
  0007e	33 ca		 xor	 ecx, edx
  00080	23 c1		 and	 eax, ecx
  00082	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00087	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0008c	75 13		 jne	 SHORT $LN2@adc

; 30   :         setOverflow(&Cpu->Flags);

  0008e	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00093	48 83 c0 03	 add	 rax, 3
  00097	48 8b c8	 mov	 rcx, rax
  0009a	e8 00 00 00 00	 call	 ?setOverflow@@YAXPEAE@Z	; setOverflow

; 31   :     else

  0009f	eb 11		 jmp	 SHORT $LN3@adc
$LN2@adc:

; 32   :         clearOverflow(&Cpu->Flags);

  000a1	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000a6	48 83 c0 03	 add	 rax, 3
  000aa	48 8b c8	 mov	 rcx, rax
  000ad	e8 00 00 00 00	 call	 ?clearOverflow@@YAXPEAE@Z ; clearOverflow
$LN3@adc:

; 33   : 
; 34   :     if(Sum & 0x100)

  000b2	0f b7 44 24 24	 movzx	 eax, WORD PTR Sum$[rsp]
  000b7	25 00 01 00 00	 and	 eax, 256		; 00000100H
  000bc	85 c0		 test	 eax, eax
  000be	74 13		 je	 SHORT $LN4@adc

; 35   :         setCarry(&Cpu->Flags);

  000c0	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000c5	48 83 c0 03	 add	 rax, 3
  000c9	48 8b c8	 mov	 rcx, rax
  000cc	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 36   :     else

  000d1	eb 11		 jmp	 SHORT $LN5@adc
$LN4@adc:

; 37   :         clearCarry(&Cpu->Flags);

  000d3	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000d8	48 83 c0 03	 add	 rax, 3
  000dc	48 8b c8	 mov	 rcx, rax
  000df	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN5@adc:

; 38   : 
; 39   :     setZero(Sum, &Cpu->Flags);

  000e4	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000e9	48 83 c0 03	 add	 rax, 3
  000ed	48 8b d0	 mov	 rdx, rax
  000f0	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Sum$[rsp]
  000f5	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 40   :     setNegative(Sum, &Cpu->Flags);

  000fa	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000ff	48 83 c0 03	 add	 rax, 3
  00103	48 8b d0	 mov	 rdx, rax
  00106	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Sum$[rsp]
  0010b	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 41   : 
; 42   :     Cpu->A = (uint8)Sum;

  00110	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00115	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Sum$[rsp]
  0011a	88 08		 mov	 BYTE PTR [rax], cl

; 43   :     return(0);

  0011c	32 c0		 xor	 al, al

; 44   : }

  0011e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00122	c3		 ret	 0
?adc@@YAEGPEAUcpu@@E@Z ENDP				; adc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
tick$1 = 32
Cpu$ = 64
?catchUpPpu@@YAXPEAUcpu@@@Z PROC			; catchUpPpu

; 11   : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 12   :     for(int tick = 0; tick < (Cpu->PotentialCatchUp*3); ++tick)

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tick$1[rsp], 0
  00011	eb 0a		 jmp	 SHORT $LN4@catchUpPpu
$LN2@catchUpPpu:
  00013	8b 44 24 20	 mov	 eax, DWORD PTR tick$1[rsp]
  00017	ff c0		 inc	 eax
  00019	89 44 24 20	 mov	 DWORD PTR tick$1[rsp], eax
$LN4@catchUpPpu:
  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR Cpu$[rsp]
  00022	0f b6 40 6d	 movzx	 eax, BYTE PTR [rax+109]
  00026	6b c0 03	 imul	 eax, eax, 3
  00029	39 44 24 20	 cmp	 DWORD PTR tick$1[rsp], eax
  0002d	7d 0e		 jge	 SHORT $LN3@catchUpPpu

; 13   :     {
; 14   :         ppuTick(GlobalPpu);

  0002f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?GlobalPpu@@3PEAUppu@@EA
  00036	e8 00 00 00 00	 call	 ?ppuTick@@YAXPEAUppu@@@Z ; ppuTick

; 15   :     }

  0003b	eb d6		 jmp	 SHORT $LN2@catchUpPpu
$LN3@catchUpPpu:

; 16   :     Cpu->CatchUpCyclesRun = Cpu->PotentialCatchUp;

  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR Cpu$[rsp]
  00042	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00047	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]
  0004b	88 48 6c	 mov	 BYTE PTR [rax+108], cl

; 17   : }

  0004e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00052	c3		 ret	 0
?catchUpPpu@@YAXPEAUcpu@@@Z ENDP			; catchUpPpu
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?crossedPageCheck@@YAHGG@Z
_TEXT	SEGMENT
tv69 = 0
Before$ = 32
Now$ = 40
?crossedPageCheck@@YAHGG@Z PROC				; crossedPageCheck, COMDAT

; 49   : inline bool32 crossedPageCheck(uint16 Before, uint16 Now) { return((Before & 0xFF00) != (Now & 0xFF00));}

$LN5:
  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 18	 sub	 rsp, 24
  0000e	0f b7 44 24 20	 movzx	 eax, WORD PTR Before$[rsp]
  00013	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00018	0f b7 4c 24 28	 movzx	 ecx, WORD PTR Now$[rsp]
  0001d	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00023	3b c1		 cmp	 eax, ecx
  00025	74 09		 je	 SHORT $LN3@crossedPag
  00027	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv69[rsp], 1
  0002e	eb 07		 jmp	 SHORT $LN4@crossedPag
$LN3@crossedPag:
  00030	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv69[rsp], 0
$LN4@crossedPag:
  00037	8b 04 24	 mov	 eax, DWORD PTR tv69[rsp]
  0003a	48 83 c4 18	 add	 rsp, 24
  0003e	c3		 ret	 0
?crossedPageCheck@@YAHGG@Z ENDP				; crossedPageCheck
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?isBitSet@@YAHEE@Z
_TEXT	SEGMENT
Bit$ = 8
Flags$ = 16
?isBitSet@@YAHEE@Z PROC					; isBitSet, COMDAT

; 48   : inline bool32 isBitSet(uint8 Bit, uint8 Flags) { return(Bit & Flags); }

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00008	0f b6 44 24 08	 movzx	 eax, BYTE PTR Bit$[rsp]
  0000d	0f b6 4c 24 10	 movzx	 ecx, BYTE PTR Flags$[rsp]
  00012	23 c1		 and	 eax, ecx
  00014	c3		 ret	 0
?isBitSet@@YAHEE@Z ENDP					; isBitSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setNegative@@YAXEPEAE@Z
_TEXT	SEGMENT
Value$ = 8
Flags$ = 16
?setNegative@@YAXEPEAE@Z PROC				; setNegative, COMDAT

; 42   : {  

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 43   :     if(Value >= 0x00 && Value <= 0x7F)

  00009	0f b6 44 24 08	 movzx	 eax, BYTE PTR Value$[rsp]
  0000e	85 c0		 test	 eax, eax
  00010	7c 1f		 jl	 SHORT $LN2@setNegativ
  00012	0f b6 44 24 08	 movzx	 eax, BYTE PTR Value$[rsp]
  00017	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  0001a	7f 15		 jg	 SHORT $LN2@setNegativ

; 44   :         *Flags = *Flags & ~NEGATIVE_BIT; // clear negative flag

  0001c	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  00021	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00024	0f ba f0 07	 btr	 eax, 7
  00028	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  0002d	88 01		 mov	 BYTE PTR [rcx], al

; 45   :     else

  0002f	eb 13		 jmp	 SHORT $LN3@setNegativ
$LN2@setNegativ:

; 46   :         *Flags = *Flags | NEGATIVE_BIT; // set negative flag

  00031	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  00036	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00039	0f ba e8 07	 bts	 eax, 7
  0003d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  00042	88 01		 mov	 BYTE PTR [rcx], al
$LN3@setNegativ:

; 47   : }

  00044	c3		 ret	 0
?setNegative@@YAXEPEAE@Z ENDP				; setNegative
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setZero@@YAXEPEAE@Z
_TEXT	SEGMENT
Value$ = 8
Flags$ = 16
?setZero@@YAXEPEAE@Z PROC				; setZero, COMDAT

; 35   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 36   :     if(Value == 0x00)

  00009	0f b6 44 24 08	 movzx	 eax, BYTE PTR Value$[rsp]
  0000e	85 c0		 test	 eax, eax
  00010	75 14		 jne	 SHORT $LN2@setZero

; 37   :         *Flags = *Flags | ZERO_BIT;

  00012	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  00017	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001a	83 c8 02	 or	 eax, 2
  0001d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  00022	88 01		 mov	 BYTE PTR [rcx], al

; 38   :     else

  00024	eb 12		 jmp	 SHORT $LN3@setZero
$LN2@setZero:

; 39   :         *Flags = *Flags & ~ZERO_BIT;

  00026	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  0002b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002e	83 e0 fd	 and	 eax, -3
  00031	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  00036	88 01		 mov	 BYTE PTR [rcx], al
$LN3@setZero:

; 40   : }

  00038	c3		 ret	 0
?setZero@@YAXEPEAE@Z ENDP				; setZero
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearOverflow@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearOverflow@@YAXPEAE@Z PROC				; clearOverflow, COMDAT

; 33   : inline void clearOverflow(uint8 *Flags)  { *Flags = *Flags & ~OVERFLOW_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 bf	 and	 eax, -65		; ffffffffffffffbfH
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?clearOverflow@@YAXPEAE@Z ENDP				; clearOverflow
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setOverflow@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setOverflow@@YAXPEAE@Z PROC				; setOverflow, COMDAT

; 32   : inline void setOverflow(uint8 *Flags)    { *Flags = *Flags | OVERFLOW_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 40	 or	 eax, 64			; 00000040H
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?setOverflow@@YAXPEAE@Z ENDP				; setOverflow
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setBlank@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setBlank@@YAXPEAE@Z PROC				; setBlank, COMDAT

; 30   : inline void setBlank(uint8 *Flags)       { *Flags = *Flags | BLANK_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 20	 or	 eax, 32			; 00000020H
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?setBlank@@YAXPEAE@Z ENDP				; setBlank
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearBreak@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearBreak@@YAXPEAE@Z PROC				; clearBreak, COMDAT

; 29   : inline void clearBreak(uint8 *Flags)     { *Flags = *Flags & ~BREAK_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 ef	 and	 eax, -17
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?clearBreak@@YAXPEAE@Z ENDP				; clearBreak
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setBreak@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setBreak@@YAXPEAE@Z PROC				; setBreak, COMDAT

; 28   : inline void setBreak(uint8 *Flags)       { *Flags = *Flags | BREAK_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 10	 or	 eax, 16
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?setBreak@@YAXPEAE@Z ENDP				; setBreak
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearDecimal@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearDecimal@@YAXPEAE@Z PROC				; clearDecimal, COMDAT

; 27   : inline void clearDecimal(uint8 *Flags)   { *Flags = *Flags & ~DECIMAL_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 f7	 and	 eax, -9
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?clearDecimal@@YAXPEAE@Z ENDP				; clearDecimal
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setDecimal@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setDecimal@@YAXPEAE@Z PROC				; setDecimal, COMDAT

; 26   : inline void setDecimal(uint8 *Flags)     { *Flags = *Flags | DECIMAL_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 08	 or	 eax, 8
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?setDecimal@@YAXPEAE@Z ENDP				; setDecimal
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearInterrupt@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearInterrupt@@YAXPEAE@Z PROC				; clearInterrupt, COMDAT

; 25   : inline void clearInterrupt(uint8 *Flags) { *Flags = *Flags & ~INTERRUPT_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 fb	 and	 eax, -5
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?clearInterrupt@@YAXPEAE@Z ENDP				; clearInterrupt
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setInterrupt@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setInterrupt@@YAXPEAE@Z PROC				; setInterrupt, COMDAT

; 24   : inline void setInterrupt(uint8 *Flags)   { *Flags = *Flags | INTERRUPT_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 04	 or	 eax, 4
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?setInterrupt@@YAXPEAE@Z ENDP				; setInterrupt
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearCarry@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearCarry@@YAXPEAE@Z PROC				; clearCarry, COMDAT

; 23   : inline void clearCarry(uint8 *Flags)     { *Flags = *Flags & ~CARRY_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 fe	 and	 eax, -2
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?clearCarry@@YAXPEAE@Z ENDP				; clearCarry
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setCarry@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setCarry@@YAXPEAE@Z PROC				; setCarry, COMDAT

; 22   : inline void setCarry(uint8 *Flags)       { *Flags = *Flags | CARRY_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 01	 or	 eax, 1
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?setCarry@@YAXPEAE@Z ENDP				; setCarry
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Value$ = 32
Cpu$ = 64
?pop@@YAEPEAUcpu@@@Z PROC				; pop

; 16   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 17   :     ++Cpu->StackPtr;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR Cpu$[rsp]
  0000e	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00012	fe c0		 inc	 al
  00014	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00019	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 18   :     uint8 Value = readCpu8((uint16)Cpu->StackPtr | STACK_ADDRESS, Cpu);

  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR Cpu$[rsp]
  00021	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00025	0f ba e8 08	 bts	 eax, 8
  00029	48 8b 54 24 40	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0002e	0f b7 c8	 movzx	 ecx, ax
  00031	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00036	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 19   :     return(Value);

  0003a	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]

; 20   : }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
?pop@@YAEPEAUcpu@@@Z ENDP				; pop
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Byte$ = 48
Cpu$ = 56
?push@@YAXEPEAUcpu@@@Z PROC				; push

; 11   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 12   :     writeCpu8(Byte, (uint16)Cpu->StackPtr | STACK_ADDRESS, Cpu);

  0000d	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00012	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00016	0f ba e8 08	 bts	 eax, 8
  0001a	4c 8b 44 24 38	 mov	 r8, QWORD PTR Cpu$[rsp]
  0001f	0f b7 d0	 movzx	 edx, ax
  00022	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR Byte$[rsp]
  00027	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8

; 13   :     --Cpu->StackPtr;  

  0002c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00031	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00035	fe c8		 dec	 al
  00037	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0003c	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 14   : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
?push@@YAXEPEAUcpu@@@Z ENDP				; push
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
SpriteIdx$1 = 32
BackgroundColour$2 = 33
PixelX$3 = 36
XOffset$4 = 40
SpriteX$5 = 41
tv225 = 42
PatternPixelValue$6 = 43
RelX$7 = 44
PatternValue$8 = 45
AtrbPixelValue$9 = 46
BgrdPaletteIndex$10 = 47
SpriteColour$11 = 48
SprtPaletteIndex$12 = 49
Colour$13 = 52
PixelY$14 = 56
PreRenderLine$ = 60
Sprite$15 = 64
tv69 = 72
tv76 = 76
tv83 = 80
tv87 = 84
VisibleLine$ = 88
RenderingEnabled$ = 92
tv364 = 96
tv204 = 100
tv215 = 104
tv279 = 108
VBlankLine$ = 112
VRamIO$ = 120
Ppu$ = 144
?ppuTick@@YAXPEAUppu@@@Z PROC				; ppuTick

; 227  : {    

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 228  :     vram_io *VRamIO = &Ppu->VRamIO; 

  0000d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00015	48 05 74 12 00
	00		 add	 rax, 4724		; 00001274H
  0001b	48 89 44 24 78	 mov	 QWORD PTR VRamIO$[rsp], rax

; 229  : 
; 230  :     bool32 RenderingEnabled = Ppu->ShowBackground || Ppu->ShowSprites;

  00020	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00028	83 b8 38 10 00
	00 00		 cmp	 DWORD PTR [rax+4152], 0
  0002f	75 1b		 jne	 SHORT $LN41@ppuTick
  00031	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00039	83 b8 3c 10 00
	00 00		 cmp	 DWORD PTR [rax+4156], 0
  00040	75 0a		 jne	 SHORT $LN41@ppuTick
  00042	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
  0004a	eb 08		 jmp	 SHORT $LN42@ppuTick
$LN41@ppuTick:
  0004c	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv69[rsp], 1
$LN42@ppuTick:
  00054	8b 44 24 48	 mov	 eax, DWORD PTR tv69[rsp]
  00058	89 44 24 5c	 mov	 DWORD PTR RenderingEnabled$[rsp], eax

; 231  :     
; 232  :     bool32 VisibleLine = (0 <= Ppu->Scanline && Ppu->Scanline <= 239);

  0005c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00064	0f b7 80 70 12
	00 00		 movzx	 eax, WORD PTR [rax+4720]
  0006b	85 c0		 test	 eax, eax
  0006d	7c 20		 jl	 SHORT $LN43@ppuTick
  0006f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00077	0f b7 80 70 12
	00 00		 movzx	 eax, WORD PTR [rax+4720]
  0007e	3d ef 00 00 00	 cmp	 eax, 239		; 000000efH
  00083	7f 0a		 jg	 SHORT $LN43@ppuTick
  00085	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  0008d	eb 08		 jmp	 SHORT $LN44@ppuTick
$LN43@ppuTick:
  0008f	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN44@ppuTick:
  00097	8b 44 24 4c	 mov	 eax, DWORD PTR tv76[rsp]
  0009b	89 44 24 58	 mov	 DWORD PTR VisibleLine$[rsp], eax

; 233  :     bool32 VBlankLine = (241 <= Ppu->Scanline && Ppu->Scanline <= 260);

  0009f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  000a7	0f b7 80 70 12
	00 00		 movzx	 eax, WORD PTR [rax+4720]
  000ae	3d f1 00 00 00	 cmp	 eax, 241		; 000000f1H
  000b3	7c 20		 jl	 SHORT $LN45@ppuTick
  000b5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  000bd	0f b7 80 70 12
	00 00		 movzx	 eax, WORD PTR [rax+4720]
  000c4	3d 04 01 00 00	 cmp	 eax, 260		; 00000104H
  000c9	7f 0a		 jg	 SHORT $LN45@ppuTick
  000cb	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv83[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN46@ppuTick
$LN45@ppuTick:
  000d5	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
$LN46@ppuTick:
  000dd	8b 44 24 50	 mov	 eax, DWORD PTR tv83[rsp]
  000e1	89 44 24 70	 mov	 DWORD PTR VBlankLine$[rsp], eax

; 234  :     bool32 PreRenderLine = (Ppu->Scanline == 261);

  000e5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  000ed	0f b7 80 70 12
	00 00		 movzx	 eax, WORD PTR [rax+4720]
  000f4	3d 05 01 00 00	 cmp	 eax, 261		; 00000105H
  000f9	75 0a		 jne	 SHORT $LN47@ppuTick
  000fb	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv87[rsp], 1
  00103	eb 08		 jmp	 SHORT $LN48@ppuTick
$LN47@ppuTick:
  00105	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
$LN48@ppuTick:
  0010d	8b 44 24 54	 mov	 eax, DWORD PTR tv87[rsp]
  00111	89 44 24 3c	 mov	 DWORD PTR PreRenderLine$[rsp], eax

; 235  : 
; 236  :     if(PreRenderLine || VisibleLine)

  00115	83 7c 24 3c 00	 cmp	 DWORD PTR PreRenderLine$[rsp], 0
  0011a	75 0b		 jne	 SHORT $LN6@ppuTick
  0011c	83 7c 24 58 00	 cmp	 DWORD PTR VisibleLine$[rsp], 0
  00121	0f 84 b7 05 00
	00		 je	 $LN5@ppuTick
$LN6@ppuTick:

; 237  :     {
; 238  :         if(RenderingEnabled)

  00127	83 7c 24 5c 00	 cmp	 DWORD PTR RenderingEnabled$[rsp], 0
  0012c	0f 84 c0 00 00
	00		 je	 $LN7@ppuTick

; 239  :         {   
; 240  :             if( (1 <= Ppu->ScanlineCycle && Ppu->ScanlineCycle <= 256) ||

  00132	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0013a	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  00141	83 f8 01	 cmp	 eax, 1
  00144	7c 16		 jl	 SHORT $LN10@ppuTick
  00146	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0014e	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  00155	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0015a	7e 2c		 jle	 SHORT $LN9@ppuTick
$LN10@ppuTick:
  0015c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00164	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  0016b	3d 41 01 00 00	 cmp	 eax, 321		; 00000141H
  00170	7c 23		 jl	 SHORT $LN8@ppuTick
  00172	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0017a	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  00181	3d 50 01 00 00	 cmp	 eax, 336		; 00000150H
  00186	7f 0d		 jg	 SHORT $LN8@ppuTick
$LN9@ppuTick:

; 241  :                 (321 <= Ppu->ScanlineCycle && Ppu->ScanlineCycle <= 336) )
; 242  :                 loadFutureData(Ppu);

  00188	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00190	e8 00 00 00 00	 call	 ?loadFutureData@@YAXPEAUppu@@@Z ; loadFutureData
$LN8@ppuTick:

; 243  :             if(Ppu->ScanlineCycle == 257)

  00195	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0019d	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  001a4	3d 01 01 00 00	 cmp	 eax, 257		; 00000101H
  001a9	75 0a		 jne	 SHORT $LN11@ppuTick

; 244  :                 resetScrollHorz(VRamIO);

  001ab	48 8b 4c 24 78	 mov	 rcx, QWORD PTR VRamIO$[rsp]
  001b0	e8 00 00 00 00	 call	 ?resetScrollHorz@@YAXPEAUvram_io@@@Z ; resetScrollHorz
$LN11@ppuTick:

; 245  :             if(PreRenderLine && 280 <= Ppu->ScanlineCycle && Ppu->ScanlineCycle <= 304)

  001b5	83 7c 24 3c 00	 cmp	 DWORD PTR PreRenderLine$[rsp], 0
  001ba	74 36		 je	 SHORT $LN12@ppuTick
  001bc	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  001c4	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  001cb	3d 18 01 00 00	 cmp	 eax, 280		; 00000118H
  001d0	7c 20		 jl	 SHORT $LN12@ppuTick
  001d2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  001da	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  001e1	3d 30 01 00 00	 cmp	 eax, 304		; 00000130H
  001e6	7f 0a		 jg	 SHORT $LN12@ppuTick

; 246  :                 resetScrollVert(VRamIO);

  001e8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR VRamIO$[rsp]
  001ed	e8 00 00 00 00	 call	 ?resetScrollVert@@YAXPEAUvram_io@@@Z ; resetScrollVert
$LN12@ppuTick:
$LN7@ppuTick:

; 247  :         }    
; 248  : 
; 249  :         if(PreRenderLine)

  001f2	83 7c 24 3c 00	 cmp	 DWORD PTR PreRenderLine$[rsp], 0
  001f7	0f 84 bb 00 00
	00		 je	 $LN13@ppuTick

; 250  :         {
; 251  :             if(Ppu->ScanlineCycle == 1)

  001fd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00205	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  0020c	83 f8 01	 cmp	 eax, 1
  0020f	75 4e		 jne	 SHORT $LN14@ppuTick

; 252  :             {
; 253  :                 Ppu->SpriteOverflow = false;

  00211	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00219	c7 80 4c 10 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4172], 0

; 254  :                 Ppu->Sprite0Hit = false;

  00223	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0022b	c7 80 50 10 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4176], 0

; 255  :                 Ppu->VerticalBlank = false; 

  00235	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0023d	c7 80 54 10 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4180], 0

; 256  :                 NmiTriggered = false;

  00247	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?NmiTriggered@@3HA, 0 ; NmiTriggered

; 257  :                 GlobalCpu->StartNmi = false;

  00251	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GlobalCpu@@3PEAUcpu@@EA
  00258	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0
$LN14@ppuTick:

; 258  :             }
; 259  :             if(Ppu->ScanlineCycle == 339 && Ppu->ShowBackground && Ppu->OddFrame)

  0025f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00267	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  0026e	3d 53 01 00 00	 cmp	 eax, 339		; 00000153H
  00273	75 43		 jne	 SHORT $LN15@ppuTick
  00275	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0027d	83 b8 38 10 00
	00 00		 cmp	 DWORD PTR [rax+4152], 0
  00284	74 32		 je	 SHORT $LN15@ppuTick
  00286	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0028e	83 b8 7c 12 00
	00 00		 cmp	 DWORD PTR [rax+4732], 0
  00295	74 21		 je	 SHORT $LN15@ppuTick

; 260  :             {
; 261  :                 Ppu->ScanlineCycle++; // Skips cycle 240

  00297	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0029f	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  002a6	66 ff c0	 inc	 ax
  002a9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  002b1	66 89 81 72 12
	00 00		 mov	 WORD PTR [rcx+4722], ax
$LN15@ppuTick:
$LN13@ppuTick:

; 262  :             }
; 263  :         }
; 264  :         
; 265  :         if(VisibleLine)

  002b8	83 7c 24 58 00	 cmp	 DWORD PTR VisibleLine$[rsp], 0
  002bd	0f 84 1b 04 00
	00		 je	 $LN16@ppuTick

; 266  :         {            
; 267  :             if(RenderingEnabled)

  002c3	83 7c 24 5c 00	 cmp	 DWORD PTR RenderingEnabled$[rsp], 0
  002c8	0f 84 10 04 00
	00		 je	 $LN17@ppuTick

; 268  :             {
; 269  :                 if(Ppu->ScanlineCycle == 1)

  002ce	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  002d6	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  002dd	83 f8 01	 cmp	 eax, 1
  002e0	75 0d		 jne	 SHORT $LN18@ppuTick

; 270  :                 {
; 271  :                     clearSecondaryOam(Ppu);

  002e2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  002ea	e8 00 00 00 00	 call	 ?clearSecondaryOam@@YAXPEAUppu@@@Z ; clearSecondaryOam
$LN18@ppuTick:

; 272  :                 }
; 273  :                 if(Ppu->ScanlineCycle == 65)

  002ef	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  002f7	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  002fe	83 f8 41	 cmp	 eax, 65			; 00000041H
  00301	75 0d		 jne	 SHORT $LN19@ppuTick

; 274  :                 {
; 275  :                     evaluateSecondaryOam(Ppu);

  00303	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0030b	e8 00 00 00 00	 call	 ?evaluateSecondaryOam@@YAXPEAUppu@@@Z ; evaluateSecondaryOam
$LN19@ppuTick:

; 276  :                 }
; 277  :                 if(Ppu->ScanlineCycle == 257)

  00310	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00318	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  0031f	3d 01 01 00 00	 cmp	 eax, 257		; 00000101H
  00324	75 1a		 jne	 SHORT $LN20@ppuTick

; 278  :                 {
; 279  :                     clearPreparedSprites(Ppu);

  00326	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0032e	e8 00 00 00 00	 call	 ?clearPreparedSprites@@YAXPEAUppu@@@Z ; clearPreparedSprites

; 280  :                     prepareSprites(Ppu);

  00333	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0033b	e8 00 00 00 00	 call	 ?prepareSprites@@YAXPEAUppu@@@Z ; prepareSprites
$LN20@ppuTick:

; 281  :                 }
; 282  :                 
; 283  :                 if(1 <= Ppu->ScanlineCycle && Ppu->ScanlineCycle <= 256)

  00340	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00348	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  0034f	83 f8 01	 cmp	 eax, 1
  00352	0f 8c 86 03 00
	00		 jl	 $LN21@ppuTick
  00358	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00360	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  00367	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0036c	0f 8f 6c 03 00
	00		 jg	 $LN21@ppuTick

; 284  :                 {
; 285  :                     uint16 PixelX = Ppu->ScanlineCycle - 1;

  00372	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0037a	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  00381	ff c8		 dec	 eax
  00383	66 89 44 24 24	 mov	 WORD PTR PixelX$3[rsp], ax

; 286  :                     uint16 PixelY = Ppu->Scanline;

  00388	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00390	0f b7 80 70 12
	00 00		 movzx	 eax, WORD PTR [rax+4720]
  00397	66 89 44 24 38	 mov	 WORD PTR PixelY$14[rsp], ax

; 287  : 
; 288  :                     uint8 Colour[3] = {};

  0039c	48 8d 44 24 34	 lea	 rax, QWORD PTR Colour$13[rsp]
  003a1	48 8b f8	 mov	 rdi, rax
  003a4	33 c0		 xor	 eax, eax
  003a6	b9 03 00 00 00	 mov	 ecx, 3
  003ab	f3 aa		 rep stosb

; 289  :                         
; 290  :                     uint8 BackgroundColour = 0;

  003ad	c6 44 24 21 00	 mov	 BYTE PTR BackgroundColour$2[rsp], 0

; 291  :                         
; 292  :                     /* *********************** */
; 293  :                     /* Background Calculations */
; 294  : 
; 295  :                     if(Ppu->ShowBackground && !(PixelX < 8 && !Ppu->ShowBGLeft8Pixels) )

  003b2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  003ba	83 b8 38 10 00
	00 00		 cmp	 DWORD PTR [rax+4152], 0
  003c1	0f 84 fb 00 00
	00		 je	 $LN22@ppuTick
  003c7	0f b7 44 24 24	 movzx	 eax, WORD PTR PixelX$3[rsp]
  003cc	83 f8 08	 cmp	 eax, 8
  003cf	7d 15		 jge	 SHORT $LN23@ppuTick
  003d1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  003d9	83 b8 30 10 00
	00 00		 cmp	 DWORD PTR [rax+4144], 0
  003e0	0f 84 dc 00 00
	00		 je	 $LN22@ppuTick
$LN23@ppuTick:

; 296  :                     {
; 297  :                         uint8 XOffset = 15 - (VRamIO->FineX + (PixelX % 8));

  003e6	48 8b 44 24 78	 mov	 rax, QWORD PTR VRamIO$[rsp]
  003eb	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  003ef	89 44 24 64	 mov	 DWORD PTR tv204[rsp], eax
  003f3	0f b7 4c 24 24	 movzx	 ecx, WORD PTR PixelX$3[rsp]
  003f8	8b c1		 mov	 eax, ecx
  003fa	99		 cdq
  003fb	83 e2 07	 and	 edx, 7
  003fe	03 c2		 add	 eax, edx
  00400	83 e0 07	 and	 eax, 7
  00403	2b c2		 sub	 eax, edx
  00405	8b 4c 24 64	 mov	 ecx, DWORD PTR tv204[rsp]
  00409	03 c8		 add	 ecx, eax
  0040b	8b c1		 mov	 eax, ecx
  0040d	b9 0f 00 00 00	 mov	 ecx, 15
  00412	2b c8		 sub	 ecx, eax
  00414	8b c1		 mov	 eax, ecx
  00416	88 44 24 28	 mov	 BYTE PTR XOffset$4[rsp], al

; 298  :                         
; 299  :                         uint8 PatternPixelValue = (((HighPatternShiftReg >> (XOffset-1) ) & 2) |

  0041a	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?HighPatternShiftReg@@3GA ; HighPatternShiftReg
  00421	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR XOffset$4[rsp]
  00426	ff c9		 dec	 ecx
  00428	d3 f8		 sar	 eax, cl
  0042a	83 e0 02	 and	 eax, 2
  0042d	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?LowPatternShiftReg@@3GA ; LowPatternShiftReg
  00434	89 4c 24 68	 mov	 DWORD PTR tv215[rsp], ecx
  00438	0f b6 54 24 28	 movzx	 edx, BYTE PTR XOffset$4[rsp]
  0043d	0f b6 ca	 movzx	 ecx, dl
  00440	8b 54 24 68	 mov	 edx, DWORD PTR tv215[rsp]
  00444	d3 fa		 sar	 edx, cl
  00446	8b ca		 mov	 ecx, edx
  00448	83 e1 01	 and	 ecx, 1
  0044b	0b c1		 or	 eax, ecx
  0044d	88 44 24 2b	 mov	 BYTE PTR PatternPixelValue$6[rsp], al

; 300  :                                                    (LowPatternShiftReg >> XOffset) & 1);
; 301  : 
; 302  :                         if(PatternPixelValue != 0) // NOTE: If Value is zero, then it is a background/transparent

  00451	0f b6 44 24 2b	 movzx	 eax, BYTE PTR PatternPixelValue$6[rsp]
  00456	85 c0		 test	 eax, eax
  00458	74 3b		 je	 SHORT $LN24@ppuTick

; 303  :                         {
; 304  :                             uint8 AtrbPixelValue = (XOffset >= 8) ? PaletteLatchOld : PaletteLatchNew;

  0045a	0f b6 44 24 28	 movzx	 eax, BYTE PTR XOffset$4[rsp]
  0045f	83 f8 08	 cmp	 eax, 8
  00462	7c 0d		 jl	 SHORT $LN49@ppuTick
  00464	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?PaletteLatchOld@@3EA ; PaletteLatchOld
  0046b	88 44 24 2a	 mov	 BYTE PTR tv225[rsp], al
  0046f	eb 0b		 jmp	 SHORT $LN50@ppuTick
$LN49@ppuTick:
  00471	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?PaletteLatchNew@@3EA ; PaletteLatchNew
  00478	88 44 24 2a	 mov	 BYTE PTR tv225[rsp], al
$LN50@ppuTick:
  0047c	0f b6 44 24 2a	 movzx	 eax, BYTE PTR tv225[rsp]
  00481	88 44 24 2e	 mov	 BYTE PTR AtrbPixelValue$9[rsp], al

; 305  :                             BackgroundColour = AtrbPixelValue | PatternPixelValue;

  00485	0f b6 44 24 2e	 movzx	 eax, BYTE PTR AtrbPixelValue$9[rsp]
  0048a	0f b6 4c 24 2b	 movzx	 ecx, BYTE PTR PatternPixelValue$6[rsp]
  0048f	0b c1		 or	 eax, ecx
  00491	88 44 24 21	 mov	 BYTE PTR BackgroundColour$2[rsp], al
$LN24@ppuTick:

; 306  :                         }
; 307  :                             
; 308  :                         uint8 BgrdPaletteIndex = readPpu8(BGRD_PALETTE_ADRS + BackgroundColour, Ppu);

  00495	0f b6 44 24 21	 movzx	 eax, BYTE PTR BackgroundColour$2[rsp]
  0049a	05 00 3f 00 00	 add	 eax, 16128		; 00003f00H
  0049f	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR Ppu$[rsp]
  004a7	0f b7 c8	 movzx	 ecx, ax
  004aa	e8 00 00 00 00	 call	 ?readPpu8@@YAEGPEAUppu@@@Z ; readPpu8
  004af	88 44 24 2f	 mov	 BYTE PTR BgrdPaletteIndex$10[rsp], al

; 309  :                         getPaletteValue(BgrdPaletteIndex, Colour);

  004b3	48 8d 54 24 34	 lea	 rdx, QWORD PTR Colour$13[rsp]
  004b8	0f b6 4c 24 2f	 movzx	 ecx, BYTE PTR BgrdPaletteIndex$10[rsp]
  004bd	e8 00 00 00 00	 call	 ?getPaletteValue@@YAXEPEAE@Z ; getPaletteValue
$LN22@ppuTick:

; 310  :                     }
; 311  :                 
; 312  :                     /* ******************* */
; 313  :                     /* Sprite Calculations */
; 314  :                         
; 315  :                     if(Ppu->ShowSprites && !(PixelX < 8 && !Ppu->ShowSPRTLeft8Pixels) )

  004c2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  004ca	83 b8 3c 10 00
	00 00		 cmp	 DWORD PTR [rax+4156], 0
  004d1	0f 84 ea 01 00
	00		 je	 $LN25@ppuTick
  004d7	0f b7 44 24 24	 movzx	 eax, WORD PTR PixelX$3[rsp]
  004dc	83 f8 08	 cmp	 eax, 8
  004df	7d 15		 jge	 SHORT $LN26@ppuTick
  004e1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  004e9	83 b8 34 10 00
	00 00		 cmp	 DWORD PTR [rax+4148], 0
  004f0	0f 84 cb 01 00
	00		 je	 $LN25@ppuTick
$LN26@ppuTick:

; 316  :                     {
; 317  :                         for(int8 SpriteIdx = Ppu->PreparedSpriteCount - 1; SpriteIdx >= 0; --SpriteIdx)

  004f6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  004fe	0f b6 80 ec 11
	00 00		 movzx	 eax, BYTE PTR [rax+4588]
  00505	ff c8		 dec	 eax
  00507	88 44 24 20	 mov	 BYTE PTR SpriteIdx$1[rsp], al
  0050b	eb 0b		 jmp	 SHORT $LN4@ppuTick
$LN2@ppuTick:
  0050d	0f b6 44 24 20	 movzx	 eax, BYTE PTR SpriteIdx$1[rsp]
  00512	fe c8		 dec	 al
  00514	88 44 24 20	 mov	 BYTE PTR SpriteIdx$1[rsp], al
$LN4@ppuTick:
  00518	0f be 44 24 20	 movsx	 eax, BYTE PTR SpriteIdx$1[rsp]
  0051d	85 c0		 test	 eax, eax
  0051f	0f 8c 9c 01 00
	00		 jl	 $LN3@ppuTick

; 318  :                         {
; 319  :                             sprite *Sprite = Ppu->PreparedSprites + SpriteIdx;

  00525	48 0f be 44 24
	20		 movsx	 rax, BYTE PTR SpriteIdx$1[rsp]
  0052b	48 6b c0 10	 imul	 rax, rax, 16
  0052f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00537	48 8d 84 01 f0
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4592]
  0053f	48 89 44 24 40	 mov	 QWORD PTR Sprite$15[rsp], rax

; 320  :                             uint8 SpriteX = Sprite->OamData.X;

  00544	48 8b 44 24 40	 mov	 rax, QWORD PTR Sprite$15[rsp]
  00549	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0054d	88 44 24 29	 mov	 BYTE PTR SpriteX$5[rsp], al

; 321  :                             
; 322  :                             if(PixelX != 0xFF && SpriteX <= PixelX && PixelX < (SpriteX + PIXEL_PER_TILE)) 

  00551	0f b7 44 24 24	 movzx	 eax, WORD PTR PixelX$3[rsp]
  00556	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0055b	0f 84 5b 01 00
	00		 je	 $LN27@ppuTick
  00561	0f b6 44 24 29	 movzx	 eax, BYTE PTR SpriteX$5[rsp]
  00566	0f b7 4c 24 24	 movzx	 ecx, WORD PTR PixelX$3[rsp]
  0056b	3b c1		 cmp	 eax, ecx
  0056d	0f 8f 49 01 00
	00		 jg	 $LN27@ppuTick
  00573	0f b7 44 24 24	 movzx	 eax, WORD PTR PixelX$3[rsp]
  00578	0f b6 4c 24 29	 movzx	 ecx, BYTE PTR SpriteX$5[rsp]
  0057d	83 c1 08	 add	 ecx, 8
  00580	3b c1		 cmp	 eax, ecx
  00582	0f 8d 34 01 00
	00		 jge	 $LN27@ppuTick

; 323  :                             {
; 324  :                                 uint8 RelX = ((PixelX - (SpriteX)) % 8);                                    

  00588	0f b7 44 24 24	 movzx	 eax, WORD PTR PixelX$3[rsp]
  0058d	0f b6 4c 24 29	 movzx	 ecx, BYTE PTR SpriteX$5[rsp]
  00592	2b c1		 sub	 eax, ecx
  00594	99		 cdq
  00595	83 e2 07	 and	 edx, 7
  00598	03 c2		 add	 eax, edx
  0059a	83 e0 07	 and	 eax, 7
  0059d	2b c2		 sub	 eax, edx
  0059f	88 44 24 2c	 mov	 BYTE PTR RelX$7[rsp], al

; 325  :                                 uint8 PatternValue = (((Sprite->PatternHigh >> (7 - RelX)) & 1) << 1) |

  005a3	48 8b 44 24 40	 mov	 rax, QWORD PTR Sprite$15[rsp]
  005a8	0f b6 40 0e	 movzx	 eax, BYTE PTR [rax+14]
  005ac	0f b6 4c 24 2c	 movzx	 ecx, BYTE PTR RelX$7[rsp]
  005b1	ba 07 00 00 00	 mov	 edx, 7
  005b6	2b d1		 sub	 edx, ecx
  005b8	8b ca		 mov	 ecx, edx
  005ba	d3 f8		 sar	 eax, cl
  005bc	83 e0 01	 and	 eax, 1
  005bf	d1 e0		 shl	 eax, 1
  005c1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Sprite$15[rsp]
  005c6	0f b6 49 0d	 movzx	 ecx, BYTE PTR [rcx+13]
  005ca	89 4c 24 6c	 mov	 DWORD PTR tv279[rsp], ecx
  005ce	0f b6 54 24 2c	 movzx	 edx, BYTE PTR RelX$7[rsp]
  005d3	bf 07 00 00 00	 mov	 edi, 7
  005d8	2b fa		 sub	 edi, edx
  005da	8b d7		 mov	 edx, edi
  005dc	0f b6 ca	 movzx	 ecx, dl
  005df	8b 54 24 6c	 mov	 edx, DWORD PTR tv279[rsp]
  005e3	d3 fa		 sar	 edx, cl
  005e5	8b ca		 mov	 ecx, edx
  005e7	83 e1 01	 and	 ecx, 1
  005ea	0b c1		 or	 eax, ecx
  005ec	88 44 24 2d	 mov	 BYTE PTR PatternValue$8[rsp], al

; 326  :                                     ((Sprite->PatternLow >> (7 - RelX)) & 1);
; 327  :                                     
; 328  :                                 if(PatternValue != 0) // If bottom two bits is 0, then is multiple of 4.

  005f0	0f b6 44 24 2d	 movzx	 eax, BYTE PTR PatternValue$8[rsp]
  005f5	85 c0		 test	 eax, eax
  005f7	0f 84 bf 00 00
	00		 je	 $LN28@ppuTick

; 329  :                                 {
; 330  :                                     uint8 SpriteColour = (Sprite->PaletteValue << 2) | PatternValue;

  005fd	48 8b 44 24 40	 mov	 rax, QWORD PTR Sprite$15[rsp]
  00602	0f b6 40 0c	 movzx	 eax, BYTE PTR [rax+12]
  00606	c1 e0 02	 shl	 eax, 2
  00609	0f b6 4c 24 2d	 movzx	 ecx, BYTE PTR PatternValue$8[rsp]
  0060e	0b c1		 or	 eax, ecx
  00610	88 44 24 30	 mov	 BYTE PTR SpriteColour$11[rsp], al

; 331  : 
; 332  :                                     if(Sprite->Sprite0 && !Ppu->Sprite0Hit && SpriteIdx == 0 &&
; 333  :                                        Ppu->ShowBackground && BackgroundColour != 0 &&

  00614	48 8b 44 24 40	 mov	 rax, QWORD PTR Sprite$15[rsp]
  00619	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0061d	74 5c		 je	 SHORT $LN29@ppuTick
  0061f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00627	83 b8 50 10 00
	00 00		 cmp	 DWORD PTR [rax+4176], 0
  0062e	75 4b		 jne	 SHORT $LN29@ppuTick
  00630	0f be 44 24 20	 movsx	 eax, BYTE PTR SpriteIdx$1[rsp]
  00635	85 c0		 test	 eax, eax
  00637	75 42		 jne	 SHORT $LN29@ppuTick
  00639	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00641	83 b8 38 10 00
	00 00		 cmp	 DWORD PTR [rax+4152], 0
  00648	74 31		 je	 SHORT $LN29@ppuTick
  0064a	0f b6 44 24 21	 movzx	 eax, BYTE PTR BackgroundColour$2[rsp]
  0064f	85 c0		 test	 eax, eax
  00651	74 28		 je	 SHORT $LN29@ppuTick
  00653	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0065b	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  00662	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00667	7f 12		 jg	 SHORT $LN29@ppuTick

; 334  :                                        Ppu->ScanlineCycle <= 256)
; 335  :                                     {
; 336  :                                         Ppu->Sprite0Hit = true;

  00669	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00671	c7 80 50 10 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4176], 1
$LN29@ppuTick:

; 337  :                                     }
; 338  : 
; 339  :                                     if( Sprite->Priority || BackgroundColour == 0 )

  0067b	48 8b 44 24 40	 mov	 rax, QWORD PTR Sprite$15[rsp]
  00680	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00684	75 09		 jne	 SHORT $LN31@ppuTick
  00686	0f b6 44 24 21	 movzx	 eax, BYTE PTR BackgroundColour$2[rsp]
  0068b	85 c0		 test	 eax, eax
  0068d	75 2d		 jne	 SHORT $LN30@ppuTick
$LN31@ppuTick:

; 340  :                                     {
; 341  :                                         uint8 SprtPaletteIndex = readPpu8(SPRT_PALETTE_ADRS + SpriteColour, Ppu);                       

  0068f	0f b6 44 24 30	 movzx	 eax, BYTE PTR SpriteColour$11[rsp]
  00694	05 10 3f 00 00	 add	 eax, 16144		; 00003f10H
  00699	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR Ppu$[rsp]
  006a1	0f b7 c8	 movzx	 ecx, ax
  006a4	e8 00 00 00 00	 call	 ?readPpu8@@YAEGPEAUppu@@@Z ; readPpu8
  006a9	88 44 24 31	 mov	 BYTE PTR SprtPaletteIndex$12[rsp], al

; 342  :                                         getPaletteValue(SprtPaletteIndex, Colour);                        

  006ad	48 8d 54 24 34	 lea	 rdx, QWORD PTR Colour$13[rsp]
  006b2	0f b6 4c 24 31	 movzx	 ecx, BYTE PTR SprtPaletteIndex$12[rsp]
  006b7	e8 00 00 00 00	 call	 ?getPaletteValue@@YAXEPEAE@Z ; getPaletteValue
$LN30@ppuTick:
$LN28@ppuTick:
$LN27@ppuTick:

; 343  :                                     }
; 344  :                                 }
; 345  :                             }
; 346  :                         }

  006bc	e9 4c fe ff ff	 jmp	 $LN2@ppuTick
$LN3@ppuTick:
$LN25@ppuTick:

; 347  :                     }
; 348  : 
; 349  :                     // PIXEL OUTPUT - using the resulting colour
; 350  :                     drawPixel(Ppu, PixelX, PixelY, Colour);

  006c1	4c 8d 4c 24 34	 lea	 r9, QWORD PTR Colour$13[rsp]
  006c6	44 0f b7 44 24
	38		 movzx	 r8d, WORD PTR PixelY$14[rsp]
  006cc	0f b7 54 24 24	 movzx	 edx, WORD PTR PixelX$3[rsp]
  006d1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  006d9	e8 00 00 00 00	 call	 ?drawPixel@@YAXPEAUppu@@GGPEAE@Z ; drawPixel
$LN21@ppuTick:
$LN17@ppuTick:
$LN16@ppuTick:
$LN5@ppuTick:

; 351  :                 }            
; 352  :             }
; 353  :         }
; 354  :     }
; 355  :     if(VBlankLine)

  006de	83 7c 24 70 00	 cmp	 DWORD PTR VBlankLine$[rsp], 0
  006e3	0f 84 cc 00 00
	00		 je	 $LN32@ppuTick

; 356  :     {
; 357  :         if(Ppu->Scanline == 241 && Ppu->ScanlineCycle == 1)

  006e9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  006f1	0f b7 80 70 12
	00 00		 movzx	 eax, WORD PTR [rax+4720]
  006f8	3d f1 00 00 00	 cmp	 eax, 241		; 000000f1H
  006fd	75 7a		 jne	 SHORT $LN33@ppuTick
  006ff	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00707	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  0070e	83 f8 01	 cmp	 eax, 1
  00711	75 66		 jne	 SHORT $LN33@ppuTick

; 358  :         {
; 359  :             if(Ppu->SupressVbl)

  00713	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0071b	83 b8 80 12 00
	00 00		 cmp	 DWORD PTR [rax+4736], 0
  00722	74 14		 je	 SHORT $LN34@ppuTick

; 360  :             {
; 361  :                 Ppu->SupressVbl = false;

  00724	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0072c	c7 80 80 12 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4736], 0

; 362  :             }
; 363  :             else

  00736	eb 37		 jmp	 SHORT $LN35@ppuTick
$LN34@ppuTick:

; 364  :             {
; 365  :                 Ppu->VerticalBlank = true;

  00738	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00740	c7 80 54 10 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4180], 1

; 366  :                 if(!Ppu->SupressNmi)

  0074a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00752	83 b8 84 12 00
	00 00		 cmp	 DWORD PTR [rax+4740], 0
  00759	75 14		 jne	 SHORT $LN36@ppuTick

; 367  :                 {
; 368  :                     TriggerNmi = Ppu->GenerateNMI;

  0075b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00763	8b 80 28 10 00
	00		 mov	 eax, DWORD PTR [rax+4136]
  00769	89 05 00 00 00
	00		 mov	 DWORD PTR ?TriggerNmi@@3HA, eax ; TriggerNmi
$LN36@ppuTick:
$LN35@ppuTick:

; 369  :                 }
; 370  :             }
; 371  : 
; 372  :             DrawScreen = true;

  0076f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?DrawScreen@@3HA, 1
$LN33@ppuTick:

; 373  :         }
; 374  :         if(Ppu->Scanline == 241 && Ppu->ScanlineCycle == 2)

  00779	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00781	0f b7 80 70 12
	00 00		 movzx	 eax, WORD PTR [rax+4720]
  00788	3d f1 00 00 00	 cmp	 eax, 241		; 000000f1H
  0078d	75 26		 jne	 SHORT $LN37@ppuTick
  0078f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00797	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  0079e	83 f8 02	 cmp	 eax, 2
  007a1	75 12		 jne	 SHORT $LN37@ppuTick

; 375  :         {
; 376  :             Ppu->SupressNmi = false;

  007a3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  007ab	c7 80 84 12 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4740], 0
$LN37@ppuTick:
$LN32@ppuTick:

; 377  :         }
; 378  :     }
; 379  :     
; 380  :     // Incrementing to the next cycle. If reached end of
; 381  :     // scanline cycles then increment scanline.
; 382  :     ++Ppu->ScanlineCycle;

  007b5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  007bd	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  007c4	66 ff c0	 inc	 ax
  007c7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  007cf	66 89 81 72 12
	00 00		 mov	 WORD PTR [rcx+4722], ax

; 383  :     
; 384  :     if(Ppu->ScanlineCycle == 341)

  007d6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  007de	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  007e5	3d 55 01 00 00	 cmp	 eax, 341		; 00000155H
  007ea	75 31		 jne	 SHORT $LN38@ppuTick

; 385  :     {
; 386  :         Ppu->Scanline += 1;

  007ec	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  007f4	0f b7 80 70 12
	00 00		 movzx	 eax, WORD PTR [rax+4720]
  007fb	ff c0		 inc	 eax
  007fd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00805	66 89 81 70 12
	00 00		 mov	 WORD PTR [rcx+4720], ax

; 387  :         Ppu->ScanlineCycle = 0;

  0080c	33 c0		 xor	 eax, eax
  0080e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00816	66 89 81 72 12
	00 00		 mov	 WORD PTR [rcx+4722], ax
$LN38@ppuTick:

; 388  :     }
; 389  : 
; 390  :     if(Ppu->Scanline == 262)

  0081d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00825	0f b7 80 70 12
	00 00		 movzx	 eax, WORD PTR [rax+4720]
  0082c	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  00831	75 46		 jne	 SHORT $LN39@ppuTick

; 391  :     {
; 392  :         Ppu->Scanline = 0;

  00833	33 c0		 xor	 eax, eax
  00835	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0083d	66 89 81 70 12
	00 00		 mov	 WORD PTR [rcx+4720], ax

; 393  :         Ppu->OddFrame = !Ppu->OddFrame;

  00844	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0084c	83 b8 7c 12 00
	00 00		 cmp	 DWORD PTR [rax+4732], 0
  00853	75 0a		 jne	 SHORT $LN51@ppuTick
  00855	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv364[rsp], 1
  0085d	eb 08		 jmp	 SHORT $LN52@ppuTick
$LN51@ppuTick:
  0085f	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv364[rsp], 0
$LN52@ppuTick:
  00867	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0086f	8b 4c 24 60	 mov	 ecx, DWORD PTR tv364[rsp]
  00873	89 88 7c 12 00
	00		 mov	 DWORD PTR [rax+4732], ecx
$LN39@ppuTick:

; 394  :     }
; 395  : }

  00879	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00880	5f		 pop	 rdi
  00881	c3		 ret	 0
?ppuTick@@YAXPEAUppu@@@Z ENDP				; ppuTick
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
SpriteIdx$1 = 0
Ppu$ = 48
?prepareSprites@@YAXPEAUppu@@@Z PROC			; prepareSprites

; 217  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 18	 sub	 rsp, 24

; 218  :     Ppu->PreparedSpriteCount = Ppu->SecondarySpriteCount;

  0000b	48 8b 44 24 30	 mov	 rax, QWORD PTR Ppu$[rsp]
  00010	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00015	0f b6 89 68 11
	00 00		 movzx	 ecx, BYTE PTR [rcx+4456]
  0001c	88 88 ec 11 00
	00		 mov	 BYTE PTR [rax+4588], cl

; 219  :         
; 220  :     for(int8 SpriteIdx = 0; SpriteIdx < Ppu->SecondarySpriteCount; ++SpriteIdx)

  00022	c6 04 24 00	 mov	 BYTE PTR SpriteIdx$1[rsp], 0
  00026	eb 09		 jmp	 SHORT $LN4@prepareSpr
$LN2@prepareSpr:
  00028	0f b6 04 24	 movzx	 eax, BYTE PTR SpriteIdx$1[rsp]
  0002c	fe c0		 inc	 al
  0002e	88 04 24	 mov	 BYTE PTR SpriteIdx$1[rsp], al
$LN4@prepareSpr:
  00031	0f be 04 24	 movsx	 eax, BYTE PTR SpriteIdx$1[rsp]
  00035	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0003a	0f b6 89 68 11
	00 00		 movzx	 ecx, BYTE PTR [rcx+4456]
  00041	3b c1		 cmp	 eax, ecx
  00043	7d 35		 jge	 SHORT $LN3@prepareSpr

; 221  :     {
; 222  :         Ppu->PreparedSprites[SpriteIdx] = Ppu->SecondaryOam[SpriteIdx];

  00045	48 0f be 04 24	 movsx	 rax, BYTE PTR SpriteIdx$1[rsp]
  0004a	48 6b c0 10	 imul	 rax, rax, 16
  0004e	48 0f be 0c 24	 movsx	 rcx, BYTE PTR SpriteIdx$1[rsp]
  00053	48 6b c9 10	 imul	 rcx, rcx, 16
  00057	48 8b 54 24 30	 mov	 rdx, QWORD PTR Ppu$[rsp]
  0005c	4c 8b 44 24 30	 mov	 r8, QWORD PTR Ppu$[rsp]
  00061	48 8d bc 0a f0
	11 00 00	 lea	 rdi, QWORD PTR [rdx+rcx+4592]
  00069	49 8d b4 00 6c
	11 00 00	 lea	 rsi, QWORD PTR [r8+rax+4460]
  00071	b9 10 00 00 00	 mov	 ecx, 16
  00076	f3 a4		 rep movsb

; 223  :     }

  00078	eb ae		 jmp	 SHORT $LN2@prepareSpr
$LN3@prepareSpr:

; 224  : }

  0007a	48 83 c4 18	 add	 rsp, 24
  0007e	5f		 pop	 rdi
  0007f	5e		 pop	 rsi
  00080	c3		 ret	 0
?prepareSprites@@YAXPEAUppu@@@Z ENDP			; prepareSprites
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
OamSpriteCount$1 = 32
TileRelY$2 = 33
YOffset$3 = 34
SpritePatternBase$4 = 36
LowAddress$5 = 40
HighAddress$6 = 44
tv130 = 48
tv142 = 52
tv163 = 56
OamSprite$7 = 64
Oam$ = 72
SecondaryOam$ = 80
Sprite$8 = 88
__$ArrayPad$ = 104
Ppu$ = 144
?evaluateSecondaryOam@@YAXPEAUppu@@@Z PROC		; evaluateSecondaryOam

; 160  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0000b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00012	48 33 c4	 xor	 rax, rsp
  00015	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 161  :     uint8 *Oam = Ppu->Oam;

  0001a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00022	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  00028	48 89 44 24 48	 mov	 QWORD PTR Oam$[rsp], rax

; 162  :     sprite *SecondaryOam = Ppu->SecondaryOam;

  0002d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00035	48 05 6c 11 00
	00		 add	 rax, 4460		; 0000116cH
  0003b	48 89 44 24 50	 mov	 QWORD PTR SecondaryOam$[rsp], rax

; 163  :         
; 164  :     Ppu->SecondarySpriteCount = 0;

  00040	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00048	c6 80 68 11 00
	00 00		 mov	 BYTE PTR [rax+4456], 0

; 165  :             
; 166  :     for(uint8 OamSpriteCount = 0;

  0004f	c6 44 24 20 00	 mov	 BYTE PTR OamSpriteCount$1[rsp], 0
  00054	eb 0b		 jmp	 SHORT $LN4@evaluateSe
$LN2@evaluateSe:

; 168  :         ++OamSpriteCount)

  00056	0f b6 44 24 20	 movzx	 eax, BYTE PTR OamSpriteCount$1[rsp]
  0005b	fe c0		 inc	 al
  0005d	88 44 24 20	 mov	 BYTE PTR OamSpriteCount$1[rsp], al
$LN4@evaluateSe:

; 167  :         OamSpriteCount < OAM_SPRITE_TOTAL && Ppu->SecondarySpriteCount != SECONDARY_OAM_SPRITE_MAX;

  00061	0f b6 44 24 20	 movzx	 eax, BYTE PTR OamSpriteCount$1[rsp]
  00066	83 f8 40	 cmp	 eax, 64			; 00000040H
  00069	0f 8d 85 02 00
	00		 jge	 $LN3@evaluateSe
  0006f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00077	0f b6 80 68 11
	00 00		 movzx	 eax, BYTE PTR [rax+4456]
  0007e	83 f8 08	 cmp	 eax, 8
  00081	0f 84 6d 02 00
	00		 je	 $LN3@evaluateSe

; 169  :     {
; 170  :         oam_sprite *OamSprite = (oam_sprite *)Oam + OamSpriteCount;

  00087	0f b6 44 24 20	 movzx	 eax, BYTE PTR OamSpriteCount$1[rsp]
  0008c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Oam$[rsp]
  00091	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  00095	48 89 44 24 40	 mov	 QWORD PTR OamSprite$7[rsp], rax

; 171  :         
; 172  :         if(Ppu->SecondarySpriteCount < SECONDARY_OAM_SPRITE_MAX &&
; 173  :            OamSprite->Y <= Ppu->Scanline && Ppu->Scanline < (OamSprite->Y + PIXEL_PER_TILE))

  0009a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  000a2	0f b6 80 68 11
	00 00		 movzx	 eax, BYTE PTR [rax+4456]
  000a9	83 f8 08	 cmp	 eax, 8
  000ac	0f 8d 3d 02 00
	00		 jge	 $LN5@evaluateSe
  000b2	48 8b 44 24 40	 mov	 rax, QWORD PTR OamSprite$7[rsp]
  000b7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ba	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  000c2	0f b7 89 70 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4720]
  000c9	3b c1		 cmp	 eax, ecx
  000cb	0f 8f 1e 02 00
	00		 jg	 $LN5@evaluateSe
  000d1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  000d9	0f b7 80 70 12
	00 00		 movzx	 eax, WORD PTR [rax+4720]
  000e0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR OamSprite$7[rsp]
  000e5	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000e8	83 c1 08	 add	 ecx, 8
  000eb	3b c1		 cmp	 eax, ecx
  000ed	0f 8d fc 01 00
	00		 jge	 $LN5@evaluateSe

; 174  :         {
; 175  :             sprite Sprite = {};

  000f3	48 8d 44 24 58	 lea	 rax, QWORD PTR Sprite$8[rsp]
  000f8	48 8b f8	 mov	 rdi, rax
  000fb	33 c0		 xor	 eax, eax
  000fd	b9 10 00 00 00	 mov	 ecx, 16
  00102	f3 aa		 rep stosb

; 176  :             Sprite.OamData = *OamSprite;

  00104	48 8b 44 24 40	 mov	 rax, QWORD PTR OamSprite$7[rsp]
  00109	8b 00		 mov	 eax, DWORD PTR [rax]
  0010b	89 44 24 58	 mov	 DWORD PTR Sprite$8[rsp], eax

; 177  :             Sprite.Priority = !(Sprite.OamData.Atrb & (1 << 5));

  0010f	0f b6 44 24 5a	 movzx	 eax, BYTE PTR Sprite$8[rsp+2]
  00114	83 e0 20	 and	 eax, 32			; 00000020H
  00117	85 c0		 test	 eax, eax
  00119	75 0a		 jne	 SHORT $LN12@evaluateSe
  0011b	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv130[rsp], 1
  00123	eb 08		 jmp	 SHORT $LN13@evaluateSe
$LN12@evaluateSe:
  00125	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
$LN13@evaluateSe:
  0012d	8b 44 24 30	 mov	 eax, DWORD PTR tv130[rsp]
  00131	89 44 24 5c	 mov	 DWORD PTR Sprite$8[rsp+4], eax

; 178  : 
; 179  :             if(OamSpriteCount == 0)

  00135	0f b6 44 24 20	 movzx	 eax, BYTE PTR OamSpriteCount$1[rsp]
  0013a	85 c0		 test	 eax, eax
  0013c	75 08		 jne	 SHORT $LN6@evaluateSe

; 180  :             {
; 181  :                 Sprite.Sprite0 = true;

  0013e	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR Sprite$8[rsp+8], 1
$LN6@evaluateSe:

; 182  :             }
; 183  : 
; 184  :             // Palette
; 185  :             Sprite.PaletteValue = Sprite.OamData.Atrb & 3;

  00146	0f b6 44 24 5a	 movzx	 eax, BYTE PTR Sprite$8[rsp+2]
  0014b	83 e0 03	 and	 eax, 3
  0014e	88 44 24 64	 mov	 BYTE PTR Sprite$8[rsp+12], al

; 186  : 
; 187  :             // CHR Data            
; 188  :             uint16 SpritePatternBase = Ppu->SPRTPattenBase;

  00152	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0015a	0f b7 80 1a 10
	00 00		 movzx	 eax, WORD PTR [rax+4122]
  00161	66 89 44 24 24	 mov	 WORD PTR SpritePatternBase$4[rsp], ax

; 189  :             if(Ppu->SpriteSize8x16)

  00166	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0016e	83 b8 20 10 00
	00 00		 cmp	 DWORD PTR [rax+4128], 0
  00175	74 28		 je	 SHORT $LN7@evaluateSe

; 190  :             {
; 191  :                 SpritePatternBase = (Sprite.OamData.Tile & 1) ? 0x1000 : 0;

  00177	0f b6 44 24 59	 movzx	 eax, BYTE PTR Sprite$8[rsp+1]
  0017c	83 e0 01	 and	 eax, 1
  0017f	85 c0		 test	 eax, eax
  00181	74 0a		 je	 SHORT $LN14@evaluateSe
  00183	c7 44 24 34 00
	10 00 00	 mov	 DWORD PTR tv142[rsp], 4096 ; 00001000H
  0018b	eb 08		 jmp	 SHORT $LN15@evaluateSe
$LN14@evaluateSe:
  0018d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN15@evaluateSe:
  00195	0f b7 44 24 34	 movzx	 eax, WORD PTR tv142[rsp]
  0019a	66 89 44 24 24	 mov	 WORD PTR SpritePatternBase$4[rsp], ax
$LN7@evaluateSe:

; 192  :             }
; 193  :             
; 194  :             uint8 TileRelY = (uint8)(Ppu->Scanline - Sprite.OamData.Y ) % PIXEL_PER_TILE; // NOTE TODO: -1?????               

  0019f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  001a7	0f b7 80 70 12
	00 00		 movzx	 eax, WORD PTR [rax+4720]
  001ae	0f b6 4c 24 58	 movzx	 ecx, BYTE PTR Sprite$8[rsp]
  001b3	2b c1		 sub	 eax, ecx
  001b5	0f b6 c0	 movzx	 eax, al
  001b8	99		 cdq
  001b9	83 e2 07	 and	 edx, 7
  001bc	03 c2		 add	 eax, edx
  001be	83 e0 07	 and	 eax, 7
  001c1	2b c2		 sub	 eax, edx
  001c3	88 44 24 21	 mov	 BYTE PTR TileRelY$2[rsp], al

; 195  :             Assert(0 <= TileRelY && TileRelY < PIXEL_PER_TILE);

  001c7	0f b6 44 24 21	 movzx	 eax, BYTE PTR TileRelY$2[rsp]
  001cc	85 c0		 test	 eax, eax
  001ce	7c 0a		 jl	 SHORT $LN9@evaluateSe
  001d0	0f b6 44 24 21	 movzx	 eax, BYTE PTR TileRelY$2[rsp]
  001d5	83 f8 08	 cmp	 eax, 8
  001d8	7c 0b		 jl	 SHORT $LN8@evaluateSe
$LN9@evaluateSe:
  001da	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN8@evaluateSe:

; 196  : 
; 197  :             uint8 YOffset = (Sprite.OamData.Atrb & (1 << 7)) ? (7 - TileRelY) : TileRelY;

  001e5	0f b6 44 24 5a	 movzx	 eax, BYTE PTR Sprite$8[rsp+2]
  001ea	25 80 00 00 00	 and	 eax, 128		; 00000080H
  001ef	85 c0		 test	 eax, eax
  001f1	74 14		 je	 SHORT $LN16@evaluateSe
  001f3	0f b6 44 24 21	 movzx	 eax, BYTE PTR TileRelY$2[rsp]
  001f8	b9 07 00 00 00	 mov	 ecx, 7
  001fd	2b c8		 sub	 ecx, eax
  001ff	8b c1		 mov	 eax, ecx
  00201	89 44 24 38	 mov	 DWORD PTR tv163[rsp], eax
  00205	eb 09		 jmp	 SHORT $LN17@evaluateSe
$LN16@evaluateSe:
  00207	0f b6 44 24 21	 movzx	 eax, BYTE PTR TileRelY$2[rsp]
  0020c	89 44 24 38	 mov	 DWORD PTR tv163[rsp], eax
$LN17@evaluateSe:
  00210	0f b6 44 24 38	 movzx	 eax, BYTE PTR tv163[rsp]
  00215	88 44 24 22	 mov	 BYTE PTR YOffset$3[rsp], al

; 198  :             
; 199  :             uint16 LowAddress  = (SpritePatternBase + (Sprite.OamData.Tile * 16)) + YOffset;

  00219	0f b7 44 24 24	 movzx	 eax, WORD PTR SpritePatternBase$4[rsp]
  0021e	0f b6 4c 24 59	 movzx	 ecx, BYTE PTR Sprite$8[rsp+1]
  00223	6b c9 10	 imul	 ecx, ecx, 16
  00226	03 c1		 add	 eax, ecx
  00228	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR YOffset$3[rsp]
  0022d	03 c1		 add	 eax, ecx
  0022f	66 89 44 24 28	 mov	 WORD PTR LowAddress$5[rsp], ax

; 200  :             uint16 HighAddress = (SpritePatternBase + (Sprite.OamData.Tile * 16) + 8) + YOffset;

  00234	0f b7 44 24 24	 movzx	 eax, WORD PTR SpritePatternBase$4[rsp]
  00239	0f b6 4c 24 59	 movzx	 ecx, BYTE PTR Sprite$8[rsp+1]
  0023e	6b c9 10	 imul	 ecx, ecx, 16
  00241	03 c1		 add	 eax, ecx
  00243	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR YOffset$3[rsp]
  00248	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  0024c	66 89 44 24 2c	 mov	 WORD PTR HighAddress$6[rsp], ax

; 201  : 
; 202  :             Sprite.PatternLow  = readPpu8(LowAddress, Ppu);

  00251	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR Ppu$[rsp]
  00259	0f b7 4c 24 28	 movzx	 ecx, WORD PTR LowAddress$5[rsp]
  0025e	e8 00 00 00 00	 call	 ?readPpu8@@YAEGPEAUppu@@@Z ; readPpu8
  00263	88 44 24 65	 mov	 BYTE PTR Sprite$8[rsp+13], al

; 203  :             Sprite.PatternHigh = readPpu8(HighAddress, Ppu);

  00267	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR Ppu$[rsp]
  0026f	0f b7 4c 24 2c	 movzx	 ecx, WORD PTR HighAddress$6[rsp]
  00274	e8 00 00 00 00	 call	 ?readPpu8@@YAEGPEAUppu@@@Z ; readPpu8
  00279	88 44 24 66	 mov	 BYTE PTR Sprite$8[rsp+14], al

; 204  : 
; 205  :             if(Sprite.OamData.Atrb & (1 << 6))

  0027d	0f b6 44 24 5a	 movzx	 eax, BYTE PTR Sprite$8[rsp+2]
  00282	83 e0 40	 and	 eax, 64			; 00000040H
  00285	85 c0		 test	 eax, eax
  00287	74 1c		 je	 SHORT $LN10@evaluateSe

; 206  :             {
; 207  :                 Sprite.PatternLow = byteReverse(Sprite.PatternLow);

  00289	0f b6 4c 24 65	 movzx	 ecx, BYTE PTR Sprite$8[rsp+13]
  0028e	e8 00 00 00 00	 call	 ?byteReverse@@YAEE@Z	; byteReverse
  00293	88 44 24 65	 mov	 BYTE PTR Sprite$8[rsp+13], al

; 208  :                 Sprite.PatternHigh = byteReverse(Sprite.PatternHigh);

  00297	0f b6 4c 24 66	 movzx	 ecx, BYTE PTR Sprite$8[rsp+14]
  0029c	e8 00 00 00 00	 call	 ?byteReverse@@YAEE@Z	; byteReverse
  002a1	88 44 24 66	 mov	 BYTE PTR Sprite$8[rsp+14], al
$LN10@evaluateSe:

; 209  :             }
; 210  :             
; 211  :             SecondaryOam[Ppu->SecondarySpriteCount++] = Sprite;

  002a5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  002ad	0f b6 80 68 11
	00 00		 movzx	 eax, BYTE PTR [rax+4456]
  002b4	48 6b c0 10	 imul	 rax, rax, 16
  002b8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR SecondaryOam$[rsp]
  002bd	48 8d 54 24 58	 lea	 rdx, QWORD PTR Sprite$8[rsp]
  002c2	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  002c6	48 8b f2	 mov	 rsi, rdx
  002c9	b9 10 00 00 00	 mov	 ecx, 16
  002ce	f3 a4		 rep movsb
  002d0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  002d8	0f b6 80 68 11
	00 00		 movzx	 eax, BYTE PTR [rax+4456]
  002df	fe c0		 inc	 al
  002e1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  002e9	88 81 68 11 00
	00		 mov	 BYTE PTR [rcx+4456], al
$LN5@evaluateSe:

; 212  :         }
; 213  :     }

  002ef	e9 62 fd ff ff	 jmp	 $LN2@evaluateSe
$LN3@evaluateSe:

; 214  : }

  002f4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002f9	48 33 cc	 xor	 rcx, rsp
  002fc	e8 00 00 00 00	 call	 __security_check_cookie
  00301	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00305	5f		 pop	 rdi
  00306	5e		 pop	 rsi
  00307	c3		 ret	 0
?evaluateSecondaryOam@@YAXPEAUppu@@@Z ENDP		; evaluateSecondaryOam
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
Byte$1 = 0
Data$ = 8
Ppu$ = 32
?clearPreparedSprites@@YAXPEAUppu@@@Z PROC		; clearPreparedSprites

; 149  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 150  :     uint8 *Data = (uint8 *)Ppu->PreparedSprites;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  0000e	48 05 f0 11 00
	00		 add	 rax, 4592		; 000011f0H
  00014	48 89 44 24 08	 mov	 QWORD PTR Data$[rsp], rax

; 151  :     
; 152  :     for(uint16 Byte = 0; Byte < (SECONDARY_OAM_SPRITE_MAX * sizeof(sprite)); ++Byte)

  00019	33 c0		 xor	 eax, eax
  0001b	66 89 04 24	 mov	 WORD PTR Byte$1[rsp], ax
  0001f	eb 0b		 jmp	 SHORT $LN4@clearPrepa
$LN2@clearPrepa:
  00021	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  00025	66 ff c0	 inc	 ax
  00028	66 89 04 24	 mov	 WORD PTR Byte$1[rsp], ax
$LN4@clearPrepa:
  0002c	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  00030	48 3d 80 00 00
	00		 cmp	 rax, 128		; 00000080H
  00036	73 0f		 jae	 SHORT $LN3@clearPrepa

; 153  :     {
; 154  :         Data[Byte] = 0xFF;

  00038	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  0003c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Data$[rsp]
  00041	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 155  :     }

  00045	eb da		 jmp	 SHORT $LN2@clearPrepa
$LN3@clearPrepa:

; 156  : }

  00047	48 83 c4 18	 add	 rsp, 24
  0004b	c3		 ret	 0
?clearPreparedSprites@@YAXPEAUppu@@@Z ENDP		; clearPreparedSprites
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
Byte$1 = 0
Data$ = 8
Ppu$ = 32
?clearSecondaryOam@@YAXPEAUppu@@@Z PROC			; clearSecondaryOam

; 139  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 140  :     uint8 *Data = (uint8 *)Ppu->SecondaryOam;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  0000e	48 05 6c 11 00
	00		 add	 rax, 4460		; 0000116cH
  00014	48 89 44 24 08	 mov	 QWORD PTR Data$[rsp], rax

; 141  :     
; 142  :     for(uint16 Byte = 0; Byte < (SECONDARY_OAM_SPRITE_MAX * sizeof(sprite)); ++Byte)

  00019	33 c0		 xor	 eax, eax
  0001b	66 89 04 24	 mov	 WORD PTR Byte$1[rsp], ax
  0001f	eb 0b		 jmp	 SHORT $LN4@clearSecon
$LN2@clearSecon:
  00021	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  00025	66 ff c0	 inc	 ax
  00028	66 89 04 24	 mov	 WORD PTR Byte$1[rsp], ax
$LN4@clearSecon:
  0002c	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  00030	48 3d 80 00 00
	00		 cmp	 rax, 128		; 00000080H
  00036	73 0f		 jae	 SHORT $LN3@clearSecon

; 143  :     {
; 144  :         Data[Byte] = 0xFF;

  00038	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  0003c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Data$[rsp]
  00041	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 145  :     }

  00045	eb da		 jmp	 SHORT $LN2@clearSecon
$LN3@clearSecon:

; 146  : }

  00047	48 83 c4 18	 add	 rsp, 24
  0004b	c3		 ret	 0
?clearSecondaryOam@@YAXPEAUppu@@@Z ENDP			; clearSecondaryOam
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
byte$ = 8
?byteReverse@@YAEE@Z PROC				; byteReverse

; 130  : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 131  :     byte = (byte & 0xF0) >> 4 | (byte & 0x0F) << 4; // 1111 0000 and 0000 1111 swap

  00004	0f b6 44 24 08	 movzx	 eax, BYTE PTR byte$[rsp]
  00009	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0000e	c1 f8 04	 sar	 eax, 4
  00011	0f b6 4c 24 08	 movzx	 ecx, BYTE PTR byte$[rsp]
  00016	83 e1 0f	 and	 ecx, 15
  00019	c1 e1 04	 shl	 ecx, 4
  0001c	0b c1		 or	 eax, ecx
  0001e	88 44 24 08	 mov	 BYTE PTR byte$[rsp], al

; 132  :     byte = (byte & 0xCC) >> 2 | (byte & 0x33) << 2; // 1100 and 0011 swap

  00022	0f b6 44 24 08	 movzx	 eax, BYTE PTR byte$[rsp]
  00027	25 cc 00 00 00	 and	 eax, 204		; 000000ccH
  0002c	c1 f8 02	 sar	 eax, 2
  0002f	0f b6 4c 24 08	 movzx	 ecx, BYTE PTR byte$[rsp]
  00034	83 e1 33	 and	 ecx, 51			; 00000033H
  00037	c1 e1 02	 shl	 ecx, 2
  0003a	0b c1		 or	 eax, ecx
  0003c	88 44 24 08	 mov	 BYTE PTR byte$[rsp], al

; 133  :     byte = (byte & 0xAA) >> 1 | (byte & 0x55) << 1; // 10 and 01 swap

  00040	0f b6 44 24 08	 movzx	 eax, BYTE PTR byte$[rsp]
  00045	25 aa 00 00 00	 and	 eax, 170		; 000000aaH
  0004a	d1 f8		 sar	 eax, 1
  0004c	0f b6 4c 24 08	 movzx	 ecx, BYTE PTR byte$[rsp]
  00051	83 e1 55	 and	 ecx, 85			; 00000055H
  00054	d1 e1		 shl	 ecx, 1
  00056	0b c1		 or	 eax, ecx
  00058	88 44 24 08	 mov	 BYTE PTR byte$[rsp], al

; 134  :     
; 135  :     return byte;

  0005c	0f b6 44 24 08	 movzx	 eax, BYTE PTR byte$[rsp]

; 136  : }

  00061	c3		 ret	 0
?byteReverse@@YAEE@Z ENDP				; byteReverse
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
Cycle$ = 32
Atrb$1 = 33
NametableAddress$2 = 36
AtrbAddress$3 = 40
quadrantSelect$4 = 44
Ppu$ = 64
?loadFutureData@@YAXPEAUppu@@@Z PROC			; loadFutureData

; 81   : {                            

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 82   :     uint8 Cycle = (Ppu->ScanlineCycle - 1) % 8;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR Ppu$[rsp]
  0000e	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  00015	ff c8		 dec	 eax
  00017	99		 cdq
  00018	83 e2 07	 and	 edx, 7
  0001b	03 c2		 add	 eax, edx
  0001d	83 e0 07	 and	 eax, 7
  00020	2b c2		 sub	 eax, edx
  00022	88 44 24 20	 mov	 BYTE PTR Cycle$[rsp], al

; 83   :     if(Cycle == 0) 

  00026	0f b6 44 24 20	 movzx	 eax, BYTE PTR Cycle$[rsp]
  0002b	85 c0		 test	 eax, eax
  0002d	0f 85 a5 00 00
	00		 jne	 $LN2@loadFuture

; 84   :     {
; 85   : 
; 86   :  LowPatternShiftReg = (LowPatternShiftReg << 8) | NextLowPattern;

  00033	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?LowPatternShiftReg@@3GA ; LowPatternShiftReg
  0003a	c1 e0 08	 shl	 eax, 8
  0003d	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?NextLowPattern@@3EA ; NextLowPattern
  00044	0b c1		 or	 eax, ecx
  00046	66 89 05 00 00
	00 00		 mov	 WORD PTR ?LowPatternShiftReg@@3GA, ax ; LowPatternShiftReg

; 87   :         HighPatternShiftReg = (HighPatternShiftReg << 8) | NextHighPattern;

  0004d	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?HighPatternShiftReg@@3GA ; HighPatternShiftReg
  00054	c1 e0 08	 shl	 eax, 8
  00057	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?NextHighPattern@@3EA ; NextHighPattern
  0005e	0b c1		 or	 eax, ecx
  00060	66 89 05 00 00
	00 00		 mov	 WORD PTR ?HighPatternShiftReg@@3GA, ax ; HighPatternShiftReg

; 88   :         PaletteLatchOld = PaletteLatchNew;

  00067	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?PaletteLatchNew@@3EA ; PaletteLatchNew
  0006e	88 05 00 00 00
	00		 mov	 BYTE PTR ?PaletteLatchOld@@3EA, al ; PaletteLatchOld

; 89   :         PaletteLatchNew = NextAtrbByte << 2;

  00074	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?NextAtrbByte@@3EA ; NextAtrbByte
  0007b	c1 e0 02	 shl	 eax, 2
  0007e	88 05 00 00 00
	00		 mov	 BYTE PTR ?PaletteLatchNew@@3EA, al ; PaletteLatchNew

; 90   :                
; 91   :         
; 92   :         uint16 NametableAddress = 0x2000 | (Ppu->VRamIO.VRamAdrs & 0x0FFF);

  00084	48 8b 44 24 40	 mov	 rax, QWORD PTR Ppu$[rsp]
  00089	0f b7 80 74 12
	00 00		 movzx	 eax, WORD PTR [rax+4724]
  00090	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00095	0f ba e8 0d	 bts	 eax, 13
  00099	66 89 44 24 24	 mov	 WORD PTR NametableAddress$2[rsp], ax

; 93   :         NextNametableAdrs = readPpu8(NametableAddress, Ppu) << 4;

  0009e	48 8b 54 24 40	 mov	 rdx, QWORD PTR Ppu$[rsp]
  000a3	0f b7 4c 24 24	 movzx	 ecx, WORD PTR NametableAddress$2[rsp]
  000a8	e8 00 00 00 00	 call	 ?readPpu8@@YAEGPEAUppu@@@Z ; readPpu8
  000ad	0f b6 c0	 movzx	 eax, al
  000b0	c1 e0 04	 shl	 eax, 4
  000b3	66 89 05 00 00
	00 00		 mov	 WORD PTR ?NextNametableAdrs@@3GA, ax ; NextNametableAdrs

; 94   :         NextNametableAdrs += Ppu->BGPatternBase;

  000ba	48 8b 44 24 40	 mov	 rax, QWORD PTR Ppu$[rsp]
  000bf	0f b7 80 1c 10
	00 00		 movzx	 eax, WORD PTR [rax+4124]
  000c6	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?NextNametableAdrs@@3GA ; NextNametableAdrs
  000cd	03 c8		 add	 ecx, eax
  000cf	8b c1		 mov	 eax, ecx
  000d1	66 89 05 00 00
	00 00		 mov	 WORD PTR ?NextNametableAdrs@@3GA, ax ; NextNametableAdrs
$LN2@loadFuture:

; 95   :     }
; 96   :     if(Cycle == 2)

  000d8	0f b6 44 24 20	 movzx	 eax, BYTE PTR Cycle$[rsp]
  000dd	83 f8 02	 cmp	 eax, 2
  000e0	0f 85 9a 00 00
	00		 jne	 $LN3@loadFuture

; 97   :     {
; 98   :         uint16 AtrbAddress = 0x23C0 | (Ppu->VRamIO.VRamAdrs & 0x0C00) |
; 99   :             ((Ppu->VRamIO.VRamAdrs >> 4) & 0x38) | ((Ppu->VRamIO.VRamAdrs >> 2) & 0x07);   

  000e6	48 8b 44 24 40	 mov	 rax, QWORD PTR Ppu$[rsp]
  000eb	0f b7 80 74 12
	00 00		 movzx	 eax, WORD PTR [rax+4724]
  000f2	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  000f7	0d c0 23 00 00	 or	 eax, 9152		; 000023c0H
  000fc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00101	0f b7 89 74 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4724]
  00108	c1 f9 04	 sar	 ecx, 4
  0010b	83 e1 38	 and	 ecx, 56			; 00000038H
  0010e	0b c1		 or	 eax, ecx
  00110	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00115	0f b7 89 74 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4724]
  0011c	c1 f9 02	 sar	 ecx, 2
  0011f	83 e1 07	 and	 ecx, 7
  00122	0b c1		 or	 eax, ecx
  00124	66 89 44 24 28	 mov	 WORD PTR AtrbAddress$3[rsp], ax

; 100  :         uint8 Atrb = readPpu8(AtrbAddress, Ppu);

  00129	48 8b 54 24 40	 mov	 rdx, QWORD PTR Ppu$[rsp]
  0012e	0f b7 4c 24 28	 movzx	 ecx, WORD PTR AtrbAddress$3[rsp]
  00133	e8 00 00 00 00	 call	 ?readPpu8@@YAEGPEAUppu@@@Z ; readPpu8
  00138	88 44 24 21	 mov	 BYTE PTR Atrb$1[rsp], al

; 101  :         int quadrantSelect = ((Ppu->VRamIO.VRamAdrs & 2) >> 1) | ((Ppu->VRamIO.VRamAdrs & 0x40) >> 5);

  0013c	48 8b 44 24 40	 mov	 rax, QWORD PTR Ppu$[rsp]
  00141	0f b7 80 74 12
	00 00		 movzx	 eax, WORD PTR [rax+4724]
  00148	83 e0 02	 and	 eax, 2
  0014b	d1 f8		 sar	 eax, 1
  0014d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00152	0f b7 89 74 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4724]
  00159	83 e1 40	 and	 ecx, 64			; 00000040H
  0015c	c1 f9 05	 sar	 ecx, 5
  0015f	0b c1		 or	 eax, ecx
  00161	89 44 24 2c	 mov	 DWORD PTR quadrantSelect$4[rsp], eax

; 102  :         
; 103  :         NextAtrbByte = ((0xFF & Atrb) >> (quadrantSelect*2)) & 3;       

  00165	0f b6 44 24 21	 movzx	 eax, BYTE PTR Atrb$1[rsp]
  0016a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0016f	8b 4c 24 2c	 mov	 ecx, DWORD PTR quadrantSelect$4[rsp]
  00173	d1 e1		 shl	 ecx, 1
  00175	d3 f8		 sar	 eax, cl
  00177	83 e0 03	 and	 eax, 3
  0017a	88 05 00 00 00
	00		 mov	 BYTE PTR ?NextAtrbByte@@3EA, al ; NextAtrbByte
$LN3@loadFuture:

; 104  :     }   
; 105  :     if(Cycle == 4)

  00180	0f b6 44 24 20	 movzx	 eax, BYTE PTR Cycle$[rsp]
  00185	83 f8 04	 cmp	 eax, 4
  00188	75 3c		 jne	 SHORT $LN4@loadFuture

; 106  :     {        
; 107  :         NextNametableAdrs = NextNametableAdrs + ((Ppu->VRamIO.VRamAdrs & 0x7000) >> 12);

  0018a	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?NextNametableAdrs@@3GA ; NextNametableAdrs
  00191	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00196	0f b7 89 74 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4724]
  0019d	81 e1 00 70 00
	00		 and	 ecx, 28672		; 00007000H
  001a3	c1 f9 0c	 sar	 ecx, 12
  001a6	03 c1		 add	 eax, ecx
  001a8	66 89 05 00 00
	00 00		 mov	 WORD PTR ?NextNametableAdrs@@3GA, ax ; NextNametableAdrs

; 108  :         NextLowPattern = readPpu8(NextNametableAdrs, Ppu);

  001af	48 8b 54 24 40	 mov	 rdx, QWORD PTR Ppu$[rsp]
  001b4	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?NextNametableAdrs@@3GA ; NextNametableAdrs
  001bb	e8 00 00 00 00	 call	 ?readPpu8@@YAEGPEAUppu@@@Z ; readPpu8
  001c0	88 05 00 00 00
	00		 mov	 BYTE PTR ?NextLowPattern@@3EA, al ; NextLowPattern
$LN4@loadFuture:

; 109  :     }
; 110  :     if(Cycle == 6)

  001c6	0f b6 44 24 20	 movzx	 eax, BYTE PTR Cycle$[rsp]
  001cb	83 f8 06	 cmp	 eax, 6
  001ce	75 1d		 jne	 SHORT $LN5@loadFuture

; 111  :     {
; 112  :         NextHighPattern = readPpu8(NextNametableAdrs+8, Ppu);

  001d0	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?NextNametableAdrs@@3GA ; NextNametableAdrs
  001d7	83 c0 08	 add	 eax, 8
  001da	48 8b 54 24 40	 mov	 rdx, QWORD PTR Ppu$[rsp]
  001df	0f b7 c8	 movzx	 ecx, ax
  001e2	e8 00 00 00 00	 call	 ?readPpu8@@YAEGPEAUppu@@@Z ; readPpu8
  001e7	88 05 00 00 00
	00		 mov	 BYTE PTR ?NextHighPattern@@3EA, al ; NextHighPattern
$LN5@loadFuture:

; 113  :     }           
; 114  :     if(Cycle == 7)

  001ed	0f b6 44 24 20	 movzx	 eax, BYTE PTR Cycle$[rsp]
  001f2	83 f8 07	 cmp	 eax, 7
  001f5	75 3b		 jne	 SHORT $LN6@loadFuture

; 115  :     {
; 116  :         if(Ppu->ScanlineCycle == 256)

  001f7	48 8b 44 24 40	 mov	 rax, QWORD PTR Ppu$[rsp]
  001fc	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  00203	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00208	75 15		 jne	 SHORT $LN7@loadFuture

; 117  :         {
; 118  :             scrollIncVert(&Ppu->VRamIO);

  0020a	48 8b 44 24 40	 mov	 rax, QWORD PTR Ppu$[rsp]
  0020f	48 05 74 12 00
	00		 add	 rax, 4724		; 00001274H
  00215	48 8b c8	 mov	 rcx, rax
  00218	e8 00 00 00 00	 call	 ?scrollIncVert@@YAXPEAUvram_io@@@Z ; scrollIncVert

; 119  :         }
; 120  :         else

  0021d	eb 13		 jmp	 SHORT $LN8@loadFuture
$LN7@loadFuture:

; 121  :         {
; 122  :             scrollIncHorz(&Ppu->VRamIO);               

  0021f	48 8b 44 24 40	 mov	 rax, QWORD PTR Ppu$[rsp]
  00224	48 05 74 12 00
	00		 add	 rax, 4724		; 00001274H
  0022a	48 8b c8	 mov	 rcx, rax
  0022d	e8 00 00 00 00	 call	 ?scrollIncHorz@@YAXPEAUvram_io@@@Z ; scrollIncHorz
$LN8@loadFuture:
$LN6@loadFuture:

; 123  :         }
; 124  :     }
; 125  : }

  00232	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00236	c3		 ret	 0
?loadFutureData@@YAXPEAUppu@@@Z ENDP			; loadFutureData
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
y$1 = 0
Vram$ = 32
?scrollIncVert@@YAXPEAUvram_io@@@Z PROC			; scrollIncVert

; 52   : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 53   :     // NOTE: Code take from nesdev wiki. Could be quicker??
; 54   :     if ((Vram->VRamAdrs & 0x7000) != 0x7000) // if fine Y < 7

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR Vram$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	25 00 70 00 00	 and	 eax, 28672		; 00007000H
  00016	3d 00 70 00 00	 cmp	 eax, 28672		; 00007000H
  0001b	74 1a		 je	 SHORT $LN2@scrollIncV

; 55   :     {
; 56   :         Vram->VRamAdrs += 0x1000; // increment fine Y

  0001d	48 8b 44 24 20	 mov	 rax, QWORD PTR Vram$[rsp]
  00022	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00025	05 00 10 00 00	 add	 eax, 4096		; 00001000H
  0002a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Vram$[rsp]
  0002f	66 89 01	 mov	 WORD PTR [rcx], ax

; 57   :     }
; 58   :     else

  00032	e9 87 00 00 00	 jmp	 $LN3@scrollIncV
$LN2@scrollIncV:

; 59   :     {
; 60   :         Vram->VRamAdrs &= ~0x7000; // fine Y = 0        

  00037	48 8b 44 24 20	 mov	 rax, QWORD PTR Vram$[rsp]
  0003c	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0003f	25 ff 8f ff ff	 and	 eax, -28673		; ffffffffffff8fffH
  00044	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Vram$[rsp]
  00049	66 89 01	 mov	 WORD PTR [rcx], ax

; 61   :         uint16 y = (Vram->VRamAdrs & 0x03E0) >> 5 ; // let y = coarse Y

  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR Vram$[rsp]
  00051	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00054	25 e0 03 00 00	 and	 eax, 992		; 000003e0H
  00059	c1 f8 05	 sar	 eax, 5
  0005c	66 89 04 24	 mov	 WORD PTR y$1[rsp], ax

; 62   :     
; 63   :         if (y == 29)

  00060	0f b7 04 24	 movzx	 eax, WORD PTR y$1[rsp]
  00064	83 f8 1d	 cmp	 eax, 29
  00067	75 1c		 jne	 SHORT $LN4@scrollIncV

; 64   :         {
; 65   :             y = 0; // coarse Y = 0

  00069	33 c0		 xor	 eax, eax
  0006b	66 89 04 24	 mov	 WORD PTR y$1[rsp], ax

; 66   :             Vram->VRamAdrs ^= 0x0800; // switch vertical nametable

  0006f	48 8b 44 24 20	 mov	 rax, QWORD PTR Vram$[rsp]
  00074	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00077	0f ba f8 0b	 btc	 eax, 11
  0007b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Vram$[rsp]
  00080	66 89 01	 mov	 WORD PTR [rcx], ax
  00083	eb 1b		 jmp	 SHORT $LN5@scrollIncV
$LN4@scrollIncV:

; 67   :         }
; 68   :         else if (y == 31)

  00085	0f b7 04 24	 movzx	 eax, WORD PTR y$1[rsp]
  00089	83 f8 1f	 cmp	 eax, 31
  0008c	75 08		 jne	 SHORT $LN6@scrollIncV

; 69   :         {
; 70   :             y = 0; // coarse Y = 0, nametable not switched

  0008e	33 c0		 xor	 eax, eax
  00090	66 89 04 24	 mov	 WORD PTR y$1[rsp], ax

; 71   :         }
; 72   :         else

  00094	eb 0a		 jmp	 SHORT $LN7@scrollIncV
$LN6@scrollIncV:

; 73   :         {
; 74   :             y += 1; // increment coarse Y

  00096	0f b7 04 24	 movzx	 eax, WORD PTR y$1[rsp]
  0009a	ff c0		 inc	 eax
  0009c	66 89 04 24	 mov	 WORD PTR y$1[rsp], ax
$LN7@scrollIncV:
$LN5@scrollIncV:

; 75   :         }
; 76   :         Vram->VRamAdrs = (Vram->VRamAdrs & ~0x03E0) | (y << 5); // put coarse Y back into v

  000a0	48 8b 44 24 20	 mov	 rax, QWORD PTR Vram$[rsp]
  000a5	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000a8	25 1f fc ff ff	 and	 eax, -993		; fffffffffffffc1fH
  000ad	0f b7 0c 24	 movzx	 ecx, WORD PTR y$1[rsp]
  000b1	c1 e1 05	 shl	 ecx, 5
  000b4	0b c1		 or	 eax, ecx
  000b6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Vram$[rsp]
  000bb	66 89 01	 mov	 WORD PTR [rcx], ax
$LN3@scrollIncV:

; 77   :     }
; 78   : }

  000be	48 83 c4 18	 add	 rsp, 24
  000c2	c3		 ret	 0
?scrollIncVert@@YAXPEAUvram_io@@@Z ENDP			; scrollIncVert
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
Vram$ = 8
?scrollIncHorz@@YAXPEAUvram_io@@@Z PROC			; scrollIncHorz

; 40   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 41   :     //NOTE: Code take from nesdev wiki. Could be quicker??
; 42   :     if ((Vram->VRamAdrs & 0x001F) == 31) // if coarse X == 31

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Vram$[rsp]
  0000a	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0000d	83 e0 1f	 and	 eax, 31
  00010	83 f8 1f	 cmp	 eax, 31
  00013	75 29		 jne	 SHORT $LN2@scrollIncH

; 43   :     {
; 44   :         Vram->VRamAdrs &= ~0x001F;  // coarse X = 0

  00015	48 8b 44 24 08	 mov	 rax, QWORD PTR Vram$[rsp]
  0001a	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0001d	83 e0 e0	 and	 eax, -32		; ffffffffffffffe0H
  00020	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Vram$[rsp]
  00025	66 89 01	 mov	 WORD PTR [rcx], ax

; 45   :         Vram->VRamAdrs ^= 0x0400;   // switch horizontal nametable

  00028	48 8b 44 24 08	 mov	 rax, QWORD PTR Vram$[rsp]
  0002d	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00030	0f ba f8 0a	 btc	 eax, 10
  00034	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Vram$[rsp]
  00039	66 89 01	 mov	 WORD PTR [rcx], ax

; 46   :     }
; 47   :     else

  0003c	eb 12		 jmp	 SHORT $LN3@scrollIncH
$LN2@scrollIncH:

; 48   :         Vram->VRamAdrs += 1;                // increment coarse X

  0003e	48 8b 44 24 08	 mov	 rax, QWORD PTR Vram$[rsp]
  00043	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00046	ff c0		 inc	 eax
  00048	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Vram$[rsp]
  0004d	66 89 01	 mov	 WORD PTR [rcx], ax
$LN3@scrollIncH:

; 49   : }

  00050	c3		 ret	 0
?scrollIncHorz@@YAXPEAUvram_io@@@Z ENDP			; scrollIncHorz
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
VRamIO$ = 8
?resetScrollVert@@YAXPEAUvram_io@@@Z PROC		; resetScrollVert

; 35   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 36   :     VRamIO->VRamAdrs = VRamIO->TempVRamAdrs;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR VRamIO$[rsp]
  0000a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR VRamIO$[rsp]
  0000f	0f b7 49 02	 movzx	 ecx, WORD PTR [rcx+2]
  00013	66 89 08	 mov	 WORD PTR [rax], cx

; 37   : }

  00016	c3		 ret	 0
?resetScrollVert@@YAXPEAUvram_io@@@Z ENDP		; resetScrollVert
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
VRamIO$ = 8
?resetScrollHorz@@YAXPEAUvram_io@@@Z PROC		; resetScrollHorz

; 29   : {   

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 30   :     VRamIO->VRamAdrs &= ~(0x041F);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR VRamIO$[rsp]
  0000a	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0000d	25 e0 fb ff ff	 and	 eax, -1056		; fffffffffffffbe0H
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR VRamIO$[rsp]
  00017	66 89 01	 mov	 WORD PTR [rcx], ax

; 31   :     VRamIO->VRamAdrs |= (VRamIO->TempVRamAdrs & 0x041F);

  0001a	48 8b 44 24 08	 mov	 rax, QWORD PTR VRamIO$[rsp]
  0001f	0f b7 40 02	 movzx	 eax, WORD PTR [rax+2]
  00023	25 1f 04 00 00	 and	 eax, 1055		; 0000041fH
  00028	48 8b 4c 24 08	 mov	 rcx, QWORD PTR VRamIO$[rsp]
  0002d	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  00030	0b c8		 or	 ecx, eax
  00032	8b c1		 mov	 eax, ecx
  00034	48 8b 4c 24 08	 mov	 rcx, QWORD PTR VRamIO$[rsp]
  00039	66 89 01	 mov	 WORD PTR [rcx], ax

; 32   : }

  0003c	c3		 ret	 0
?resetScrollHorz@@YAXPEAUvram_io@@@Z ENDP		; resetScrollHorz
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
CurrentPixel$ = 0
Ppu$ = 32
X$ = 40
Y$ = 48
Colour$ = 56
?drawPixel@@YAXPEAUppu@@GGPEAE@Z PROC			; drawPixel

; 13   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000b	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	48 83 ec 18	 sub	 rsp, 24

; 14   :     uint32 *CurrentPixel = (Ppu->BasePixel + (Y * PIXEL_WIDTH)) + X;

  00019	0f b7 44 24 30	 movzx	 eax, WORD PTR Y$[rsp]
  0001e	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  00024	48 98		 cdqe
  00026	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0002b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0002f	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  00033	0f b7 4c 24 28	 movzx	 ecx, WORD PTR X$[rsp]
  00038	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  0003c	48 89 04 24	 mov	 QWORD PTR CurrentPixel$[rsp], rax

; 15   :     *CurrentPixel  = ((Colour[0] << 16) | (Colour[1] << 8) | Colour[2]);

  00040	b8 01 00 00 00	 mov	 eax, 1
  00045	48 6b c0 00	 imul	 rax, rax, 0
  00049	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Colour$[rsp]
  0004e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00052	c1 e0 10	 shl	 eax, 16
  00055	b9 01 00 00 00	 mov	 ecx, 1
  0005a	48 6b c9 01	 imul	 rcx, rcx, 1
  0005e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Colour$[rsp]
  00063	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00067	c1 e1 08	 shl	 ecx, 8
  0006a	0b c1		 or	 eax, ecx
  0006c	b9 01 00 00 00	 mov	 ecx, 1
  00071	48 6b c9 02	 imul	 rcx, rcx, 2
  00075	48 8b 54 24 38	 mov	 rdx, QWORD PTR Colour$[rsp]
  0007a	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0007e	0b c1		 or	 eax, ecx
  00080	48 8b 0c 24	 mov	 rcx, QWORD PTR CurrentPixel$[rsp]
  00084	89 01		 mov	 DWORD PTR [rcx], eax

; 16   : }

  00086	48 83 c4 18	 add	 rsp, 24
  0008a	c3		 ret	 0
?drawPixel@@YAXPEAUppu@@GGPEAE@Z ENDP			; drawPixel
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\palette.cpp
_TEXT	SEGMENT
Entry$ = 8
Colour$ = 16
?getPaletteValue@@YAXEPEAE@Z PROC			; getPaletteValue

; 31   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 32   :     Colour[0] = Palette[Entry][0];

  00009	0f b6 44 24 08	 movzx	 eax, BYTE PTR Entry$[rsp]
  0000e	48 6b c0 03	 imul	 rax, rax, 3
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Palette@@3PAY02EA ; Palette
  00019	48 03 c8	 add	 rcx, rax
  0001c	48 8b c1	 mov	 rax, rcx
  0001f	b9 01 00 00 00	 mov	 ecx, 1
  00024	48 6b c9 00	 imul	 rcx, rcx, 0
  00028	ba 01 00 00 00	 mov	 edx, 1
  0002d	48 6b d2 00	 imul	 rdx, rdx, 0
  00031	4c 8b 44 24 10	 mov	 r8, QWORD PTR Colour$[rsp]
  00036	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0003a	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 33   :     Colour[1] = Palette[Entry][1];

  0003e	0f b6 44 24 08	 movzx	 eax, BYTE PTR Entry$[rsp]
  00043	48 6b c0 03	 imul	 rax, rax, 3
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Palette@@3PAY02EA ; Palette
  0004e	48 03 c8	 add	 rcx, rax
  00051	48 8b c1	 mov	 rax, rcx
  00054	b9 01 00 00 00	 mov	 ecx, 1
  00059	48 6b c9 01	 imul	 rcx, rcx, 1
  0005d	ba 01 00 00 00	 mov	 edx, 1
  00062	48 6b d2 01	 imul	 rdx, rdx, 1
  00066	4c 8b 44 24 10	 mov	 r8, QWORD PTR Colour$[rsp]
  0006b	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0006f	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 34   :     Colour[2]  = Palette[Entry][2];

  00073	0f b6 44 24 08	 movzx	 eax, BYTE PTR Entry$[rsp]
  00078	48 6b c0 03	 imul	 rax, rax, 3
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Palette@@3PAY02EA ; Palette
  00083	48 03 c8	 add	 rcx, rax
  00086	48 8b c1	 mov	 rax, rcx
  00089	b9 01 00 00 00	 mov	 ecx, 1
  0008e	48 6b c9 02	 imul	 rcx, rcx, 2
  00092	ba 01 00 00 00	 mov	 edx, 1
  00097	48 6b d2 02	 imul	 rdx, rdx, 2
  0009b	4c 8b 44 24 10	 mov	 r8, QWORD PTR Colour$[rsp]
  000a0	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000a4	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 35   : }

  000a8	c3		 ret	 0
?getPaletteValue@@YAXEPEAE@Z ENDP			; getPaletteValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\memory.cpp
_TEXT	SEGMENT
Byte$ = 48
Address$ = 56
Ppu$ = 64
?writePpu8@@YAXEGPEAUppu@@@Z PROC			; writePpu8

; 286  : {    

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 287  :     Address = ppuMemoryMirror(Address);

  00012	0f b7 4c 24 38	 movzx	 ecx, WORD PTR Address$[rsp]
  00017	e8 00 00 00 00	 call	 ?ppuMemoryMirror@@YAGG@Z ; ppuMemoryMirror
  0001c	66 89 44 24 38	 mov	 WORD PTR Address$[rsp], ax

; 288  : 
; 289  :     if(0x2000 <= Address && Address < 0x3000)

  00021	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00026	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  0002b	7c 22		 jl	 SHORT $LN2@writePpu8
  0002d	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00032	3d 00 30 00 00	 cmp	 eax, 12288		; 00003000H
  00037	7d 16		 jge	 SHORT $LN2@writePpu8

; 290  :     {
; 291  :         writeNametable(Byte, Address, Ppu);

  00039	4c 8b 44 24 40	 mov	 r8, QWORD PTR Ppu$[rsp]
  0003e	0f b7 54 24 38	 movzx	 edx, WORD PTR Address$[rsp]
  00043	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR Byte$[rsp]
  00048	e8 00 00 00 00	 call	 ?writeNametable@@YAXEGPEAUppu@@@Z ; writeNametable

; 292  :     }
; 293  :     else

  0004d	eb 17		 jmp	 SHORT $LN3@writePpu8
$LN2@writePpu8:

; 294  :     {
; 295  :         write8(Byte, Address, Ppu->MemoryBase);

  0004f	48 8b 44 24 40	 mov	 rax, QWORD PTR Ppu$[rsp]
  00054	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00057	0f b7 54 24 38	 movzx	 edx, WORD PTR Address$[rsp]
  0005c	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR Byte$[rsp]
  00061	e8 00 00 00 00	 call	 ?write8@@YAXEG_K@Z	; write8
$LN3@writePpu8:

; 296  :     }
; 297  : }

  00066	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006a	c3		 ret	 0
?writePpu8@@YAXEGPEAUppu@@@Z ENDP			; writePpu8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\memory.cpp
_TEXT	SEGMENT
Result$ = 32
Address$ = 64
Ppu$ = 72
?readPpu8@@YAEGPEAUppu@@@Z PROC				; readPpu8

; 265  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 266  :     uint8 Result;
; 267  :     
; 268  :     Address = ppuMemoryMirror(Address);

  0000e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00013	e8 00 00 00 00	 call	 ?ppuMemoryMirror@@YAGG@Z ; ppuMemoryMirror
  00018	66 89 44 24 40	 mov	 WORD PTR Address$[rsp], ax

; 269  :             
; 270  :     if(Address == 0x3F04 || Address == 0x3F08 || Address == 0x3F0C ||
; 271  :        Address == 0x3F14 || Address == 0x3F18 || Address == 0x3F1C)

  0001d	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00022	3d 04 3f 00 00	 cmp	 eax, 16132		; 00003f04H
  00027	74 3c		 je	 SHORT $LN3@readPpu8
  00029	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0002e	3d 08 3f 00 00	 cmp	 eax, 16136		; 00003f08H
  00033	74 30		 je	 SHORT $LN3@readPpu8
  00035	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0003a	3d 0c 3f 00 00	 cmp	 eax, 16140		; 00003f0cH
  0003f	74 24		 je	 SHORT $LN3@readPpu8
  00041	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00046	3d 14 3f 00 00	 cmp	 eax, 16148		; 00003f14H
  0004b	74 18		 je	 SHORT $LN3@readPpu8
  0004d	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00052	3d 18 3f 00 00	 cmp	 eax, 16152		; 00003f18H
  00057	74 0c		 je	 SHORT $LN3@readPpu8
  00059	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0005e	3d 1c 3f 00 00	 cmp	 eax, 16156		; 00003f1cH
  00063	75 0a		 jne	 SHORT $LN2@readPpu8
$LN3@readPpu8:

; 272  :         Address = 0x3F00;

  00065	b8 00 3f 00 00	 mov	 eax, 16128		; 00003f00H
  0006a	66 89 44 24 40	 mov	 WORD PTR Address$[rsp], ax
$LN2@readPpu8:

; 273  : 
; 274  :     // If address in nametable range. Then map to the current mirror state and return
; 275  :     if(0x2000 <= Address && Address < 0x3000)

  0006f	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00074	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  00079	7c 21		 jl	 SHORT $LN4@readPpu8
  0007b	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00080	3d 00 30 00 00	 cmp	 eax, 12288		; 00003000H
  00085	7d 15		 jge	 SHORT $LN4@readPpu8

; 276  :     {
; 277  :         Result = readNametable(Address, Ppu);

  00087	48 8b 54 24 48	 mov	 rdx, QWORD PTR Ppu$[rsp]
  0008c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00091	e8 00 00 00 00	 call	 ?readNametable@@YAEGPEAUppu@@@Z ; readNametable
  00096	88 44 24 20	 mov	 BYTE PTR Result$[rsp], al

; 278  :     }
; 279  :     else

  0009a	eb 16		 jmp	 SHORT $LN5@readPpu8
$LN4@readPpu8:

; 280  :     {
; 281  :         Result = read8(Address, Ppu->MemoryBase);

  0009c	48 8b 44 24 48	 mov	 rax, QWORD PTR Ppu$[rsp]
  000a1	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  000a4	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  000a9	e8 00 00 00 00	 call	 ?read8@@YAEG_K@Z	; read8
  000ae	88 44 24 20	 mov	 BYTE PTR Result$[rsp], al
$LN5@readPpu8:

; 282  :     }
; 283  :     return(Result);

  000b2	0f b6 44 24 20	 movzx	 eax, BYTE PTR Result$[rsp]

; 284  : }

  000b7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bb	c3		 ret	 0
?readPpu8@@YAEGPEAUppu@@@Z ENDP				; readPpu8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\memory.cpp
_TEXT	SEGMENT
Nametable$ = 32
Byte$ = 64
Address$ = 72
Ppu$ = 80
?writeNametable@@YAXEGPEAUppu@@@Z PROC			; writeNametable

; 259  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 260  :     uint8 *Nametable = getNametableBank(Address, Ppu);

  00012	48 8b 54 24 50	 mov	 rdx, QWORD PTR Ppu$[rsp]
  00017	0f b7 4c 24 48	 movzx	 ecx, WORD PTR Address$[rsp]
  0001c	e8 00 00 00 00	 call	 ?getNametableBank@@YAPEAEGPEAUppu@@@Z ; getNametableBank
  00021	48 89 44 24 20	 mov	 QWORD PTR Nametable$[rsp], rax

; 261  :     Nametable[Address % 0x400] = Byte;;

  00026	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  0002b	99		 cdq
  0002c	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00032	03 c2		 add	 eax, edx
  00034	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00039	2b c2		 sub	 eax, edx
  0003b	48 98		 cdqe
  0003d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Nametable$[rsp]
  00042	0f b6 54 24 40	 movzx	 edx, BYTE PTR Byte$[rsp]
  00047	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 262  : }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
?writeNametable@@YAXEGPEAUppu@@@Z ENDP			; writeNametable
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\memory.cpp
_TEXT	SEGMENT
Result$ = 32
Nametable$ = 40
Address$ = 64
Ppu$ = 72
?readNametable@@YAEGPEAUppu@@@Z PROC			; readNametable

; 249  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 250  :     uint8 Result = 0;

  0000e	c6 44 24 20 00	 mov	 BYTE PTR Result$[rsp], 0

; 251  :     
; 252  :     uint8 *Nametable = getNametableBank(Address, Ppu);

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR Ppu$[rsp]
  00018	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0001d	e8 00 00 00 00	 call	 ?getNametableBank@@YAPEAEGPEAUppu@@@Z ; getNametableBank
  00022	48 89 44 24 28	 mov	 QWORD PTR Nametable$[rsp], rax

; 253  :     Result = Nametable[Address % 0x400];

  00027	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0002c	99		 cdq
  0002d	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00033	03 c2		 add	 eax, edx
  00035	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  0003a	2b c2		 sub	 eax, edx
  0003c	48 98		 cdqe
  0003e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR Nametable$[rsp]
  00043	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00047	88 44 24 20	 mov	 BYTE PTR Result$[rsp], al

; 254  :     
; 255  :     return Result;

  0004b	0f b6 44 24 20	 movzx	 eax, BYTE PTR Result$[rsp]

; 256  : }

  00050	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00054	c3		 ret	 0
?readNametable@@YAEGPEAUppu@@@Z ENDP			; readNametable
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\memory.cpp
_TEXT	SEGMENT
tv65 = 0
Result$ = 8
Address$ = 32
Ppu$ = 40
?getNametableBank@@YAPEAEGPEAUppu@@@Z PROC		; getNametableBank

; 183  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 184  :     uint8 * Result = 0;

  0000e	48 c7 44 24 08
	00 00 00 00	 mov	 QWORD PTR Result$[rsp], 0

; 185  : 
; 186  :     switch(Ppu->MirrorType)

  00017	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  0001c	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0001f	89 04 24	 mov	 DWORD PTR tv65[rsp], eax
  00022	83 3c 24 00	 cmp	 DWORD PTR tv65[rsp], 0
  00026	74 25		 je	 SHORT $LN4@getNametab
  00028	83 3c 24 01	 cmp	 DWORD PTR tv65[rsp], 1
  0002c	74 32		 je	 SHORT $LN5@getNametab
  0002e	83 3c 24 02	 cmp	 DWORD PTR tv65[rsp], 2
  00032	74 41		 je	 SHORT $LN6@getNametab
  00034	83 3c 24 03	 cmp	 DWORD PTR tv65[rsp], 3
  00038	0f 84 80 00 00
	00		 je	 $LN10@getNametab
  0003e	83 3c 24 04	 cmp	 DWORD PTR tv65[rsp], 4
  00042	0f 84 a4 00 00
	00		 je	 $LN13@getNametab
  00048	e9 19 01 00 00	 jmp	 $LN2@getNametab
$LN4@getNametab:

; 187  :     {
; 188  :         case SINGLE_SCREEN_BANK_A:
; 189  :         {
; 190  :             Result = Ppu->NametableBankA;

  0004d	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  00052	48 83 c0 18	 add	 rax, 24
  00056	48 89 44 24 08	 mov	 QWORD PTR Result$[rsp], rax

; 191  :             break;

  0005b	e9 06 01 00 00	 jmp	 $LN2@getNametab
$LN5@getNametab:

; 192  :         }
; 193  :         case SINGLE_SCREEN_BANK_B:
; 194  :         {
; 195  :             Result = Ppu->NametableBankB;

  00060	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  00065	48 05 18 04 00
	00		 add	 rax, 1048		; 00000418H
  0006b	48 89 44 24 08	 mov	 QWORD PTR Result$[rsp], rax

; 196  :             break;

  00070	e9 f1 00 00 00	 jmp	 $LN2@getNametab
$LN6@getNametab:

; 197  :         }
; 198  :         case VERTICAL_MIRROR:
; 199  :         {
; 200  :             if(Address < 0x2400 || (0x2800 <= Address && Address < 0x2C00) )

  00075	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  0007a	3d 00 24 00 00	 cmp	 eax, 9216		; 00002400H
  0007f	7c 18		 jl	 SHORT $LN9@getNametab
  00081	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  00086	3d 00 28 00 00	 cmp	 eax, 10240		; 00002800H
  0008b	7c 1c		 jl	 SHORT $LN7@getNametab
  0008d	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  00092	3d 00 2c 00 00	 cmp	 eax, 11264		; 00002c00H
  00097	7d 10		 jge	 SHORT $LN7@getNametab
$LN9@getNametab:

; 201  :             {
; 202  :                 Result = Ppu->NametableBankA;

  00099	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  0009e	48 83 c0 18	 add	 rax, 24
  000a2	48 89 44 24 08	 mov	 QWORD PTR Result$[rsp], rax

; 203  :             }
; 204  :             else

  000a7	eb 10		 jmp	 SHORT $LN8@getNametab
$LN7@getNametab:

; 205  :             {
; 206  :                 Result = Ppu->NametableBankB;

  000a9	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  000ae	48 05 18 04 00
	00		 add	 rax, 1048		; 00000418H
  000b4	48 89 44 24 08	 mov	 QWORD PTR Result$[rsp], rax
$LN8@getNametab:

; 207  :             }
; 208  :             break;

  000b9	e9 a8 00 00 00	 jmp	 $LN2@getNametab
$LN10@getNametab:

; 209  :         }
; 210  :         case HORIZONTAL_MIRROR:
; 211  :         {
; 212  :             if(Address < 0x2800)

  000be	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  000c3	3d 00 28 00 00	 cmp	 eax, 10240		; 00002800H
  000c8	7d 10		 jge	 SHORT $LN11@getNametab

; 213  :             {
; 214  :                 Result = Ppu->NametableBankA;

  000ca	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  000cf	48 83 c0 18	 add	 rax, 24
  000d3	48 89 44 24 08	 mov	 QWORD PTR Result$[rsp], rax

; 215  :             }
; 216  :             else

  000d8	eb 10		 jmp	 SHORT $LN12@getNametab
$LN11@getNametab:

; 217  :             {
; 218  :                 Result = Ppu->NametableBankB;

  000da	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  000df	48 05 18 04 00
	00		 add	 rax, 1048		; 00000418H
  000e5	48 89 44 24 08	 mov	 QWORD PTR Result$[rsp], rax
$LN12@getNametab:

; 219  :             } 
; 220  :             break;

  000ea	eb 7a		 jmp	 SHORT $LN2@getNametab
$LN13@getNametab:

; 221  :         }
; 222  :         case FOUR_SCREEN_MIRROR:
; 223  :         {
; 224  :             Assert(0);

  000ec	33 c0		 xor	 eax, eax
  000ee	83 f8 01	 cmp	 eax, 1
  000f1	74 0b		 je	 SHORT $LN14@getNametab
  000f3	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN14@getNametab:

; 225  :             if(Address < 0x2400)

  000fe	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  00103	3d 00 24 00 00	 cmp	 eax, 9216		; 00002400H
  00108	7d 10		 jge	 SHORT $LN15@getNametab

; 226  :             {
; 227  :                 Result = Ppu->NametableBankA;

  0010a	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  0010f	48 83 c0 18	 add	 rax, 24
  00113	48 89 44 24 08	 mov	 QWORD PTR Result$[rsp], rax
  00118	eb 4c		 jmp	 SHORT $LN16@getNametab
$LN15@getNametab:

; 228  :             }
; 229  :             else if(Address < 0x2800)

  0011a	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  0011f	3d 00 28 00 00	 cmp	 eax, 10240		; 00002800H
  00124	7d 12		 jge	 SHORT $LN17@getNametab

; 230  :             {
; 231  :                 Result = Ppu->NametableBankB;

  00126	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  0012b	48 05 18 04 00
	00		 add	 rax, 1048		; 00000418H
  00131	48 89 44 24 08	 mov	 QWORD PTR Result$[rsp], rax
  00136	eb 2e		 jmp	 SHORT $LN18@getNametab
$LN17@getNametab:

; 232  :             }
; 233  :             else if(Address < 0x2C00)

  00138	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  0013d	3d 00 2c 00 00	 cmp	 eax, 11264		; 00002c00H
  00142	7d 12		 jge	 SHORT $LN19@getNametab

; 234  :             {
; 235  :                 Result = Ppu->NametableBankC;

  00144	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  00149	48 05 18 08 00
	00		 add	 rax, 2072		; 00000818H
  0014f	48 89 44 24 08	 mov	 QWORD PTR Result$[rsp], rax

; 236  :             }
; 237  :             else

  00154	eb 10		 jmp	 SHORT $LN20@getNametab
$LN19@getNametab:

; 238  :             {
; 239  :                 Result = Ppu->NametableBankD;

  00156	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  0015b	48 05 18 0c 00
	00		 add	 rax, 3096		; 00000c18H
  00161	48 89 44 24 08	 mov	 QWORD PTR Result$[rsp], rax
$LN20@getNametab:
$LN18@getNametab:
$LN16@getNametab:
$LN2@getNametab:

; 240  :             }
; 241  :             break;
; 242  :         }
; 243  :     }
; 244  :     
; 245  :     return Result;

  00166	48 8b 44 24 08	 mov	 rax, QWORD PTR Result$[rsp]

; 246  : }

  0016b	48 83 c4 18	 add	 rsp, 24
  0016f	c3		 ret	 0
?getNametableBank@@YAPEAEGPEAUppu@@@Z ENDP		; getNametableBank
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\memory.cpp
_TEXT	SEGMENT
BtnValue$1 = 32
Bit0$2 = 33
Reg1Value$3 = 34
Reg2Value$4 = 35
Byte$ = 64
Address$ = 72
Cpu$ = 80
?writeCpu8@@YAXEGPEAUcpu@@@Z PROC			; writeCpu8

; 133  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 134  :     Address = cpuMemoryMirror(Address);

  00012	0f b7 4c 24 48	 movzx	 ecx, WORD PTR Address$[rsp]
  00017	e8 00 00 00 00	 call	 ?cpuMemoryMirror@@YAGG@Z ; cpuMemoryMirror
  0001c	66 89 44 24 48	 mov	 WORD PTR Address$[rsp], ax

; 135  : 
; 136  : 
; 137  :     if((0x2000 <= Address && Address < 0x2008) ||

  00021	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  00026	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  0002b	7c 0c		 jl	 SHORT $LN4@writeCpu8
  0002d	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  00032	3d 08 20 00 00	 cmp	 eax, 8200		; 00002008H
  00037	7c 0c		 jl	 SHORT $LN3@writeCpu8
$LN4@writeCpu8:
  00039	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  0003e	3d 14 40 00 00	 cmp	 eax, 16404		; 00004014H
  00043	75 0f		 jne	 SHORT $LN2@writeCpu8
$LN3@writeCpu8:

; 138  :        (Address == 0x4014))
; 139  :     {
; 140  :         writePpuRegister(Byte, Address);

  00045	0f b7 54 24 48	 movzx	 edx, WORD PTR Address$[rsp]
  0004a	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR Byte$[rsp]
  0004f	e8 00 00 00 00	 call	 ?writePpuRegister@@YAXEG@Z ; writePpuRegister
$LN2@writeCpu8:

; 141  :     }
; 142  :     
; 143  :     write8(Byte, Address, Cpu->MemoryBase);

  00054	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  00059	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  0005d	0f b7 54 24 48	 movzx	 edx, WORD PTR Address$[rsp]
  00062	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR Byte$[rsp]
  00067	e8 00 00 00 00	 call	 ?write8@@YAXEG_K@Z	; write8

; 144  :     
; 145  :     // Input
; 146  :     if(Address == 0x4016 || Address == 0x4017)

  0006c	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  00071	3d 16 40 00 00	 cmp	 eax, 16406		; 00004016H
  00076	74 10		 je	 SHORT $LN6@writeCpu8
  00078	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  0007d	3d 17 40 00 00	 cmp	 eax, 16407		; 00004017H
  00082	0f 85 e9 00 00
	00		 jne	 $LN5@writeCpu8
$LN6@writeCpu8:

; 147  :     {
; 148  :         uint8 Reg1Value = read8(0x4016, Cpu->MemoryBase);

  00088	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  0008d	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00091	66 b9 16 40	 mov	 cx, 16406		; 00004016H
  00095	e8 00 00 00 00	 call	 ?read8@@YAEG_K@Z	; read8
  0009a	88 44 24 22	 mov	 BYTE PTR Reg1Value$3[rsp], al

; 149  :         uint8 Reg2Value = read8(0x4017, Cpu->MemoryBase);

  0009e	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  000a3	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000a7	66 b9 17 40	 mov	 cx, 16407		; 00004017H
  000ab	e8 00 00 00 00	 call	 ?read8@@YAEG_K@Z	; read8
  000b0	88 44 24 23	 mov	 BYTE PTR Reg2Value$4[rsp], al

; 150  : 
; 151  :         uint8 Bit0 = (Reg1Value | Reg2Value) & 1;

  000b4	0f b6 44 24 22	 movzx	 eax, BYTE PTR Reg1Value$3[rsp]
  000b9	0f b6 4c 24 23	 movzx	 ecx, BYTE PTR Reg2Value$4[rsp]
  000be	0b c1		 or	 eax, ecx
  000c0	83 e0 01	 and	 eax, 1
  000c3	88 44 24 21	 mov	 BYTE PTR Bit0$2[rsp], al

; 152  : 
; 153  :         if(Bit0 == 0)

  000c7	0f b6 44 24 21	 movzx	 eax, BYTE PTR Bit0$2[rsp]
  000cc	85 c0		 test	 eax, eax
  000ce	75 2b		 jne	 SHORT $LN7@writeCpu8

; 154  :         {
; 155  :             if(Cpu->PadStrobe)

  000d0	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  000d5	83 78 1c 00	 cmp	 DWORD PTR [rax+28], 0
  000d9	74 12		 je	 SHORT $LN9@writeCpu8

; 156  :             {
; 157  :                 Cpu->Pad1CurrentButton = Cpu->Pad2CurrentButton = input::B_A;

  000db	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  000e0	c6 40 64 00	 mov	 BYTE PTR [rax+100], 0
  000e4	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  000e9	c6 40 40 00	 mov	 BYTE PTR [rax+64], 0
$LN9@writeCpu8:

; 158  :             }
; 159  :             Cpu->PadStrobe = false;

  000ed	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  000f2	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0
  000f9	eb 16		 jmp	 SHORT $LN8@writeCpu8
$LN7@writeCpu8:

; 160  :         }
; 161  :         else if(Bit0 == 1)

  000fb	0f b6 44 24 21	 movzx	 eax, BYTE PTR Bit0$2[rsp]
  00100	83 f8 01	 cmp	 eax, 1
  00103	75 0c		 jne	 SHORT $LN10@writeCpu8

; 162  :         {
; 163  :             Cpu->PadStrobe = true;

  00105	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  0010a	c7 40 1c 01 00
	00 00		 mov	 DWORD PTR [rax+28], 1
$LN10@writeCpu8:
$LN8@writeCpu8:

; 164  :         }        
; 165  : 
; 166  :         uint8 BtnValue = Cpu->InputPad1.buttons[Cpu->Pad1CurrentButton] & 1;

  00111	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  00116	0f b6 40 40	 movzx	 eax, BYTE PTR [rax+64]
  0011a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0011f	8b 44 81 20	 mov	 eax, DWORD PTR [rcx+rax*4+32]
  00123	83 e0 01	 and	 eax, 1
  00126	88 44 24 20	 mov	 BYTE PTR BtnValue$1[rsp], al

; 167  :         write8(BtnValue, 0x4016, Cpu->MemoryBase);

  0012a	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  0012f	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00133	66 ba 16 40	 mov	 dx, 16406		; 00004016H
  00137	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR BtnValue$1[rsp]
  0013c	e8 00 00 00 00	 call	 ?write8@@YAXEG_K@Z	; write8

; 168  : 
; 169  :         BtnValue = Cpu->InputPad2.buttons[Cpu->Pad2CurrentButton] & 1;

  00141	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  00146	0f b6 40 64	 movzx	 eax, BYTE PTR [rax+100]
  0014a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0014f	8b 44 81 44	 mov	 eax, DWORD PTR [rcx+rax*4+68]
  00153	83 e0 01	 and	 eax, 1
  00156	88 44 24 20	 mov	 BYTE PTR BtnValue$1[rsp], al

; 170  :         write8(BtnValue, 0x4017, Cpu->MemoryBase);

  0015a	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  0015f	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00163	66 ba 17 40	 mov	 dx, 16407		; 00004017H
  00167	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR BtnValue$1[rsp]
  0016c	e8 00 00 00 00	 call	 ?write8@@YAXEG_K@Z	; write8
$LN5@writeCpu8:

; 171  :     }
; 172  : 
; 173  :     // Mapper
; 174  :     if(Address >= 0x8000)

  00171	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  00176	3d 00 80 00 00	 cmp	 eax, 32768		; 00008000H
  0017b	7c 27		 jl	 SHORT $LN11@writeCpu8

; 175  :     {
; 176  :         Cpu->MapperWrite = true;

  0017d	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  00182	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [rax+20], 1

; 177  :         Cpu->MapperReg = Byte;

  00189	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  0018e	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR Byte$[rsp]
  00193	88 48 10	 mov	 BYTE PTR [rax+16], cl

; 178  :         Cpu->MapperWriteAddress = Address;

  00196	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  0019b	0f b7 4c 24 48	 movzx	 ecx, WORD PTR Address$[rsp]
  001a0	66 89 48 12	 mov	 WORD PTR [rax+18], cx
$LN11@writeCpu8:

; 179  :     }
; 180  : }

  001a4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001a8	c3		 ret	 0
?writeCpu8@@YAXEGPEAUcpu@@@Z ENDP			; writeCpu8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\memory.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
Byte2Adrs$ = 36
NewAddress$ = 40
Address$ = 64
Cpu$ = 72
?bugReadCpu16@@YAGGPEAUcpu@@@Z PROC			; bugReadCpu16

; 120  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 121  :     // NOTE: This is a bug in the nes 6502 that will wrap the value instead of going to new page.
; 122  :     //       Only happens with indirect addressing.
; 123  :     
; 124  :     uint8 LowByte = readCpu8(Address, Cpu);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00013	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00018	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  0001d	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 125  :     uint16 Byte2Adrs = (Address & 0xFF00) | (uint16)((uint8)(Address + 1));

  00021	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00026	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  0002b	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00030	ff c1		 inc	 ecx
  00032	0f b6 c9	 movzx	 ecx, cl
  00035	0b c1		 or	 eax, ecx
  00037	66 89 44 24 24	 mov	 WORD PTR Byte2Adrs$[rsp], ax

; 126  :     uint8 HighByte = readCpu8(Byte2Adrs, Cpu);

  0003c	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00041	0f b7 4c 24 24	 movzx	 ecx, WORD PTR Byte2Adrs$[rsp]
  00046	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  0004b	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 127  :         
; 128  :     uint16 NewAddress = (HighByte << 8) | LowByte;

  0004f	0f b6 44 24 20	 movzx	 eax, BYTE PTR HighByte$[rsp]
  00054	c1 e0 08	 shl	 eax, 8
  00057	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  0005c	0b c1		 or	 eax, ecx
  0005e	66 89 44 24 28	 mov	 WORD PTR NewAddress$[rsp], ax

; 129  :     return(NewAddress);

  00063	0f b7 44 24 28	 movzx	 eax, WORD PTR NewAddress$[rsp]

; 130  : }

  00068	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006c	c3		 ret	 0
?bugReadCpu16@@YAGGPEAUcpu@@@Z ENDP			; bugReadCpu16
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\memory.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
NewAddress$ = 36
Address$ = 64
Cpu$ = 72
?readCpu16@@YAGGPEAUcpu@@@Z PROC			; readCpu16

; 110  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 111  :     // NOTE: Little Endian
; 112  :     uint8 LowByte = readCpu8(Address, Cpu);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00013	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00018	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  0001d	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 113  :     uint8 HighByte = readCpu8(Address+1, Cpu);

  00021	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00026	ff c0		 inc	 eax
  00028	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0002d	0f b7 c8	 movzx	 ecx, ax
  00030	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00035	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 114  :         
; 115  :     uint16 NewAddress = (HighByte << 8) | LowByte;

  00039	0f b6 44 24 20	 movzx	 eax, BYTE PTR HighByte$[rsp]
  0003e	c1 e0 08	 shl	 eax, 8
  00041	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  00046	0b c1		 or	 eax, ecx
  00048	66 89 44 24 24	 mov	 WORD PTR NewAddress$[rsp], ax

; 116  :     return(NewAddress);

  0004d	0f b7 44 24 24	 movzx	 eax, WORD PTR NewAddress$[rsp]

; 117  : }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
?readCpu16@@YAGGPEAUcpu@@@Z ENDP			; readCpu16
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\memory.cpp
_TEXT	SEGMENT
tv89 = 32
tv93 = 33
BtnValue$1 = 34
CurrentValue$2 = 35
NewValue$3 = 36
Value$ = 37
InputAddress$4 = 40
Address$ = 64
Cpu$ = 72
?readCpu8@@YAEGPEAUcpu@@@Z PROC				; readCpu8

; 64   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 65   :     Address = cpuMemoryMirror(Address);

  0000e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00013	e8 00 00 00 00	 call	 ?cpuMemoryMirror@@YAGG@Z ; cpuMemoryMirror
  00018	66 89 44 24 40	 mov	 WORD PTR Address$[rsp], ax

; 66   :         
; 67   :     if((0x2000 <= Address && Address < 0x2008) ||

  0001d	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00022	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  00027	7c 0c		 jl	 SHORT $LN4@readCpu8
  00029	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0002e	3d 08 20 00 00	 cmp	 eax, 8200		; 00002008H
  00033	7c 0c		 jl	 SHORT $LN3@readCpu8
$LN4@readCpu8:
  00035	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0003a	3d 14 40 00 00	 cmp	 eax, 16404		; 00004014H
  0003f	75 0f		 jne	 SHORT $LN2@readCpu8
$LN3@readCpu8:

; 68   :        (Address == 0x4014))
; 69   :     {
; 70   :         // TODO: Catch up the ppu before we read. Depending on how many cycles has elapsed.
; 71   :         
; 72   :         return readPpuRegister(Address);

  00041	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00046	e8 00 00 00 00	 call	 ?readPpuRegister@@YAEG@Z ; readPpuRegister
  0004b	e9 3b 01 00 00	 jmp	 $LN1@readCpu8
$LN2@readCpu8:

; 73   :     }
; 74   :    
; 75   :     uint8 Value = read8(Address, Cpu->MemoryBase);

  00050	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00055	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00059	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0005e	e8 00 00 00 00	 call	 ?read8@@YAEG_K@Z	; read8
  00063	88 44 24 25	 mov	 BYTE PTR Value$[rsp], al

; 76   :     
; 77   :     // Input
; 78   :     if(Address == 0x4016 || Address == 0x4017)

  00067	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0006c	3d 16 40 00 00	 cmp	 eax, 16406		; 00004016H
  00071	74 10		 je	 SHORT $LN6@readCpu8
  00073	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00078	3d 17 40 00 00	 cmp	 eax, 16407		; 00004017H
  0007d	0f 85 03 01 00
	00		 jne	 $LN5@readCpu8
$LN6@readCpu8:

; 79   :     {
; 80   :         if( !Cpu->PadStrobe )

  00083	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00088	83 78 1c 00	 cmp	 DWORD PTR [rax+28], 0
  0008c	75 60		 jne	 SHORT $LN7@readCpu8

; 81   :         {
; 82   :             if(Address == 0x4016)

  0008e	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00093	3d 16 40 00 00	 cmp	 eax, 16406		; 00004016H
  00098	75 2b		 jne	 SHORT $LN8@readCpu8

; 83   :                 Cpu->Pad1CurrentButton = ++(Cpu->Pad1CurrentButton);

  0009a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0009f	0f b6 40 40	 movzx	 eax, BYTE PTR [rax+64]
  000a3	fe c0		 inc	 al
  000a5	88 44 24 20	 mov	 BYTE PTR tv89[rsp], al
  000a9	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000ae	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR tv89[rsp]
  000b3	88 48 40	 mov	 BYTE PTR [rax+64], cl
  000b6	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000bb	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR tv89[rsp]
  000c0	88 48 40	 mov	 BYTE PTR [rax+64], cl

; 84   :             else

  000c3	eb 29		 jmp	 SHORT $LN9@readCpu8
$LN8@readCpu8:

; 85   :                 Cpu->Pad2CurrentButton = ++(Cpu->Pad2CurrentButton);

  000c5	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000ca	0f b6 40 64	 movzx	 eax, BYTE PTR [rax+100]
  000ce	fe c0		 inc	 al
  000d0	88 44 24 21	 mov	 BYTE PTR tv93[rsp], al
  000d4	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000d9	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR tv93[rsp]
  000de	88 48 64	 mov	 BYTE PTR [rax+100], cl
  000e1	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000e6	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR tv93[rsp]
  000eb	88 48 64	 mov	 BYTE PTR [rax+100], cl
$LN9@readCpu8:
$LN7@readCpu8:

; 86   :         }
; 87   :         
; 88   :         uint16 InputAddress;
; 89   :         uint8 BtnValue;
; 90   :         if(Address == 0x4016)

  000ee	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  000f3	3d 16 40 00 00	 cmp	 eax, 16406		; 00004016H
  000f8	75 25		 jne	 SHORT $LN10@readCpu8

; 91   :         {
; 92   :             InputAddress = 0x4016;

  000fa	b8 16 40 00 00	 mov	 eax, 16406		; 00004016H
  000ff	66 89 44 24 28	 mov	 WORD PTR InputAddress$4[rsp], ax

; 93   :             BtnValue = Cpu->InputPad1.buttons[Cpu->Pad1CurrentButton] & 1;

  00104	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00109	0f b6 40 40	 movzx	 eax, BYTE PTR [rax+64]
  0010d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00112	8b 44 81 20	 mov	 eax, DWORD PTR [rcx+rax*4+32]
  00116	83 e0 01	 and	 eax, 1
  00119	88 44 24 22	 mov	 BYTE PTR BtnValue$1[rsp], al

; 94   :         }
; 95   :         else

  0011d	eb 23		 jmp	 SHORT $LN11@readCpu8
$LN10@readCpu8:

; 96   :         {
; 97   :             InputAddress = 0x4017;

  0011f	b8 17 40 00 00	 mov	 eax, 16407		; 00004017H
  00124	66 89 44 24 28	 mov	 WORD PTR InputAddress$4[rsp], ax

; 98   :             BtnValue = Cpu->InputPad2.buttons[Cpu->Pad2CurrentButton] & 1;

  00129	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0012e	0f b6 40 64	 movzx	 eax, BYTE PTR [rax+100]
  00132	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00137	8b 44 81 44	 mov	 eax, DWORD PTR [rcx+rax*4+68]
  0013b	83 e0 01	 and	 eax, 1
  0013e	88 44 24 22	 mov	 BYTE PTR BtnValue$1[rsp], al
$LN11@readCpu8:

; 99   :         }
; 100  : 
; 101  :         uint8 CurrentValue = read8(InputAddress, Cpu->MemoryBase);

  00142	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00147	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0014b	0f b7 4c 24 28	 movzx	 ecx, WORD PTR InputAddress$4[rsp]
  00150	e8 00 00 00 00	 call	 ?read8@@YAEG_K@Z	; read8
  00155	88 44 24 23	 mov	 BYTE PTR CurrentValue$2[rsp], al

; 102  :         uint8 NewValue = (CurrentValue & 0xFE) | BtnValue;

  00159	0f b6 44 24 23	 movzx	 eax, BYTE PTR CurrentValue$2[rsp]
  0015e	25 fe 00 00 00	 and	 eax, 254		; 000000feH
  00163	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR BtnValue$1[rsp]
  00168	0b c1		 or	 eax, ecx
  0016a	88 44 24 24	 mov	 BYTE PTR NewValue$3[rsp], al

; 103  :         write8(NewValue, InputAddress, Cpu->MemoryBase);

  0016e	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00173	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00177	0f b7 54 24 28	 movzx	 edx, WORD PTR InputAddress$4[rsp]
  0017c	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR NewValue$3[rsp]
  00181	e8 00 00 00 00	 call	 ?write8@@YAXEG_K@Z	; write8
$LN5@readCpu8:

; 104  :     }
; 105  :     
; 106  :     return(Value);

  00186	0f b6 44 24 25	 movzx	 eax, BYTE PTR Value$[rsp]
$LN1@readCpu8:

; 107  : }

  0018b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0018f	c3		 ret	 0
?readCpu8@@YAEGPEAUcpu@@@Z ENDP				; readCpu8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\memory.cpp
_TEXT	SEGMENT
Ppu$ = 0
Address$ = 32
?ppuMemoryMirror@@YAGG@Z PROC				; ppuMemoryMirror

; 35   : {

  00000	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00005	48 83 ec 18	 sub	 rsp, 24

; 36   :     ppu * Ppu = GlobalPpu;

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GlobalPpu@@3PEAUppu@@EA
  00010	48 89 04 24	 mov	 QWORD PTR Ppu$[rsp], rax

; 37   :     
; 38   :     if(Address >= 0x4000) // Over half of the memory map is mirrored

  00014	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  00019	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  0001e	7c 1a		 jl	 SHORT $LN2@ppuMemoryM

; 39   :         Address = Address % 0x4000; 

  00020	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  00025	99		 cdq
  00026	81 e2 ff 3f 00
	00		 and	 edx, 16383		; 00003fffH
  0002c	03 c2		 add	 eax, edx
  0002e	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  00033	2b c2		 sub	 eax, edx
  00035	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax
$LN2@ppuMemoryM:

; 40   : 
; 41   :     if(0x3F20 <= Address && Address < 0x4000)

  0003a	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  0003f	3d 20 3f 00 00	 cmp	 eax, 16160		; 00003f20H
  00044	7c 26		 jl	 SHORT $LN3@ppuMemoryM
  00046	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  0004b	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  00050	7d 1a		 jge	 SHORT $LN3@ppuMemoryM

; 42   :         Address = (Address % 0x20) + 0x3F00;

  00052	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  00057	99		 cdq
  00058	83 e2 1f	 and	 edx, 31
  0005b	03 c2		 add	 eax, edx
  0005d	83 e0 1f	 and	 eax, 31
  00060	2b c2		 sub	 eax, edx
  00062	05 00 3f 00 00	 add	 eax, 16128		; 00003f00H
  00067	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax
$LN3@ppuMemoryM:

; 43   :         
; 44   :     if(0x3F00 <= Address && Address < 0x3F20) // Palette

  0006c	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  00071	3d 00 3f 00 00	 cmp	 eax, 16128		; 00003f00H
  00076	7c 64		 jl	 SHORT $LN4@ppuMemoryM
  00078	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  0007d	3d 20 3f 00 00	 cmp	 eax, 16160		; 00003f20H
  00082	7d 58		 jge	 SHORT $LN4@ppuMemoryM

; 45   :     {
; 46   :         if(Address == 0x3F10)

  00084	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  00089	3d 10 3f 00 00	 cmp	 eax, 16144		; 00003f10H
  0008e	75 0a		 jne	 SHORT $LN5@ppuMemoryM

; 47   :             Address = 0x3F00;

  00090	b8 00 3f 00 00	 mov	 eax, 16128		; 00003f00H
  00095	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax
$LN5@ppuMemoryM:

; 48   :         if(Address == 0x3F14)

  0009a	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  0009f	3d 14 3f 00 00	 cmp	 eax, 16148		; 00003f14H
  000a4	75 0a		 jne	 SHORT $LN6@ppuMemoryM

; 49   :             Address = 0x3F04;

  000a6	b8 04 3f 00 00	 mov	 eax, 16132		; 00003f04H
  000ab	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax
$LN6@ppuMemoryM:

; 50   :         if(Address == 0x3F18)

  000b0	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  000b5	3d 18 3f 00 00	 cmp	 eax, 16152		; 00003f18H
  000ba	75 0a		 jne	 SHORT $LN7@ppuMemoryM

; 51   :             Address = 0x3F08;

  000bc	b8 08 3f 00 00	 mov	 eax, 16136		; 00003f08H
  000c1	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax
$LN7@ppuMemoryM:

; 52   :         if(Address == 0x3F1C)

  000c6	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  000cb	3d 1c 3f 00 00	 cmp	 eax, 16156		; 00003f1cH
  000d0	75 0a		 jne	 SHORT $LN8@ppuMemoryM

; 53   :             Address = 0x3F0C;

  000d2	b8 0c 3f 00 00	 mov	 eax, 16140		; 00003f0cH
  000d7	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax
$LN8@ppuMemoryM:
$LN4@ppuMemoryM:

; 54   :     }
; 55   :    
; 56   :     // NOTE: Nametable Mirroring. Controlled by Cartridge
; 57   :     if(0x3000 <= Address && Address < 0x3F00) // This first as it maps to the nametable range

  000dc	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  000e1	3d 00 30 00 00	 cmp	 eax, 12288		; 00003000H
  000e6	7c 25		 jl	 SHORT $LN9@ppuMemoryM
  000e8	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  000ed	3d 00 3f 00 00	 cmp	 eax, 16128		; 00003f00H
  000f2	7d 19		 jge	 SHORT $LN9@ppuMemoryM

; 58   :         Address = (Address % 0x0F00) + 0x2000;

  000f4	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  000f9	99		 cdq
  000fa	b9 00 0f 00 00	 mov	 ecx, 3840		; 00000f00H
  000ff	f7 f9		 idiv	 ecx
  00101	8b c2		 mov	 eax, edx
  00103	05 00 20 00 00	 add	 eax, 8192		; 00002000H
  00108	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax
$LN9@ppuMemoryM:

; 59   : 
; 60   :     return Address;

  0010d	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]

; 61   : }

  00112	48 83 c4 18	 add	 rsp, 24
  00116	c3		 ret	 0
?ppuMemoryMirror@@YAGG@Z ENDP				; ppuMemoryMirror
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\memory.cpp
_TEXT	SEGMENT
Address$ = 8
?cpuMemoryMirror@@YAGG@Z PROC				; cpuMemoryMirror

; 24   : {

  00000	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 25   :     // NOTE: Mirrors the address for the 2kb ram 
; 26   :     if(0x0800 <= Address && Address < 0x2000)

  00005	0f b7 44 24 08	 movzx	 eax, WORD PTR Address$[rsp]
  0000a	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  0000f	7c 26		 jl	 SHORT $LN2@cpuMemoryM
  00011	0f b7 44 24 08	 movzx	 eax, WORD PTR Address$[rsp]
  00016	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  0001b	7d 1a		 jge	 SHORT $LN2@cpuMemoryM

; 27   :         Address = (Address % 0x0800);

  0001d	0f b7 44 24 08	 movzx	 eax, WORD PTR Address$[rsp]
  00022	99		 cdq
  00023	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  00029	03 c2		 add	 eax, edx
  0002b	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00030	2b c2		 sub	 eax, edx
  00032	66 89 44 24 08	 mov	 WORD PTR Address$[rsp], ax
$LN2@cpuMemoryM:

; 28   :     // NOTE: Mirror for PPU Registers
; 29   :     if(0x2008 <= Address && Address < 0x4000)

  00037	0f b7 44 24 08	 movzx	 eax, WORD PTR Address$[rsp]
  0003c	3d 08 20 00 00	 cmp	 eax, 8200		; 00002008H
  00041	7c 26		 jl	 SHORT $LN3@cpuMemoryM
  00043	0f b7 44 24 08	 movzx	 eax, WORD PTR Address$[rsp]
  00048	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  0004d	7d 1a		 jge	 SHORT $LN3@cpuMemoryM

; 30   :         Address = (Address % (0x2008 - 0x2000)) + 0x2000;

  0004f	0f b7 44 24 08	 movzx	 eax, WORD PTR Address$[rsp]
  00054	99		 cdq
  00055	83 e2 07	 and	 edx, 7
  00058	03 c2		 add	 eax, edx
  0005a	83 e0 07	 and	 eax, 7
  0005d	2b c2		 sub	 eax, edx
  0005f	05 00 20 00 00	 add	 eax, 8192		; 00002000H
  00064	66 89 44 24 08	 mov	 WORD PTR Address$[rsp], ax
$LN3@cpuMemoryM:

; 31   :     return(Address);

  00069	0f b7 44 24 08	 movzx	 eax, WORD PTR Address$[rsp]

; 32   : }

  0006e	c3		 ret	 0
?cpuMemoryMirror@@YAGG@Z ENDP				; cpuMemoryMirror
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\memory.cpp
_TEXT	SEGMENT
Value$ = 0
NewAddress$ = 8
Address$ = 32
MemoryOffset$ = 40
?read8@@YAEG_K@Z PROC					; read8

; 16   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 17   :     uint8 *NewAddress = (uint8 *)(Address + MemoryOffset);

  0000e	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  00013	48 03 44 24 28	 add	 rax, QWORD PTR MemoryOffset$[rsp]
  00018	48 89 44 24 08	 mov	 QWORD PTR NewAddress$[rsp], rax

; 18   :     uint8 Value = *NewAddress;

  0001d	48 8b 44 24 08	 mov	 rax, QWORD PTR NewAddress$[rsp]
  00022	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00025	88 04 24	 mov	 BYTE PTR Value$[rsp], al

; 19   :     return(Value);

  00028	0f b6 04 24	 movzx	 eax, BYTE PTR Value$[rsp]

; 20   : }

  0002c	48 83 c4 18	 add	 rsp, 24
  00030	c3		 ret	 0
?read8@@YAEG_K@Z ENDP					; read8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\memory.cpp
_TEXT	SEGMENT
NewAddress$ = 0
Byte$ = 32
Address$ = 40
MemoryOffset$ = 48
?write8@@YAXEG_K@Z PROC					; write8

; 10   : {   

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	48 83 ec 18	 sub	 rsp, 24

; 11   :     uint8 *NewAddress = (uint8 *)(Address + MemoryOffset);

  00012	0f b7 44 24 28	 movzx	 eax, WORD PTR Address$[rsp]
  00017	48 03 44 24 30	 add	 rax, QWORD PTR MemoryOffset$[rsp]
  0001c	48 89 04 24	 mov	 QWORD PTR NewAddress$[rsp], rax

; 12   :     *NewAddress = Byte;

  00020	48 8b 04 24	 mov	 rax, QWORD PTR NewAddress$[rsp]
  00024	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Byte$[rsp]
  00029	88 08		 mov	 BYTE PTR [rax], cl

; 13   : }

  0002b	48 83 c4 18	 add	 rsp, 24
  0002f	c3		 ret	 0
?write8@@YAXEG_K@Z ENDP					; write8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\memory.cpp
_TEXT	SEGMENT
Ppu$ = 32
index$1 = 40
tv66 = 44
NewAddress$2 = 48
tv92 = 52
tv130 = 56
tv136 = 60
tv142 = 64
tv147 = 68
tv152 = 72
tv184 = 76
tv189 = 80
tv194 = 84
tv199 = 88
tv204 = 92
tv209 = 96
tv214 = 100
tv219 = 104
Byte$ = 128
Address$ = 136
?writePpuRegister@@YAXEG@Z PROC				; writePpuRegister

; 301  : {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00009	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 302  :     ppu * Ppu = GlobalPpu;

  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GlobalPpu@@3PEAUppu@@EA
  00014	48 89 44 24 20	 mov	 QWORD PTR Ppu$[rsp], rax

; 303  :     
; 304  :     Ppu->OpenBus = Byte;

  00019	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  0001e	0f b6 8c 24 80
	00 00 00	 movzx	 ecx, BYTE PTR Byte$[rsp]
  00026	88 48 10	 mov	 BYTE PTR [rax+16], cl

; 305  :     
; 306  :     switch(Address)

  00029	0f b7 84 24 88
	00 00 00	 movzx	 eax, WORD PTR Address$[rsp]
  00031	89 44 24 2c	 mov	 DWORD PTR tv66[rsp], eax
  00035	81 7c 24 2c 14
	40 00 00	 cmp	 DWORD PTR tv66[rsp], 16404 ; 00004014H
  0003d	7f 3e		 jg	 SHORT $LN60@writePpuRe
  0003f	81 7c 24 2c 14
	40 00 00	 cmp	 DWORD PTR tv66[rsp], 16404 ; 00004014H
  00047	0f 84 61 07 00
	00		 je	 $LN30@writePpuRe
  0004d	8b 44 24 2c	 mov	 eax, DWORD PTR tv66[rsp]
  00051	2d 00 20 00 00	 sub	 eax, 8192		; 00002000H
  00056	89 44 24 2c	 mov	 DWORD PTR tv66[rsp], eax
  0005a	83 7c 24 2c 07	 cmp	 DWORD PTR tv66[rsp], 7
  0005f	0f 87 b2 07 00
	00		 ja	 $LN2@writePpuRe
  00065	48 63 44 24 2c	 movsxd	 rax, DWORD PTR tv66[rsp]
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00071	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN61@writePpuRe[rcx+rax*4]
  00078	48 03 c1	 add	 rax, rcx
  0007b	ff e0		 jmp	 rax
$LN60@writePpuRe:
  0007d	e9 95 07 00 00	 jmp	 $LN2@writePpuRe
$LN7@writePpuRe:

; 307  :     {
; 308  :         case 0x2000:
; 309  :         {
; 310  :             Ppu->NametableBase = Byte & 3;

  00082	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  0008a	83 e0 03	 and	 eax, 3
  0008d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00092	88 81 18 10 00
	00		 mov	 BYTE PTR [rcx+4120], al

; 311  :             Ppu->VRamIO.TempVRamAdrs &= ~0xC00;

  00098	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  0009d	0f b7 80 76 12
	00 00		 movzx	 eax, WORD PTR [rax+4726]
  000a4	25 ff f3 ff ff	 and	 eax, -3073		; fffffffffffff3ffH
  000a9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  000ae	66 89 81 76 12
	00 00		 mov	 WORD PTR [rcx+4726], ax

; 312  :             Ppu->VRamIO.TempVRamAdrs |= (Byte & 3) << 10;            

  000b5	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  000bd	83 e0 03	 and	 eax, 3
  000c0	c1 e0 0a	 shl	 eax, 10
  000c3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  000c8	0f b7 89 76 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4726]
  000cf	0b c8		 or	 ecx, eax
  000d1	8b c1		 mov	 eax, ecx
  000d3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  000d8	66 89 81 76 12
	00 00		 mov	 WORD PTR [rcx+4726], ax

; 313  :             Ppu->VRamIncrement = ((Byte & 4) != 0) ? 32 : 1;

  000df	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  000e7	83 e0 04	 and	 eax, 4
  000ea	85 c0		 test	 eax, eax
  000ec	74 0a		 je	 SHORT $LN32@writePpuRe
  000ee	c7 44 24 34 20
	00 00 00	 mov	 DWORD PTR tv92[rsp], 32	; 00000020H
  000f6	eb 08		 jmp	 SHORT $LN33@writePpuRe
$LN32@writePpuRe:
  000f8	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
$LN33@writePpuRe:
  00100	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00105	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv92[rsp]
  0010a	88 88 19 10 00
	00		 mov	 BYTE PTR [rax+4121], cl

; 314  :             Ppu->SPRTPattenBase = ((Byte & 8) != 0) ? 0x1000 : 0;

  00110	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  00118	83 e0 08	 and	 eax, 8
  0011b	85 c0		 test	 eax, eax
  0011d	74 0a		 je	 SHORT $LN34@writePpuRe
  0011f	c7 44 24 38 00
	10 00 00	 mov	 DWORD PTR tv130[rsp], 4096 ; 00001000H
  00127	eb 08		 jmp	 SHORT $LN35@writePpuRe
$LN34@writePpuRe:
  00129	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
$LN35@writePpuRe:
  00131	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00136	0f b7 4c 24 38	 movzx	 ecx, WORD PTR tv130[rsp]
  0013b	66 89 88 1a 10
	00 00		 mov	 WORD PTR [rax+4122], cx

; 315  :             Ppu->BGPatternBase = ((Byte & 16) != 0) ? 0x1000 : 0;

  00142	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  0014a	83 e0 10	 and	 eax, 16
  0014d	85 c0		 test	 eax, eax
  0014f	74 0a		 je	 SHORT $LN36@writePpuRe
  00151	c7 44 24 3c 00
	10 00 00	 mov	 DWORD PTR tv136[rsp], 4096 ; 00001000H
  00159	eb 08		 jmp	 SHORT $LN37@writePpuRe
$LN36@writePpuRe:
  0015b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN37@writePpuRe:
  00163	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00168	0f b7 4c 24 3c	 movzx	 ecx, WORD PTR tv136[rsp]
  0016d	66 89 88 1c 10
	00 00		 mov	 WORD PTR [rax+4124], cx

; 316  :             Ppu->SpriteSize8x16 = ((Byte & 32) != 0);

  00174	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  0017c	83 e0 20	 and	 eax, 32			; 00000020H
  0017f	85 c0		 test	 eax, eax
  00181	74 0a		 je	 SHORT $LN38@writePpuRe
  00183	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv142[rsp], 1
  0018b	eb 08		 jmp	 SHORT $LN39@writePpuRe
$LN38@writePpuRe:
  0018d	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN39@writePpuRe:
  00195	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  0019a	8b 4c 24 40	 mov	 ecx, DWORD PTR tv142[rsp]
  0019e	89 88 20 10 00
	00		 mov	 DWORD PTR [rax+4128], ecx

; 317  :             Ppu->PpuSlave = ((Byte & 64) != 0);

  001a4	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  001ac	83 e0 40	 and	 eax, 64			; 00000040H
  001af	85 c0		 test	 eax, eax
  001b1	74 0a		 je	 SHORT $LN40@writePpuRe
  001b3	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv147[rsp], 1
  001bb	eb 08		 jmp	 SHORT $LN41@writePpuRe
$LN40@writePpuRe:
  001bd	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
$LN41@writePpuRe:
  001c5	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  001ca	8b 4c 24 44	 mov	 ecx, DWORD PTR tv147[rsp]
  001ce	89 88 24 10 00
	00		 mov	 DWORD PTR [rax+4132], ecx

; 318  :             Ppu->GenerateNMI = ((Byte & 128) != 0);

  001d4	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  001dc	25 80 00 00 00	 and	 eax, 128		; 00000080H
  001e1	85 c0		 test	 eax, eax
  001e3	74 0a		 je	 SHORT $LN42@writePpuRe
  001e5	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv152[rsp], 1
  001ed	eb 08		 jmp	 SHORT $LN43@writePpuRe
$LN42@writePpuRe:
  001ef	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv152[rsp], 0
$LN43@writePpuRe:
  001f7	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  001fc	8b 4c 24 48	 mov	 ecx, DWORD PTR tv152[rsp]
  00200	89 88 28 10 00
	00		 mov	 DWORD PTR [rax+4136], ecx

; 319  :             
; 320  :             if(Ppu->Scanline == 261 && Ppu->ScanlineCycle == 0)

  00206	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  0020b	0f b7 80 70 12
	00 00		 movzx	 eax, WORD PTR [rax+4720]
  00212	3d 05 01 00 00	 cmp	 eax, 261		; 00000105H
  00217	75 1f		 jne	 SHORT $LN8@writePpuRe
  00219	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  0021e	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  00225	85 c0		 test	 eax, eax
  00227	75 0f		 jne	 SHORT $LN8@writePpuRe

; 321  :             {
; 322  :                 NmiTriggered = false;

  00229	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?NmiTriggered@@3HA, 0 ; NmiTriggered
  00233	e9 a1 00 00 00	 jmp	 $LN9@writePpuRe
$LN8@writePpuRe:

; 323  :             }
; 324  :             else if(Ppu->GenerateNMI && !Ppu->SupressNmi && Ppu->VerticalBlank && !NmiTriggered)

  00238	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  0023d	83 b8 28 10 00
	00 00		 cmp	 DWORD PTR [rax+4136], 0
  00244	74 38		 je	 SHORT $LN10@writePpuRe
  00246	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  0024b	83 b8 84 12 00
	00 00		 cmp	 DWORD PTR [rax+4740], 0
  00252	75 2a		 jne	 SHORT $LN10@writePpuRe
  00254	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00259	83 b8 54 10 00
	00 00		 cmp	 DWORD PTR [rax+4180], 0
  00260	74 1c		 je	 SHORT $LN10@writePpuRe
  00262	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?NmiTriggered@@3HA, 0 ; NmiTriggered
  00269	75 13		 jne	 SHORT $LN10@writePpuRe

; 325  :             {
; 326  :                 TriggerNmi = Ppu->GenerateNMI;

  0026b	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00270	8b 80 28 10 00
	00		 mov	 eax, DWORD PTR [rax+4136]
  00276	89 05 00 00 00
	00		 mov	 DWORD PTR ?TriggerNmi@@3HA, eax ; TriggerNmi
  0027c	eb 5b		 jmp	 SHORT $LN11@writePpuRe
$LN10@writePpuRe:

; 327  :             }
; 328  :             else if(!Ppu->GenerateNMI && Ppu->Scanline == 241 && (Ppu->ScanlineCycle == 1  || Ppu->ScanlineCycle == 2))

  0027e	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00283	83 b8 28 10 00
	00 00		 cmp	 DWORD PTR [rax+4136], 0
  0028a	75 4d		 jne	 SHORT $LN12@writePpuRe
  0028c	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00291	0f b7 80 70 12
	00 00		 movzx	 eax, WORD PTR [rax+4720]
  00298	3d f1 00 00 00	 cmp	 eax, 241		; 000000f1H
  0029d	75 3a		 jne	 SHORT $LN12@writePpuRe
  0029f	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  002a4	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  002ab	83 f8 01	 cmp	 eax, 1
  002ae	74 11		 je	 SHORT $LN13@writePpuRe
  002b0	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  002b5	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  002bc	83 f8 02	 cmp	 eax, 2
  002bf	75 18		 jne	 SHORT $LN12@writePpuRe
$LN13@writePpuRe:

; 329  :             {
; 330  :                 TriggerNmi = false;

  002c1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?TriggerNmi@@3HA, 0 ; TriggerNmi

; 331  :                 GlobalCpu->StartNmi = false;

  002cb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GlobalCpu@@3PEAUcpu@@EA
  002d2	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0
$LN12@writePpuRe:
$LN11@writePpuRe:
$LN9@writePpuRe:

; 332  :             }
; 333  : 
; 334  :             NmiTriggered = Ppu->GenerateNMI;

  002d9	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  002de	8b 80 28 10 00
	00		 mov	 eax, DWORD PTR [rax+4136]
  002e4	89 05 00 00 00
	00		 mov	 DWORD PTR ?NmiTriggered@@3HA, eax ; NmiTriggered

; 335  :             break;

  002ea	e9 28 05 00 00	 jmp	 $LN2@writePpuRe
$LN14@writePpuRe:

; 336  :         }
; 337  :         case 0x2001:
; 338  :         {
; 339  :             Ppu->GreyScale           = ((Byte & 1) != 0);

  002ef	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  002f7	83 e0 01	 and	 eax, 1
  002fa	85 c0		 test	 eax, eax
  002fc	74 0a		 je	 SHORT $LN44@writePpuRe
  002fe	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv184[rsp], 1
  00306	eb 08		 jmp	 SHORT $LN45@writePpuRe
$LN44@writePpuRe:
  00308	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv184[rsp], 0
$LN45@writePpuRe:
  00310	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00315	8b 4c 24 4c	 mov	 ecx, DWORD PTR tv184[rsp]
  00319	89 88 2c 10 00
	00		 mov	 DWORD PTR [rax+4140], ecx

; 340  :             Ppu->ShowBGLeft8Pixels   = ((Byte & 2) != 0);

  0031f	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  00327	83 e0 02	 and	 eax, 2
  0032a	85 c0		 test	 eax, eax
  0032c	74 0a		 je	 SHORT $LN46@writePpuRe
  0032e	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv189[rsp], 1
  00336	eb 08		 jmp	 SHORT $LN47@writePpuRe
$LN46@writePpuRe:
  00338	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv189[rsp], 0
$LN47@writePpuRe:
  00340	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00345	8b 4c 24 50	 mov	 ecx, DWORD PTR tv189[rsp]
  00349	89 88 30 10 00
	00		 mov	 DWORD PTR [rax+4144], ecx

; 341  :             Ppu->ShowSPRTLeft8Pixels = ((Byte & 4) != 0);

  0034f	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  00357	83 e0 04	 and	 eax, 4
  0035a	85 c0		 test	 eax, eax
  0035c	74 0a		 je	 SHORT $LN48@writePpuRe
  0035e	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv194[rsp], 1
  00366	eb 08		 jmp	 SHORT $LN49@writePpuRe
$LN48@writePpuRe:
  00368	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv194[rsp], 0
$LN49@writePpuRe:
  00370	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00375	8b 4c 24 54	 mov	 ecx, DWORD PTR tv194[rsp]
  00379	89 88 34 10 00
	00		 mov	 DWORD PTR [rax+4148], ecx

; 342  :             Ppu->ShowBackground      = ((Byte & 8) != 0);

  0037f	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  00387	83 e0 08	 and	 eax, 8
  0038a	85 c0		 test	 eax, eax
  0038c	74 0a		 je	 SHORT $LN50@writePpuRe
  0038e	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv199[rsp], 1
  00396	eb 08		 jmp	 SHORT $LN51@writePpuRe
$LN50@writePpuRe:
  00398	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv199[rsp], 0
$LN51@writePpuRe:
  003a0	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  003a5	8b 4c 24 58	 mov	 ecx, DWORD PTR tv199[rsp]
  003a9	89 88 38 10 00
	00		 mov	 DWORD PTR [rax+4152], ecx

; 343  :             Ppu->ShowSprites         = ((Byte & 16) != 0);

  003af	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  003b7	83 e0 10	 and	 eax, 16
  003ba	85 c0		 test	 eax, eax
  003bc	74 0a		 je	 SHORT $LN52@writePpuRe
  003be	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv204[rsp], 1
  003c6	eb 08		 jmp	 SHORT $LN53@writePpuRe
$LN52@writePpuRe:
  003c8	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv204[rsp], 0
$LN53@writePpuRe:
  003d0	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  003d5	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv204[rsp]
  003d9	89 88 3c 10 00
	00		 mov	 DWORD PTR [rax+4156], ecx

; 344  :             Ppu->EmphasizeRed        = ((Byte & 32) != 0);

  003df	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  003e7	83 e0 20	 and	 eax, 32			; 00000020H
  003ea	85 c0		 test	 eax, eax
  003ec	74 0a		 je	 SHORT $LN54@writePpuRe
  003ee	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv209[rsp], 1
  003f6	eb 08		 jmp	 SHORT $LN55@writePpuRe
$LN54@writePpuRe:
  003f8	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv209[rsp], 0
$LN55@writePpuRe:
  00400	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00405	8b 4c 24 60	 mov	 ecx, DWORD PTR tv209[rsp]
  00409	89 88 40 10 00
	00		 mov	 DWORD PTR [rax+4160], ecx

; 345  :             Ppu->EmphasizeGreen      = ((Byte & 64) != 0);

  0040f	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  00417	83 e0 40	 and	 eax, 64			; 00000040H
  0041a	85 c0		 test	 eax, eax
  0041c	74 0a		 je	 SHORT $LN56@writePpuRe
  0041e	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv214[rsp], 1
  00426	eb 08		 jmp	 SHORT $LN57@writePpuRe
$LN56@writePpuRe:
  00428	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv214[rsp], 0
$LN57@writePpuRe:
  00430	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00435	8b 4c 24 64	 mov	 ecx, DWORD PTR tv214[rsp]
  00439	89 88 44 10 00
	00		 mov	 DWORD PTR [rax+4164], ecx

; 346  :             Ppu->EmphasizeBlue       = ((Byte & 128) != 0);

  0043f	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  00447	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0044c	85 c0		 test	 eax, eax
  0044e	74 0a		 je	 SHORT $LN58@writePpuRe
  00450	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv219[rsp], 1
  00458	eb 08		 jmp	 SHORT $LN59@writePpuRe
$LN58@writePpuRe:
  0045a	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv219[rsp], 0
$LN59@writePpuRe:
  00462	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00467	8b 4c 24 68	 mov	 ecx, DWORD PTR tv219[rsp]
  0046b	89 88 48 10 00
	00		 mov	 DWORD PTR [rax+4168], ecx

; 347  :             break;

  00471	e9 a1 03 00 00	 jmp	 $LN2@writePpuRe
$LN15@writePpuRe:

; 348  :         }
; 349  :         case 0x2003:
; 350  :         {
; 351  :             Ppu->OamAddress = Byte;

  00476	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  0047b	0f b6 8c 24 80
	00 00 00	 movzx	 ecx, BYTE PTR Byte$[rsp]
  00483	88 88 58 10 00
	00		 mov	 BYTE PTR [rax+4184], cl

; 352  :             break;

  00489	e9 89 03 00 00	 jmp	 $LN2@writePpuRe
$LN16@writePpuRe:

; 353  :         }
; 354  :         case 0x2004:
; 355  :         {
; 356  :             // If Writing OAM Data while rendering, then a glitch increments it by 4 instead
; 357  :             if(Ppu->Scanline < 240 || Ppu->Scanline == 261 || Ppu->ShowBackground || Ppu->ShowSprites)

  0048e	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00493	0f b7 80 70 12
	00 00		 movzx	 eax, WORD PTR [rax+4720]
  0049a	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  0049f	7c 2f		 jl	 SHORT $LN19@writePpuRe
  004a1	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  004a6	0f b7 80 70 12
	00 00		 movzx	 eax, WORD PTR [rax+4720]
  004ad	3d 05 01 00 00	 cmp	 eax, 261		; 00000105H
  004b2	74 1c		 je	 SHORT $LN19@writePpuRe
  004b4	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  004b9	83 b8 38 10 00
	00 00		 cmp	 DWORD PTR [rax+4152], 0
  004c0	75 0e		 jne	 SHORT $LN19@writePpuRe
  004c2	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  004c7	83 b8 3c 10 00
	00 00		 cmp	 DWORD PTR [rax+4156], 0
  004ce	74 1c		 je	 SHORT $LN17@writePpuRe
$LN19@writePpuRe:

; 358  :             {
; 359  :                 Ppu->OamAddress += 4;

  004d0	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  004d5	0f b6 80 58 10
	00 00		 movzx	 eax, BYTE PTR [rax+4184]
  004dc	83 c0 04	 add	 eax, 4
  004df	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  004e4	88 81 58 10 00
	00		 mov	 BYTE PTR [rcx+4184], al

; 360  :             }
; 361  :             else

  004ea	eb 39		 jmp	 SHORT $LN18@writePpuRe
$LN17@writePpuRe:

; 362  :             {
; 363  :                 /*
; 364  :                 if( ( OAMADDR & 0x03 ) == 0x02 )
; 365  :                     b&=0xe3;
; 366  :                 map.ppuwriteoam(Byte.toUnsignedInt(OAMADDR), b); TODO: Look at the example code
; 367  :                 */
; 368  :                 Ppu->Oam[Ppu->OamAddress] = Byte;

  004ec	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  004f1	0f b6 80 58 10
	00 00		 movzx	 eax, BYTE PTR [rax+4184]
  004f8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  004fd	0f b6 94 24 80
	00 00 00	 movzx	 edx, BYTE PTR Byte$[rsp]
  00505	88 94 01 68 10
	00 00		 mov	 BYTE PTR [rcx+rax+4200], dl

; 369  :                 Ppu->OamAddress++;

  0050c	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00511	0f b6 80 58 10
	00 00		 movzx	 eax, BYTE PTR [rax+4184]
  00518	fe c0		 inc	 al
  0051a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0051f	88 81 58 10 00
	00		 mov	 BYTE PTR [rcx+4184], al
$LN18@writePpuRe:

; 370  :             }
; 371  :             break;

  00525	e9 ed 02 00 00	 jmp	 $LN2@writePpuRe
$LN20@writePpuRe:

; 372  :         }
; 373  :         case 0x2005:
; 374  :         {
; 375  :             if(Ppu->VRamIO.LatchWrite == 0)

  0052a	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  0052f	0f b6 80 78 12
	00 00		 movzx	 eax, BYTE PTR [rax+4728]
  00536	85 c0		 test	 eax, eax
  00538	75 69		 jne	 SHORT $LN21@writePpuRe

; 376  :             {
; 377  :                 Ppu->VRamIO.FineX = Byte & 7; // Bit 0,1, and 2 are fine X

  0053a	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  00542	83 e0 07	 and	 eax, 7
  00545	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0054a	88 81 79 12 00
	00		 mov	 BYTE PTR [rcx+4729], al

; 378  :                 Ppu->VRamIO.TempVRamAdrs &= ~(0x001F); // Clear Bits

  00550	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00555	0f b7 80 76 12
	00 00		 movzx	 eax, WORD PTR [rax+4726]
  0055c	83 e0 e0	 and	 eax, -32		; ffffffffffffffe0H
  0055f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00564	66 89 81 76 12
	00 00		 mov	 WORD PTR [rcx+4726], ax

; 379  :                 Ppu->VRamIO.TempVRamAdrs |= ((uint16)Byte) >> 3;

  0056b	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  00573	c1 f8 03	 sar	 eax, 3
  00576	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0057b	0f b7 89 76 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4726]
  00582	0b c8		 or	 ecx, eax
  00584	8b c1		 mov	 eax, ecx
  00586	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0058b	66 89 81 76 12
	00 00		 mov	 WORD PTR [rcx+4726], ax

; 380  :                 Ppu->VRamIO.LatchWrite = 1;

  00592	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00597	c6 80 78 12 00
	00 01		 mov	 BYTE PTR [rax+4728], 1

; 381  :             }
; 382  :             else

  0059e	e9 85 00 00 00	 jmp	 $LN22@writePpuRe
$LN21@writePpuRe:

; 383  :             {
; 384  :                 Ppu->VRamIO.TempVRamAdrs &= ~(0x73E0); // Clear Bits

  005a3	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  005a8	0f b7 80 76 12
	00 00		 movzx	 eax, WORD PTR [rax+4726]
  005af	25 1f 8c ff ff	 and	 eax, -29665		; ffffffffffff8c1fH
  005b4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  005b9	66 89 81 76 12
	00 00		 mov	 WORD PTR [rcx+4726], ax

; 385  :                 Ppu->VRamIO.TempVRamAdrs |= ((uint16)(Byte & 0x7)) << 12; // Set fine scroll Y, bits 0-2 set bit 12-14

  005c0	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  005c8	83 e0 07	 and	 eax, 7
  005cb	0f b7 c0	 movzx	 eax, ax
  005ce	c1 e0 0c	 shl	 eax, 12
  005d1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  005d6	0f b7 89 76 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4726]
  005dd	0b c8		 or	 ecx, eax
  005df	8b c1		 mov	 eax, ecx
  005e1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  005e6	66 89 81 76 12
	00 00		 mov	 WORD PTR [rcx+4726], ax

; 386  :                 Ppu->VRamIO.TempVRamAdrs |= ((uint16)(Byte & 0xF8)) << 2; // Set coarse Y, bits 3-7 set bit 5-9

  005ed	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  005f5	25 f8 00 00 00	 and	 eax, 248		; 000000f8H
  005fa	0f b7 c0	 movzx	 eax, ax
  005fd	c1 e0 02	 shl	 eax, 2
  00600	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00605	0f b7 89 76 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4726]
  0060c	0b c8		 or	 ecx, eax
  0060e	8b c1		 mov	 eax, ecx
  00610	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00615	66 89 81 76 12
	00 00		 mov	 WORD PTR [rcx+4726], ax

; 387  :                 Ppu->VRamIO.LatchWrite = 0;

  0061c	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00621	c6 80 78 12 00
	00 00		 mov	 BYTE PTR [rax+4728], 0
$LN22@writePpuRe:

; 388  :             }
; 389  :                 
; 390  :             break;

  00628	e9 ea 01 00 00	 jmp	 $LN2@writePpuRe
$LN23@writePpuRe:

; 391  :         }
; 392  :         case 0x2006:
; 393  :         {
; 394  :             if(Ppu->VRamIO.LatchWrite == 0)

  0062d	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00632	0f b6 80 78 12
	00 00		 movzx	 eax, BYTE PTR [rax+4728]
  00639	85 c0		 test	 eax, eax
  0063b	75 75		 jne	 SHORT $LN24@writePpuRe

; 395  :             {
; 396  :                 Ppu->VRamIO.TempVRamAdrs &= 0xC0FF; // Clear Bits About to be set 

  0063d	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00642	0f b7 80 76 12
	00 00		 movzx	 eax, WORD PTR [rax+4726]
  00649	25 ff c0 00 00	 and	 eax, 49407		; 0000c0ffH
  0064e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00653	66 89 81 76 12
	00 00		 mov	 WORD PTR [rcx+4726], ax

; 397  :                 Ppu->VRamIO.TempVRamAdrs |= ((uint16)(Byte & 0x003F)) << 8;

  0065a	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  00662	83 e0 3f	 and	 eax, 63			; 0000003fH
  00665	0f b7 c0	 movzx	 eax, ax
  00668	c1 e0 08	 shl	 eax, 8
  0066b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00670	0f b7 89 76 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4726]
  00677	0b c8		 or	 ecx, eax
  00679	8b c1		 mov	 eax, ecx
  0067b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00680	66 89 81 76 12
	00 00		 mov	 WORD PTR [rcx+4726], ax

; 398  :                 Ppu->VRamIO.TempVRamAdrs &= 0x3FFF; // Clear 14th bit 

  00687	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  0068c	0f b7 80 76 12
	00 00		 movzx	 eax, WORD PTR [rax+4726]
  00693	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  00698	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0069d	66 89 81 76 12
	00 00		 mov	 WORD PTR [rcx+4726], ax

; 399  :                 Ppu->VRamIO.LatchWrite = 1;

  006a4	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  006a9	c6 80 78 12 00
	00 01		 mov	 BYTE PTR [rax+4728], 1

; 400  :             }
; 401  :             else

  006b0	eb 6d		 jmp	 SHORT $LN25@writePpuRe
$LN24@writePpuRe:

; 402  :             { 
; 403  :                 Ppu->VRamIO.TempVRamAdrs &= 0x7F00; // Clear low byte

  006b2	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  006b7	0f b7 80 76 12
	00 00		 movzx	 eax, WORD PTR [rax+4726]
  006be	25 00 7f 00 00	 and	 eax, 32512		; 00007f00H
  006c3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  006c8	66 89 81 76 12
	00 00		 mov	 WORD PTR [rcx+4726], ax

; 404  :                 Ppu->VRamIO.TempVRamAdrs |= (uint16)(Byte & 0x00FF); 

  006cf	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  006d7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006dc	0f b7 c0	 movzx	 eax, ax
  006df	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  006e4	0f b7 89 76 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4726]
  006eb	0b c8		 or	 ecx, eax
  006ed	8b c1		 mov	 eax, ecx
  006ef	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  006f4	66 89 81 76 12
	00 00		 mov	 WORD PTR [rcx+4726], ax

; 405  :                 Ppu->VRamIO.VRamAdrs = Ppu->VRamIO.TempVRamAdrs;

  006fb	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00700	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00705	0f b7 89 76 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4726]
  0070c	66 89 88 74 12
	00 00		 mov	 WORD PTR [rax+4724], cx

; 406  :                 Ppu->VRamIO.LatchWrite = 0;

  00713	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00718	c6 80 78 12 00
	00 00		 mov	 BYTE PTR [rax+4728], 0
$LN25@writePpuRe:

; 407  :             }
; 408  :             
; 409  :             break;

  0071f	e9 f3 00 00 00	 jmp	 $LN2@writePpuRe
$LN26@writePpuRe:

; 410  :         }
; 411  :         case 0x2007:
; 412  :         {
; 413  :             writePpu8(Byte, Ppu->VRamIO.VRamAdrs, Ppu);

  00724	4c 8b 44 24 20	 mov	 r8, QWORD PTR Ppu$[rsp]
  00729	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  0072e	0f b7 90 74 12
	00 00		 movzx	 edx, WORD PTR [rax+4724]
  00735	0f b6 8c 24 80
	00 00 00	 movzx	 ecx, BYTE PTR Byte$[rsp]
  0073d	e8 00 00 00 00	 call	 ?writePpu8@@YAXEGPEAUppu@@@Z ; writePpu8

; 414  : 
; 415  :             if( !(Ppu->ShowBackground || Ppu->ShowSprites) ||

  00742	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00747	83 b8 38 10 00
	00 00		 cmp	 DWORD PTR [rax+4152], 0
  0074e	75 0e		 jne	 SHORT $LN29@writePpuRe
  00750	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00755	83 b8 3c 10 00
	00 00		 cmp	 DWORD PTR [rax+4156], 0
  0075c	74 26		 je	 SHORT $LN28@writePpuRe
$LN29@writePpuRe:
  0075e	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00763	0f b7 80 70 12
	00 00		 movzx	 eax, WORD PTR [rax+4720]
  0076a	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  0076f	7e 3b		 jle	 SHORT $LN27@writePpuRe
  00771	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00776	0f b7 80 70 12
	00 00		 movzx	 eax, WORD PTR [rax+4720]
  0077d	3d 04 01 00 00	 cmp	 eax, 260		; 00000104H
  00782	7f 28		 jg	 SHORT $LN27@writePpuRe
$LN28@writePpuRe:

; 416  :                 (Ppu->Scanline > 240 && Ppu->Scanline <= 260) )
; 417  :             {            
; 418  :                 Ppu->VRamIO.VRamAdrs += Ppu->VRamIncrement;

  00784	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  00789	0f b6 80 19 10
	00 00		 movzx	 eax, BYTE PTR [rax+4121]
  00790	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00795	0f b7 89 74 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4724]
  0079c	03 c8		 add	 ecx, eax
  0079e	8b c1		 mov	 eax, ecx
  007a0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  007a5	66 89 81 74 12
	00 00		 mov	 WORD PTR [rcx+4724], ax
$LN27@writePpuRe:

; 419  :             }
; 420  :             break;

  007ac	eb 69		 jmp	 SHORT $LN2@writePpuRe
$LN30@writePpuRe:

; 421  :         }
; 422  :         case 0x4014:
; 423  :         {
; 424  :             // NOTE: OAM DMA Write
; 425  :             for(uint16 index = Ppu->OamAddress; index < OAM_SIZE; ++index)

  007ae	48 8b 44 24 20	 mov	 rax, QWORD PTR Ppu$[rsp]
  007b3	0f b6 80 58 10
	00 00		 movzx	 eax, BYTE PTR [rax+4184]
  007ba	66 89 44 24 28	 mov	 WORD PTR index$1[rsp], ax
  007bf	eb 0d		 jmp	 SHORT $LN6@writePpuRe
$LN4@writePpuRe:
  007c1	0f b7 44 24 28	 movzx	 eax, WORD PTR index$1[rsp]
  007c6	66 ff c0	 inc	 ax
  007c9	66 89 44 24 28	 mov	 WORD PTR index$1[rsp], ax
$LN6@writePpuRe:
  007ce	0f b7 44 24 28	 movzx	 eax, WORD PTR index$1[rsp]
  007d3	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  007d8	7d 3d		 jge	 SHORT $LN5@writePpuRe

; 426  :             {
; 427  :                 uint16 NewAddress = (Byte << 8) | index; 

  007da	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  007e2	c1 e0 08	 shl	 eax, 8
  007e5	0f b7 4c 24 28	 movzx	 ecx, WORD PTR index$1[rsp]
  007ea	0b c1		 or	 eax, ecx
  007ec	66 89 44 24 30	 mov	 WORD PTR NewAddress$2[rsp], ax

; 428  :                 OamData[index] = read8(NewAddress, GlobalCpu->MemoryBase);

  007f1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GlobalCpu@@3PEAUcpu@@EA
  007f8	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  007fc	0f b7 4c 24 30	 movzx	 ecx, WORD PTR NewAddress$2[rsp]
  00801	e8 00 00 00 00	 call	 ?read8@@YAEG_K@Z	; read8
  00806	0f b7 4c 24 28	 movzx	 ecx, WORD PTR index$1[rsp]
  0080b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?OamData@@3PEAEEA
  00812	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 429  :             }            

  00815	eb aa		 jmp	 SHORT $LN4@writePpuRe
$LN5@writePpuRe:
$LN2@writePpuRe:

; 430  :             break;
; 431  :         }
; 432  :     }
; 433  : }

  00817	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0081b	c3		 ret	 0
$LN61@writePpuRe:
  0081c	00 00 00 00	 DD	 $LN7@writePpuRe
  00820	00 00 00 00	 DD	 $LN14@writePpuRe
  00824	00 00 00 00	 DD	 $LN2@writePpuRe
  00828	00 00 00 00	 DD	 $LN15@writePpuRe
  0082c	00 00 00 00	 DD	 $LN16@writePpuRe
  00830	00 00 00 00	 DD	 $LN20@writePpuRe
  00834	00 00 00 00	 DD	 $LN23@writePpuRe
  00838	00 00 00 00	 DD	 $LN26@writePpuRe
?writePpuRegister@@YAXEG@Z ENDP				; writePpuRegister
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\memory.cpp
_TEXT	SEGMENT
Byte$ = 32
Ppu$ = 40
tv65 = 48
tv90 = 52
tv130 = 56
tv137 = 60
tv143 = 64
tv167 = 68
OnPalette$1 = 72
Address$ = 96
?readPpuRegister@@YAEG@Z PROC				; readPpuRegister

; 436  : {

  00000	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 437  :     ppu * Ppu = GlobalPpu;

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GlobalPpu@@3PEAUppu@@EA
  00010	48 89 44 24 28	 mov	 QWORD PTR Ppu$[rsp], rax

; 438  :     
; 439  :     uint8 Byte = 0;

  00015	c6 44 24 20 00	 mov	 BYTE PTR Byte$[rsp], 0

; 440  :     
; 441  :     switch(Address)

  0001a	0f b7 44 24 60	 movzx	 eax, WORD PTR Address$[rsp]
  0001f	89 44 24 30	 mov	 DWORD PTR tv65[rsp], eax
  00023	81 7c 24 30 02
	20 00 00	 cmp	 DWORD PTR tv65[rsp], 8194 ; 00002002H
  0002b	74 21		 je	 SHORT $LN4@readPpuReg
  0002d	81 7c 24 30 04
	20 00 00	 cmp	 DWORD PTR tv65[rsp], 8196 ; 00002004H
  00035	0f 84 d3 01 00
	00		 je	 $LN11@readPpuReg
  0003b	81 7c 24 30 07
	20 00 00	 cmp	 DWORD PTR tv65[rsp], 8199 ; 00002007H
  00043	0f 84 eb 01 00
	00		 je	 $LN12@readPpuReg
  00049	e9 33 03 00 00	 jmp	 $LN2@readPpuReg
$LN4@readPpuReg:

; 442  :     {
; 443  :         case 0x2002:
; 444  :         {
; 445  :             // One before vbl set, vbl is clear and does not get set the next cycle
; 446  :             // On vbl set or one after, clears it, and supresses nmi for that frame?
; 447  :             // Two or more cycles after, reads normally,             
; 448  :             if( Ppu->Scanline == 241 && (Ppu->ScanlineCycle == 1 || Ppu->ScanlineCycle == 1) )

  0004e	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  00053	0f b7 80 70 12
	00 00		 movzx	 eax, WORD PTR [rax+4720]
  0005a	3d f1 00 00 00	 cmp	 eax, 241		; 000000f1H
  0005f	75 36		 jne	 SHORT $LN5@readPpuReg
  00061	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  00066	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  0006d	83 f8 01	 cmp	 eax, 1
  00070	74 11		 je	 SHORT $LN7@readPpuReg
  00072	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  00077	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  0007e	83 f8 01	 cmp	 eax, 1
  00081	75 14		 jne	 SHORT $LN5@readPpuReg
$LN7@readPpuReg:

; 449  :             {
; 450  :                 Ppu->SupressVbl = true;

  00083	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  00088	c7 80 80 12 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4736], 1
  00092	e9 cd 00 00 00	 jmp	 $LN6@readPpuReg
$LN5@readPpuReg:

; 451  :             }
; 452  : /*            else if( Ppu->Scanline == 240 && (Ppu->ScanlineCycle == 339 || Ppu->ScanlineCycle == 340) )
; 453  :             {
; 454  :                 // Do nothing?
; 455  :                 }*/
; 456  :             else if( Ppu->Scanline == 241 && (Ppu->ScanlineCycle == 1 || Ppu->ScanlineCycle == 2 || Ppu->ScanlineCycle == 3))

  00097	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  0009c	0f b7 80 70 12
	00 00		 movzx	 eax, WORD PTR [rax+4720]
  000a3	3d f1 00 00 00	 cmp	 eax, 241		; 000000f1H
  000a8	0f 85 89 00 00
	00		 jne	 $LN8@readPpuReg
  000ae	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  000b3	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  000ba	83 f8 01	 cmp	 eax, 1
  000bd	74 22		 je	 SHORT $LN10@readPpuReg
  000bf	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  000c4	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  000cb	83 f8 02	 cmp	 eax, 2
  000ce	74 11		 je	 SHORT $LN10@readPpuReg
  000d0	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  000d5	0f b7 80 72 12
	00 00		 movzx	 eax, WORD PTR [rax+4722]
  000dc	83 f8 03	 cmp	 eax, 3
  000df	75 56		 jne	 SHORT $LN8@readPpuReg
$LN10@readPpuReg:

; 457  :             {
; 458  :                 Byte |= Ppu->VerticalBlank ? 0x80 : 0;

  000e1	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  000e6	83 b8 54 10 00
	00 00		 cmp	 DWORD PTR [rax+4180], 0
  000ed	74 0a		 je	 SHORT $LN20@readPpuReg
  000ef	c7 44 24 34 80
	00 00 00	 mov	 DWORD PTR tv90[rsp], 128 ; 00000080H
  000f7	eb 08		 jmp	 SHORT $LN21@readPpuReg
$LN20@readPpuReg:
  000f9	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN21@readPpuReg:
  00101	0f b6 44 24 20	 movzx	 eax, BYTE PTR Byte$[rsp]
  00106	0b 44 24 34	 or	 eax, DWORD PTR tv90[rsp]
  0010a	88 44 24 20	 mov	 BYTE PTR Byte$[rsp], al

; 459  :                 Ppu->SupressNmi = true;

  0010e	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  00113	c7 80 84 12 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4740], 1

; 460  :                 TriggerNmi = false;

  0011d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?TriggerNmi@@3HA, 0 ; TriggerNmi

; 461  :                 GlobalCpu->StartNmi = false;

  00127	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GlobalCpu@@3PEAUcpu@@EA
  0012e	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0

; 462  :             }
; 463  :             else

  00135	eb 2d		 jmp	 SHORT $LN9@readPpuReg
$LN8@readPpuReg:

; 464  :             {
; 465  :                 // Else if not anywhere near where vbl is set
; 466  :                 Byte |= Ppu->VerticalBlank ? 0x80 : 0; // Read normally

  00137	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  0013c	83 b8 54 10 00
	00 00		 cmp	 DWORD PTR [rax+4180], 0
  00143	74 0a		 je	 SHORT $LN22@readPpuReg
  00145	c7 44 24 38 80
	00 00 00	 mov	 DWORD PTR tv130[rsp], 128 ; 00000080H
  0014d	eb 08		 jmp	 SHORT $LN23@readPpuReg
$LN22@readPpuReg:
  0014f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
$LN23@readPpuReg:
  00157	0f b6 44 24 20	 movzx	 eax, BYTE PTR Byte$[rsp]
  0015c	0b 44 24 38	 or	 eax, DWORD PTR tv130[rsp]
  00160	88 44 24 20	 mov	 BYTE PTR Byte$[rsp], al
$LN9@readPpuReg:
$LN6@readPpuReg:

; 467  :             }
; 468  :             
; 469  :             Ppu->VerticalBlank = false;

  00164	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  00169	c7 80 54 10 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4180], 0

; 470  :             
; 471  :             Byte |= Ppu->Sprite0Hit ? 0x40 : 0;

  00173	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  00178	83 b8 50 10 00
	00 00		 cmp	 DWORD PTR [rax+4176], 0
  0017f	74 0a		 je	 SHORT $LN24@readPpuReg
  00181	c7 44 24 3c 40
	00 00 00	 mov	 DWORD PTR tv137[rsp], 64 ; 00000040H
  00189	eb 08		 jmp	 SHORT $LN25@readPpuReg
$LN24@readPpuReg:
  0018b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN25@readPpuReg:
  00193	0f b6 44 24 20	 movzx	 eax, BYTE PTR Byte$[rsp]
  00198	0b 44 24 3c	 or	 eax, DWORD PTR tv137[rsp]
  0019c	88 44 24 20	 mov	 BYTE PTR Byte$[rsp], al

; 472  :             Byte |= Ppu->SpriteOverflow ? 0x20 : 0;

  001a0	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  001a5	83 b8 4c 10 00
	00 00		 cmp	 DWORD PTR [rax+4172], 0
  001ac	74 0a		 je	 SHORT $LN26@readPpuReg
  001ae	c7 44 24 40 20
	00 00 00	 mov	 DWORD PTR tv143[rsp], 32 ; 00000020H
  001b6	eb 08		 jmp	 SHORT $LN27@readPpuReg
$LN26@readPpuReg:
  001b8	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv143[rsp], 0
$LN27@readPpuReg:
  001c0	0f b6 44 24 20	 movzx	 eax, BYTE PTR Byte$[rsp]
  001c5	0b 44 24 40	 or	 eax, DWORD PTR tv143[rsp]
  001c9	88 44 24 20	 mov	 BYTE PTR Byte$[rsp], al

; 473  :             Byte |= (Ppu->OpenBus & 0x1F); // Low 5 bits is the open bus

  001cd	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  001d2	0f b6 40 10	 movzx	 eax, BYTE PTR [rax+16]
  001d6	83 e0 1f	 and	 eax, 31
  001d9	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Byte$[rsp]
  001de	0b c8		 or	 ecx, eax
  001e0	8b c1		 mov	 eax, ecx
  001e2	88 44 24 20	 mov	 BYTE PTR Byte$[rsp], al

; 474  :             
; 475  :             Ppu->VRamIO.LatchWrite = 0;

  001e6	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  001eb	c6 80 78 12 00
	00 00		 mov	 BYTE PTR [rax+4728], 0

; 476  :             NmiTriggered = false;

  001f2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?NmiTriggered@@3HA, 0 ; NmiTriggered

; 477  :             Ppu->OpenBus = Byte;

  001fc	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  00201	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Byte$[rsp]
  00206	88 48 10	 mov	 BYTE PTR [rax+16], cl

; 478  :             break;

  00209	e9 73 01 00 00	 jmp	 $LN2@readPpuReg
$LN11@readPpuReg:

; 479  :         }
; 480  :         case 0x2004:
; 481  :         {
; 482  :             Ppu->OpenBus = Ppu->Oam[Ppu->OamAddress];

  0020e	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  00213	0f b6 80 58 10
	00 00		 movzx	 eax, BYTE PTR [rax+4184]
  0021a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0021f	48 8b 54 24 28	 mov	 rdx, QWORD PTR Ppu$[rsp]
  00224	0f b6 84 02 68
	10 00 00	 movzx	 eax, BYTE PTR [rdx+rax+4200]
  0022c	88 41 10	 mov	 BYTE PTR [rcx+16], al

; 483  :             break;

  0022f	e9 4d 01 00 00	 jmp	 $LN2@readPpuReg
$LN12@readPpuReg:

; 484  :         }
; 485  :         case 0x2007:
; 486  :         {
; 487  :             bool32 OnPalette = !((Ppu->VRamIO.VRamAdrs&0x3FFF) < 0x3F00);

  00234	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  00239	0f b7 80 74 12
	00 00		 movzx	 eax, WORD PTR [rax+4724]
  00240	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  00245	3d 00 3f 00 00	 cmp	 eax, 16128		; 00003f00H
  0024a	7c 0a		 jl	 SHORT $LN28@readPpuReg
  0024c	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv167[rsp], 1
  00254	eb 08		 jmp	 SHORT $LN29@readPpuReg
$LN28@readPpuReg:
  00256	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv167[rsp], 0
$LN29@readPpuReg:
  0025e	8b 44 24 44	 mov	 eax, DWORD PTR tv167[rsp]
  00262	89 44 24 48	 mov	 DWORD PTR OnPalette$1[rsp], eax

; 488  : 
; 489  :             if(OnPalette)

  00266	83 7c 24 48 00	 cmp	 DWORD PTR OnPalette$1[rsp], 0
  0026b	74 6c		 je	 SHORT $LN13@readPpuReg

; 490  :             {
; 491  :                 Ppu->VRamDataBuffer = readPpu8(Ppu->VRamIO.VRamAdrs-0x1000, Ppu);

  0026d	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  00272	0f b7 80 74 12
	00 00		 movzx	 eax, WORD PTR [rax+4724]
  00279	2d 00 10 00 00	 sub	 eax, 4096		; 00001000H
  0027e	48 8b 54 24 28	 mov	 rdx, QWORD PTR Ppu$[rsp]
  00283	0f b7 c8	 movzx	 ecx, ax
  00286	e8 00 00 00 00	 call	 ?readPpu8@@YAEGPEAUppu@@@Z ; readPpu8
  0028b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00290	88 81 59 10 00
	00		 mov	 BYTE PTR [rcx+4185], al

; 492  :                 Byte = readPpu8(Ppu->VRamIO.VRamAdrs, Ppu);

  00296	48 8b 54 24 28	 mov	 rdx, QWORD PTR Ppu$[rsp]
  0029b	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  002a0	0f b7 88 74 12
	00 00		 movzx	 ecx, WORD PTR [rax+4724]
  002a7	e8 00 00 00 00	 call	 ?readPpu8@@YAEGPEAUppu@@@Z ; readPpu8
  002ac	88 44 24 20	 mov	 BYTE PTR Byte$[rsp], al

; 493  : 
; 494  :                 // Pulled from nes dev forum
; 495  :                 Byte &= 0x3F;

  002b0	0f b6 44 24 20	 movzx	 eax, BYTE PTR Byte$[rsp]
  002b5	83 e0 3f	 and	 eax, 63			; 0000003fH
  002b8	88 44 24 20	 mov	 BYTE PTR Byte$[rsp], al

; 496  :                 Byte |= Ppu->OpenBus & 0xC0;

  002bc	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  002c1	0f b6 40 10	 movzx	 eax, BYTE PTR [rax+16]
  002c5	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  002ca	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Byte$[rsp]
  002cf	0b c8		 or	 ecx, eax
  002d1	8b c1		 mov	 eax, ecx
  002d3	88 44 24 20	 mov	 BYTE PTR Byte$[rsp], al

; 497  :             }
; 498  :             else

  002d7	eb 31		 jmp	 SHORT $LN14@readPpuReg
$LN13@readPpuReg:

; 499  :             {
; 500  :                 Byte = Ppu->VRamDataBuffer;

  002d9	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  002de	0f b6 80 59 10
	00 00		 movzx	 eax, BYTE PTR [rax+4185]
  002e5	88 44 24 20	 mov	 BYTE PTR Byte$[rsp], al

; 501  :                 Ppu->VRamDataBuffer = readPpu8(Ppu->VRamIO.VRamAdrs, Ppu);

  002e9	48 8b 54 24 28	 mov	 rdx, QWORD PTR Ppu$[rsp]
  002ee	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  002f3	0f b7 88 74 12
	00 00		 movzx	 ecx, WORD PTR [rax+4724]
  002fa	e8 00 00 00 00	 call	 ?readPpu8@@YAEGPEAUppu@@@Z ; readPpu8
  002ff	48 8b 4c 24 28	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00304	88 81 59 10 00
	00		 mov	 BYTE PTR [rcx+4185], al
$LN14@readPpuReg:

; 502  :             }
; 503  : 
; 504  :             if( !(Ppu->ShowBackground || Ppu->ShowSprites) ||

  0030a	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  0030f	83 b8 38 10 00
	00 00		 cmp	 DWORD PTR [rax+4152], 0
  00316	75 0e		 jne	 SHORT $LN17@readPpuReg
  00318	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  0031d	83 b8 3c 10 00
	00 00		 cmp	 DWORD PTR [rax+4156], 0
  00324	74 26		 je	 SHORT $LN16@readPpuReg
$LN17@readPpuReg:
  00326	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  0032b	0f b7 80 70 12
	00 00		 movzx	 eax, WORD PTR [rax+4720]
  00332	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  00337	7e 3b		 jle	 SHORT $LN15@readPpuReg
  00339	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  0033e	0f b7 80 70 12
	00 00		 movzx	 eax, WORD PTR [rax+4720]
  00345	3d 04 01 00 00	 cmp	 eax, 260		; 00000104H
  0034a	7f 28		 jg	 SHORT $LN15@readPpuReg
$LN16@readPpuReg:

; 505  :                 (Ppu->Scanline > 240 && Ppu->Scanline <= 260) )
; 506  :             {            
; 507  :                 Ppu->VRamIO.VRamAdrs += Ppu->VRamIncrement;

  0034c	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  00351	0f b6 80 19 10
	00 00		 movzx	 eax, BYTE PTR [rax+4121]
  00358	48 8b 4c 24 28	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0035d	0f b7 89 74 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4724]
  00364	03 c8		 add	 ecx, eax
  00366	8b c1		 mov	 eax, ecx
  00368	48 8b 4c 24 28	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0036d	66 89 81 74 12
	00 00		 mov	 WORD PTR [rcx+4724], ax
$LN15@readPpuReg:

; 508  :             }
; 509  :                         
; 510  :             Ppu->OpenBus = Byte;

  00374	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  00379	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Byte$[rsp]
  0037e	88 48 10	 mov	 BYTE PTR [rax+16], cl
$LN2@readPpuReg:

; 511  :             break;
; 512  :         }
; 513  :         case 0x4014:
; 514  :         {
; 515  :             break;
; 516  :         }
; 517  :     }
; 518  : 
; 519  :     return Ppu->OpenBus;

  00381	48 8b 44 24 28	 mov	 rax, QWORD PTR Ppu$[rsp]
  00386	0f b6 40 10	 movzx	 eax, BYTE PTR [rax+16]

; 520  : }

  0038a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0038e	c3		 ret	 0
?readPpuRegister@@YAEG@Z ENDP				; readPpuRegister
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
BytesRead$1 = 64
FileData$ = 72
FileHandle$ = 80
Filesize$2 = 88
Filename$ = 112
Size$ = 120
?LoadFile@@YAPEAXPEADPEAI@Z PROC			; LoadFile

; 278  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 279  :     void *FileData = 0;

  0000e	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR FileData$[rsp], 0

; 280  :     
; 281  :     HANDLE FileHandle = CreateFileA(Filename, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);

  00017	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00020	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00028	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  00030	45 33 c9	 xor	 r9d, r9d
  00033	41 b8 01 00 00
	00		 mov	 r8d, 1
  00039	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  0003e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Filename$[rsp]
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileA
  00049	48 89 44 24 50	 mov	 QWORD PTR FileHandle$[rsp], rax

; 282  :     if(FileHandle != INVALID_HANDLE_VALUE)

  0004e	48 83 7c 24 50
	ff		 cmp	 QWORD PTR FileHandle$[rsp], -1
  00054	0f 84 8b 00 00
	00		 je	 $LN2@LoadFile

; 283  :     {
; 284  :         LARGE_INTEGER Filesize;
; 285  :         if(GetFileSizeEx(FileHandle, &Filesize))

  0005a	48 8d 54 24 58	 lea	 rdx, QWORD PTR Filesize$2[rsp]
  0005f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR FileHandle$[rsp]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileSizeEx
  0006a	85 c0		 test	 eax, eax
  0006c	74 77		 je	 SHORT $LN4@LoadFile

; 286  :         {
; 287  :             FileData = VirtualAlloc(0, Filesize.LowPart, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);

  0006e	8b 44 24 58	 mov	 eax, DWORD PTR Filesize$2[rsp]
  00072	41 b9 04 00 00
	00		 mov	 r9d, 4
  00078	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  0007e	8b d0		 mov	 edx, eax
  00080	33 c9		 xor	 ecx, ecx
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  00088	48 89 44 24 48	 mov	 QWORD PTR FileData$[rsp], rax

; 288  :             if(FileData)

  0008d	48 83 7c 24 48
	00		 cmp	 QWORD PTR FileData$[rsp], 0
  00093	74 50		 je	 SHORT $LN6@LoadFile

; 289  :             {
; 290  :                 DWORD BytesRead;
; 291  :                 if(ReadFile(FileHandle, FileData, Filesize.LowPart, &BytesRead, 0) &&

  00095	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0009e	4c 8d 4c 24 40	 lea	 r9, QWORD PTR BytesRead$1[rsp]
  000a3	44 8b 44 24 58	 mov	 r8d, DWORD PTR Filesize$2[rsp]
  000a8	48 8b 54 24 48	 mov	 rdx, QWORD PTR FileData$[rsp]
  000ad	48 8b 4c 24 50	 mov	 rcx, QWORD PTR FileHandle$[rsp]
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReadFile
  000b8	85 c0		 test	 eax, eax
  000ba	74 17		 je	 SHORT $LN8@LoadFile
  000bc	8b 44 24 40	 mov	 eax, DWORD PTR BytesRead$1[rsp]
  000c0	39 44 24 58	 cmp	 DWORD PTR Filesize$2[rsp], eax
  000c4	75 0d		 jne	 SHORT $LN8@LoadFile

; 292  :                    (Filesize.LowPart == BytesRead))
; 293  :                 {
; 294  :                     *Size = (uint32)BytesRead;

  000c6	48 8b 44 24 78	 mov	 rax, QWORD PTR Size$[rsp]
  000cb	8b 4c 24 40	 mov	 ecx, DWORD PTR BytesRead$1[rsp]
  000cf	89 08		 mov	 DWORD PTR [rax], ecx

; 295  :                     // It worked!
; 296  :                 }
; 297  :                 else

  000d1	eb 12		 jmp	 SHORT $LN9@LoadFile
$LN8@LoadFile:

; 298  :                 {
; 299  :                     Assert(0);

  000d3	33 c0		 xor	 eax, eax
  000d5	83 f8 01	 cmp	 eax, 1
  000d8	74 0b		 je	 SHORT $LN10@LoadFile
  000da	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN10@LoadFile:
$LN9@LoadFile:
$LN6@LoadFile:
$LN4@LoadFile:
$LN2@LoadFile:

; 300  :                 }
; 301  :             }
; 302  :             else
; 303  :             {
; 304  :             }   
; 305  :         }
; 306  :         else
; 307  :         {
; 308  :         }
; 309  :     }
; 310  :     else
; 311  :     {
; 312  : //        Assert(0);
; 313  :     }
; 314  :     return(FileData);

  000e5	48 8b 44 24 48	 mov	 rax, QWORD PTR FileData$[rsp]

; 315  : }

  000ea	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000ee	c3		 ret	 0
?LoadFile@@YAPEAXPEADPEAI@Z ENDP			; LoadFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
tv64 = 32
IsDown$1 = 36
NameSize$2 = 40
tv146 = 44
tv67 = 48
tv70 = 52
tv73 = 56
tv79 = 60
tv83 = 64
tv87 = 68
tv91 = 72
tv95 = 76
tv131 = 80
tv135 = 84
tv139 = 88
tv75 = 96
WasDown$3 = 104
AltPressed$4 = 108
FileOpened$5 = 112
Result$ = 120
newRom$6 = 128
tempFileName$7 = 288
__$ArrayPad$ = 544
WindowHandle$ = 576
Message$ = 584
wParam$ = 592
lParam$ = 600
?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z PROC		; WinInputCallback

; 110  : {

$LN60:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec 30 02
	00 00		 sub	 rsp, 560		; 00000230H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 111  :     LRESULT Result = 0;

  0002d	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR Result$[rsp], 0

; 112  :     
; 113  :     switch(Message) 

  00036	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR Message$[rsp]
  0003d	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  00041	83 7c 24 20 10	 cmp	 DWORD PTR tv64[rsp], 16
  00046	77 21		 ja	 SHORT $LN57@WinInputCa
  00048	83 7c 24 20 10	 cmp	 DWORD PTR tv64[rsp], 16
  0004d	74 67		 je	 SHORT $LN10@WinInputCa
  0004f	83 7c 24 20 01	 cmp	 DWORD PTR tv64[rsp], 1
  00054	74 56		 je	 SHORT $LN8@WinInputCa
  00056	83 7c 24 20 02	 cmp	 DWORD PTR tv64[rsp], 2
  0005b	74 68		 je	 SHORT $LN11@WinInputCa
  0005d	83 7c 24 20 05	 cmp	 DWORD PTR tv64[rsp], 5
  00062	74 4d		 je	 SHORT $LN9@WinInputCa
  00064	e9 92 04 00 00	 jmp	 $LN33@WinInputCa
$LN57@WinInputCa:
  00069	81 7c 24 20 00
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 256 ; 00000100H
  00071	0f 82 84 04 00
	00		 jb	 $LN33@WinInputCa
  00077	81 7c 24 20 01
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 257 ; 00000101H
  0007f	76 49		 jbe	 SHORT $LN12@WinInputCa
  00081	81 7c 24 20 03
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 259 ; 00000103H
  00089	0f 86 6c 04 00
	00		 jbe	 $LN33@WinInputCa
  0008f	81 7c 24 20 05
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 261 ; 00000105H
  00097	76 31		 jbe	 SHORT $LN12@WinInputCa
  00099	81 7c 24 20 11
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 273 ; 00000111H
  000a1	0f 84 c5 02 00
	00		 je	 $LN26@WinInputCa
  000a7	e9 4f 04 00 00	 jmp	 $LN33@WinInputCa
$LN8@WinInputCa:

; 114  :     { 
; 115  :         case WM_CREATE:
; 116  :         {
; 117  :             // Initialize the window. 
; 118  :             break; 

  000ac	e9 74 04 00 00	 jmp	 $LN2@WinInputCa
$LN9@WinInputCa:

; 119  :         }
; 120  :         
; 121  :         case WM_SIZE:
; 122  :         {
; 123  :             // Set the size and position of the window. 
; 124  :             break;

  000b1	e9 6f 04 00 00	 jmp	 $LN2@WinInputCa
$LN10@WinInputCa:

; 125  :         }
; 126  :         case WM_CLOSE:
; 127  :         {
; 128  :             GlobalRunning = false;

  000b6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0

; 129  :             break;

  000c0	e9 60 04 00 00	 jmp	 $LN2@WinInputCa
$LN11@WinInputCa:

; 130  :         }
; 131  :         case WM_DESTROY:
; 132  :         {
; 133  :             break;

  000c5	e9 5b 04 00 00	 jmp	 $LN2@WinInputCa
$LN12@WinInputCa:

; 134  :         }
; 135  :         case WM_SYSKEYDOWN:
; 136  :         case WM_SYSKEYUP:
; 137  :         case WM_KEYDOWN:
; 138  :         case WM_KEYUP:
; 139  :         {
; 140  :             bool32 IsDown = ((lParam & (1<<31)) == 0);

  000ca	48 8b 84 24 58
	02 00 00	 mov	 rax, QWORD PTR lParam$[rsp]
  000d2	48 25 00 00 00
	80		 and	 rax, -2147483648	; ffffffff80000000H
  000d8	48 85 c0	 test	 rax, rax
  000db	75 0a		 jne	 SHORT $LN35@WinInputCa
  000dd	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  000e5	eb 08		 jmp	 SHORT $LN36@WinInputCa
$LN35@WinInputCa:
  000e7	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN36@WinInputCa:
  000ef	8b 44 24 30	 mov	 eax, DWORD PTR tv67[rsp]
  000f3	89 44 24 24	 mov	 DWORD PTR IsDown$1[rsp], eax

; 141  :             bool32 WasDown = ((lParam & (1<<30)) != 0);

  000f7	48 8b 84 24 58
	02 00 00	 mov	 rax, QWORD PTR lParam$[rsp]
  000ff	48 25 00 00 00
	40		 and	 rax, 1073741824		; 40000000H
  00105	48 85 c0	 test	 rax, rax
  00108	74 0a		 je	 SHORT $LN37@WinInputCa
  0010a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00112	eb 08		 jmp	 SHORT $LN38@WinInputCa
$LN37@WinInputCa:
  00114	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN38@WinInputCa:
  0011c	8b 44 24 34	 mov	 eax, DWORD PTR tv70[rsp]
  00120	89 44 24 68	 mov	 DWORD PTR WasDown$3[rsp], eax

; 142  : 
; 143  :             // NOTE: Alt only on SYSDOWN messages
; 144  :             bool32 AltPressed = ((lParam & (1<<29)) != 0);

  00124	48 8b 84 24 58
	02 00 00	 mov	 rax, QWORD PTR lParam$[rsp]
  0012c	48 25 00 00 00
	20		 and	 rax, 536870912		; 20000000H
  00132	48 85 c0	 test	 rax, rax
  00135	74 0a		 je	 SHORT $LN39@WinInputCa
  00137	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  0013f	eb 08		 jmp	 SHORT $LN40@WinInputCa
$LN39@WinInputCa:
  00141	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN40@WinInputCa:
  00149	8b 44 24 38	 mov	 eax, DWORD PTR tv73[rsp]
  0014d	89 44 24 6c	 mov	 DWORD PTR AltPressed$4[rsp], eax

; 145  :             
; 146  :             if(IsDown != WasDown)

  00151	8b 44 24 68	 mov	 eax, DWORD PTR WasDown$3[rsp]
  00155	39 44 24 24	 cmp	 DWORD PTR IsDown$1[rsp], eax
  00159	0f 84 08 02 00
	00		 je	 $LN13@WinInputCa

; 147  :             {  
; 148  :                 switch(wParam)

  0015f	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR wParam$[rsp]
  00167	48 89 44 24 60	 mov	 QWORD PTR tv75[rsp], rax
  0016c	48 8b 44 24 60	 mov	 rax, QWORD PTR tv75[rsp]
  00171	48 83 e8 0d	 sub	 rax, 13
  00175	48 89 44 24 60	 mov	 QWORD PTR tv75[rsp], rax
  0017a	48 83 7c 24 60
	66		 cmp	 QWORD PTR tv75[rsp], 102 ; 00000066H
  00180	0f 87 e1 01 00
	00		 ja	 $LN4@WinInputCa
  00186	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:__ImageBase
  0018d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv75[rsp]
  00192	0f b6 8c 08 00
	00 00 00	 movzx	 ecx, BYTE PTR $LN58@WinInputCa[rax+rcx]
  0019a	8b 8c 88 00 00
	00 00		 mov	 ecx, DWORD PTR $LN59@WinInputCa[rax+rcx*4]
  001a1	48 03 c8	 add	 rcx, rax
  001a4	ff e1		 jmp	 rcx
$LN14@WinInputCa:

; 149  :                 {
; 150  :                     case VK_UP:
; 151  :                     {
; 152  :                         WinInput.buttons[input::B_UP] = IsDown ? 1 : 0;

  001a6	83 7c 24 24 00	 cmp	 DWORD PTR IsDown$1[rsp], 0
  001ab	74 0a		 je	 SHORT $LN41@WinInputCa
  001ad	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  001b5	eb 08		 jmp	 SHORT $LN42@WinInputCa
$LN41@WinInputCa:
  001b7	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN42@WinInputCa:
  001bf	b8 04 00 00 00	 mov	 eax, 4
  001c4	48 6b c0 04	 imul	 rax, rax, 4
  001c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  001cf	8b 54 24 3c	 mov	 edx, DWORD PTR tv79[rsp]
  001d3	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 153  :                         break;

  001d6	e9 8c 01 00 00	 jmp	 $LN4@WinInputCa
$LN15@WinInputCa:

; 154  :                     }
; 155  :                     case VK_DOWN:
; 156  :                     {
; 157  :                         WinInput.buttons[input::B_DOWN] = IsDown ? 1 : 0;

  001db	83 7c 24 24 00	 cmp	 DWORD PTR IsDown$1[rsp], 0
  001e0	74 0a		 je	 SHORT $LN43@WinInputCa
  001e2	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv83[rsp], 1
  001ea	eb 08		 jmp	 SHORT $LN44@WinInputCa
$LN43@WinInputCa:
  001ec	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
$LN44@WinInputCa:
  001f4	b8 04 00 00 00	 mov	 eax, 4
  001f9	48 6b c0 05	 imul	 rax, rax, 5
  001fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00204	8b 54 24 40	 mov	 edx, DWORD PTR tv83[rsp]
  00208	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 158  :                         break;

  0020b	e9 57 01 00 00	 jmp	 $LN4@WinInputCa
$LN16@WinInputCa:

; 159  :                     }
; 160  :                     case VK_LEFT:
; 161  :                     {
; 162  :                         WinInput.buttons[input::B_LEFT] = IsDown ? 1 : 0;

  00210	83 7c 24 24 00	 cmp	 DWORD PTR IsDown$1[rsp], 0
  00215	74 0a		 je	 SHORT $LN45@WinInputCa
  00217	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv87[rsp], 1
  0021f	eb 08		 jmp	 SHORT $LN46@WinInputCa
$LN45@WinInputCa:
  00221	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
$LN46@WinInputCa:
  00229	b8 04 00 00 00	 mov	 eax, 4
  0022e	48 6b c0 06	 imul	 rax, rax, 6
  00232	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00239	8b 54 24 44	 mov	 edx, DWORD PTR tv87[rsp]
  0023d	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 163  :                         break;

  00240	e9 22 01 00 00	 jmp	 $LN4@WinInputCa
$LN17@WinInputCa:

; 164  :                     }
; 165  :                     case VK_RIGHT:
; 166  :                     {
; 167  :                         WinInput.buttons[input::B_RIGHT] = IsDown ? 1 : 0;

  00245	83 7c 24 24 00	 cmp	 DWORD PTR IsDown$1[rsp], 0
  0024a	74 0a		 je	 SHORT $LN47@WinInputCa
  0024c	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
  00254	eb 08		 jmp	 SHORT $LN48@WinInputCa
$LN47@WinInputCa:
  00256	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
$LN48@WinInputCa:
  0025e	b8 04 00 00 00	 mov	 eax, 4
  00263	48 6b c0 07	 imul	 rax, rax, 7
  00267	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0026e	8b 54 24 48	 mov	 edx, DWORD PTR tv91[rsp]
  00272	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 168  :                         break;

  00275	e9 ed 00 00 00	 jmp	 $LN4@WinInputCa
$LN18@WinInputCa:

; 169  :                     }
; 170  :                     case 'Z':
; 171  :                     {
; 172  :                         WinInput.buttons[input::B_A] = IsDown ? 1 : 0;

  0027a	83 7c 24 24 00	 cmp	 DWORD PTR IsDown$1[rsp], 0
  0027f	74 0a		 je	 SHORT $LN49@WinInputCa
  00281	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv95[rsp], 1
  00289	eb 08		 jmp	 SHORT $LN50@WinInputCa
$LN49@WinInputCa:
  0028b	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
$LN50@WinInputCa:
  00293	b8 04 00 00 00	 mov	 eax, 4
  00298	48 6b c0 00	 imul	 rax, rax, 0
  0029c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  002a3	8b 54 24 4c	 mov	 edx, DWORD PTR tv95[rsp]
  002a7	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 173  :                         break;

  002aa	e9 b8 00 00 00	 jmp	 $LN4@WinInputCa
$LN19@WinInputCa:

; 174  :                     }
; 175  :                     case 'X':
; 176  :                     {
; 177  :                         WinInput.buttons[input::B_B] = IsDown ? 1 : 0;

  002af	83 7c 24 24 00	 cmp	 DWORD PTR IsDown$1[rsp], 0
  002b4	74 0a		 je	 SHORT $LN51@WinInputCa
  002b6	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  002be	eb 08		 jmp	 SHORT $LN52@WinInputCa
$LN51@WinInputCa:
  002c0	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN52@WinInputCa:
  002c8	b8 04 00 00 00	 mov	 eax, 4
  002cd	48 6b c0 01	 imul	 rax, rax, 1
  002d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  002d8	8b 54 24 50	 mov	 edx, DWORD PTR tv131[rsp]
  002dc	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 178  :                         break;

  002df	e9 83 00 00 00	 jmp	 $LN4@WinInputCa
$LN20@WinInputCa:

; 179  :                     }
; 180  :                     case VK_RETURN:
; 181  :                     {
; 182  :                         WinInput.buttons[input::B_START] = IsDown ? 1 : 0;

  002e4	83 7c 24 24 00	 cmp	 DWORD PTR IsDown$1[rsp], 0
  002e9	74 0a		 je	 SHORT $LN53@WinInputCa
  002eb	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv135[rsp], 1
  002f3	eb 08		 jmp	 SHORT $LN54@WinInputCa
$LN53@WinInputCa:
  002f5	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN54@WinInputCa:
  002fd	b8 04 00 00 00	 mov	 eax, 4
  00302	48 6b c0 03	 imul	 rax, rax, 3
  00306	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0030d	8b 54 24 54	 mov	 edx, DWORD PTR tv135[rsp]
  00311	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 183  :                         break;

  00314	eb 51		 jmp	 SHORT $LN4@WinInputCa
$LN21@WinInputCa:

; 184  :                     }
; 185  :                     case VK_SHIFT:
; 186  :                     {
; 187  :                         WinInput.buttons[input::B_SELECT] = IsDown ? 1 : 0;

  00316	83 7c 24 24 00	 cmp	 DWORD PTR IsDown$1[rsp], 0
  0031b	74 0a		 je	 SHORT $LN55@WinInputCa
  0031d	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv139[rsp], 1
  00325	eb 08		 jmp	 SHORT $LN56@WinInputCa
$LN55@WinInputCa:
  00327	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv139[rsp], 0
$LN56@WinInputCa:
  0032f	b8 04 00 00 00	 mov	 eax, 4
  00334	48 6b c0 02	 imul	 rax, rax, 2
  00338	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0033f	8b 54 24 58	 mov	 edx, DWORD PTR tv139[rsp]
  00343	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 188  :                         break;

  00346	eb 1f		 jmp	 SHORT $LN4@WinInputCa

; 189  :                     }
; 190  :                     case VK_SPACE:
; 191  :                     {                        
; 192  :                         break;

  00348	eb 1d		 jmp	 SHORT $LN4@WinInputCa
$LN23@WinInputCa:

; 193  :                     }
; 194  :                     case VK_ESCAPE:
; 195  :                     {
; 196  :                         GlobalRunning = false;

  0034a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0

; 197  :                         break;

  00354	eb 11		 jmp	 SHORT $LN4@WinInputCa
$LN24@WinInputCa:

; 198  :                     }
; 199  :                     case VK_F4:
; 200  :                     {
; 201  :                         if(AltPressed)

  00356	83 7c 24 6c 00	 cmp	 DWORD PTR AltPressed$4[rsp], 0
  0035b	74 0a		 je	 SHORT $LN25@WinInputCa

; 202  :                         {
; 203  :                             GlobalRunning = false;

  0035d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0
$LN25@WinInputCa:
$LN4@WinInputCa:
$LN13@WinInputCa:

; 204  :                         }
; 205  :                         break;
; 206  :                     }
; 207  :                 }
; 208  :             }
; 209  :             break;

  00367	e9 b9 01 00 00	 jmp	 $LN2@WinInputCa
$LN26@WinInputCa:

; 210  :         }
; 211  :         
; 212  :         case WM_COMMAND:
; 213  :         {
; 214  :             switch(LOWORD(wParam))

  0036c	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR wParam$[rsp]
  00374	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  0037a	0f b7 c0	 movzx	 eax, ax
  0037d	89 44 24 2c	 mov	 DWORD PTR tv146[rsp], eax
  00381	81 7c 24 2c e9
	03 00 00	 cmp	 DWORD PTR tv146[rsp], 1001 ; 000003e9H
  00389	74 21		 je	 SHORT $LN27@WinInputCa
  0038b	81 7c 24 2c ea
	03 00 00	 cmp	 DWORD PTR tv146[rsp], 1002 ; 000003eaH
  00393	0f 84 36 01 00
	00		 je	 $LN31@WinInputCa
  00399	81 7c 24 2c eb
	03 00 00	 cmp	 DWORD PTR tv146[rsp], 1003 ; 000003ebH
  003a1	0f 84 48 01 00
	00		 je	 $LN32@WinInputCa
  003a7	e9 4d 01 00 00	 jmp	 $LN6@WinInputCa
$LN27@WinInputCa:

; 215  :             {
; 216  :                 case ID_OPEN_ROM_ITEM:
; 217  :                 {
; 218  :                     char tempFileName[256];
; 219  :                     
; 220  :                     OPENFILENAMEA newRom = {};

  003ac	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR newRom$6[rsp]
  003b4	48 8b f8	 mov	 rdi, rax
  003b7	33 c0		 xor	 eax, eax
  003b9	b9 98 00 00 00	 mov	 ecx, 152		; 00000098H
  003be	f3 aa		 rep stosb

; 221  :                     newRom.lStructSize = sizeof(OPENFILENAME);

  003c0	c7 84 24 80 00
	00 00 98 00 00
	00		 mov	 DWORD PTR newRom$6[rsp], 152 ; 00000098H

; 222  :                     newRom.hwndOwner = WindowHandle;

  003cb	48 8b 84 24 40
	02 00 00	 mov	 rax, QWORD PTR WindowHandle$[rsp]
  003d3	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR newRom$6[rsp+8], rax

; 223  :                     newRom.lpstrFile = tempFileName;

  003db	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR tempFileName$7[rsp]
  003e3	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR newRom$6[rsp+48], rax

; 224  :                     newRom.lpstrFile[0] = '\0';

  003eb	b8 01 00 00 00	 mov	 eax, 1
  003f0	48 6b c0 00	 imul	 rax, rax, 0
  003f4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR newRom$6[rsp+48]
  003fc	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 225  :                     newRom.nMaxFile = sizeof(tempFileName);

  00400	c7 84 24 b8 00
	00 00 00 01 00
	00		 mov	 DWORD PTR newRom$6[rsp+56], 256 ; 00000100H

; 226  :                     newRom.lpstrFilter = ".nes\0*.nes\0";

  0040b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG87661
  00412	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR newRom$6[rsp+24], rax

; 227  :                     newRom.nFilterIndex =1;

  0041a	c7 84 24 ac 00
	00 00 01 00 00
	00		 mov	 DWORD PTR newRom$6[rsp+44], 1

; 228  :                     newRom.lpstrFileTitle = NULL ;

  00425	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR newRom$6[rsp+64], 0

; 229  :                     newRom.nMaxFileTitle = 0 ;

  00431	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR newRom$6[rsp+72], 0

; 230  :                     newRom.lpstrInitialDir=NULL ;

  0043c	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR newRom$6[rsp+80], 0

; 231  :                     newRom.Flags = OFN_PATHMUSTEXIST|OFN_FILEMUSTEXIST ;

  00448	c7 84 24 e0 00
	00 00 00 18 00
	00		 mov	 DWORD PTR newRom$6[rsp+96], 6144 ; 00001800H

; 232  : 
; 233  :                     bool32 FileOpened = GetOpenFileName(&newRom); 

  00453	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR newRom$6[rsp]
  0045b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetOpenFileNameA
  00461	89 44 24 70	 mov	 DWORD PTR FileOpened$5[rsp], eax

; 234  :                     
; 235  :                     if(FileOpened) // If exists then restart emulator with new file 

  00465	83 7c 24 70 00	 cmp	 DWORD PTR FileOpened$5[rsp], 0
  0046a	74 61		 je	 SHORT $LN28@WinInputCa

; 236  :                     {
; 237  :                         ZeroMemory(&RomFileName, sizeof(RomFileName));

  0046c	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00472	33 d2		 xor	 edx, edx
  00474	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?RomFileName@@3PADA
  0047b	e8 00 00 00 00	 call	 memset

; 238  :                         uint8 NameSize = strlen(tempFileName);

  00480	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR tempFileName$7[rsp]
  00488	e8 00 00 00 00	 call	 strlen
  0048d	88 44 24 28	 mov	 BYTE PTR NameSize$2[rsp], al

; 239  :                         cpyMemory((uint8 *)RomFileName, (uint8 *)tempFileName, NameSize);

  00491	0f b6 44 24 28	 movzx	 eax, BYTE PTR NameSize$2[rsp]
  00496	44 0f b7 c0	 movzx	 r8d, ax
  0049a	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR tempFileName$7[rsp]
  004a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?RomFileName@@3PADA
  004a9	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 240  :                         
; 241  :                         if(PowerOn)

  004ae	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PowerOn@@3HA, 0
  004b5	74 0c		 je	 SHORT $LN29@WinInputCa

; 242  :                         {
; 243  :                             ResetHit = true;

  004b7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?ResetHit@@3HA, 1

; 244  :                         }
; 245  :                         else

  004c1	eb 0a		 jmp	 SHORT $LN30@WinInputCa
$LN29@WinInputCa:

; 246  :                         {
; 247  :                             PowerHit = true;

  004c3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?PowerHit@@3HA, 1
$LN30@WinInputCa:
$LN28@WinInputCa:

; 248  :                         }
; 249  :                     }
; 250  :                     
; 251  :                     break;

  004cd	eb 2a		 jmp	 SHORT $LN6@WinInputCa
$LN31@WinInputCa:

; 252  :                 }
; 253  :                 case ID_CLOSE_ROM_ITEM:
; 254  :                 {
; 255  :                     ZeroMemory(&RomFileName, sizeof(RomFileName));

  004cf	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  004d5	33 d2		 xor	 edx, edx
  004d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?RomFileName@@3PADA
  004de	e8 00 00 00 00	 call	 memset

; 256  :                     PowerHit = true;

  004e3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?PowerHit@@3HA, 1

; 257  :                     break;

  004ed	eb 0a		 jmp	 SHORT $LN6@WinInputCa
$LN32@WinInputCa:

; 258  :                 }
; 259  :                 case ID_QUIT_ITEM:
; 260  :                 {
; 261  :                     GlobalRunning = false;

  004ef	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0
$LN6@WinInputCa:

; 262  :                     break;
; 263  :                 }
; 264  :             }
; 265  :             break;

  004f9	eb 2a		 jmp	 SHORT $LN2@WinInputCa
$LN33@WinInputCa:

; 266  :         }
; 267  :                 
; 268  :         default:
; 269  :         {
; 270  :             Result = DefWindowProc(WindowHandle, Message, wParam, lParam);

  004fb	4c 8b 8c 24 58
	02 00 00	 mov	 r9, QWORD PTR lParam$[rsp]
  00503	4c 8b 84 24 50
	02 00 00	 mov	 r8, QWORD PTR wParam$[rsp]
  0050b	8b 94 24 48 02
	00 00		 mov	 edx, DWORD PTR Message$[rsp]
  00512	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR WindowHandle$[rsp]
  0051a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DefWindowProcA
  00520	48 89 44 24 78	 mov	 QWORD PTR Result$[rsp], rax
$LN2@WinInputCa:

; 271  :             break;
; 272  :         }
; 273  :     }
; 274  :     return Result;

  00525	48 8b 44 24 78	 mov	 rax, QWORD PTR Result$[rsp]

; 275  : }

  0052a	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00532	48 33 cc	 xor	 rcx, rsp
  00535	e8 00 00 00 00	 call	 __security_check_cookie
  0053a	48 81 c4 30 02
	00 00		 add	 rsp, 560		; 00000230H
  00541	5f		 pop	 rdi
  00542	c3		 ret	 0
  00543	90		 npad	 1
$LN59@WinInputCa:
  00544	00 00 00 00	 DD	 $LN20@WinInputCa
  00548	00 00 00 00	 DD	 $LN21@WinInputCa
  0054c	00 00 00 00	 DD	 $LN23@WinInputCa
  00550	00 00 00 00	 DD	 $LN16@WinInputCa
  00554	00 00 00 00	 DD	 $LN14@WinInputCa
  00558	00 00 00 00	 DD	 $LN17@WinInputCa
  0055c	00 00 00 00	 DD	 $LN15@WinInputCa
  00560	00 00 00 00	 DD	 $LN19@WinInputCa
  00564	00 00 00 00	 DD	 $LN18@WinInputCa
  00568	00 00 00 00	 DD	 $LN24@WinInputCa
  0056c	00 00 00 00	 DD	 $LN4@WinInputCa
$LN58@WinInputCa:
  00570	00		 DB	 0
  00571	0a		 DB	 10
  00572	0a		 DB	 10
  00573	01		 DB	 1
  00574	0a		 DB	 10
  00575	0a		 DB	 10
  00576	0a		 DB	 10
  00577	0a		 DB	 10
  00578	0a		 DB	 10
  00579	0a		 DB	 10
  0057a	0a		 DB	 10
  0057b	0a		 DB	 10
  0057c	0a		 DB	 10
  0057d	0a		 DB	 10
  0057e	02		 DB	 2
  0057f	0a		 DB	 10
  00580	0a		 DB	 10
  00581	0a		 DB	 10
  00582	0a		 DB	 10
  00583	0a		 DB	 10
  00584	0a		 DB	 10
  00585	0a		 DB	 10
  00586	0a		 DB	 10
  00587	0a		 DB	 10
  00588	03		 DB	 3
  00589	04		 DB	 4
  0058a	05		 DB	 5
  0058b	06		 DB	 6
  0058c	0a		 DB	 10
  0058d	0a		 DB	 10
  0058e	0a		 DB	 10
  0058f	0a		 DB	 10
  00590	0a		 DB	 10
  00591	0a		 DB	 10
  00592	0a		 DB	 10
  00593	0a		 DB	 10
  00594	0a		 DB	 10
  00595	0a		 DB	 10
  00596	0a		 DB	 10
  00597	0a		 DB	 10
  00598	0a		 DB	 10
  00599	0a		 DB	 10
  0059a	0a		 DB	 10
  0059b	0a		 DB	 10
  0059c	0a		 DB	 10
  0059d	0a		 DB	 10
  0059e	0a		 DB	 10
  0059f	0a		 DB	 10
  005a0	0a		 DB	 10
  005a1	0a		 DB	 10
  005a2	0a		 DB	 10
  005a3	0a		 DB	 10
  005a4	0a		 DB	 10
  005a5	0a		 DB	 10
  005a6	0a		 DB	 10
  005a7	0a		 DB	 10
  005a8	0a		 DB	 10
  005a9	0a		 DB	 10
  005aa	0a		 DB	 10
  005ab	0a		 DB	 10
  005ac	0a		 DB	 10
  005ad	0a		 DB	 10
  005ae	0a		 DB	 10
  005af	0a		 DB	 10
  005b0	0a		 DB	 10
  005b1	0a		 DB	 10
  005b2	0a		 DB	 10
  005b3	0a		 DB	 10
  005b4	0a		 DB	 10
  005b5	0a		 DB	 10
  005b6	0a		 DB	 10
  005b7	0a		 DB	 10
  005b8	0a		 DB	 10
  005b9	0a		 DB	 10
  005ba	0a		 DB	 10
  005bb	07		 DB	 7
  005bc	0a		 DB	 10
  005bd	08		 DB	 8
  005be	0a		 DB	 10
  005bf	0a		 DB	 10
  005c0	0a		 DB	 10
  005c1	0a		 DB	 10
  005c2	0a		 DB	 10
  005c3	0a		 DB	 10
  005c4	0a		 DB	 10
  005c5	0a		 DB	 10
  005c6	0a		 DB	 10
  005c7	0a		 DB	 10
  005c8	0a		 DB	 10
  005c9	0a		 DB	 10
  005ca	0a		 DB	 10
  005cb	0a		 DB	 10
  005cc	0a		 DB	 10
  005cd	0a		 DB	 10
  005ce	0a		 DB	 10
  005cf	0a		 DB	 10
  005d0	0a		 DB	 10
  005d1	0a		 DB	 10
  005d2	0a		 DB	 10
  005d3	0a		 DB	 10
  005d4	0a		 DB	 10
  005d5	0a		 DB	 10
  005d6	09		 DB	 9
?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z ENDP		; WinInputCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Byte$1 = 0
Dest$ = 32
Src$ = 40
Size$ = 48
?cpyMemory@@YAXPEAE0G@Z PROC				; cpyMemory

; 87   : {

  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	48 83 ec 18	 sub	 rsp, 24

; 88   :     // NOTE: Very basic copy. Not bounds protection
; 89   :     for(uint16 Byte = 0; Byte < Size; ++Byte)

  00014	33 c0		 xor	 eax, eax
  00016	66 89 04 24	 mov	 WORD PTR Byte$1[rsp], ax
  0001a	eb 0b		 jmp	 SHORT $LN4@cpyMemory
$LN2@cpyMemory:
  0001c	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  00020	66 ff c0	 inc	 ax
  00023	66 89 04 24	 mov	 WORD PTR Byte$1[rsp], ax
$LN4@cpyMemory:
  00027	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  0002b	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Size$[rsp]
  00030	3b c1		 cmp	 eax, ecx
  00032	7d 1c		 jge	 SHORT $LN3@cpyMemory

; 90   :         Dest[Byte] = Src[Byte];

  00034	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  00038	0f b7 0c 24	 movzx	 ecx, WORD PTR Byte$1[rsp]
  0003c	48 8b 54 24 20	 mov	 rdx, QWORD PTR Dest$[rsp]
  00041	4c 8b 44 24 28	 mov	 r8, QWORD PTR Src$[rsp]
  00046	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0004b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0004e	eb cc		 jmp	 SHORT $LN2@cpyMemory
$LN3@cpyMemory:

; 91   : }

  00050	48 83 c4 18	 add	 rsp, 24
  00054	c3		 ret	 0
?cpyMemory@@YAXPEAE0G@Z ENDP				; cpyMemory
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
MSElapsed$ = 32
Counter$ = 40
CounterElapsed$ = 48
PerfCountFrequency$ = 80
?getMilliSeconds@@YAM_K@Z PROC				; getMilliSeconds

; 76   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 77   :     LARGE_INTEGER Counter;
; 78   :     QueryPerformanceCounter(&Counter);

  00009	48 8d 4c 24 28	 lea	 rcx, QWORD PTR Counter$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_QueryPerformanceCounter

; 79   :     
; 80   :     uint64 CounterElapsed = Counter.QuadPart;

  00014	48 8b 44 24 28	 mov	 rax, QWORD PTR Counter$[rsp]
  00019	48 89 44 24 30	 mov	 QWORD PTR CounterElapsed$[rsp], rax

; 81   :     real32 MSElapsed = ((1000.0f * (real32)CounterElapsed) / (real32)PerfCountFrequency);

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR CounterElapsed$[rsp]
  00023	f3 48 0f 2a c0	 cvtsi2ss xmm0, rax
  00028	48 85 c0	 test	 rax, rax
  0002b	7d 08		 jge	 SHORT $LN4@getMilliSe
  0002d	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@5f800000
$LN4@getMilliSe:
  00035	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@447a0000
  0003d	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00041	0f 28 c1	 movaps	 xmm0, xmm1
  00044	48 8b 44 24 50	 mov	 rax, QWORD PTR PerfCountFrequency$[rsp]
  00049	f3 48 0f 2a c8	 cvtsi2ss xmm1, rax
  0004e	48 85 c0	 test	 rax, rax
  00051	7d 08		 jge	 SHORT $LN3@getMilliSe
  00053	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@5f800000
$LN3@getMilliSe:
  0005b	f3 0f 5e c1	 divss	 xmm0, xmm1
  0005f	f3 0f 11 44 24
	20		 movss	 DWORD PTR MSElapsed$[rsp], xmm0

; 82   : 
; 83   :     return(MSElapsed);

  00065	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR MSElapsed$[rsp]

; 84   : }

  0006b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006f	c3		 ret	 0
?getMilliSeconds@@YAM_K@Z ENDP				; getMilliSeconds
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  00018	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  0001d	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00022	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00027	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0002c	45 33 c0	 xor	 r8d, r8d
  0002f	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00039	e8 00 00 00 00	 call	 _vsprintf_l
  0003e	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

  00042	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

  0004b	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1788 : }

  0004f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00053	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00027	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  0002c	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00038	e8 00 00 00 00	 call	 _vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 83 c8 01	 or	 rax, 1
  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00029	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00033	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00038	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003d	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00047	48 8b c8	 mov	 rcx, rax
  0004a	e8 00 00 00 00	 call	 __stdio_common_vsprintf
  0004f	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00053	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00058	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005a	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00062	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00064	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  00068	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006c	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1391 : }

  00070	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00074	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File u:\programs\visual studio\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 81   :     static unsigned __int64 _OptionsStorage;
; 82   :     return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 83   : }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
i$1 = 96
ResScale$ = 97
WindowHeight$ = 100
WindowWidth$ = 104
RenderScaleHeight$ = 108
RenderScaleWidth$ = 112
TickCycles$2 = 116
InitialWindowPosY$ = 120
InitialWindowPosX$ = 124
Window$3 = 128
CpuMemorySize$4 = 136
CpuCyclesElapsed$5 = 140
CurrentSecs$6 = 144
PrevSecs$7 = 148
SubMenu$8 = 152
PpuMemorySize$9 = 160
CpuClockRateHz$10 = 164
ElapsedSecs$11 = 168
CpuMemoryBase$12 = 176
PpuMemoryBase$13 = 184
WindowMenu$14 = 192
Memory$15 = 200
DeviceContext$16 = 208
PerfCountFrequency$ = 216
CpuCyclesPerMS$17 = 224
WinPerfCountFrequency$ = 232
tv284 = 240
WindowClass$ = 256
Message$18 = 336
ScreenBackBuffer$ = 384
Nes$19 = 464
MemoryInfoBuffer$20 = 5408
__$ArrayPad$ = 5472
WindowInstance$ = 5504
PrevWindowInstance$ = 5512
CommandLine$ = 5520
CommandShow$ = 5528
WinMain	PROC

; 713  : {

$LN21:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	b8 70 15 00 00	 mov	 eax, 5488		; 00001570H
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	48 2b e0	 sub	 rsp, rax
  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00029	48 33 c4	 xor	 rax, rsp
  0002c	48 89 84 24 60
	15 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 714  :     LARGE_INTEGER WinPerfCountFrequency;
; 715  :     QueryPerformanceFrequency(&WinPerfCountFrequency); 

  00034	48 8d 8c 24 e8
	00 00 00	 lea	 rcx, QWORD PTR WinPerfCountFrequency$[rsp]
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_QueryPerformanceFrequency

; 716  :     uint64 PerfCountFrequency = WinPerfCountFrequency.QuadPart;            

  00042	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR WinPerfCountFrequency$[rsp]
  0004a	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR PerfCountFrequency$[rsp], rax

; 717  : 
; 718  :     /**************************************/
; 719  :     /* NOTE : Screen back buffer creation */
; 720  :     
; 721  :     uint16 RenderScaleWidth = 256, RenderScaleHeight = 240;

  00052	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00057	66 89 44 24 70	 mov	 WORD PTR RenderScaleWidth$[rsp], ax
  0005c	b8 f0 00 00 00	 mov	 eax, 240		; 000000f0H
  00061	66 89 44 24 6c	 mov	 WORD PTR RenderScaleHeight$[rsp], ax

; 722  :     uint8 ResScale = 4;

  00066	c6 44 24 61 04	 mov	 BYTE PTR ResScale$[rsp], 4

; 723  :     uint16 WindowWidth = RenderScaleWidth * ResScale, WindowHeight = RenderScaleHeight * ResScale;

  0006b	0f b7 44 24 70	 movzx	 eax, WORD PTR RenderScaleWidth$[rsp]
  00070	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR ResScale$[rsp]
  00075	0f af c1	 imul	 eax, ecx
  00078	66 89 44 24 68	 mov	 WORD PTR WindowWidth$[rsp], ax
  0007d	0f b7 44 24 6c	 movzx	 eax, WORD PTR RenderScaleHeight$[rsp]
  00082	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR ResScale$[rsp]
  00087	0f af c1	 imul	 eax, ecx
  0008a	66 89 44 24 64	 mov	 WORD PTR WindowHeight$[rsp], ax

; 724  :     screen_buffer ScreenBackBuffer = {};

  0008f	48 8d 84 24 80
	01 00 00	 lea	 rax, QWORD PTR ScreenBackBuffer$[rsp]
  00097	48 8b f8	 mov	 rdi, rax
  0009a	33 c0		 xor	 eax, eax
  0009c	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  000a1	f3 aa		 rep stosb

; 725  :     createBackBuffer(&ScreenBackBuffer, RenderScaleWidth, RenderScaleHeight);

  000a3	44 0f b7 44 24
	6c		 movzx	 r8d, WORD PTR RenderScaleHeight$[rsp]
  000a9	0f b7 54 24 70	 movzx	 edx, WORD PTR RenderScaleWidth$[rsp]
  000ae	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR ScreenBackBuffer$[rsp]
  000b6	e8 00 00 00 00	 call	 ?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z ; createBackBuffer

; 726  : 
; 727  :     /**************************/
; 728  :     /* NOTE : Window creation */
; 729  : 
; 730  :     WNDCLASSA WindowClass = {};

  000bb	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR WindowClass$[rsp]
  000c3	48 8b f8	 mov	 rdi, rax
  000c6	33 c0		 xor	 eax, eax
  000c8	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  000cd	f3 aa		 rep stosb

; 731  :     WindowClass.style = CS_HREDRAW | CS_VREDRAW;

  000cf	c7 84 24 00 01
	00 00 03 00 00
	00		 mov	 DWORD PTR WindowClass$[rsp], 3

; 732  :     WindowClass.lpfnWndProc = WinInputCallback;

  000da	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z ; WinInputCallback
  000e1	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR WindowClass$[rsp+8], rax

; 733  :     WindowClass.hInstance = WindowInstance;

  000e9	48 8b 84 24 80
	15 00 00	 mov	 rax, QWORD PTR WindowInstance$[rsp]
  000f1	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR WindowClass$[rsp+24], rax

; 734  :     WindowClass.lpszClassName = "Nes Emulator";

  000f9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG89458
  00100	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR WindowClass$[rsp+64], rax

; 735  : 
; 736  :     uint16 InitialWindowPosX = 0;

  00108	33 c0		 xor	 eax, eax
  0010a	66 89 44 24 7c	 mov	 WORD PTR InitialWindowPosX$[rsp], ax

; 737  :     uint16 InitialWindowPosY = 0;

  0010f	33 c0		 xor	 eax, eax
  00111	66 89 44 24 78	 mov	 WORD PTR InitialWindowPosY$[rsp], ax

; 738  :     
; 739  :     if(RegisterClassA(&WindowClass))

  00116	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR WindowClass$[rsp]
  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegisterClassA
  00124	0f b7 c0	 movzx	 eax, ax
  00127	85 c0		 test	 eax, eax
  00129	0f 84 63 05 00
	00		 je	 $LN9@WinMain

; 740  :     {        
; 741  :         HWND Window = CreateWindowExA(0, WindowClass.lpszClassName, "NesEmu", WS_OVERLAPPEDWINDOW|WS_VISIBLE,

  0012f	0f b7 44 24 64	 movzx	 eax, WORD PTR WindowHeight$[rsp]
  00134	0f b7 4c 24 68	 movzx	 ecx, WORD PTR WindowWidth$[rsp]
  00139	0f b7 54 24 78	 movzx	 edx, WORD PTR InitialWindowPosY$[rsp]
  0013e	0f b7 7c 24 7c	 movzx	 edi, WORD PTR InitialWindowPosX$[rsp]
  00143	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR [rsp+88], 0
  0014c	4c 8b 84 24 80
	15 00 00	 mov	 r8, QWORD PTR WindowInstance$[rsp]
  00154	4c 89 44 24 50	 mov	 QWORD PTR [rsp+80], r8
  00159	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  00162	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  0016b	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0016f	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  00173	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  00177	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  0017b	41 b9 00 00 cf
	10		 mov	 r9d, 282001408		; 10cf0000H
  00181	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG89461
  00188	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR WindowClass$[rsp+64]
  00190	33 c9		 xor	 ecx, ecx
  00192	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateWindowExA
  00198	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR Window$3[rsp], rax

; 742  :                                       InitialWindowPosX, InitialWindowPosY, WindowWidth, WindowHeight,
; 743  :                                       0, 0, WindowInstance, 0);
; 744  : 
; 745  :         if(Window) // If window was created successfully

  001a0	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR Window$3[rsp], 0
  001a9	0f 84 cf 04 00
	00		 je	 $LN11@WinMain

; 746  :         {
; 747  :             HMENU WindowMenu = CreateMenu();

  001af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateMenu
  001b5	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR WindowMenu$14[rsp], rax

; 748  :             HMENU SubMenu = CreatePopupMenu();

  001bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreatePopupMenu
  001c3	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR SubMenu$8[rsp], rax

; 749  :             
; 750  :             AppendMenu(SubMenu, MF_STRING, ID_OPEN_ROM_ITEM, "&Open Rom");

  001cb	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG89464
  001d2	41 b8 e9 03 00
	00		 mov	 r8d, 1001		; 000003e9H
  001d8	33 d2		 xor	 edx, edx
  001da	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR SubMenu$8[rsp]
  001e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_AppendMenuA

; 751  :             AppendMenu(SubMenu, MF_STRING, ID_CLOSE_ROM_ITEM, "&Close Rom");

  001e8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG89465
  001ef	41 b8 ea 03 00
	00		 mov	 r8d, 1002		; 000003eaH
  001f5	33 d2		 xor	 edx, edx
  001f7	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR SubMenu$8[rsp]
  001ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_AppendMenuA

; 752  :             AppendMenu(SubMenu, MF_STRING, ID_QUIT_ITEM, "&Quit");

  00205	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG89466
  0020c	41 b8 eb 03 00
	00		 mov	 r8d, 1003		; 000003ebH
  00212	33 d2		 xor	 edx, edx
  00214	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR SubMenu$8[rsp]
  0021c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_AppendMenuA

; 753  :             AppendMenu(WindowMenu, MF_STRING | MF_POPUP, (uint64)SubMenu, "&File");

  00222	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG89467
  00229	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR SubMenu$8[rsp]
  00231	ba 10 00 00 00	 mov	 edx, 16
  00236	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR WindowMenu$14[rsp]
  0023e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_AppendMenuA

; 754  : 
; 755  :             SetMenu(Window, WindowMenu);

  00244	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR WindowMenu$14[rsp]
  0024c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Window$3[rsp]
  00254	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetMenu

; 756  : 
; 757  :             /**************************************************************************/
; 758  :             /* NOTE : creation and initialization of Emulators Cpu, Ppu, and Cartridge structures */
; 759  : 
; 760  : 
; 761  :             // Memory allocation for the Cpu and Ppu.
; 762  :             uint32 CpuMemorySize = Kilobytes(64);

  0025a	c7 84 24 88 00
	00 00 00 00 01
	00		 mov	 DWORD PTR CpuMemorySize$4[rsp], 65536 ; 00010000H

; 763  :             uint32 PpuMemorySize = Kilobytes(64);

  00265	c7 84 24 a0 00
	00 00 00 00 01
	00		 mov	 DWORD PTR PpuMemorySize$9[rsp], 65536 ; 00010000H

; 764  : 
; 765  :             uint8 * Memory = (uint8 *)VirtualAlloc(0, (size_t)(CpuMemorySize + PpuMemorySize), MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);

  00270	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR PpuMemorySize$9[rsp]
  00277	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR CpuMemorySize$4[rsp]
  0027e	03 c8		 add	 ecx, eax
  00280	8b c1		 mov	 eax, ecx
  00282	8b c0		 mov	 eax, eax
  00284	41 b9 04 00 00
	00		 mov	 r9d, 4
  0028a	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  00290	8b d0		 mov	 edx, eax
  00292	33 c9		 xor	 ecx, ecx
  00294	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  0029a	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR Memory$15[rsp], rax

; 766  : 
; 767  :             uint64 CpuMemoryBase = (uint64)Memory;

  002a2	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR Memory$15[rsp]
  002aa	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR CpuMemoryBase$12[rsp], rax

; 768  :             uint64 PpuMemoryBase = (uint64)Memory + CpuMemorySize;

  002b2	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR CpuMemorySize$4[rsp]
  002b9	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR Memory$15[rsp]
  002c1	48 03 c8	 add	 rcx, rax
  002c4	48 8b c1	 mov	 rax, rcx
  002c7	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR PpuMemoryBase$13[rsp], rax

; 769  :             GlobalCpuMemoryBase = CpuMemoryBase;

  002cf	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR CpuMemoryBase$12[rsp]
  002d7	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?GlobalCpuMemoryBase@@3_KA, rax

; 770  :             GlobalPpuMemoryBase = PpuMemoryBase;

  002de	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR PpuMemoryBase$13[rsp]
  002e6	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?GlobalPpuMemoryBase@@3_KA, rax

; 771  : 
; 772  :             char MemoryInfoBuffer[64];
; 773  :             sprintf(MemoryInfoBuffer, "Cpu Base = %X , Ppu Base = %X\n", (uint32)CpuMemoryBase, (uint32)PpuMemoryBase);

  002ed	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR PpuMemoryBase$13[rsp]
  002f5	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR CpuMemoryBase$12[rsp]
  002fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG89468
  00304	48 8d 8c 24 20
	15 00 00	 lea	 rcx, QWORD PTR MemoryInfoBuffer$20[rsp]
  0030c	e8 00 00 00 00	 call	 sprintf

; 774  :             OutputDebugString(MemoryInfoBuffer);

  00311	48 8d 8c 24 20
	15 00 00	 lea	 rcx, QWORD PTR MemoryInfoBuffer$20[rsp]
  00319	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 775  :             
; 776  :             nes Nes = {};

  0031f	48 8d 84 24 d0
	01 00 00	 lea	 rax, QWORD PTR Nes$19[rsp]
  00327	48 8b f8	 mov	 rdi, rax
  0032a	33 c0		 xor	 eax, eax
  0032c	b9 50 13 00 00	 mov	 ecx, 4944		; 00001350H
  00331	f3 aa		 rep stosb

; 777  :             initCpu(&Nes.Cpu, CpuMemoryBase);

  00333	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR CpuMemoryBase$12[rsp]
  0033b	48 8d 8c 24 d0
	01 00 00	 lea	 rcx, QWORD PTR Nes$19[rsp]
  00343	e8 00 00 00 00	 call	 ?initCpu@@YAXPEAUcpu@@_K@Z ; initCpu

; 778  :             initPpu(&Nes.Ppu, PpuMemoryBase, (uint32 *)ScreenBackBuffer.Memory);

  00348	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR ScreenBackBuffer$[rsp+48]
  00350	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR PpuMemoryBase$13[rsp]
  00358	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR Nes$19[rsp+112]
  00360	e8 00 00 00 00	 call	 ?initPpu@@YAXPEAUppu@@_KPEAI@Z ; initPpu

; 779  :             GlobalCpu = &Nes.Cpu;

  00365	48 8d 84 24 d0
	01 00 00	 lea	 rax, QWORD PTR Nes$19[rsp]
  0036d	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?GlobalCpu@@3PEAUcpu@@EA, rax

; 780  :             GlobalPpu = &Nes.Ppu;

  00374	48 8d 84 24 40
	02 00 00	 lea	 rax, QWORD PTR Nes$19[rsp+112]
  0037c	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?GlobalPpu@@3PEAUppu@@EA, rax

; 781  :             
; 782  :             loadCartridge(&Nes, "Mario Bros.nes");

  00383	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG89469
  0038a	48 8d 8c 24 d0
	01 00 00	 lea	 rcx, QWORD PTR Nes$19[rsp]
  00392	e8 00 00 00 00	 call	 ?loadCartridge@@YAXPEAUnes@@PEAD@Z ; loadCartridge

; 783  : 
; 784  :             // NOTE: Load the program counter with the reset vector
; 785  :             Nes.Cpu.PrgCounter = readCpu16(RESET_VEC, &Nes.Cpu);

  00397	48 8d 94 24 d0
	01 00 00	 lea	 rdx, QWORD PTR Nes$19[rsp]
  0039f	66 b9 fc ff	 mov	 cx, 65532		; 0000fffcH
  003a3	e8 00 00 00 00	 call	 ?readCpu16@@YAGGPEAUcpu@@@Z ; readCpu16
  003a8	66 89 84 24 d6
	01 00 00	 mov	 WORD PTR Nes$19[rsp+6], ax

; 786  : 
; 787  :             /*****************/
; 788  :             /* NOTE : Timing */
; 789  :             
; 790  :             real32 CpuClockRateHz = 1789772.727272728;

  003b0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@49da7a66
  003b8	f3 0f 11 84 24
	a4 00 00 00	 movss	 DWORD PTR CpuClockRateHz$10[rsp], xmm0

; 791  :             real32 CpuCyclesPerMS = CpuClockRateHz / 1000.0;

  003c1	f3 0f 5a 84 24
	a4 00 00 00	 cvtss2sd xmm0, DWORD PTR CpuClockRateHz$10[rsp]
  003ca	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@408f400000000000
  003d2	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  003d6	f3 0f 11 84 24
	e0 00 00 00	 movss	 DWORD PTR CpuCyclesPerMS$17[rsp], xmm0

; 792  :             
; 793  :             uint32 CpuCyclesElapsed = 0;

  003df	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR CpuCyclesElapsed$5[rsp], 0

; 794  :             uint32 TickCycles = 0;

  003ea	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR TickCycles$2[rsp], 0

; 795  :             
; 796  :             real32 ElapsedSecs = 0;

  003f2	0f 57 c0	 xorps	 xmm0, xmm0
  003f5	f3 0f 11 84 24
	a8 00 00 00	 movss	 DWORD PTR ElapsedSecs$11[rsp], xmm0

; 797  :             real32 CurrentSecs, PrevSecs = getMilliSeconds(PerfCountFrequency) / 1000.0f;

  003fe	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR PerfCountFrequency$[rsp]
  00406	e8 00 00 00 00	 call	 ?getMilliSeconds@@YAM_K@Z ; getMilliSeconds
  0040b	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@447a0000
  00413	f3 0f 11 84 24
	94 00 00 00	 movss	 DWORD PTR PrevSecs$7[rsp], xmm0

; 798  : 
; 799  :             /********************/
; 800  :             /* NOTE : Main Loop */
; 801  :             
; 802  :             GlobalRunning = true; 

  0041c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 1
$LN2@WinMain:

; 803  :             while(GlobalRunning)

  00426	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?GlobalRunning@@3HA, 0
  0042d	0f 84 49 02 00
	00		 je	 $LN3@WinMain

; 804  :             {
; 805  :                 MSG Message = {}; 

  00433	48 8d 84 24 50
	01 00 00	 lea	 rax, QWORD PTR Message$18[rsp]
  0043b	48 8b f8	 mov	 rdi, rax
  0043e	33 c0		 xor	 eax, eax
  00440	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00445	f3 aa		 rep stosb
$LN4@WinMain:

; 806  :                 while (PeekMessage(&Message, Window, 0, 0, PM_REMOVE))

  00447	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0044f	45 33 c9	 xor	 r9d, r9d
  00452	45 33 c0	 xor	 r8d, r8d
  00455	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR Window$3[rsp]
  0045d	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR Message$18[rsp]
  00465	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PeekMessageA
  0046b	85 c0		 test	 eax, eax
  0046d	74 1e		 je	 SHORT $LN5@WinMain

; 807  :                 {
; 808  :                     TranslateMessage(&Message);

  0046f	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR Message$18[rsp]
  00477	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TranslateMessage

; 809  :                     DispatchMessage(&Message);

  0047d	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR Message$18[rsp]
  00485	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DispatchMessageA

; 810  :                 }

  0048b	eb ba		 jmp	 SHORT $LN4@WinMain
$LN5@WinMain:

; 811  :                 
; 812  :                 if(PowerHit)

  0048d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PowerHit@@3HA, 0
  00494	74 17		 je	 SHORT $LN13@WinMain

; 813  :                 {
; 814  :                     PowerHit = false;

  00496	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PowerHit@@3HA, 0

; 815  :                     power(&Nes);

  004a0	48 8d 8c 24 d0
	01 00 00	 lea	 rcx, QWORD PTR Nes$19[rsp]
  004a8	e8 00 00 00 00	 call	 ?power@@YAXPEAUnes@@@Z	; power
$LN13@WinMain:

; 816  :                 }                
; 817  :                 if(ResetHit)

  004ad	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ResetHit@@3HA, 0
  004b4	74 2b		 je	 SHORT $LN14@WinMain

; 818  :                 {
; 819  :                     ResetHit = false;

  004b6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ResetHit@@3HA, 0

; 820  :                     loadCartridge(&Nes, RomFileName);

  004c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?RomFileName@@3PADA
  004c7	48 8d 8c 24 d0
	01 00 00	 lea	 rcx, QWORD PTR Nes$19[rsp]
  004cf	e8 00 00 00 00	 call	 ?loadCartridge@@YAXPEAUnes@@PEAD@Z ; loadCartridge

; 821  :                     reset(&Nes);

  004d4	48 8d 8c 24 d0
	01 00 00	 lea	 rcx, QWORD PTR Nes$19[rsp]
  004dc	e8 00 00 00 00	 call	 ?reset@@YAXPEAUnes@@@Z	; reset
$LN14@WinMain:

; 822  :                 }
; 823  : 
; 824  :                 if(Nes.Cpu.MapperWrite)

  004e1	83 bc 24 e4 01
	00 00 00	 cmp	 DWORD PTR Nes$19[rsp+20], 0
  004e9	74 45		 je	 SHORT $LN15@WinMain

; 825  :                 {
; 826  :                     Nes.Cpu.MapperWrite = false;

  004eb	c7 84 24 e4 01
	00 00 00 00 00
	00		 mov	 DWORD PTR Nes$19[rsp+20], 0

; 827  :                     mapperUpdate[Nes.Cartridge.MapperNum](&Nes.Cartridge, &Nes.Cpu, &Nes.Ppu);

  004f6	0f b6 84 24 09
	15 00 00	 movzx	 eax, BYTE PTR Nes$19[rsp+4921]
  004fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mapperUpdate@@3PAP6AXPEAUcartridge@@PEAUcpu@@PEAUppu@@@ZA ; mapperUpdate
  00505	48 89 8c 24 f0
	00 00 00	 mov	 QWORD PTR tv284[rsp], rcx
  0050d	4c 8d 84 24 40
	02 00 00	 lea	 r8, QWORD PTR Nes$19[rsp+112]
  00515	48 8d 94 24 d0
	01 00 00	 lea	 rdx, QWORD PTR Nes$19[rsp]
  0051d	48 8d 8c 24 d0
	14 00 00	 lea	 rcx, QWORD PTR Nes$19[rsp+4864]
  00525	48 8b bc 24 f0
	00 00 00	 mov	 rdi, QWORD PTR tv284[rsp]
  0052d	ff 14 c7	 call	 QWORD PTR [rdi+rax*8]
$LN15@WinMain:

; 828  :                 }
; 829  :                 
; 830  :                 if(PowerOn)

  00530	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PowerOn@@3HA, 0
  00537	74 7c		 je	 SHORT $LN16@WinMain

; 831  :                 {
; 832  :                     TickCycles = cpuTick(&Nes.Cpu, &WinInput);

  00539	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00540	48 8d 8c 24 d0
	01 00 00	 lea	 rcx, QWORD PTR Nes$19[rsp]
  00548	e8 00 00 00 00	 call	 ?cpuTick@@YAEPEAUcpu@@PEAUinput@@@Z ; cpuTick
  0054d	0f b6 c0	 movzx	 eax, al
  00550	89 44 24 74	 mov	 DWORD PTR TickCycles$2[rsp], eax

; 833  : 
; 834  :                     // Minus the cycles we have already executed on the ppu for catchup
; 835  :                     TickCycles -= Nes.Cpu.CatchUpCyclesRun;

  00554	0f b6 84 24 3c
	02 00 00	 movzx	 eax, BYTE PTR Nes$19[rsp+108]
  0055c	8b 4c 24 74	 mov	 ecx, DWORD PTR TickCycles$2[rsp]
  00560	2b c8		 sub	 ecx, eax
  00562	8b c1		 mov	 eax, ecx
  00564	89 44 24 74	 mov	 DWORD PTR TickCycles$2[rsp], eax

; 836  :                     Nes.Cpu.CatchUpCyclesRun = 0;

  00568	c6 84 24 3c 02
	00 00 00	 mov	 BYTE PTR Nes$19[rsp+108], 0

; 837  :                     
; 838  :                     for(uint8 i = 0; i < (3*TickCycles); ++i)

  00570	c6 44 24 60 00	 mov	 BYTE PTR i$1[rsp], 0
  00575	eb 0b		 jmp	 SHORT $LN8@WinMain
$LN6@WinMain:
  00577	0f b6 44 24 60	 movzx	 eax, BYTE PTR i$1[rsp]
  0057c	fe c0		 inc	 al
  0057e	88 44 24 60	 mov	 BYTE PTR i$1[rsp], al
$LN8@WinMain:
  00582	0f b6 44 24 60	 movzx	 eax, BYTE PTR i$1[rsp]
  00587	6b 4c 24 74 03	 imul	 ecx, DWORD PTR TickCycles$2[rsp], 3
  0058c	3b c1		 cmp	 eax, ecx
  0058e	73 0f		 jae	 SHORT $LN7@WinMain

; 839  :                     {
; 840  :                         ppuTick(&Nes.Ppu);

  00590	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR Nes$19[rsp+112]
  00598	e8 00 00 00 00	 call	 ?ppuTick@@YAXPEAUppu@@@Z ; ppuTick

; 841  :                     }

  0059d	eb d8		 jmp	 SHORT $LN6@WinMain
$LN7@WinMain:

; 842  : 
; 843  :                     CpuCyclesElapsed += TickCycles;

  0059f	8b 44 24 74	 mov	 eax, DWORD PTR TickCycles$2[rsp]
  005a3	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR CpuCyclesElapsed$5[rsp]
  005aa	03 c8		 add	 ecx, eax
  005ac	8b c1		 mov	 eax, ecx
  005ae	89 84 24 8c 00
	00 00		 mov	 DWORD PTR CpuCyclesElapsed$5[rsp], eax
$LN16@WinMain:

; 844  :                 }
; 845  :                 
; 846  :                 if(DrawScreen) // NOTE: Gets called everytime the vblank happens in Ppu TODO: Should it be the end of vblank?

  005b5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DrawScreen@@3HA, 0
  005bc	74 6e		 je	 SHORT $LN17@WinMain

; 847  :                 {
; 848  :                     DrawScreen = false; 

  005be	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?DrawScreen@@3HA, 0

; 849  :                     getWindowSize(Window, &WindowWidth, &WindowHeight);

  005c8	4c 8d 44 24 64	 lea	 r8, QWORD PTR WindowHeight$[rsp]
  005cd	48 8d 54 24 68	 lea	 rdx, QWORD PTR WindowWidth$[rsp]
  005d2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Window$3[rsp]
  005da	e8 00 00 00 00	 call	 ?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z ; getWindowSize

; 850  :                 
; 851  :                     // NOTE: Drawing the backbuffer to the window 
; 852  :                     HDC DeviceContext = GetDC(Window);

  005df	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Window$3[rsp]
  005e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetDC
  005ed	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR DeviceContext$16[rsp], rax

; 853  :                     drawScreenBuffer(&ScreenBackBuffer, DeviceContext,

  005f5	44 0f b7 4c 24
	64		 movzx	 r9d, WORD PTR WindowHeight$[rsp]
  005fb	44 0f b7 44 24
	68		 movzx	 r8d, WORD PTR WindowWidth$[rsp]
  00601	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR DeviceContext$16[rsp]
  00609	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR ScreenBackBuffer$[rsp]
  00611	e8 00 00 00 00	 call	 ?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z ; drawScreenBuffer

; 854  :                                      WindowWidth, WindowHeight);
; 855  :                     ReleaseDC(Window, DeviceContext);

  00616	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR DeviceContext$16[rsp]
  0061e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Window$3[rsp]
  00626	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReleaseDC
$LN17@WinMain:

; 856  :                 }
; 857  :            
; 858  :                 CurrentSecs = getMilliSeconds(PerfCountFrequency) / 1000.0f;

  0062c	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR PerfCountFrequency$[rsp]
  00634	e8 00 00 00 00	 call	 ?getMilliSeconds@@YAM_K@Z ; getMilliSeconds
  00639	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@447a0000
  00641	f3 0f 11 84 24
	90 00 00 00	 movss	 DWORD PTR CurrentSecs$6[rsp], xmm0

; 859  :                 ElapsedSecs = CurrentSecs - PrevSecs;

  0064a	f3 0f 10 84 24
	90 00 00 00	 movss	 xmm0, DWORD PTR CurrentSecs$6[rsp]
  00653	f3 0f 5c 84 24
	94 00 00 00	 subss	 xmm0, DWORD PTR PrevSecs$7[rsp]
  0065c	f3 0f 11 84 24
	a8 00 00 00	 movss	 DWORD PTR ElapsedSecs$11[rsp], xmm0

; 860  :                 PrevSecs = CurrentSecs;

  00665	f3 0f 10 84 24
	90 00 00 00	 movss	 xmm0, DWORD PTR CurrentSecs$6[rsp]
  0066e	f3 0f 11 84 24
	94 00 00 00	 movss	 DWORD PTR PrevSecs$7[rsp], xmm0

; 861  :             }

  00677	e9 aa fd ff ff	 jmp	 $LN2@WinMain
$LN3@WinMain:

; 862  : 
; 863  :         }
; 864  :         else

  0067c	eb 12		 jmp	 SHORT $LN12@WinMain
$LN11@WinMain:

; 865  :         {
; 866  :             // NOTE: Window failed to create
; 867  :             // TODO: Handle this in a better way
; 868  :             Assert(0);

  0067e	33 c0		 xor	 eax, eax
  00680	83 f8 01	 cmp	 eax, 1
  00683	74 0b		 je	 SHORT $LN18@WinMain
  00685	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN18@WinMain:
$LN12@WinMain:

; 869  :         }
; 870  :     }
; 871  :     else

  00690	eb 12		 jmp	 SHORT $LN10@WinMain
$LN9@WinMain:

; 872  :     {
; 873  :         // NOTE: Failed to register window
; 874  :         // TODO: Handle this in a better way
; 875  :         Assert(0);

  00692	33 c0		 xor	 eax, eax
  00694	83 f8 01	 cmp	 eax, 1
  00697	74 0b		 je	 SHORT $LN19@WinMain
  00699	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN19@WinMain:
$LN10@WinMain:

; 876  :     }
; 877  :     return(0);

  006a4	33 c0		 xor	 eax, eax

; 878  : } 

  006a6	48 8b 8c 24 60
	15 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  006ae	48 33 cc	 xor	 rcx, rsp
  006b1	e8 00 00 00 00	 call	 __security_check_cookie
  006b6	48 81 c4 70 15
	00 00		 add	 rsp, 5488		; 00001570H
  006bd	5f		 pop	 rdi
  006be	c3		 ret	 0
WinMain	ENDP
_TEXT	ENDS
END
