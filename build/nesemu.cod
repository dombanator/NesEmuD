; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?adc@@YAEGPEAUcpu@@E@Z				; adc
PUBLIC	?AND@@YAEGPEAUcpu@@E@Z				; AND
PUBLIC	?asl@@YAEGPEAUcpu@@E@Z				; asl
PUBLIC	?bcc@@YAEGPEAUcpu@@E@Z				; bcc
PUBLIC	?bcs@@YAEGPEAUcpu@@E@Z				; bcs
PUBLIC	?beq@@YAEGPEAUcpu@@E@Z				; beq
PUBLIC	?bit@@YAEGPEAUcpu@@E@Z				; bit
PUBLIC	?bmi@@YAEGPEAUcpu@@E@Z				; bmi
PUBLIC	?bne@@YAEGPEAUcpu@@E@Z				; bne
PUBLIC	?bpl@@YAEGPEAUcpu@@E@Z				; bpl
PUBLIC	?brk@@YAEGPEAUcpu@@E@Z				; brk
PUBLIC	?bvc@@YAEGPEAUcpu@@E@Z				; bvc
PUBLIC	?bvs@@YAEGPEAUcpu@@E@Z				; bvs
PUBLIC	?clc@@YAEGPEAUcpu@@E@Z				; clc
PUBLIC	?cld@@YAEGPEAUcpu@@E@Z				; cld
PUBLIC	?cli@@YAEGPEAUcpu@@E@Z				; cli
PUBLIC	?clv@@YAEGPEAUcpu@@E@Z				; clv
PUBLIC	?cmp@@YAEGPEAUcpu@@E@Z				; cmp
PUBLIC	?cpx@@YAEGPEAUcpu@@E@Z				; cpx
PUBLIC	?cpy@@YAEGPEAUcpu@@E@Z				; cpy
PUBLIC	?dec@@YAEGPEAUcpu@@E@Z				; dec
PUBLIC	?dex@@YAEGPEAUcpu@@E@Z				; dex
PUBLIC	?dey@@YAEGPEAUcpu@@E@Z				; dey
PUBLIC	?eor@@YAEGPEAUcpu@@E@Z				; eor
PUBLIC	?inc@@YAEGPEAUcpu@@E@Z				; inc
PUBLIC	?inx@@YAEGPEAUcpu@@E@Z				; inx
PUBLIC	?iny@@YAEGPEAUcpu@@E@Z				; iny
PUBLIC	?jmp@@YAEGPEAUcpu@@E@Z				; jmp
PUBLIC	?jsr@@YAEGPEAUcpu@@E@Z				; jsr
PUBLIC	?lda@@YAEGPEAUcpu@@E@Z				; lda
PUBLIC	?ldx@@YAEGPEAUcpu@@E@Z				; ldx
PUBLIC	?ldy@@YAEGPEAUcpu@@E@Z				; ldy
PUBLIC	?lsr@@YAEGPEAUcpu@@E@Z				; lsr
PUBLIC	?nop@@YAEGPEAUcpu@@E@Z				; nop
PUBLIC	?ora@@YAEGPEAUcpu@@E@Z				; ora
PUBLIC	?pha@@YAEGPEAUcpu@@E@Z				; pha
PUBLIC	?php@@YAEGPEAUcpu@@E@Z				; php
PUBLIC	?pla@@YAEGPEAUcpu@@E@Z				; pla
PUBLIC	?plp@@YAEGPEAUcpu@@E@Z				; plp
PUBLIC	?rol@@YAEGPEAUcpu@@E@Z				; rol
PUBLIC	?ror@@YAEGPEAUcpu@@E@Z				; ror
PUBLIC	?rti@@YAEGPEAUcpu@@E@Z				; rti
PUBLIC	?rts@@YAEGPEAUcpu@@E@Z				; rts
PUBLIC	?sbc@@YAEGPEAUcpu@@E@Z				; sbc
PUBLIC	?sec@@YAEGPEAUcpu@@E@Z				; sec
PUBLIC	?sed@@YAEGPEAUcpu@@E@Z				; sed
PUBLIC	?sei@@YAEGPEAUcpu@@E@Z				; sei
PUBLIC	?sta@@YAEGPEAUcpu@@E@Z				; sta
PUBLIC	?stx@@YAEGPEAUcpu@@E@Z				; stx
PUBLIC	?sty@@YAEGPEAUcpu@@E@Z				; sty
PUBLIC	?tax@@YAEGPEAUcpu@@E@Z				; tax
PUBLIC	?tay@@YAEGPEAUcpu@@E@Z				; tay
PUBLIC	?tsx@@YAEGPEAUcpu@@E@Z				; tsx
PUBLIC	?txa@@YAEGPEAUcpu@@E@Z				; txa
PUBLIC	?tya@@YAEGPEAUcpu@@E@Z				; tya
PUBLIC	?txs@@YAEGPEAUcpu@@E@Z				; txs
PUBLIC	?ahx@@YAEGPEAUcpu@@E@Z				; ahx
PUBLIC	?alr@@YAEGPEAUcpu@@E@Z				; alr
PUBLIC	?anc@@YAEGPEAUcpu@@E@Z				; anc
PUBLIC	?arr@@YAEGPEAUcpu@@E@Z				; arr
PUBLIC	?axs@@YAEGPEAUcpu@@E@Z				; axs
PUBLIC	?dcp@@YAEGPEAUcpu@@E@Z				; dcp
PUBLIC	?isc@@YAEGPEAUcpu@@E@Z				; isc
PUBLIC	?kil@@YAEGPEAUcpu@@E@Z				; kil
PUBLIC	?las@@YAEGPEAUcpu@@E@Z				; las
PUBLIC	?lax@@YAEGPEAUcpu@@E@Z				; lax
PUBLIC	?rla@@YAEGPEAUcpu@@E@Z				; rla
PUBLIC	?rra@@YAEGPEAUcpu@@E@Z				; rra
PUBLIC	?sax@@YAEGPEAUcpu@@E@Z				; sax
PUBLIC	?shx@@YAEGPEAUcpu@@E@Z				; shx
PUBLIC	?shy@@YAEGPEAUcpu@@E@Z				; shy
PUBLIC	?slo@@YAEGPEAUcpu@@E@Z				; slo
PUBLIC	?sre@@YAEGPEAUcpu@@E@Z				; sre
PUBLIC	?tas@@YAEGPEAUcpu@@E@Z				; tas
PUBLIC	?xaa@@YAEGPEAUcpu@@E@Z				; xaa
PUBLIC	?instrOps@@3PAP6AEGPEAUcpu@@E@ZA		; instrOps
PUBLIC	?NmiTriggered@@3HA				; NmiTriggered
PUBLIC	?IrqTriggered@@3HA				; IrqTriggered
PUBLIC	?VRamAdrsChange@@3HA				; VRamAdrsChange
PUBLIC	?OamDataChange@@3HA				; OamDataChange
PUBLIC	?Palette@@3PAY02EA				; Palette
PUBLIC	?IOWriteFromCpu@@3HA				; IOWriteFromCpu
PUBLIC	?ScrollAdrsChange@@3HA				; ScrollAdrsChange
PUBLIC	?VRamAdrsOnPalette@@3HA				; VRamAdrsOnPalette
PUBLIC	?IOReadFromCpu@@3HA				; IOReadFromCpu
PUBLIC	?ResetVRamIOAdrs@@3HA				; ResetVRamIOAdrs
PUBLIC	?ResetScrollIOAdrs@@3HA				; ResetScrollIOAdrs
PUBLIC	?DrawScreen@@3HA				; DrawScreen
PUBLIC	?nromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ; nromInit
PUBLIC	?mapperInit@@3PAP6AXPEAUcartridge@@PEAUcpu@@PEAUppu@@@ZA ; mapperInit
_BSS	SEGMENT
?WinInput@@3Uinput@@A DB 020H DUP (?)			; WinInput
?PowerHit@@3HA DD 01H DUP (?)				; PowerHit
?ResetHit@@3HA DD 01H DUP (?)				; ResetHit
?OamData@@3PEAEEA DQ 01H DUP (?)			; OamData
?NmiTriggered@@3HA DD 01H DUP (?)			; NmiTriggered
?IrqTriggered@@3HA DD 01H DUP (?)			; IrqTriggered
?VRamAdrsChange@@3HA DD 01H DUP (?)			; VRamAdrsChange
?OamDataChange@@3HA DD 01H DUP (?)			; OamDataChange
?IOWriteFromCpu@@3HA DD 01H DUP (?)			; IOWriteFromCpu
?ScrollAdrsChange@@3HA DD 01H DUP (?)			; ScrollAdrsChange
?VRamAdrsOnPalette@@3HA DD 01H DUP (?)			; VRamAdrsOnPalette
?IOReadFromCpu@@3HA DD 01H DUP (?)			; IOReadFromCpu
?ResetVRamIOAdrs@@3HA DD 01H DUP (?)			; ResetVRamIOAdrs
?ResetScrollIOAdrs@@3HA DD 01H DUP (?)			; ResetScrollIOAdrs
?DrawScreen@@3HA DD 01H DUP (?)				; DrawScreen
_BSS	ENDS
_DATA	SEGMENT
?instCycles@@3PAEA DB 07H				; instCycles
	DB	06H
	DB	00H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
	DB	06H
	DB	06H
	DB	00H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	04H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
	DB	06H
	DB	06H
	DB	00H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	03H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
	DB	06H
	DB	06H
	DB	00H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	04H
	DB	02H
	DB	02H
	DB	02H
	DB	05H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
	DB	02H
	DB	06H
	DB	02H
	DB	06H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	02H
	DB	06H
	DB	00H
	DB	06H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	02H
	DB	05H
	DB	02H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	02H
	DB	06H
	DB	02H
	DB	06H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	02H
	DB	05H
	DB	00H
	DB	05H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	02H
	DB	04H
	DB	02H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	02H
	DB	06H
	DB	02H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
	DB	02H
	DB	06H
	DB	02H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
?instBoundaryCheck@@3PAEA DB 00H			; instBoundaryCheck
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
?PowerOn@@3HA DD 01H					; PowerOn
	ORG $+12
?instrOps@@3PAP6AEGPEAUcpu@@E@ZA DQ FLAT:?brk@@YAEGPEAUcpu@@E@Z ; instrOps
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?asl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?php@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?asl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?anc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?asl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bpl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?asl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?clc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?asl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?jsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bit@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rol@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?plp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rol@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?anc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bit@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rol@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bmi@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rol@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sec@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rol@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rti@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?pha@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?alr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?jmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bvc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cli@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rts@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ror@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?pla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ror@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?arr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?jmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ror@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bvs@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ror@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sei@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ror@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sty@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?stx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dey@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?txa@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?xaa@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sty@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?stx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bcc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ahx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sty@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?stx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?tya@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?txs@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?tas@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?shy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?shx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ahx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?tay@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?tax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bcs@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?clv@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?tsx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?las@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dec@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?iny@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dex@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?axs@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dec@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bne@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dec@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cld@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dec@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?inc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?inx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?inc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?beq@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?inc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sed@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?inc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
?Palette@@3PAY02EA DB 075H				; Palette
	DB	075H
	DB	075H
	DB	027H
	DB	01bH
	DB	08fH
	DB	00H
	DB	00H
	DB	0abH
	DB	047H
	DB	00H
	DB	09fH
	DB	08fH
	DB	00H
	DB	077H
	DB	0abH
	DB	00H
	DB	013H
	DB	0a7H
	DB	00H
	DB	00H
	DB	07fH
	DB	0bH
	DB	00H
	DB	043H
	DB	02fH
	DB	00H
	DB	00H
	DB	047H
	DB	00H
	DB	00H
	DB	051H
	DB	00H
	DB	00H
	DB	03fH
	DB	017H
	DB	01bH
	DB	03fH
	DB	05fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0bcH
	DB	0bcH
	DB	0bcH
	DB	00H
	DB	073H
	DB	0efH
	DB	023H
	DB	03bH
	DB	0efH
	DB	083H
	DB	00H
	DB	0f3H
	DB	0bfH
	DB	00H
	DB	0bfH
	DB	0e7H
	DB	00H
	DB	05bH
	DB	0dbH
	DB	02bH
	DB	00H
	DB	0cbH
	DB	04fH
	DB	0fH
	DB	08bH
	DB	073H
	DB	00H
	DB	00H
	DB	097H
	DB	00H
	DB	00H
	DB	0abH
	DB	00H
	DB	00H
	DB	093H
	DB	03bH
	DB	00H
	DB	083H
	DB	08bH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	03fH
	DB	0bfH
	DB	0ffH
	DB	05fH
	DB	097H
	DB	0ffH
	DB	0a7H
	DB	08bH
	DB	0fdH
	DB	0f7H
	DB	07bH
	DB	0ffH
	DB	0ffH
	DB	077H
	DB	0b7H
	DB	0ffH
	DB	077H
	DB	063H
	DB	0ffH
	DB	09bH
	DB	03bH
	DB	0f3H
	DB	0bfH
	DB	03fH
	DB	083H
	DB	0d3H
	DB	013H
	DB	04fH
	DB	0dfH
	DB	04bH
	DB	058H
	DB	0f8H
	DB	098H
	DB	00H
	DB	0ebH
	DB	0dbH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0abH
	DB	0e7H
	DB	0ffH
	DB	0c7H
	DB	0d7H
	DB	0ffH
	DB	0d7H
	DB	0cbH
	DB	0ffH
	DB	0ffH
	DB	0c7H
	DB	0ffH
	DB	0ffH
	DB	0c7H
	DB	0dbH
	DB	0ffH
	DB	0bfH
	DB	0b3H
	DB	0ffH
	DB	0dbH
	DB	0abH
	DB	0ffH
	DB	0e7H
	DB	0a3H
	DB	0e3H
	DB	0ffH
	DB	0a3H
	DB	0abH
	DB	0f3H
	DB	0bfH
	DB	0b3H
	DB	0ffH
	DB	0cfH
	DB	09fH
	DB	0ffH
	DB	0f3H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
?instAddressMode@@3PAEA DB 09H				; instAddressMode
	DB	0bH
	DB	09H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	01H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	06H
	DB	0bH
	DB	09H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	01H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	09H
	DB	0bH
	DB	09H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	01H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	09H
	DB	0bH
	DB	09H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	01H
	DB	02H
	DB	0dH
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	02H
	DB	0bH
	DB	02H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	09H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	02H
	DB	0bH
	DB	02H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	09H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	02H
	DB	0bH
	DB	02H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	09H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	02H
	DB	0bH
	DB	02H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	09H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
?instLength@@3PAEA DB 02H				; instLength
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
?instName@@3PAPEADA DQ FLAT:$SG87864			; instName
	DQ	FLAT:$SG87865
	DQ	FLAT:$SG87866
	DQ	FLAT:$SG87867
	DQ	FLAT:$SG87868
	DQ	FLAT:$SG87869
	DQ	FLAT:$SG87870
	DQ	FLAT:$SG87871
	DQ	FLAT:$SG87872
	DQ	FLAT:$SG87873
	DQ	FLAT:$SG87874
	DQ	FLAT:$SG87875
	DQ	FLAT:$SG87876
	DQ	FLAT:$SG87877
	DQ	FLAT:$SG87878
	DQ	FLAT:$SG87879
	DQ	FLAT:$SG87880
	DQ	FLAT:$SG87881
	DQ	FLAT:$SG87882
	DQ	FLAT:$SG87883
	DQ	FLAT:$SG87884
	DQ	FLAT:$SG87885
	DQ	FLAT:$SG87886
	DQ	FLAT:$SG87887
	DQ	FLAT:$SG87888
	DQ	FLAT:$SG87889
	DQ	FLAT:$SG87890
	DQ	FLAT:$SG87891
	DQ	FLAT:$SG87892
	DQ	FLAT:$SG87893
	DQ	FLAT:$SG87894
	DQ	FLAT:$SG87895
	DQ	FLAT:$SG87896
	DQ	FLAT:$SG87897
	DQ	FLAT:$SG87898
	DQ	FLAT:$SG87899
	DQ	FLAT:$SG87900
	DQ	FLAT:$SG87901
	DQ	FLAT:$SG87902
	DQ	FLAT:$SG87903
	DQ	FLAT:$SG87904
	DQ	FLAT:$SG87905
	DQ	FLAT:$SG87906
	DQ	FLAT:$SG87907
	DQ	FLAT:$SG87908
	DQ	FLAT:$SG87909
	DQ	FLAT:$SG87910
	DQ	FLAT:$SG87911
	DQ	FLAT:$SG87912
	DQ	FLAT:$SG87913
	DQ	FLAT:$SG87914
	DQ	FLAT:$SG87915
	DQ	FLAT:$SG87916
	DQ	FLAT:$SG87917
	DQ	FLAT:$SG87918
	DQ	FLAT:$SG87919
	DQ	FLAT:$SG87920
	DQ	FLAT:$SG87921
	DQ	FLAT:$SG87922
	DQ	FLAT:$SG87923
	DQ	FLAT:$SG87924
	DQ	FLAT:$SG87925
	DQ	FLAT:$SG87926
	DQ	FLAT:$SG87927
	DQ	FLAT:$SG87928
	DQ	FLAT:$SG87929
	DQ	FLAT:$SG87930
	DQ	FLAT:$SG87931
	DQ	FLAT:$SG87932
	DQ	FLAT:$SG87933
	DQ	FLAT:$SG87934
	DQ	FLAT:$SG87935
	DQ	FLAT:$SG87936
	DQ	FLAT:$SG87937
	DQ	FLAT:$SG87938
	DQ	FLAT:$SG87939
	DQ	FLAT:$SG87940
	DQ	FLAT:$SG87941
	DQ	FLAT:$SG87942
	DQ	FLAT:$SG87943
	DQ	FLAT:$SG87944
	DQ	FLAT:$SG87945
	DQ	FLAT:$SG87946
	DQ	FLAT:$SG87947
	DQ	FLAT:$SG87948
	DQ	FLAT:$SG87949
	DQ	FLAT:$SG87950
	DQ	FLAT:$SG87951
	DQ	FLAT:$SG87952
	DQ	FLAT:$SG87953
	DQ	FLAT:$SG87954
	DQ	FLAT:$SG87955
	DQ	FLAT:$SG87956
	DQ	FLAT:$SG87957
	DQ	FLAT:$SG87958
	DQ	FLAT:$SG87959
	DQ	FLAT:$SG87960
	DQ	FLAT:$SG87961
	DQ	FLAT:$SG87962
	DQ	FLAT:$SG87963
	DQ	FLAT:$SG87964
	DQ	FLAT:$SG87965
	DQ	FLAT:$SG87966
	DQ	FLAT:$SG87967
	DQ	FLAT:$SG87968
	DQ	FLAT:$SG87969
	DQ	FLAT:$SG87970
	DQ	FLAT:$SG87971
	DQ	FLAT:$SG87972
	DQ	FLAT:$SG87973
	DQ	FLAT:$SG87974
	DQ	FLAT:$SG87975
	DQ	FLAT:$SG87976
	DQ	FLAT:$SG87977
	DQ	FLAT:$SG87978
	DQ	FLAT:$SG87979
	DQ	FLAT:$SG87980
	DQ	FLAT:$SG87981
	DQ	FLAT:$SG87982
	DQ	FLAT:$SG87983
	DQ	FLAT:$SG87984
	DQ	FLAT:$SG87985
	DQ	FLAT:$SG87986
	DQ	FLAT:$SG87987
	DQ	FLAT:$SG87988
	DQ	FLAT:$SG87989
	DQ	FLAT:$SG87990
	DQ	FLAT:$SG87991
	DQ	FLAT:$SG87992
	DQ	FLAT:$SG87993
	DQ	FLAT:$SG87994
	DQ	FLAT:$SG87995
	DQ	FLAT:$SG87996
	DQ	FLAT:$SG87997
	DQ	FLAT:$SG87998
	DQ	FLAT:$SG87999
	DQ	FLAT:$SG88000
	DQ	FLAT:$SG88001
	DQ	FLAT:$SG88002
	DQ	FLAT:$SG88003
	DQ	FLAT:$SG88004
	DQ	FLAT:$SG88005
	DQ	FLAT:$SG88006
	DQ	FLAT:$SG88007
	DQ	FLAT:$SG88008
	DQ	FLAT:$SG88009
	DQ	FLAT:$SG88010
	DQ	FLAT:$SG88011
	DQ	FLAT:$SG88012
	DQ	FLAT:$SG88013
	DQ	FLAT:$SG88014
	DQ	FLAT:$SG88015
	DQ	FLAT:$SG88016
	DQ	FLAT:$SG88017
	DQ	FLAT:$SG88018
	DQ	FLAT:$SG88019
	DQ	FLAT:$SG88020
	DQ	FLAT:$SG88021
	DQ	FLAT:$SG88022
	DQ	FLAT:$SG88023
	DQ	FLAT:$SG88024
	DQ	FLAT:$SG88025
	DQ	FLAT:$SG88026
	DQ	FLAT:$SG88027
	DQ	FLAT:$SG88028
	DQ	FLAT:$SG88029
	DQ	FLAT:$SG88030
	DQ	FLAT:$SG88031
	DQ	FLAT:$SG88032
	DQ	FLAT:$SG88033
	DQ	FLAT:$SG88034
	DQ	FLAT:$SG88035
	DQ	FLAT:$SG88036
	DQ	FLAT:$SG88037
	DQ	FLAT:$SG88038
	DQ	FLAT:$SG88039
	DQ	FLAT:$SG88040
	DQ	FLAT:$SG88041
	DQ	FLAT:$SG88042
	DQ	FLAT:$SG88043
	DQ	FLAT:$SG88044
	DQ	FLAT:$SG88045
	DQ	FLAT:$SG88046
	DQ	FLAT:$SG88047
	DQ	FLAT:$SG88048
	DQ	FLAT:$SG88049
	DQ	FLAT:$SG88050
	DQ	FLAT:$SG88051
	DQ	FLAT:$SG88052
	DQ	FLAT:$SG88053
	DQ	FLAT:$SG88054
	DQ	FLAT:$SG88055
	DQ	FLAT:$SG88056
	DQ	FLAT:$SG88057
	DQ	FLAT:$SG88058
	DQ	FLAT:$SG88059
	DQ	FLAT:$SG88060
	DQ	FLAT:$SG88061
	DQ	FLAT:$SG88062
	DQ	FLAT:$SG88063
	DQ	FLAT:$SG88064
	DQ	FLAT:$SG88065
	DQ	FLAT:$SG88066
	DQ	FLAT:$SG88067
	DQ	FLAT:$SG88068
	DQ	FLAT:$SG88069
	DQ	FLAT:$SG88070
	DQ	FLAT:$SG88071
	DQ	FLAT:$SG88072
	DQ	FLAT:$SG88073
	DQ	FLAT:$SG88074
	DQ	FLAT:$SG88075
	DQ	FLAT:$SG88076
	DQ	FLAT:$SG88077
	DQ	FLAT:$SG88078
	DQ	FLAT:$SG88079
	DQ	FLAT:$SG88080
	DQ	FLAT:$SG88081
	DQ	FLAT:$SG88082
	DQ	FLAT:$SG88083
	DQ	FLAT:$SG88084
	DQ	FLAT:$SG88085
	DQ	FLAT:$SG88086
	DQ	FLAT:$SG88087
	DQ	FLAT:$SG88088
	DQ	FLAT:$SG88089
	DQ	FLAT:$SG88090
	DQ	FLAT:$SG88091
	DQ	FLAT:$SG88092
	DQ	FLAT:$SG88093
	DQ	FLAT:$SG88094
	DQ	FLAT:$SG88095
	DQ	FLAT:$SG88096
	DQ	FLAT:$SG88097
	DQ	FLAT:$SG88098
	DQ	FLAT:$SG88099
	DQ	FLAT:$SG88100
	DQ	FLAT:$SG88101
	DQ	FLAT:$SG88102
	DQ	FLAT:$SG88103
	DQ	FLAT:$SG88104
	DQ	FLAT:$SG88105
	DQ	FLAT:$SG88106
	DQ	FLAT:$SG88107
	DQ	FLAT:$SG88108
	DQ	FLAT:$SG88109
	DQ	FLAT:$SG88110
	DQ	FLAT:$SG88111
	DQ	FLAT:$SG88112
	DQ	FLAT:$SG88113
	DQ	FLAT:$SG88114
	DQ	FLAT:$SG88115
	DQ	FLAT:$SG88116
	DQ	FLAT:$SG88117
	DQ	FLAT:$SG88118
	DQ	FLAT:$SG88119
?mapperInit@@3PAP6AXPEAUcartridge@@PEAUcpu@@PEAUppu@@@ZA DQ FLAT:?nromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ; mapperInit
_DATA	ENDS
CONST	SEGMENT
$SG88064 DB	'INY', 00H
$SG88065 DB	'CMP', 00H
$SG88066 DB	'DEX', 00H
$SG88067 DB	'AXS', 00H
$SG88068 DB	'CPY', 00H
$SG88069 DB	'CMP', 00H
$SG88070 DB	'DEC', 00H
$SG88071 DB	'DCP', 00H
$SG88072 DB	'BNE', 00H
$SG88073 DB	'CMP', 00H
$SG88074 DB	'KIL', 00H
$SG88075 DB	'DCP', 00H
$SG88076 DB	'NOP', 00H
$SG88077 DB	'CMP', 00H
$SG88078 DB	'DEC', 00H
$SG88079 DB	'DCP', 00H
$SG88080 DB	'CLD', 00H
$SG88081 DB	'CMP', 00H
$SG88082 DB	'NOP', 00H
$SG88083 DB	'DCP', 00H
$SG88084 DB	'NOP', 00H
$SG88085 DB	'CMP', 00H
$SG88086 DB	'DEC', 00H
$SG88087 DB	'DCP', 00H
$SG88088 DB	'CPX', 00H
$SG88089 DB	'SBC', 00H
$SG88090 DB	'NOP', 00H
$SG88091 DB	'ISC', 00H
$SG88092 DB	'CPX', 00H
$SG88093 DB	'SBC', 00H
$SG88094 DB	'INC', 00H
$SG88095 DB	'ISC', 00H
$SG88096 DB	'INX', 00H
$SG88097 DB	'SBC', 00H
$SG88098 DB	'NOP', 00H
$SG89123 DB	'NesEmu', 00H
	ORG $+1
$SG88099 DB	'SBC', 00H
$SG88100 DB	'CPX', 00H
$SG88101 DB	'SBC', 00H
$SG89126 DB	'NesEmu', 00H
	ORG $+1
$SG88102 DB	'INC', 00H
$SG88103 DB	'ISC', 00H
$SG88104 DB	'BEQ', 00H
$SG88105 DB	'SBC', 00H
$SG89129 DB	'&Open Rom', 00H
	ORG $+2
$SG88106 DB	'KIL', 00H
$SG89130 DB	'&Close Rom', 00H
	ORG $+1
$SG89131 DB	'&Quit', 00H
	ORG $+2
$SG88107 DB	'ISC', 00H
$SG89132 DB	'&File', 00H
	ORG $+2
$SG88108 DB	'NOP', 00H
$SG88109 DB	'SBC', 00H
$SG89133 DB	'Donkey Kong.nes', 00H
$SG88110 DB	'INC', 00H
$SG88111 DB	'ISC', 00H
$SG88112 DB	'SED', 00H
$SG88113 DB	'SBC', 00H
$SG88114 DB	'NOP', 00H
$SG88115 DB	'ISC', 00H
$SG88116 DB	'NOP', 00H
$SG88117 DB	'SBC', 00H
$SG88118 DB	'INC', 00H
$SG88119 DB	'ISC', 00H
$SG87667 DB	'.nes', 00H, '*.nes', 00H, 00H
$SG88698 DB	'NMI', 00H
$SG88701 DB	'IRQ', 00H
$SG87864 DB	'BRK', 00H
$SG87865 DB	'ORA', 00H
$SG87866 DB	'KIL', 00H
$SG87867 DB	'SLO', 00H
$SG87868 DB	'NOP', 00H
$SG87869 DB	'ORA', 00H
$SG87870 DB	'ASL', 00H
$SG87871 DB	'SLO', 00H
$SG87872 DB	'PHP', 00H
$SG87873 DB	'ORA', 00H
$SG87874 DB	'ASL', 00H
$SG87875 DB	'ANC', 00H
$SG87876 DB	'NOP', 00H
$SG87877 DB	'ORA', 00H
$SG87878 DB	'ASL', 00H
$SG87879 DB	'SLO', 00H
$SG87880 DB	'BPL', 00H
$SG87881 DB	'ORA', 00H
$SG87882 DB	'KIL', 00H
$SG87883 DB	'SLO', 00H
$SG87884 DB	'NOP', 00H
$SG87885 DB	'ORA', 00H
$SG87886 DB	'ASL', 00H
$SG87887 DB	'SLO', 00H
$SG87888 DB	'CLC', 00H
$SG87889 DB	'ORA', 00H
$SG87890 DB	'NOP', 00H
$SG87891 DB	'SLO', 00H
$SG87892 DB	'NOP', 00H
$SG87893 DB	'ORA', 00H
$SG87894 DB	'ASL', 00H
$SG87895 DB	'SLO', 00H
$SG87896 DB	'JSR', 00H
$SG87897 DB	'AND', 00H
$SG87898 DB	'KIL', 00H
$SG87899 DB	'RLA', 00H
$SG87900 DB	'BIT', 00H
$SG87901 DB	'AND', 00H
$SG87902 DB	'ROL', 00H
$SG87903 DB	'RLA', 00H
$SG87904 DB	'PLP', 00H
$SG87905 DB	'AND', 00H
$SG87906 DB	'ROL', 00H
$SG87907 DB	'ANC', 00H
$SG87908 DB	'BIT', 00H
$SG87909 DB	'AND', 00H
$SG87910 DB	'ROL', 00H
$SG87911 DB	'RLA', 00H
$SG87912 DB	'BMI', 00H
$SG87913 DB	'AND', 00H
$SG87914 DB	'KIL', 00H
$SG87915 DB	'RLA', 00H
$SG87916 DB	'NOP', 00H
$SG87917 DB	'AND', 00H
$SG87918 DB	'ROL', 00H
$SG87919 DB	'RLA', 00H
$SG87920 DB	'SEC', 00H
$SG87921 DB	'AND', 00H
$SG87922 DB	'NOP', 00H
$SG87923 DB	'RLA', 00H
$SG87924 DB	'NOP', 00H
$SG87925 DB	'AND', 00H
$SG87926 DB	'ROL', 00H
$SG87927 DB	'RLA', 00H
$SG87928 DB	'RTI', 00H
$SG87929 DB	'EOR', 00H
$SG87930 DB	'KIL', 00H
$SG87931 DB	'SRE', 00H
$SG87932 DB	'NOP', 00H
$SG87933 DB	'EOR', 00H
$SG87934 DB	'LSR', 00H
$SG87935 DB	'SRE', 00H
$SG87936 DB	'PHA', 00H
$SG87937 DB	'EOR', 00H
$SG87938 DB	'LSR', 00H
$SG87939 DB	'ALR', 00H
$SG87940 DB	'JMP', 00H
$SG87941 DB	'EOR', 00H
$SG87942 DB	'LSR', 00H
$SG87943 DB	'SRE', 00H
$SG87944 DB	'BVC', 00H
$SG87945 DB	'EOR', 00H
$SG87946 DB	'KIL', 00H
$SG87947 DB	'SRE', 00H
$SG87948 DB	'NOP', 00H
$SG87949 DB	'EOR', 00H
$SG87950 DB	'LSR', 00H
$SG87951 DB	'SRE', 00H
$SG87952 DB	'CLI', 00H
$SG87953 DB	'EOR', 00H
$SG87954 DB	'NOP', 00H
$SG87955 DB	'SRE', 00H
$SG87956 DB	'NOP', 00H
$SG87957 DB	'EOR', 00H
$SG87958 DB	'LSR', 00H
$SG87959 DB	'SRE', 00H
$SG87960 DB	'RTS', 00H
$SG87961 DB	'ADC', 00H
$SG87962 DB	'KIL', 00H
$SG87963 DB	'RRA', 00H
$SG87964 DB	'NOP', 00H
$SG87965 DB	'ADC', 00H
$SG87966 DB	'ROR', 00H
$SG87967 DB	'RRA', 00H
$SG87968 DB	'PLA', 00H
$SG87969 DB	'ADC', 00H
$SG87970 DB	'ROR', 00H
$SG87971 DB	'ARR', 00H
$SG87972 DB	'JMP', 00H
$SG87973 DB	'ADC', 00H
$SG87974 DB	'ROR', 00H
$SG87975 DB	'RRA', 00H
$SG87976 DB	'BVS', 00H
$SG87977 DB	'ADC', 00H
$SG87978 DB	'KIL', 00H
$SG87979 DB	'RRA', 00H
$SG87980 DB	'NOP', 00H
$SG87981 DB	'ADC', 00H
$SG87982 DB	'ROR', 00H
$SG87983 DB	'RRA', 00H
$SG87984 DB	'SEI', 00H
$SG87985 DB	'ADC', 00H
$SG87986 DB	'NOP', 00H
$SG87987 DB	'RRA', 00H
$SG87988 DB	'NOP', 00H
$SG87989 DB	'ADC', 00H
$SG87990 DB	'ROR', 00H
$SG87991 DB	'RRA', 00H
$SG87992 DB	'NOP', 00H
$SG87993 DB	'STA', 00H
$SG87994 DB	'NOP', 00H
$SG87995 DB	'SAX', 00H
$SG87996 DB	'STY', 00H
$SG87997 DB	'STA', 00H
$SG87998 DB	'STX', 00H
$SG87999 DB	'SAX', 00H
$SG88000 DB	'DEY', 00H
$SG88001 DB	'NOP', 00H
$SG88002 DB	'TXA', 00H
$SG88003 DB	'XAA', 00H
$SG88004 DB	'STY', 00H
$SG88005 DB	'STA', 00H
$SG88006 DB	'STX', 00H
$SG88007 DB	'SAX', 00H
$SG88008 DB	'BCC', 00H
$SG88009 DB	'STA', 00H
$SG88010 DB	'KIL', 00H
$SG88011 DB	'AHX', 00H
$SG88012 DB	'STY', 00H
$SG88013 DB	'STA', 00H
$SG88014 DB	'STX', 00H
$SG88015 DB	'SAX', 00H
$SG88016 DB	'TYA', 00H
$SG88017 DB	'STA', 00H
$SG88018 DB	'TXS', 00H
$SG88019 DB	'TAS', 00H
$SG88020 DB	'SHY', 00H
$SG88021 DB	'STA', 00H
$SG88022 DB	'SHX', 00H
$SG88023 DB	'AHX', 00H
$SG88024 DB	'LDY', 00H
$SG88025 DB	'LDA', 00H
$SG88026 DB	'LDX', 00H
$SG88027 DB	'LAX', 00H
$SG88028 DB	'LDY', 00H
$SG88029 DB	'LDA', 00H
$SG88030 DB	'LDX', 00H
$SG88031 DB	'LAX', 00H
$SG88032 DB	'TAY', 00H
$SG88033 DB	'LDA', 00H
$SG88034 DB	'TAX', 00H
$SG88035 DB	'LAX', 00H
$SG88036 DB	'LDY', 00H
$SG88037 DB	'LDA', 00H
$SG88038 DB	'LDX', 00H
$SG88039 DB	'LAX', 00H
$SG88040 DB	'BCS', 00H
$SG88041 DB	'LDA', 00H
$SG88042 DB	'KIL', 00H
$SG88043 DB	'LAX', 00H
$SG88044 DB	'LDY', 00H
$SG88045 DB	'LDA', 00H
$SG88046 DB	'LDX', 00H
$SG88047 DB	'LAX', 00H
$SG88048 DB	'CLV', 00H
$SG88049 DB	'LDA', 00H
$SG88050 DB	'TSX', 00H
$SG88051 DB	'LAS', 00H
$SG88052 DB	'LDY', 00H
$SG88053 DB	'LDA', 00H
$SG88054 DB	'LDX', 00H
$SG88055 DB	'LAX', 00H
$SG88056 DB	'CPY', 00H
$SG88057 DB	'CMP', 00H
$SG88058 DB	'NOP', 00H
$SG88059 DB	'DCP', 00H
$SG88060 DB	'CPY', 00H
$SG88061 DB	'CMP', 00H
$SG88062 DB	'DEC', 00H
$SG88063 DB	'DCP', 00H
CONST	ENDS
PUBLIC	WinMain
PUBLIC	?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z	; WinInputCallback
PUBLIC	?setCarry@@YAXPEAE@Z				; setCarry
PUBLIC	?clearCarry@@YAXPEAE@Z				; clearCarry
PUBLIC	?setInterrupt@@YAXPEAE@Z			; setInterrupt
PUBLIC	?clearInterrupt@@YAXPEAE@Z			; clearInterrupt
PUBLIC	?setDecimal@@YAXPEAE@Z				; setDecimal
PUBLIC	?clearDecimal@@YAXPEAE@Z			; clearDecimal
PUBLIC	?setBreak@@YAXPEAE@Z				; setBreak
PUBLIC	?clearBreak@@YAXPEAE@Z				; clearBreak
PUBLIC	?setBlank@@YAXPEAE@Z				; setBlank
PUBLIC	?setOverflow@@YAXPEAE@Z				; setOverflow
PUBLIC	?clearOverflow@@YAXPEAE@Z			; clearOverflow
PUBLIC	?setZero@@YAXEPEAE@Z				; setZero
PUBLIC	?setNegative@@YAXEPEAE@Z			; setNegative
PUBLIC	?isBitSet@@YAHEE@Z				; isBitSet
PUBLIC	?crossedPageCheck@@YAHGG@Z			; crossedPageCheck
PUBLIC	?getPaletteValue@@YAXEPEAE@Z			; getPaletteValue
PUBLIC	?drawPixel@@YAXPEAUppu@@GGPEAE@Z		; drawPixel
PUBLIC	?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z	; ppuTick
PUBLIC	__real@408f400000000000
PUBLIC	__real@447a0000
PUBLIC	__real@49da7a66
PUBLIC	__real@5f800000
EXTRN	__report_rangecheckfailure:PROC
EXTRN	memset:PROC
EXTRN	strlen:PROC
EXTRN	__imp_CreateFileA:PROC
EXTRN	__imp_GetFileSizeEx:PROC
EXTRN	__imp_ReadFile:PROC
EXTRN	__imp_QueryPerformanceCounter:PROC
EXTRN	__imp_QueryPerformanceFrequency:PROC
EXTRN	__imp_VirtualAlloc:PROC
EXTRN	__imp_VirtualFree:PROC
EXTRN	__imp_StretchDIBits:PROC
EXTRN	__imp_TranslateMessage:PROC
EXTRN	__imp_DispatchMessageA:PROC
EXTRN	__imp_PeekMessageA:PROC
EXTRN	__imp_DefWindowProcA:PROC
EXTRN	__imp_RegisterClassA:PROC
EXTRN	__imp_CreateWindowExA:PROC
EXTRN	__imp_SetMenu:PROC
EXTRN	__imp_CreateMenu:PROC
EXTRN	__imp_CreatePopupMenu:PROC
EXTRN	__imp_AppendMenuA:PROC
EXTRN	__imp_GetDC:PROC
EXTRN	__imp_ReleaseDC:PROC
EXTRN	__imp_GetClientRect:PROC
EXTRN	__imp_GetOpenFileNameA:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_BSS	SEGMENT
?GlobalRunning@@3HA DD 01H DUP (?)			; GlobalRunning
?RomFileName@@3PADA DB 0100H DUP (?)			; RomFileName
_BSS	ENDS
pdata	SEGMENT
$pdata$WinMain DD imagerel $LN20
	DD	imagerel $LN20+1639
	DD	imagerel $unwind$WinMain
$pdata$?getMilliSeconds@@YAM_K@Z DD imagerel ?getMilliSeconds@@YAM_K@Z
	DD	imagerel ?getMilliSeconds@@YAM_K@Z+112
	DD	imagerel $unwind$?getMilliSeconds@@YAM_K@Z
$pdata$?cpyMemory@@YAXPEAE0G@Z DD imagerel ?cpyMemory@@YAXPEAE0G@Z
	DD	imagerel ?cpyMemory@@YAXPEAE0G@Z+85
	DD	imagerel $unwind$?cpyMemory@@YAXPEAE0G@Z
$pdata$?write8@@YAXEG_K@Z DD imagerel ?write8@@YAXEG_K@Z
	DD	imagerel ?write8@@YAXEG_K@Z+48
	DD	imagerel $unwind$?write8@@YAXEG_K@Z
$pdata$?read8@@YAEG_K@Z DD imagerel ?read8@@YAEG_K@Z
	DD	imagerel ?read8@@YAEG_K@Z+49
	DD	imagerel $unwind$?read8@@YAEG_K@Z
$pdata$?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z DD imagerel $LN60
	DD	imagerel $LN60+1615
	DD	imagerel $unwind$?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z
$pdata$?LoadFile@@YAPEAXPEADPEAI@Z DD imagerel ?LoadFile@@YAPEAXPEADPEAI@Z
	DD	imagerel ?LoadFile@@YAPEAXPEADPEAI@Z+259
	DD	imagerel $unwind$?LoadFile@@YAPEAXPEADPEAI@Z
$pdata$?readCpu8@@YAEG_K@Z DD imagerel ?readCpu8@@YAEG_K@Z
	DD	imagerel ?readCpu8@@YAEG_K@Z+230
	DD	imagerel $unwind$?readCpu8@@YAEG_K@Z
$pdata$?writeCpu8@@YAXEG_K@Z DD imagerel ?writeCpu8@@YAXEG_K@Z
	DD	imagerel ?writeCpu8@@YAXEG_K@Z+424
	DD	imagerel $unwind$?writeCpu8@@YAXEG_K@Z
$pdata$?readCpu16@@YAGG_K@Z DD imagerel ?readCpu16@@YAGG_K@Z
	DD	imagerel ?readCpu16@@YAGG_K@Z+87
	DD	imagerel $unwind$?readCpu16@@YAGG_K@Z
$pdata$?bugReadCpu16@@YAGG_K@Z DD imagerel ?bugReadCpu16@@YAGG_K@Z
	DD	imagerel ?bugReadCpu16@@YAGG_K@Z+109
	DD	imagerel $unwind$?bugReadCpu16@@YAGG_K@Z
$pdata$?push@@YAXEPEAUcpu@@@Z DD imagerel ?push@@YAXEPEAUcpu@@@Z
	DD	imagerel ?push@@YAXEPEAUcpu@@@Z+72
	DD	imagerel $unwind$?push@@YAXEPEAUcpu@@@Z
$pdata$?pop@@YAEPEAUcpu@@@Z DD imagerel ?pop@@YAEPEAUcpu@@@Z
	DD	imagerel ?pop@@YAEPEAUcpu@@@Z+72
	DD	imagerel $unwind$?pop@@YAEPEAUcpu@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?crossedPageCheck@@YAHGG@Z DD imagerel $LN5
	DD	imagerel $LN5+63
	DD	imagerel $unwind$?crossedPageCheck@@YAHGG@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?adc@@YAEGPEAUcpu@@E@Z DD imagerel $LN7
	DD	imagerel $LN7+285
	DD	imagerel $unwind$?adc@@YAEGPEAUcpu@@E@Z
$pdata$?AND@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+121
	DD	imagerel $unwind$?AND@@YAEGPEAUcpu@@E@Z
$pdata$?asl@@YAEGPEAUcpu@@E@Z DD imagerel $LN9
	DD	imagerel $LN9+274
	DD	imagerel $unwind$?asl@@YAEGPEAUcpu@@E@Z
$pdata$?bcc@@YAEGPEAUcpu@@E@Z DD imagerel $LN6
	DD	imagerel $LN6+120
	DD	imagerel $unwind$?bcc@@YAEGPEAUcpu@@E@Z
$pdata$?bcs@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bcs@@YAEGPEAUcpu@@E@Z
$pdata$?beq@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?beq@@YAEGPEAUcpu@@E@Z
$pdata$?bit@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+151
	DD	imagerel $unwind$?bit@@YAEGPEAUcpu@@E@Z
$pdata$?bmi@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bmi@@YAEGPEAUcpu@@E@Z
$pdata$?bne@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bne@@YAEGPEAUcpu@@E@Z
$pdata$?bpl@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bpl@@YAEGPEAUcpu@@E@Z
$pdata$?brk@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+182
	DD	imagerel $unwind$?brk@@YAEGPEAUcpu@@E@Z
$pdata$?bvc@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bvc@@YAEGPEAUcpu@@E@Z
$pdata$?bvs@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bvs@@YAEGPEAUcpu@@E@Z
$pdata$?clc@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?clc@@YAEGPEAUcpu@@E@Z
$pdata$?cld@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?cld@@YAEGPEAUcpu@@E@Z
$pdata$?cli@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?cli@@YAEGPEAUcpu@@E@Z
$pdata$?clv@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?clv@@YAEGPEAUcpu@@E@Z
$pdata$?cmp@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+165
	DD	imagerel $unwind$?cmp@@YAEGPEAUcpu@@E@Z
$pdata$?cpx@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+167
	DD	imagerel $unwind$?cpx@@YAEGPEAUcpu@@E@Z
$pdata$?cpy@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+167
	DD	imagerel $unwind$?cpy@@YAEGPEAUcpu@@E@Z
$pdata$?dec@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+122
	DD	imagerel $unwind$?dec@@YAEGPEAUcpu@@E@Z
$pdata$?dex@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?dex@@YAEGPEAUcpu@@E@Z
$pdata$?dey@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?dey@@YAEGPEAUcpu@@E@Z
$pdata$?eor@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+121
	DD	imagerel $unwind$?eor@@YAEGPEAUcpu@@E@Z
$pdata$?inc@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+122
	DD	imagerel $unwind$?inc@@YAEGPEAUcpu@@E@Z
$pdata$?inx@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?inx@@YAEGPEAUcpu@@E@Z
$pdata$?iny@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?iny@@YAEGPEAUcpu@@E@Z
$pdata$?jsr@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$?jsr@@YAEGPEAUcpu@@E@Z
$pdata$?lda@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+105
	DD	imagerel $unwind$?lda@@YAEGPEAUcpu@@E@Z
$pdata$?ldx@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+106
	DD	imagerel $unwind$?ldx@@YAEGPEAUcpu@@E@Z
$pdata$?ldy@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+106
	DD	imagerel $unwind$?ldy@@YAEGPEAUcpu@@E@Z
$pdata$?lsr@@YAEGPEAUcpu@@E@Z DD imagerel $LN9
	DD	imagerel $LN9+273
	DD	imagerel $unwind$?lsr@@YAEGPEAUcpu@@E@Z
$pdata$?ora@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+121
	DD	imagerel $unwind$?ora@@YAEGPEAUcpu@@E@Z
$pdata$?pha@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?pha@@YAEGPEAUcpu@@E@Z
$pdata$?php@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?php@@YAEGPEAUcpu@@E@Z
$pdata$?pla@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$?pla@@YAEGPEAUcpu@@E@Z
$pdata$?plp@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?plp@@YAEGPEAUcpu@@E@Z
$pdata$?rol@@YAEGPEAUcpu@@E@Z DD imagerel $LN11
	DD	imagerel $LN11+339
	DD	imagerel $unwind$?rol@@YAEGPEAUcpu@@E@Z
$pdata$?ror@@YAEGPEAUcpu@@E@Z DD imagerel $LN11
	DD	imagerel $LN11+337
	DD	imagerel $unwind$?ror@@YAEGPEAUcpu@@E@Z
$pdata$?rti@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+105
	DD	imagerel $unwind$?rti@@YAEGPEAUcpu@@E@Z
$pdata$?rts@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$?rts@@YAEGPEAUcpu@@E@Z
$pdata$?sbc@@YAEGPEAUcpu@@E@Z DD imagerel $LN7
	DD	imagerel $LN7+290
	DD	imagerel $unwind$?sbc@@YAEGPEAUcpu@@E@Z
$pdata$?sec@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?sec@@YAEGPEAUcpu@@E@Z
$pdata$?sed@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?sed@@YAEGPEAUcpu@@E@Z
$pdata$?sei@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?sei@@YAEGPEAUcpu@@E@Z
$pdata$?sta@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?sta@@YAEGPEAUcpu@@E@Z
$pdata$?stx@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$?stx@@YAEGPEAUcpu@@E@Z
$pdata$?sty@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$?sty@@YAEGPEAUcpu@@E@Z
$pdata$?tax@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+94
	DD	imagerel $unwind$?tax@@YAEGPEAUcpu@@E@Z
$pdata$?tay@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+94
	DD	imagerel $unwind$?tay@@YAEGPEAUcpu@@E@Z
$pdata$?tsx@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$?tsx@@YAEGPEAUcpu@@E@Z
$pdata$?txa@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+92
	DD	imagerel $unwind$?txa@@YAEGPEAUcpu@@E@Z
$pdata$?tya@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+92
	DD	imagerel $unwind$?tya@@YAEGPEAUcpu@@E@Z
$pdata$?alr@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?alr@@YAEGPEAUcpu@@E@Z
$pdata$?anc@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+103
	DD	imagerel $unwind$?anc@@YAEGPEAUcpu@@E@Z
$pdata$?arr@@YAEGPEAUcpu@@E@Z DD imagerel $LN9
	DD	imagerel $LN9+262
	DD	imagerel $unwind$?arr@@YAEGPEAUcpu@@E@Z
$pdata$?axs@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+194
	DD	imagerel $unwind$?axs@@YAEGPEAUcpu@@E@Z
$pdata$?dcp@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?dcp@@YAEGPEAUcpu@@E@Z
$pdata$?isc@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?isc@@YAEGPEAUcpu@@E@Z
$pdata$?lax@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?lax@@YAEGPEAUcpu@@E@Z
$pdata$?rla@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?rla@@YAEGPEAUcpu@@E@Z
$pdata$?rra@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?rra@@YAEGPEAUcpu@@E@Z
$pdata$?sax@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$?sax@@YAEGPEAUcpu@@E@Z
$pdata$?slo@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?slo@@YAEGPEAUcpu@@E@Z
$pdata$?sre@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?sre@@YAEGPEAUcpu@@E@Z
$pdata$?nmi_irq@@YAEGPEAUcpu@@E@Z DD imagerel ?nmi_irq@@YAEGPEAUcpu@@E@Z
	DD	imagerel ?nmi_irq@@YAEGPEAUcpu@@E@Z+166
	DD	imagerel $unwind$?nmi_irq@@YAEGPEAUcpu@@E@Z
$pdata$?cpuTick@@YAEPEAUcpu@@@Z DD imagerel ?cpuTick@@YAEPEAUcpu@@@Z
	DD	imagerel ?cpuTick@@YAEPEAUcpu@@@Z+1520
	DD	imagerel $unwind$?cpuTick@@YAEPEAUcpu@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?drawPixel@@YAXPEAUppu@@GGPEAE@Z DD imagerel $LN3
	DD	imagerel $LN3+139
	DD	imagerel $unwind$?drawPixel@@YAXPEAUppu@@GGPEAE@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?readPpu8@@YAEG_K@Z DD imagerel ?readPpu8@@YAEG_K@Z
	DD	imagerel ?readPpu8@@YAEG_K@Z+186
	DD	imagerel $unwind$?readPpu8@@YAEG_K@Z
$pdata$?writePpu8@@YAXEG_K@Z DD imagerel ?writePpu8@@YAXEG_K@Z
	DD	imagerel ?writePpu8@@YAXEG_K@Z+186
	DD	imagerel $unwind$?writePpu8@@YAXEG_K@Z
$pdata$?getNameTableValue@@YAEGGG_K@Z DD imagerel ?getNameTableValue@@YAEGGG_K@Z
	DD	imagerel ?getNameTableValue@@YAEGGG_K@Z+179
	DD	imagerel $unwind$?getNameTableValue@@YAEGGG_K@Z
$pdata$?getPatternValue@@YAEGGEG_K@Z DD imagerel ?getPatternValue@@YAEGGEG_K@Z
	DD	imagerel ?getPatternValue@@YAEGGEG_K@Z+307
	DD	imagerel $unwind$?getPatternValue@@YAEGGEG_K@Z
$pdata$?getAttributeValue@@YAEGGG_K@Z DD imagerel ?getAttributeValue@@YAEGGG_K@Z
	DD	imagerel ?getAttributeValue@@YAEGGG_K@Z+291
	DD	imagerel $unwind$?getAttributeValue@@YAEGGG_K@Z
$pdata$?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z DD imagerel $LN73
	DD	imagerel $LN73+2769
	DD	imagerel $unwind$?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z
$pdata$?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z DD imagerel ?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z
	DD	imagerel ?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z+108
	DD	imagerel $unwind$?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z
$pdata$?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z DD imagerel ?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z
	DD	imagerel ?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z+262
	DD	imagerel $unwind$?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z
$pdata$?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z DD imagerel ?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z
	DD	imagerel ?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z+165
	DD	imagerel $unwind$?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z
$pdata$?nromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z DD imagerel $LN9
	DD	imagerel $LN9+287
	DD	imagerel $unwind$?nromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z
$pdata$?loadCartridge@@YAXPEAUcartridge@@PEADPEAUcpu@@PEAUppu@@@Z DD imagerel ?loadCartridge@@YAXPEAUcartridge@@PEADPEAUcpu@@PEAUppu@@@Z
	DD	imagerel ?loadCartridge@@YAXPEAUcartridge@@PEADPEAUcpu@@PEAUppu@@@Z+543
	DD	imagerel $unwind$?loadCartridge@@YAXPEAUcartridge@@PEADPEAUcpu@@PEAUppu@@@Z
$pdata$?power@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z DD imagerel ?power@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z
	DD	imagerel ?power@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z+402
	DD	imagerel $unwind$?power@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z
$pdata$?reset@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z DD imagerel ?reset@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z
	DD	imagerel ?reset@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z+88
	DD	imagerel $unwind$?reset@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z
pdata	ENDS
;	COMDAT __real@5f800000
CONST	SEGMENT
__real@5f800000 DD 05f800000r			; 1.84467e+19
CONST	ENDS
;	COMDAT __real@49da7a66
CONST	SEGMENT
__real@49da7a66 DD 049da7a66r			; 1.78977e+06
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?drawPixel@@YAXPEAUppu@@GGPEAE@Z DD 011901H
	DD	02219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?crossedPageCheck@@YAHGG@Z DD 010e01H
	DD	0220eH
xdata	ENDS
xdata	SEGMENT
$unwind$WinMain DD 032e19H
	DD	06e011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0360H
$unwind$?getMilliSeconds@@YAM_K@Z DD 010901H
	DD	08209H
$unwind$?cpyMemory@@YAXPEAE0G@Z DD 011401H
	DD	02214H
$unwind$?write8@@YAXEG_K@Z DD 011201H
	DD	02212H
$unwind$?read8@@YAEG_K@Z DD 010e01H
	DD	0220eH
$unwind$?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z DD 032d19H
	DD	046011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	0220H
$unwind$?LoadFile@@YAPEAXPEADPEAI@Z DD 010e01H
	DD	0c20eH
$unwind$?readCpu8@@YAEG_K@Z DD 010e01H
	DD	0620eH
$unwind$?writeCpu8@@YAXEG_K@Z DD 011201H
	DD	06212H
$unwind$?readCpu16@@YAGG_K@Z DD 010e01H
	DD	0620eH
$unwind$?bugReadCpu16@@YAGG_K@Z DD 010e01H
	DD	0620eH
$unwind$?push@@YAXEPEAUcpu@@@Z DD 010d01H
	DD	0420dH
$unwind$?pop@@YAEPEAUcpu@@@Z DD 010901H
	DD	06209H
$unwind$?adc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?AND@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?asl@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bcc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bcs@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?beq@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bit@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bmi@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bne@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bpl@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?brk@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bvc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bvs@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?clc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?cld@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?cli@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?clv@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?cmp@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?cpx@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?cpy@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?dec@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?dex@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?dey@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?eor@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?inc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?inx@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?iny@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?jsr@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?lda@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?ldx@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?ldy@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?lsr@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?ora@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?pha@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?php@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?pla@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?plp@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?rol@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?ror@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?rti@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?rts@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?sbc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?sec@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?sed@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?sei@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?sta@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?stx@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?sty@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?tax@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?tay@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?tsx@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?txa@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?tya@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?alr@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?anc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?arr@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?axs@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?dcp@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?isc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?lax@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?rla@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?rra@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?sax@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?slo@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?sre@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?nmi_irq@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?cpuTick@@YAEPEAUcpu@@@Z DD 042019H
	DD	013010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$?readPpu8@@YAEG_K@Z DD 010e01H
	DD	0620eH
$unwind$?writePpu8@@YAXEG_K@Z DD 011201H
	DD	04212H
$unwind$?getNameTableValue@@YAEGGG_K@Z DD 011901H
	DD	06219H
$unwind$?getPatternValue@@YAEGGEG_K@Z DD 011901H
	DD	08219H
$unwind$?getAttributeValue@@YAEGGG_K@Z DD 011901H
	DD	06219H
$unwind$?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z DD 031201H
	DD	0180112H
	DD	0700bH
$unwind$?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z DD 012219H
	DD	08213H
	DD	imagerel __GSHandlerCheck
	DD	030H
$unwind$?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z DD 011401H
	DD	06214H
$unwind$?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z DD 011a01H
	DD	0e21aH
$unwind$?nromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z DD 011301H
	DD	08213H
$unwind$?loadCartridge@@YAXPEAUcartridge@@PEADPEAUcpu@@PEAUppu@@@Z DD 011801H
	DD	08218H
$unwind$?power@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z DD 042a19H
	DD	0330118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0180H
$unwind$?reset@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z DD 011301H
	DD	04213H
xdata	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Cpu$ = 48
Ppu$ = 56
Cartridge$ = 64
?reset@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z PROC	; reset

; 544  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 545  :     Cpu->PrgCounter = readCpu16(RESET_VEC, Cpu->MemoryBase);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	66 b9 fc ff	 mov	 cx, 65532		; 0000fffcH
  00020	e8 00 00 00 00	 call	 ?readCpu16@@YAGG_K@Z	; readCpu16
  00025	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0002a	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 546  : 
; 547  :     // NOTE: The status after reset was taken from nesdev
; 548  :     Cpu->StackPtr -= 3;

  0002e	48 8b 44 24 30	 mov	 rax, QWORD PTR Cpu$[rsp]
  00033	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00037	83 e8 03	 sub	 eax, 3
  0003a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0003f	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 549  :     setInterrupt(&Cpu->Flags);

  00042	48 8b 44 24 30	 mov	 rax, QWORD PTR Cpu$[rsp]
  00047	48 83 c0 03	 add	 rax, 3
  0004b	48 8b c8	 mov	 rcx, rax
  0004e	e8 00 00 00 00	 call	 ?setInterrupt@@YAXPEAE@Z ; setInterrupt

; 550  :     // TODO: APU on reset
; 551  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
?reset@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z ENDP	; reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
tv65 = 32
MemoryBase$1 = 40
BasePixel$2 = 48
Registers$3 = 56
$T4 = 64
$T5 = 80
__$ArrayPad$ = 384
Cpu$ = 432
Ppu$ = 440
Cartridge$ = 448
?power@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z PROC	; power

; 518  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 519  :     PowerOn = !PowerOn;

  0002a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PowerOn@@3HA, 0
  00031	75 0a		 jne	 SHORT $LN5@power
  00033	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv65[rsp], 1
  0003b	eb 08		 jmp	 SHORT $LN6@power
$LN5@power:
  0003d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv65[rsp], 0
$LN6@power:
  00045	8b 44 24 20	 mov	 eax, DWORD PTR tv65[rsp]
  00049	89 05 00 00 00
	00		 mov	 DWORD PTR ?PowerOn@@3HA, eax

; 520  : 
; 521  :     if(PowerOn)

  0004f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PowerOn@@3HA, 0
  00056	74 4a		 je	 SHORT $LN2@power

; 522  :     {
; 523  :         loadCartridge(Cartridge, RomFileName, Cpu, Ppu);

  00058	4c 8b 8c 24 b8
	01 00 00	 mov	 r9, QWORD PTR Ppu$[rsp]
  00060	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR Cpu$[rsp]
  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?RomFileName@@3PADA
  0006f	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00077	e8 00 00 00 00	 call	 ?loadCartridge@@YAXPEAUcartridge@@PEADPEAUcpu@@PEAUppu@@@Z ; loadCartridge

; 524  :         Cpu->PrgCounter = readCpu16(RESET_VEC, Cpu->MemoryBase);        

  0007c	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  00084	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00088	66 b9 fc ff	 mov	 cx, 65532		; 0000fffcH
  0008c	e8 00 00 00 00	 call	 ?readCpu16@@YAGG_K@Z	; readCpu16
  00091	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00099	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 525  :     }
; 526  :     else

  0009d	e9 d6 00 00 00	 jmp	 $LN3@power
$LN2@power:

; 527  :     {
; 528  :         uint64 MemoryBase = Cpu->MemoryBase;

  000a2	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  000aa	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000ae	48 89 44 24 28	 mov	 QWORD PTR MemoryBase$1[rsp], rax

; 529  :         *Cpu = {};

  000b3	48 8d 44 24 40	 lea	 rax, QWORD PTR $T4[rsp]
  000b8	48 8b f8	 mov	 rdi, rax
  000bb	33 c0		 xor	 eax, eax
  000bd	b9 10 00 00 00	 mov	 ecx, 16
  000c2	f3 aa		 rep stosb
  000c4	48 8d 44 24 40	 lea	 rax, QWORD PTR $T4[rsp]
  000c9	48 8b bc 24 b0
	01 00 00	 mov	 rdi, QWORD PTR Cpu$[rsp]
  000d1	48 8b f0	 mov	 rsi, rax
  000d4	b9 10 00 00 00	 mov	 ecx, 16
  000d9	f3 a4		 rep movsb

; 530  :         Cpu->MemoryBase = MemoryBase;

  000db	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  000e3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR MemoryBase$1[rsp]
  000e8	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 531  : 
; 532  :         MemoryBase = Ppu->MemoryBase;

  000ec	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  000f4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000f7	48 89 44 24 28	 mov	 QWORD PTR MemoryBase$1[rsp], rax

; 533  :         uint32 *BasePixel = Ppu->BasePixel;

  000fc	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00104	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00108	48 89 44 24 30	 mov	 QWORD PTR BasePixel$2[rsp], rax

; 534  :         ppu_registers *Registers = Ppu->Registers; 

  0010d	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00115	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00119	48 89 44 24 38	 mov	 QWORD PTR Registers$3[rsp], rax

; 535  :         *Ppu = {};

  0011e	48 8d 44 24 50	 lea	 rax, QWORD PTR $T5[rsp]
  00123	48 8b f8	 mov	 rdi, rax
  00126	33 c0		 xor	 eax, eax
  00128	b9 30 01 00 00	 mov	 ecx, 304		; 00000130H
  0012d	f3 aa		 rep stosb
  0012f	48 8d 44 24 50	 lea	 rax, QWORD PTR $T5[rsp]
  00134	48 8b bc 24 b8
	01 00 00	 mov	 rdi, QWORD PTR Ppu$[rsp]
  0013c	48 8b f0	 mov	 rsi, rax
  0013f	b9 30 01 00 00	 mov	 ecx, 304		; 00000130H
  00144	f3 a4		 rep movsb

; 536  :         Ppu->MemoryBase = MemoryBase;

  00146	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0014e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR MemoryBase$1[rsp]
  00153	48 89 08	 mov	 QWORD PTR [rax], rcx

; 537  :         Ppu->BasePixel = BasePixel;

  00156	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0015e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR BasePixel$2[rsp]
  00163	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 538  :         Ppu->Registers = Registers;

  00167	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0016f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Registers$3[rsp]
  00174	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
$LN3@power:

; 539  :     }
; 540  : }

  00178	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00180	48 33 cc	 xor	 rcx, rsp
  00183	e8 00 00 00 00	 call	 __security_check_cookie
  00188	48 81 c4 98 01
	00 00		 add	 rsp, 408		; 00000198H
  0018f	5f		 pop	 rdi
  00190	5e		 pop	 rsi
  00191	c3		 ret	 0
?power@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z ENDP	; power
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Flags6$ = 32
Flags7$ = 33
RomData$ = 40
tv173 = 48
Cartridge$ = 80
FileName$ = 88
Cpu$ = 96
Ppu$ = 104
?loadCartridge@@YAXPEAUcartridge@@PEADPEAUcpu@@PEAUppu@@@Z PROC ; loadCartridge

; 479  : {    

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 480  :     // Reading rom file
; 481  :     Cartridge->FileName = FileName;

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR FileName$[rsp]
  00022	48 89 08	 mov	 QWORD PTR [rax], rcx

; 482  :     Cartridge->FileSize;
; 483  :     Cartridge->Data = (uint8 *)LoadFile(FileName, &Cartridge->FileSize);

  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0002a	48 83 c0 08	 add	 rax, 8
  0002e	48 8b d0	 mov	 rdx, rax
  00031	48 8b 4c 24 58	 mov	 rcx, QWORD PTR FileName$[rsp]
  00036	e8 00 00 00 00	 call	 ?LoadFile@@YAPEAXPEADPEAI@Z ; LoadFile
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00040	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 484  : 
; 485  :     uint8 * RomData = Cartridge->Data;

  00044	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00049	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004d	48 89 44 24 28	 mov	 QWORD PTR RomData$[rsp], rax

; 486  :         
; 487  :     // NOTE: Check for correct header
; 488  :     if(RomData[0] != 'N' || RomData[1] != 'E' || RomData[2] != 'S' || RomData[3] != 0x1A)

  00052	b8 01 00 00 00	 mov	 eax, 1
  00057	48 6b c0 00	 imul	 rax, rax, 0
  0005b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR RomData$[rsp]
  00060	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00064	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  00067	75 45		 jne	 SHORT $LN3@loadCartri
  00069	b8 01 00 00 00	 mov	 eax, 1
  0006e	48 6b c0 01	 imul	 rax, rax, 1
  00072	48 8b 4c 24 28	 mov	 rcx, QWORD PTR RomData$[rsp]
  00077	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0007b	83 f8 45	 cmp	 eax, 69			; 00000045H
  0007e	75 2e		 jne	 SHORT $LN3@loadCartri
  00080	b8 01 00 00 00	 mov	 eax, 1
  00085	48 6b c0 02	 imul	 rax, rax, 2
  00089	48 8b 4c 24 28	 mov	 rcx, QWORD PTR RomData$[rsp]
  0008e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00092	83 f8 53	 cmp	 eax, 83			; 00000053H
  00095	75 17		 jne	 SHORT $LN3@loadCartri
  00097	b8 01 00 00 00	 mov	 eax, 1
  0009c	48 6b c0 03	 imul	 rax, rax, 3
  000a0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR RomData$[rsp]
  000a5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000a9	83 f8 1a	 cmp	 eax, 26
  000ac	74 12		 je	 SHORT $LN2@loadCartri
$LN3@loadCartri:

; 489  :         Assert(0);   

  000ae	33 c0		 xor	 eax, eax
  000b0	83 f8 01	 cmp	 eax, 1
  000b3	74 0b		 je	 SHORT $LN4@loadCartri
  000b5	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN4@loadCartri:
$LN2@loadCartri:

; 490  : 
; 491  :     // NOTE: Read header
; 492  :     Cartridge->PrgBankCount = RomData[4];

  000c0	b8 01 00 00 00	 mov	 eax, 1
  000c5	48 6b c0 04	 imul	 rax, rax, 4
  000c9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  000ce	48 8b 54 24 28	 mov	 rdx, QWORD PTR RomData$[rsp]
  000d3	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  000d7	88 41 18	 mov	 BYTE PTR [rcx+24], al

; 493  :     Cartridge->ChrBankCount = RomData[5];

  000da	b8 01 00 00 00	 mov	 eax, 1
  000df	48 6b c0 05	 imul	 rax, rax, 5
  000e3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  000e8	48 8b 54 24 28	 mov	 rdx, QWORD PTR RomData$[rsp]
  000ed	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  000f1	88 41 28	 mov	 BYTE PTR [rcx+40], al

; 494  :     uint8 Flags6            = RomData[6];        

  000f4	b8 01 00 00 00	 mov	 eax, 1
  000f9	48 6b c0 06	 imul	 rax, rax, 6
  000fd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR RomData$[rsp]
  00102	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00106	88 44 24 20	 mov	 BYTE PTR Flags6$[rsp], al

; 495  :     uint8 Flags7            = RomData[7];

  0010a	b8 01 00 00 00	 mov	 eax, 1
  0010f	48 6b c0 07	 imul	 rax, rax, 7
  00113	48 8b 4c 24 28	 mov	 rcx, QWORD PTR RomData$[rsp]
  00118	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0011c	88 44 24 21	 mov	 BYTE PTR Flags7$[rsp], al

; 496  :     Cartridge->PrgRamSize   = RomData[8];

  00120	b8 01 00 00 00	 mov	 eax, 1
  00125	48 6b c0 08	 imul	 rax, rax, 8
  00129	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  0012e	48 8b 54 24 28	 mov	 rdx, QWORD PTR RomData$[rsp]
  00133	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00137	88 41 38	 mov	 BYTE PTR [rcx+56], al

; 497  :         
; 498  :     Cartridge->UseVertMirror       = Flags6 & (1);

  0013a	0f b6 44 24 20	 movzx	 eax, BYTE PTR Flags6$[rsp]
  0013f	83 e0 01	 and	 eax, 1
  00142	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00147	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 499  :     Cartridge->HasBatteryRam       = Flags6 & (1 << 1);

  0014a	0f b6 44 24 20	 movzx	 eax, BYTE PTR Flags6$[rsp]
  0014f	83 e0 02	 and	 eax, 2
  00152	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00157	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 500  :     Cartridge->HasTrainer          = Flags6 & (1 << 2);

  0015a	0f b6 44 24 20	 movzx	 eax, BYTE PTR Flags6$[rsp]
  0015f	83 e0 04	 and	 eax, 4
  00162	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00167	89 41 44	 mov	 DWORD PTR [rcx+68], eax

; 501  :     Cartridge->UseFourScreenMirror = Flags6 & (1 << 3);

  0016a	0f b6 44 24 20	 movzx	 eax, BYTE PTR Flags6$[rsp]
  0016f	83 e0 08	 and	 eax, 8
  00172	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00177	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 502  :     Cartridge->MapperNum           = (Flags7 & 0xF0) | (Flags6 >> 4);

  0017a	0f b6 44 24 21	 movzx	 eax, BYTE PTR Flags7$[rsp]
  0017f	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00184	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Flags6$[rsp]
  00189	c1 f9 04	 sar	 ecx, 4
  0018c	0b c1		 or	 eax, ecx
  0018e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00193	88 41 39	 mov	 BYTE PTR [rcx+57], al

; 503  : 
; 504  :     Cartridge->PrgData = RomData + 16; // PrgData starts after the header info(16 bytes)

  00196	48 8b 44 24 28	 mov	 rax, QWORD PTR RomData$[rsp]
  0019b	48 83 c0 10	 add	 rax, 16
  0019f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  001a4	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 505  : 
; 506  :     if(Cartridge->HasTrainer)

  001a8	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  001ad	83 78 44 00	 cmp	 DWORD PTR [rax+68], 0
  001b1	74 18		 je	 SHORT $LN5@loadCartri

; 507  :     {
; 508  :         Cartridge->PrgData += 512; // Trainer size 512 bytes

  001b3	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  001b8	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001bc	48 05 00 02 00
	00		 add	 rax, 512		; 00000200H
  001c2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  001c7	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
$LN5@loadCartri:

; 509  :     }
; 510  : 
; 511  :     Cartridge->ChrData = Cartridge->PrgData + (Cartridge->PrgBankCount * Kilobytes(16));

  001cb	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  001d0	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  001d4	48 69 c0 00 40
	00 00		 imul	 rax, rax, 16384		; 00004000H
  001db	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  001e0	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  001e4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  001e9	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 512  : 
; 513  :     mapperInit[Cartridge->MapperNum](Cartridge, Cpu, Ppu);

  001ed	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  001f2	0f b6 40 39	 movzx	 eax, BYTE PTR [rax+57]
  001f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mapperInit@@3PAP6AXPEAUcartridge@@PEAUcpu@@PEAUppu@@@ZA ; mapperInit
  001fd	48 89 4c 24 30	 mov	 QWORD PTR tv173[rsp], rcx
  00202	4c 8b 44 24 68	 mov	 r8, QWORD PTR Ppu$[rsp]
  00207	48 8b 54 24 60	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0020c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00211	4c 8b 4c 24 30	 mov	 r9, QWORD PTR tv173[rsp]
  00216	41 ff 14 c1	 call	 QWORD PTR [r9+rax*8]

; 514  : }

  0021a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0021e	c3		 ret	 0
?loadCartridge@@YAXPEAUcartridge@@PEADPEAUcpu@@PEAUppu@@@Z ENDP ; loadCartridge
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
MemPrgBank1$ = 32
MemPrgBank2$ = 36
BankToCpy1$ = 40
BankToCpy2$ = 48
Cartridge$ = 80
Cpu$ = 88
Ppu$ = 96
?nromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z PROC	; nromInit

; 438  : {

$LN9:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 439  :     if(Cartridge->PrgBankCount != 1 && Cartridge->PrgBankCount != 2 )

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00018	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  0001c	83 f8 01	 cmp	 eax, 1
  0001f	74 20		 je	 SHORT $LN2@nromInit
  00021	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00026	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  0002a	83 f8 02	 cmp	 eax, 2
  0002d	74 12		 je	 SHORT $LN2@nromInit

; 440  :         Assert(0);

  0002f	33 c0		 xor	 eax, eax
  00031	83 f8 01	 cmp	 eax, 1
  00034	74 0b		 je	 SHORT $LN3@nromInit
  00036	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN3@nromInit:
$LN2@nromInit:

; 441  : 
; 442  :     uint16 MemPrgBank1 = 0x8000;

  00041	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00046	66 89 44 24 20	 mov	 WORD PTR MemPrgBank1$[rsp], ax

; 443  :     uint16 MemPrgBank2 = 0xC000;

  0004b	b8 00 c0 00 00	 mov	 eax, 49152		; 0000c000H
  00050	66 89 44 24 24	 mov	 WORD PTR MemPrgBank2$[rsp], ax

; 444  : 
; 445  :     uint8 * BankToCpy1;
; 446  :     uint8 * BankToCpy2;
; 447  :         
; 448  :     if(Cartridge->PrgBankCount == 1)

  00055	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0005a	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  0005e	83 f8 01	 cmp	 eax, 1
  00061	75 1e		 jne	 SHORT $LN4@nromInit

; 449  :     {
; 450  :         BankToCpy1 = Cartridge->PrgData;

  00063	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00068	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0006c	48 89 44 24 28	 mov	 QWORD PTR BankToCpy1$[rsp], rax

; 451  :         BankToCpy2 = Cartridge->PrgData;

  00071	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00076	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0007a	48 89 44 24 30	 mov	 QWORD PTR BankToCpy2$[rsp], rax
  0007f	eb 30		 jmp	 SHORT $LN5@nromInit
$LN4@nromInit:

; 452  :     }
; 453  :     else if(Cartridge->PrgBankCount == 2)

  00081	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00086	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  0008a	83 f8 02	 cmp	 eax, 2
  0008d	75 22		 jne	 SHORT $LN6@nromInit

; 454  :     {
; 455  :         BankToCpy1 = Cartridge->PrgData;

  0008f	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00094	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00098	48 89 44 24 28	 mov	 QWORD PTR BankToCpy1$[rsp], rax

; 456  :         BankToCpy2 = Cartridge->PrgData + Kilobytes(16);

  0009d	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  000a2	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000a6	48 05 00 40 00
	00		 add	 rax, 16384		; 00004000H
  000ac	48 89 44 24 30	 mov	 QWORD PTR BankToCpy2$[rsp], rax
$LN6@nromInit:
$LN5@nromInit:

; 457  :     }
; 458  :         
; 459  :     cpyMemory((uint8 *)MemPrgBank1 + Cpu->MemoryBase, BankToCpy1, Kilobytes(16));

  000b1	0f b7 44 24 20	 movzx	 eax, WORD PTR MemPrgBank1$[rsp]
  000b6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Cpu$[rsp]
  000bb	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  000bf	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  000c4	48 8b 54 24 28	 mov	 rdx, QWORD PTR BankToCpy1$[rsp]
  000c9	48 8b c8	 mov	 rcx, rax
  000cc	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 460  :     cpyMemory((uint8 *)MemPrgBank2 + Cpu->MemoryBase, BankToCpy2, Kilobytes(16));

  000d1	0f b7 44 24 24	 movzx	 eax, WORD PTR MemPrgBank2$[rsp]
  000d6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Cpu$[rsp]
  000db	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  000df	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  000e4	48 8b 54 24 30	 mov	 rdx, QWORD PTR BankToCpy2$[rsp]
  000e9	48 8b c8	 mov	 rcx, rax
  000ec	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 461  : 
; 462  :     // Map CHR Data to Ppu
; 463  :     if(Cartridge->ChrBankCount == 1)

  000f1	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  000f6	0f b6 40 28	 movzx	 eax, BYTE PTR [rax+40]
  000fa	83 f8 01	 cmp	 eax, 1
  000fd	75 1b		 jne	 SHORT $LN7@nromInit

; 464  :     {
; 465  :         cpyMemory((uint8 *)Ppu->MemoryBase, Cartridge->ChrData, Kilobytes(8));

  000ff	66 41 b8 00 20	 mov	 r8w, 8192		; 00002000H
  00104	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00109	48 8b 50 30	 mov	 rdx, QWORD PTR [rax+48]
  0010d	48 8b 44 24 60	 mov	 rax, QWORD PTR Ppu$[rsp]
  00112	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00115	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory
$LN7@nromInit:

; 466  :     }
; 467  : }

  0011a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0011e	c3		 ret	 0
?nromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ENDP	; nromInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Ppu$ = 8
MemoryBase$ = 16
BasePixel$ = 24
PpuRegisters$ = 32
?initPpu@@YAXPEAUppu@@_KPEAIPEAUppu_registers@@@Z PROC	; initPpu

; 405  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 406  :     OamData = Ppu->Oam;

  00014	48 8b 44 24 08	 mov	 rax, QWORD PTR Ppu$[rsp]
  00019	48 83 c0 20	 add	 rax, 32			; 00000020H
  0001d	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?OamData@@3PEAEEA, rax

; 407  : 
; 408  :     Ppu->MemoryBase = MemoryBase;

  00024	48 8b 44 24 08	 mov	 rax, QWORD PTR Ppu$[rsp]
  00029	48 8b 4c 24 10	 mov	 rcx, QWORD PTR MemoryBase$[rsp]
  0002e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 409  :     Ppu->Registers = PpuRegisters;    

  00031	48 8b 44 24 08	 mov	 rax, QWORD PTR Ppu$[rsp]
  00036	48 8b 4c 24 20	 mov	 rcx, QWORD PTR PpuRegisters$[rsp]
  0003b	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 410  :     Ppu->BasePixel = BasePixel;

  0003f	48 8b 44 24 08	 mov	 rax, QWORD PTR Ppu$[rsp]
  00044	48 8b 4c 24 18	 mov	 rcx, QWORD PTR BasePixel$[rsp]
  00049	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 411  : }

  0004d	c3		 ret	 0
?initPpu@@YAXPEAUppu@@_KPEAIPEAUppu_registers@@@Z ENDP	; initPpu
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Cpu$ = 8
MemoryBase$ = 16
?initCPU@@YAXPEAUcpu@@_K@Z PROC				; initCPU

; 398  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 399  :     Cpu->MemoryBase = MemoryBase;

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR Cpu$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR MemoryBase$[rsp]
  00014	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 400  : }

  00018	c3		 ret	 0
?initCPU@@YAXPEAUcpu@@_K@Z ENDP				; initCPU
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
BackBuffer$ = 128
DeviceContext$ = 136
WindowWidth$ = 144
WindowHeight$ = 152
?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z PROC ; drawScreenBuffer

; 386  : {                

  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000c	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00011	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00016	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 387  :     StretchDIBits(DeviceContext,

  0001a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  00022	0f b7 8c 24 98
	00 00 00	 movzx	 ecx, WORD PTR WindowHeight$[rsp]
  0002a	0f b7 94 24 90
	00 00 00	 movzx	 edx, WORD PTR WindowWidth$[rsp]
  00032	c7 44 24 60 20
	00 cc 00	 mov	 DWORD PTR [rsp+96], 13369376 ; 00cc0020H
  0003a	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR [rsp+88], 0
  00042	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00047	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  0004f	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00053	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00058	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  00060	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00063	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00067	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  0006f	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00072	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00076	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  0007e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00086	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0008a	44 8b ca	 mov	 r9d, edx
  0008d	45 33 c0	 xor	 r8d, r8d
  00090	33 d2		 xor	 edx, edx
  00092	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR DeviceContext$[rsp]
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_StretchDIBits

; 388  :                   0, 0, WindowWidth, WindowHeight,
; 389  :                   0, 0, BackBuffer->Width, BackBuffer->Height,
; 390  :                   BackBuffer->Memory,
; 391  :                   &BackBuffer->Info,
; 392  :                   DIB_RGB_COLORS, SRCCOPY);
; 393  : }

  000a0	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000a4	c3		 ret	 0
?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z ENDP ; drawScreenBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
MemorySize$ = 32
Buffer$ = 64
Width$ = 72
Height$ = 80
?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z PROC	; createBackBuffer

; 360  : {

  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 361  :     // TODO: This is based on Handmade Hero code. Will need to reference and look at licences later on
; 362  :     //       website: handmadehero.org
; 363  :     if(Buffer->Memory)

  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  00019	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  0001e	74 17		 je	 SHORT $LN2@createBack

; 364  :     {
; 365  :         VirtualFree(Buffer->Memory, 0, MEM_RELEASE);

  00020	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00026	33 d2		 xor	 edx, edx
  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  0002d	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualFree
$LN2@createBack:

; 366  :     }
; 367  : 
; 368  :     Buffer->Width = Width;

  00037	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  00041	89 41 38	 mov	 DWORD PTR [rcx+56], eax

; 369  :     Buffer->Height = Height;

  00044	0f b7 44 24 50	 movzx	 eax, WORD PTR Height$[rsp]
  00049	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  0004e	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 370  :     Buffer->BytesPerPixel = 4;

  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  00056	c7 40 44 04 00
	00 00		 mov	 DWORD PTR [rax+68], 4

; 371  : 
; 372  :     Buffer->Info.bmiHeader.biSize = sizeof(Buffer->Info.bmiHeader);

  0005d	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  00062	c7 00 28 00 00
	00		 mov	 DWORD PTR [rax], 40	; 00000028H

; 373  :     Buffer->Info.bmiHeader.biWidth = Width;

  00068	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  0006d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  00072	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 374  :     Buffer->Info.bmiHeader.biHeight = -Height; // Negative tells windows that we raster top to bottom

  00075	0f b7 44 24 50	 movzx	 eax, WORD PTR Height$[rsp]
  0007a	f7 d8		 neg	 eax
  0007c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  00081	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 375  :     Buffer->Info.bmiHeader.biPlanes = 1;

  00084	b8 01 00 00 00	 mov	 eax, 1
  00089	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  0008e	66 89 41 0c	 mov	 WORD PTR [rcx+12], ax

; 376  :     Buffer->Info.bmiHeader.biBitCount = 32;

  00092	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  0009c	66 89 41 0e	 mov	 WORD PTR [rcx+14], ax

; 377  :     Buffer->Info.bmiHeader.biCompression = BI_RGB;

  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  000a5	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 378  : 
; 379  :     int MemorySize = Width * Height * Buffer->BytesPerPixel;

  000ac	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  000b1	0f b7 4c 24 50	 movzx	 ecx, WORD PTR Height$[rsp]
  000b6	0f af c1	 imul	 eax, ecx
  000b9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000be	0f af 41 44	 imul	 eax, DWORD PTR [rcx+68]
  000c2	89 44 24 20	 mov	 DWORD PTR MemorySize$[rsp], eax

; 380  :     Buffer->Memory = VirtualAlloc(0, MemorySize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);

  000c6	48 63 44 24 20	 movsxd	 rax, DWORD PTR MemorySize$[rsp]
  000cb	41 b9 04 00 00
	00		 mov	 r9d, 4
  000d1	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  000d7	48 8b d0	 mov	 rdx, rax
  000da	33 c9		 xor	 ecx, ecx
  000dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  000e2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000e7	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 381  :     Buffer->Pitch = Width * Buffer->BytesPerPixel;

  000eb	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  000f0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000f5	0f af 41 44	 imul	 eax, DWORD PTR [rcx+68]
  000f9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000fe	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 382  : }

  00101	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00105	c3		 ret	 0
?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z ENDP	; createBackBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
ClientRect$ = 32
__$ArrayPad$ = 48
Window$ = 80
Width$ = 88
Height$ = 96
?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z PROC		; getWindowSize

; 351  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 352  :     RECT ClientRect;
; 353  :     GetClientRect(Window, &ClientRect);

  00022	48 8d 54 24 20	 lea	 rdx, QWORD PTR ClientRect$[rsp]
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Window$[rsp]
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetClientRect

; 354  :     *Width = ClientRect.right - ClientRect.left;

  00032	8b 44 24 20	 mov	 eax, DWORD PTR ClientRect$[rsp]
  00036	8b 4c 24 28	 mov	 ecx, DWORD PTR ClientRect$[rsp+8]
  0003a	2b c8		 sub	 ecx, eax
  0003c	8b c1		 mov	 eax, ecx
  0003e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Width$[rsp]
  00043	66 89 01	 mov	 WORD PTR [rcx], ax

; 355  :     *Height = ClientRect.bottom - ClientRect.top;

  00046	8b 44 24 24	 mov	 eax, DWORD PTR ClientRect$[rsp+4]
  0004a	8b 4c 24 2c	 mov	 ecx, DWORD PTR ClientRect$[rsp+12]
  0004e	2b c8		 sub	 ecx, eax
  00050	8b c1		 mov	 eax, ecx
  00052	48 8b 4c 24 60	 mov	 rcx, QWORD PTR Height$[rsp]
  00057	66 89 01	 mov	 WORD PTR [rcx], ax

; 356  : }

  0005a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0005f	48 33 cc	 xor	 rcx, rsp
  00062	e8 00 00 00 00	 call	 __security_check_cookie
  00067	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006b	c3		 ret	 0
?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z ENDP		; getWindowSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
SprtPixY$1 = 48
SprtPixX$2 = 49
NameTableBaseNum$ = 50
PatternValue$3 = 51
Registers$ = 56
NameTableBaseAdrs$ = 64
PixelY$4 = 68
PixelX$5 = 72
NameTableValue$6 = 76
AttributeValue$7 = 77
PatternPixelValue$8 = 78
PixelColourIndex$9 = 79
PaletteIndex$10 = 80
SpriteY$11 = 81
SpriteX$12 = 82
SpriteTile$13 = 83
TempColour$14 = 84
PatternBase$ = 88
TempPatternBase$ = 92
y$15 = 96
x$16 = 100
i$17 = 104
SpriteInfo$18 = 108
SpriteAttrib$19 = 112
Colour$20 = 116
tv442 = 120
Sprite8x16$ = 124
tv162 = 128
tv241 = 132
tv245 = 136
tv252 = 140
tv256 = 144
VisibleLine$ = 148
BackgroundEnabled$ = 152
SpritesEnabled$ = 156
PostRenderLine$ = 160
VBlankLine$ = 164
PreRenderLine$ = 168
SpriteInfoPtr$ = 176
BackBuffer$ = 208
Ppu$ = 216
?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z PROC	; ppuTick

; 164  : {    

$LN73:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H

; 165  :     ppu_registers *Registers = Ppu->Registers;

  00012	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0001a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0001e	48 89 44 24 38	 mov	 QWORD PTR Registers$[rsp], rax

; 166  : 
; 167  :     if(OamDataChange)

  00023	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?OamDataChange@@3HA, 0 ; OamDataChange
  0002a	74 3b		 je	 SHORT $LN19@ppuTick

; 168  :     {
; 169  :         OamDataChange = false;

  0002c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?OamDataChange@@3HA, 0 ; OamDataChange

; 170  :         Ppu->Oam[Registers->OamAddress] = Registers->OamIO;

  00036	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  0003b	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0003f	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00047	48 8b 54 24 38	 mov	 rdx, QWORD PTR Registers$[rsp]
  0004c	0f b6 52 04	 movzx	 edx, BYTE PTR [rdx+4]
  00050	88 54 01 20	 mov	 BYTE PTR [rcx+rax+32], dl

; 171  :         ++Registers->OamAddress;

  00054	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  00059	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0005d	fe c0		 inc	 al
  0005f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Registers$[rsp]
  00064	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN19@ppuTick:

; 172  :     }
; 173  :     
; 174  :     if(ScrollAdrsChange)

  00067	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ScrollAdrsChange@@3HA, 0 ; ScrollAdrsChange
  0006e	74 36		 je	 SHORT $LN20@ppuTick

; 175  :     {
; 176  :         ScrollAdrsChange = false;

  00070	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ScrollAdrsChange@@3HA, 0 ; ScrollAdrsChange

; 177  :         Ppu->ScrollPosition = (Ppu->ScrollPosition << 8) | (uint16)Registers->ScrollAddress;

  0007a	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00082	0f b7 80 26 01
	00 00		 movzx	 eax, WORD PTR [rax+294]
  00089	c1 e0 08	 shl	 eax, 8
  0008c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Registers$[rsp]
  00091	0f b6 49 05	 movzx	 ecx, BYTE PTR [rcx+5]
  00095	0b c1		 or	 eax, ecx
  00097	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0009f	66 89 81 26 01
	00 00		 mov	 WORD PTR [rcx+294], ax
$LN20@ppuTick:

; 178  :     }
; 179  :     
; 180  :     // NOTE: This is where data is transferred from Cpu via IO registers
; 181  :     if(VRamAdrsChange)

  000a6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?VRamAdrsChange@@3HA, 0 ; VRamAdrsChange
  000ad	0f 84 89 00 00
	00		 je	 $LN21@ppuTick

; 182  :     {
; 183  :         VRamAdrsChange = false;

  000b3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?VRamAdrsChange@@3HA, 0 ; VRamAdrsChange

; 184  :         Ppu->VRamIOAddress = (Ppu->VRamIOAddress << 8) | (uint16)Registers->VRamAddress;

  000bd	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  000c5	0f b7 80 24 01
	00 00		 movzx	 eax, WORD PTR [rax+292]
  000cc	c1 e0 08	 shl	 eax, 8
  000cf	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Registers$[rsp]
  000d4	0f b6 49 06	 movzx	 ecx, BYTE PTR [rcx+6]
  000d8	0b c1		 or	 eax, ecx
  000da	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  000e2	66 89 81 24 01
	00 00		 mov	 WORD PTR [rcx+292], ax

; 185  :         
; 186  :         // NOTE: If address is on the pallette. Then IO register is updated immediately
; 187  :         if(0x3F00 <= Ppu->VRamIOAddress && Ppu->VRamIOAddress <= 0x3FFF)

  000e9	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  000f1	0f b7 80 24 01
	00 00		 movzx	 eax, WORD PTR [rax+292]
  000f8	3d 00 3f 00 00	 cmp	 eax, 16128		; 00003f00H
  000fd	7c 3d		 jl	 SHORT $LN22@ppuTick
  000ff	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00107	0f b7 80 24 01
	00 00		 movzx	 eax, WORD PTR [rax+292]
  0010e	3d ff 3f 00 00	 cmp	 eax, 16383		; 00003fffH
  00113	7f 27		 jg	 SHORT $LN22@ppuTick

; 188  :             Registers->VRamIO = readPpu8(Ppu->VRamIOAddress, Ppu->MemoryBase);

  00115	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0011d	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00120	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00128	0f b7 88 24 01
	00 00		 movzx	 ecx, WORD PTR [rax+292]
  0012f	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  00134	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Registers$[rsp]
  00139	88 41 07	 mov	 BYTE PTR [rcx+7], al
$LN22@ppuTick:
$LN21@ppuTick:

; 189  :     }
; 190  : 
; 191  :     if(IOWriteFromCpu)

  0013c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IOWriteFromCpu@@3HA, 0 ; IOWriteFromCpu
  00143	0f 84 85 00 00
	00		 je	 $LN23@ppuTick

; 192  :     {
; 193  :         IOWriteFromCpu = false;

  00149	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?IOWriteFromCpu@@3HA, 0 ; IOWriteFromCpu

; 194  :         
; 195  :         writePpu8(Registers->VRamIO, Ppu->VRamIOAddress, Ppu->MemoryBase);

  00153	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0015b	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  0015e	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00166	0f b7 90 24 01
	00 00		 movzx	 edx, WORD PTR [rax+292]
  0016d	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  00172	0f b6 48 07	 movzx	 ecx, BYTE PTR [rax+7]
  00176	e8 00 00 00 00	 call	 ?writePpu8@@YAXEG_K@Z	; writePpu8

; 196  :         if(Registers->Ctrl1 & (1 << 2))

  0017b	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  00180	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00183	83 e0 04	 and	 eax, 4
  00186	85 c0		 test	 eax, eax
  00188	74 23		 je	 SHORT $LN24@ppuTick

; 197  :             Ppu->VRamIOAddress += 32;

  0018a	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00192	0f b7 80 24 01
	00 00		 movzx	 eax, WORD PTR [rax+292]
  00199	83 c0 20	 add	 eax, 32			; 00000020H
  0019c	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  001a4	66 89 81 24 01
	00 00		 mov	 WORD PTR [rcx+292], ax

; 198  :         else

  001ab	eb 21		 jmp	 SHORT $LN25@ppuTick
$LN24@ppuTick:

; 199  :             ++Ppu->VRamIOAddress;

  001ad	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  001b5	0f b7 80 24 01
	00 00		 movzx	 eax, WORD PTR [rax+292]
  001bc	66 ff c0	 inc	 ax
  001bf	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  001c7	66 89 81 24 01
	00 00		 mov	 WORD PTR [rcx+292], ax
$LN25@ppuTick:
$LN23@ppuTick:

; 200  :     }
; 201  : 
; 202  :     VRamAdrsOnPalette = (0x3F00 <= Ppu->VRamIOAddress && Ppu->VRamIOAddress <= 0x3FFF);

  001ce	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  001d6	0f b7 80 24 01
	00 00		 movzx	 eax, WORD PTR [rax+292]
  001dd	3d 00 3f 00 00	 cmp	 eax, 16128		; 00003f00H
  001e2	7c 23		 jl	 SHORT $LN63@ppuTick
  001e4	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  001ec	0f b7 80 24 01
	00 00		 movzx	 eax, WORD PTR [rax+292]
  001f3	3d ff 3f 00 00	 cmp	 eax, 16383		; 00003fffH
  001f8	7f 0d		 jg	 SHORT $LN63@ppuTick
  001fa	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv162[rsp], 1
  00205	eb 0b		 jmp	 SHORT $LN64@ppuTick
$LN63@ppuTick:
  00207	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv162[rsp], 0
$LN64@ppuTick:
  00212	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv162[rsp]
  00219	89 05 00 00 00
	00		 mov	 DWORD PTR ?VRamAdrsOnPalette@@3HA, eax ; VRamAdrsOnPalette

; 203  :     
; 204  :     if(IOReadFromCpu)

  0021f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IOReadFromCpu@@3HA, 0 ; IOReadFromCpu
  00226	0f 84 09 01 00
	00		 je	 $LN26@ppuTick

; 205  :     {
; 206  :         IOReadFromCpu = false;

  0022c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?IOReadFromCpu@@3HA, 0 ; IOReadFromCpu

; 207  : 
; 208  :         if(VRamAdrsOnPalette)

  00236	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?VRamAdrsOnPalette@@3HA, 0 ; VRamAdrsOnPalette
  0023d	74 7c		 je	 SHORT $LN27@ppuTick

; 209  :         {
; 210  :             if(Registers->Ctrl1 & (1 << 2))

  0023f	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  00244	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00247	83 e0 04	 and	 eax, 4
  0024a	85 c0		 test	 eax, eax
  0024c	74 23		 je	 SHORT $LN29@ppuTick

; 211  :                 Ppu->VRamIOAddress += 32;

  0024e	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00256	0f b7 80 24 01
	00 00		 movzx	 eax, WORD PTR [rax+292]
  0025d	83 c0 20	 add	 eax, 32			; 00000020H
  00260	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00268	66 89 81 24 01
	00 00		 mov	 WORD PTR [rcx+292], ax

; 212  :             else

  0026f	eb 21		 jmp	 SHORT $LN30@ppuTick
$LN29@ppuTick:

; 213  :                 ++Ppu->VRamIOAddress;

  00271	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00279	0f b7 80 24 01
	00 00		 movzx	 eax, WORD PTR [rax+292]
  00280	66 ff c0	 inc	 ax
  00283	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0028b	66 89 81 24 01
	00 00		 mov	 WORD PTR [rcx+292], ax
$LN30@ppuTick:

; 214  :             Registers->VRamIO = readPpu8(Ppu->VRamIOAddress, Ppu->MemoryBase);

  00292	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0029a	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0029d	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  002a5	0f b7 88 24 01
	00 00		 movzx	 ecx, WORD PTR [rax+292]
  002ac	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  002b1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Registers$[rsp]
  002b6	88 41 07	 mov	 BYTE PTR [rcx+7], al

; 215  :         }
; 216  :         else

  002b9	eb 7a		 jmp	 SHORT $LN28@ppuTick
$LN27@ppuTick:

; 217  :         {
; 218  :             Registers->VRamIO = readPpu8(Ppu->VRamIOAddress, Ppu->MemoryBase);

  002bb	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  002c3	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  002c6	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  002ce	0f b7 88 24 01
	00 00		 movzx	 ecx, WORD PTR [rax+292]
  002d5	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  002da	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Registers$[rsp]
  002df	88 41 07	 mov	 BYTE PTR [rcx+7], al

; 219  :             if(Registers->Ctrl1 & (1 << 2))

  002e2	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  002e7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002ea	83 e0 04	 and	 eax, 4
  002ed	85 c0		 test	 eax, eax
  002ef	74 23		 je	 SHORT $LN31@ppuTick

; 220  :                 Ppu->VRamIOAddress += 32;

  002f1	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  002f9	0f b7 80 24 01
	00 00		 movzx	 eax, WORD PTR [rax+292]
  00300	83 c0 20	 add	 eax, 32			; 00000020H
  00303	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0030b	66 89 81 24 01
	00 00		 mov	 WORD PTR [rcx+292], ax

; 221  :             else

  00312	eb 21		 jmp	 SHORT $LN32@ppuTick
$LN31@ppuTick:

; 222  :                 ++Ppu->VRamIOAddress;

  00314	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0031c	0f b7 80 24 01
	00 00		 movzx	 eax, WORD PTR [rax+292]
  00323	66 ff c0	 inc	 ax
  00326	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0032e	66 89 81 24 01
	00 00		 mov	 WORD PTR [rcx+292], ax
$LN32@ppuTick:
$LN28@ppuTick:
$LN26@ppuTick:

; 223  :         }
; 224  :     }
; 225  :     
; 226  :     if(ResetVRamIOAdrs)

  00335	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ResetVRamIOAdrs@@3HA, 0 ; ResetVRamIOAdrs
  0033c	74 1b		 je	 SHORT $LN33@ppuTick

; 227  :     {
; 228  :         Ppu->VRamIOAddress = 0;

  0033e	33 c0		 xor	 eax, eax
  00340	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00348	66 89 81 24 01
	00 00		 mov	 WORD PTR [rcx+292], ax

; 229  :         ResetVRamIOAdrs = false;

  0034f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ResetVRamIOAdrs@@3HA, 0 ; ResetVRamIOAdrs
$LN33@ppuTick:

; 230  :     }
; 231  :     if(ResetScrollIOAdrs)

  00359	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ResetScrollIOAdrs@@3HA, 0 ; ResetScrollIOAdrs
  00360	74 1b		 je	 SHORT $LN34@ppuTick

; 232  :     {
; 233  :         Ppu->ScrollPosition = 0;

  00362	33 c0		 xor	 eax, eax
  00364	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0036c	66 89 81 26 01
	00 00		 mov	 WORD PTR [rcx+294], ax

; 234  :         ResetScrollIOAdrs = false;

  00373	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ResetScrollIOAdrs@@3HA, 0 ; ResetScrollIOAdrs
$LN34@ppuTick:

; 235  :     }
; 236  :     
; 237  : 
; 238  :     uint16 Sprite8x16 = Registers->Ctrl1 & (1 << 5);

  0037d	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  00382	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00385	83 e0 20	 and	 eax, 32			; 00000020H
  00388	66 89 44 24 7c	 mov	 WORD PTR Sprite8x16$[rsp], ax

; 239  : 
; 240  :         
; 241  :     uint16 TempPatternBase = 0x0000;

  0038d	33 c0		 xor	 eax, eax
  0038f	66 89 44 24 5c	 mov	 WORD PTR TempPatternBase$[rsp], ax

; 242  :     if(Registers->Ctrl1 & (1 << 3))

  00394	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  00399	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0039c	83 e0 08	 and	 eax, 8
  0039f	85 c0		 test	 eax, eax
  003a1	74 0a		 je	 SHORT $LN35@ppuTick

; 243  :         TempPatternBase = 0x1000;

  003a3	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  003a8	66 89 44 24 5c	 mov	 WORD PTR TempPatternBase$[rsp], ax
$LN35@ppuTick:

; 244  : 
; 245  : 
; 246  :     
; 247  :     uint16 PatternBase = 0x0000;

  003ad	33 c0		 xor	 eax, eax
  003af	66 89 44 24 58	 mov	 WORD PTR PatternBase$[rsp], ax

; 248  :     if(Registers->Ctrl1 & (1 << 4))

  003b4	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  003b9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003bc	83 e0 10	 and	 eax, 16
  003bf	85 c0		 test	 eax, eax
  003c1	74 0a		 je	 SHORT $LN36@ppuTick

; 249  :         PatternBase = 0x1000;

  003c3	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  003c8	66 89 44 24 58	 mov	 WORD PTR PatternBase$[rsp], ax
$LN36@ppuTick:

; 250  : 
; 251  :     uint8 NameTableBaseNum = Registers->Ctrl1 & 3;

  003cd	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  003d2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003d5	83 e0 03	 and	 eax, 3
  003d8	88 44 24 32	 mov	 BYTE PTR NameTableBaseNum$[rsp], al

; 252  :     uint16 NameTableBaseAdrs; 
; 253  :     if(NameTableBaseNum == 0)

  003dc	0f b6 44 24 32	 movzx	 eax, BYTE PTR NameTableBaseNum$[rsp]
  003e1	85 c0		 test	 eax, eax
  003e3	75 0c		 jne	 SHORT $LN37@ppuTick

; 254  :         NameTableBaseAdrs = 0x2000;

  003e5	b8 00 20 00 00	 mov	 eax, 8192		; 00002000H
  003ea	66 89 44 24 40	 mov	 WORD PTR NameTableBaseAdrs$[rsp], ax
  003ef	eb 40		 jmp	 SHORT $LN38@ppuTick
$LN37@ppuTick:

; 255  :     else if(NameTableBaseNum == 1)

  003f1	0f b6 44 24 32	 movzx	 eax, BYTE PTR NameTableBaseNum$[rsp]
  003f6	83 f8 01	 cmp	 eax, 1
  003f9	75 0c		 jne	 SHORT $LN39@ppuTick

; 256  :         NameTableBaseAdrs = 0x2400;

  003fb	b8 00 24 00 00	 mov	 eax, 9216		; 00002400H
  00400	66 89 44 24 40	 mov	 WORD PTR NameTableBaseAdrs$[rsp], ax
  00405	eb 2a		 jmp	 SHORT $LN40@ppuTick
$LN39@ppuTick:

; 257  :     else if(NameTableBaseNum == 2)

  00407	0f b6 44 24 32	 movzx	 eax, BYTE PTR NameTableBaseNum$[rsp]
  0040c	83 f8 02	 cmp	 eax, 2
  0040f	75 0c		 jne	 SHORT $LN41@ppuTick

; 258  :         NameTableBaseAdrs = 0x2800;

  00411	b8 00 28 00 00	 mov	 eax, 10240		; 00002800H
  00416	66 89 44 24 40	 mov	 WORD PTR NameTableBaseAdrs$[rsp], ax
  0041b	eb 14		 jmp	 SHORT $LN42@ppuTick
$LN41@ppuTick:

; 259  :     else if(NameTableBaseNum == 3)

  0041d	0f b6 44 24 32	 movzx	 eax, BYTE PTR NameTableBaseNum$[rsp]
  00422	83 f8 03	 cmp	 eax, 3
  00425	75 0a		 jne	 SHORT $LN43@ppuTick

; 260  :         NameTableBaseAdrs = 0x2C00;

  00427	b8 00 2c 00 00	 mov	 eax, 11264		; 00002c00H
  0042c	66 89 44 24 40	 mov	 WORD PTR NameTableBaseAdrs$[rsp], ax
$LN43@ppuTick:
$LN42@ppuTick:
$LN40@ppuTick:
$LN38@ppuTick:

; 261  : 
; 262  :     bool32 BackgroundEnabled = Registers->Ctrl2 & (1 << 3);

  00431	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  00436	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0043a	83 e0 08	 and	 eax, 8
  0043d	89 84 24 98 00
	00 00		 mov	 DWORD PTR BackgroundEnabled$[rsp], eax

; 263  :     bool32 SpritesEnabled = Registers->Ctrl2 & (1 << 4);

  00444	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  00449	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0044d	83 e0 10	 and	 eax, 16
  00450	89 84 24 9c 00
	00 00		 mov	 DWORD PTR SpritesEnabled$[rsp], eax

; 264  :     
; 265  :     bool32 VisibleLine = (0 <= Ppu->Scanline && Ppu->Scanline <= 239);

  00457	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0045f	0f b7 80 20 01
	00 00		 movzx	 eax, WORD PTR [rax+288]
  00466	85 c0		 test	 eax, eax
  00468	7c 23		 jl	 SHORT $LN65@ppuTick
  0046a	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00472	0f b7 80 20 01
	00 00		 movzx	 eax, WORD PTR [rax+288]
  00479	3d ef 00 00 00	 cmp	 eax, 239		; 000000efH
  0047e	7f 0d		 jg	 SHORT $LN65@ppuTick
  00480	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv241[rsp], 1
  0048b	eb 0b		 jmp	 SHORT $LN66@ppuTick
$LN65@ppuTick:
  0048d	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv241[rsp], 0
$LN66@ppuTick:
  00498	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv241[rsp]
  0049f	89 84 24 94 00
	00 00		 mov	 DWORD PTR VisibleLine$[rsp], eax

; 266  :     bool32 PostRenderLine = (Ppu->Scanline == 240);

  004a6	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  004ae	0f b7 80 20 01
	00 00		 movzx	 eax, WORD PTR [rax+288]
  004b5	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  004ba	75 0d		 jne	 SHORT $LN67@ppuTick
  004bc	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv245[rsp], 1
  004c7	eb 0b		 jmp	 SHORT $LN68@ppuTick
$LN67@ppuTick:
  004c9	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv245[rsp], 0
$LN68@ppuTick:
  004d4	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv245[rsp]
  004db	89 84 24 a0 00
	00 00		 mov	 DWORD PTR PostRenderLine$[rsp], eax

; 267  :     bool32 VBlankLine = (241 <= Ppu->Scanline && Ppu->Scanline <= 260);

  004e2	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  004ea	0f b7 80 20 01
	00 00		 movzx	 eax, WORD PTR [rax+288]
  004f1	3d f1 00 00 00	 cmp	 eax, 241		; 000000f1H
  004f6	7c 23		 jl	 SHORT $LN69@ppuTick
  004f8	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00500	0f b7 80 20 01
	00 00		 movzx	 eax, WORD PTR [rax+288]
  00507	3d 04 01 00 00	 cmp	 eax, 260		; 00000104H
  0050c	7f 0d		 jg	 SHORT $LN69@ppuTick
  0050e	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv252[rsp], 1
  00519	eb 0b		 jmp	 SHORT $LN70@ppuTick
$LN69@ppuTick:
  0051b	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv252[rsp], 0
$LN70@ppuTick:
  00526	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv252[rsp]
  0052d	89 84 24 a4 00
	00 00		 mov	 DWORD PTR VBlankLine$[rsp], eax

; 268  :     bool32 PreRenderLine = (Ppu->Scanline == 261);

  00534	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0053c	0f b7 80 20 01
	00 00		 movzx	 eax, WORD PTR [rax+288]
  00543	3d 05 01 00 00	 cmp	 eax, 261		; 00000105H
  00548	75 0d		 jne	 SHORT $LN71@ppuTick
  0054a	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv256[rsp], 1
  00555	eb 0b		 jmp	 SHORT $LN72@ppuTick
$LN71@ppuTick:
  00557	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv256[rsp], 0
$LN72@ppuTick:
  00562	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv256[rsp]
  00569	89 84 24 a8 00
	00 00		 mov	 DWORD PTR PreRenderLine$[rsp], eax

; 269  : 
; 270  :     uint32 * SpriteInfoPtr;
; 271  :     
; 272  :     if(VisibleLine)

  00570	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR VisibleLine$[rsp], 0
  00578	0f 84 a9 03 00
	00		 je	 $LN44@ppuTick

; 273  :     {
; 274  :         // NOTE: At the moment I am going to just produce a pixel per cycle with fetching happening each time.
; 275  :         // TODO: Timing of fetches so less loading happens, using fine X scrolling to move through bytes
; 276  : 
; 277  :         if(1 <= Ppu->ScanlineCycle && Ppu->ScanlineCycle <= PIXEL_WIDTH)

  0057e	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00586	0f b7 80 22 01
	00 00		 movzx	 eax, WORD PTR [rax+290]
  0058d	83 f8 01	 cmp	 eax, 1
  00590	0f 8c 91 03 00
	00		 jl	 $LN45@ppuTick
  00596	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0059e	0f b7 80 22 01
	00 00		 movzx	 eax, WORD PTR [rax+290]
  005a5	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  005aa	0f 8f 77 03 00
	00		 jg	 $LN45@ppuTick

; 278  :         {
; 279  :             uint16 PixelX = Ppu->ScanlineCycle - 1;

  005b0	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  005b8	0f b7 80 22 01
	00 00		 movzx	 eax, WORD PTR [rax+290]
  005bf	ff c8		 dec	 eax
  005c1	66 89 44 24 48	 mov	 WORD PTR PixelX$5[rsp], ax

; 280  :             uint16 PixelY = Ppu->Scanline;

  005c6	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  005ce	0f b7 80 20 01
	00 00		 movzx	 eax, WORD PTR [rax+288]
  005d5	66 89 44 24 44	 mov	 WORD PTR PixelY$4[rsp], ax

; 281  : 
; 282  :             // NOTE: If set, draw background
; 283  :             if(BackgroundEnabled)

  005da	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR BackgroundEnabled$[rsp], 0
  005e2	0f 84 f0 00 00
	00		 je	 $LN46@ppuTick

; 284  :             {
; 285  :                 uint8 NameTableValue = getNameTableValue(PixelX, PixelY, NameTableBaseAdrs, Ppu->MemoryBase);

  005e8	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  005f0	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  005f3	44 0f b7 44 24
	40		 movzx	 r8d, WORD PTR NameTableBaseAdrs$[rsp]
  005f9	0f b7 54 24 44	 movzx	 edx, WORD PTR PixelY$4[rsp]
  005fe	0f b7 4c 24 48	 movzx	 ecx, WORD PTR PixelX$5[rsp]
  00603	e8 00 00 00 00	 call	 ?getNameTableValue@@YAEGGG_K@Z ; getNameTableValue
  00608	88 44 24 4c	 mov	 BYTE PTR NameTableValue$6[rsp], al

; 286  :                 uint8 PatternPixelValue = getPatternValue(PixelX, PixelY, NameTableValue, PatternBase, Ppu->MemoryBase);

  0060c	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00614	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00617	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0061c	44 0f b7 4c 24
	58		 movzx	 r9d, WORD PTR PatternBase$[rsp]
  00622	44 0f b6 44 24
	4c		 movzx	 r8d, BYTE PTR NameTableValue$6[rsp]
  00628	0f b7 54 24 44	 movzx	 edx, WORD PTR PixelY$4[rsp]
  0062d	0f b7 4c 24 48	 movzx	 ecx, WORD PTR PixelX$5[rsp]
  00632	e8 00 00 00 00	 call	 ?getPatternValue@@YAEGGEG_K@Z ; getPatternValue
  00637	88 44 24 4e	 mov	 BYTE PTR PatternPixelValue$8[rsp], al

; 287  :                 uint8 AttributeValue = getAttributeValue(PixelX, PixelY, NameTableBaseAdrs + ATTRIBUTE_OFFSET, Ppu->MemoryBase);

  0063b	0f b7 44 24 40	 movzx	 eax, WORD PTR NameTableBaseAdrs$[rsp]
  00640	05 c0 03 00 00	 add	 eax, 960		; 000003c0H
  00645	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0064d	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  00650	44 0f b7 c0	 movzx	 r8d, ax
  00654	0f b7 54 24 44	 movzx	 edx, WORD PTR PixelY$4[rsp]
  00659	0f b7 4c 24 48	 movzx	 ecx, WORD PTR PixelX$5[rsp]
  0065e	e8 00 00 00 00	 call	 ?getAttributeValue@@YAEGGG_K@Z ; getAttributeValue
  00663	88 44 24 4d	 mov	 BYTE PTR AttributeValue$7[rsp], al

; 288  : 
; 289  :                 uint8 PixelColourIndex = (AttributeValue << 2) | PatternPixelValue;

  00667	0f b6 44 24 4d	 movzx	 eax, BYTE PTR AttributeValue$7[rsp]
  0066c	c1 e0 02	 shl	 eax, 2
  0066f	0f b6 4c 24 4e	 movzx	 ecx, BYTE PTR PatternPixelValue$8[rsp]
  00674	0b c1		 or	 eax, ecx
  00676	88 44 24 4f	 mov	 BYTE PTR PixelColourIndex$9[rsp], al

; 290  : 
; 291  :                 uint8 PaletteIndex = readPpu8(BGRD_PALETTE_ADRS + PixelColourIndex, Ppu->MemoryBase);

  0067a	0f b6 44 24 4f	 movzx	 eax, BYTE PTR PixelColourIndex$9[rsp]
  0067f	05 00 3f 00 00	 add	 eax, 16128		; 00003f00H
  00684	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0068c	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  0068f	0f b7 c8	 movzx	 ecx, ax
  00692	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  00697	88 44 24 50	 mov	 BYTE PTR PaletteIndex$10[rsp], al

; 292  :             
; 293  :                 uint8 Colour[3] = {};

  0069b	48 8d 44 24 74	 lea	 rax, QWORD PTR Colour$20[rsp]
  006a0	48 8b f8	 mov	 rdi, rax
  006a3	33 c0		 xor	 eax, eax
  006a5	b9 03 00 00 00	 mov	 ecx, 3
  006aa	f3 aa		 rep stosb

; 294  :                 getPaletteValue(PaletteIndex, Colour);

  006ac	48 8d 54 24 74	 lea	 rdx, QWORD PTR Colour$20[rsp]
  006b1	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR PaletteIndex$10[rsp]
  006b6	e8 00 00 00 00	 call	 ?getPaletteValue@@YAXEPEAE@Z ; getPaletteValue

; 295  :            
; 296  :                 drawPixel(Ppu, PixelX, PixelY, Colour);

  006bb	4c 8d 4c 24 74	 lea	 r9, QWORD PTR Colour$20[rsp]
  006c0	44 0f b7 44 24
	44		 movzx	 r8d, WORD PTR PixelY$4[rsp]
  006c6	0f b7 54 24 48	 movzx	 edx, WORD PTR PixelX$5[rsp]
  006cb	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  006d3	e8 00 00 00 00	 call	 ?drawPixel@@YAXPEAUppu@@GGPEAE@Z ; drawPixel
$LN46@ppuTick:

; 297  :             }            
; 298  : 
; 299  : 
; 300  : 
; 301  :             // NOTE: I am drawing the sprite at the end of the frame.
; 302  :             if(SpritesEnabled && Ppu->Scanline == 239 && Ppu->ScanlineCycle == PIXEL_WIDTH)

  006d8	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR SpritesEnabled$[rsp], 0
  006e0	0f 84 41 02 00
	00		 je	 $LN47@ppuTick
  006e6	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  006ee	0f b7 80 20 01
	00 00		 movzx	 eax, WORD PTR [rax+288]
  006f5	3d ef 00 00 00	 cmp	 eax, 239		; 000000efH
  006fa	0f 85 27 02 00
	00		 jne	 $LN47@ppuTick
  00700	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00708	0f b7 80 22 01
	00 00		 movzx	 eax, WORD PTR [rax+290]
  0070f	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00714	0f 85 0d 02 00
	00		 jne	 $LN47@ppuTick

; 303  :             {
; 304  :                 // Loop through each pixel, if sprite top left is there...draw!
; 305  :                 for(uint8 SprtPixY = 0; SprtPixY < 240; ++SprtPixY)

  0071a	c6 44 24 30 00	 mov	 BYTE PTR SprtPixY$1[rsp], 0
  0071f	eb 0b		 jmp	 SHORT $LN4@ppuTick
$LN2@ppuTick:
  00721	0f b6 44 24 30	 movzx	 eax, BYTE PTR SprtPixY$1[rsp]
  00726	fe c0		 inc	 al
  00728	88 44 24 30	 mov	 BYTE PTR SprtPixY$1[rsp], al
$LN4@ppuTick:
  0072c	0f b6 44 24 30	 movzx	 eax, BYTE PTR SprtPixY$1[rsp]
  00731	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  00736	0f 8d eb 01 00
	00		 jge	 $LN3@ppuTick

; 306  :                 {
; 307  :                     for(uint8 SprtPixX = 1; SprtPixX <= PIXEL_WIDTH; ++SprtPixX)

  0073c	c6 44 24 31 01	 mov	 BYTE PTR SprtPixX$2[rsp], 1
  00741	eb 0b		 jmp	 SHORT $LN7@ppuTick
$LN5@ppuTick:
  00743	0f b6 44 24 31	 movzx	 eax, BYTE PTR SprtPixX$2[rsp]
  00748	fe c0		 inc	 al
  0074a	88 44 24 31	 mov	 BYTE PTR SprtPixX$2[rsp], al
$LN7@ppuTick:
  0074e	0f b6 44 24 31	 movzx	 eax, BYTE PTR SprtPixX$2[rsp]
  00753	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00758	0f 8f c4 01 00
	00		 jg	 $LN6@ppuTick

; 308  :                     {
; 309  :                 
; 310  :                         if(!Sprite8x16)

  0075e	0f b7 44 24 7c	 movzx	 eax, WORD PTR Sprite8x16$[rsp]
  00763	85 c0		 test	 eax, eax
  00765	0f 85 b2 01 00
	00		 jne	 $LN48@ppuTick

; 311  :                         {
; 312  :                             SpriteInfoPtr = (uint32 *)Ppu->Oam;

  0076b	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00773	48 83 c0 20	 add	 rax, 32			; 00000020H
  00777	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR SpriteInfoPtr$[rsp], rax

; 313  :                             for(int i = 0; i < 5; ++i)

  0077f	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$17[rsp], 0
  00787	eb 0a		 jmp	 SHORT $LN10@ppuTick
$LN8@ppuTick:
  00789	8b 44 24 68	 mov	 eax, DWORD PTR i$17[rsp]
  0078d	ff c0		 inc	 eax
  0078f	89 44 24 68	 mov	 DWORD PTR i$17[rsp], eax
$LN10@ppuTick:
  00793	83 7c 24 68 05	 cmp	 DWORD PTR i$17[rsp], 5
  00798	0f 8d 7f 01 00
	00		 jge	 $LN9@ppuTick

; 314  :                             {
; 315  :                                 uint32 SpriteInfo = SpriteInfoPtr[i]; 

  0079e	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$17[rsp]
  007a3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR SpriteInfoPtr$[rsp]
  007ab	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  007ae	89 44 24 6c	 mov	 DWORD PTR SpriteInfo$18[rsp], eax

; 316  :                         
; 317  :                                 uint8 SpriteY = SpriteInfo & 0xFF;

  007b2	8b 44 24 6c	 mov	 eax, DWORD PTR SpriteInfo$18[rsp]
  007b6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  007bb	88 44 24 51	 mov	 BYTE PTR SpriteY$11[rsp], al

; 318  :                                 uint8 SpriteTile = (SpriteInfo >> 8)  & 0xFF;

  007bf	8b 44 24 6c	 mov	 eax, DWORD PTR SpriteInfo$18[rsp]
  007c3	c1 e8 08	 shr	 eax, 8
  007c6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  007cb	88 44 24 53	 mov	 BYTE PTR SpriteTile$13[rsp], al

; 319  :                                 uint8 SpriteAttrib = (SpriteInfo >> 16)  & 0xFF;

  007cf	8b 44 24 6c	 mov	 eax, DWORD PTR SpriteInfo$18[rsp]
  007d3	c1 e8 10	 shr	 eax, 16
  007d6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  007db	88 44 24 70	 mov	 BYTE PTR SpriteAttrib$19[rsp], al

; 320  :                                 uint8 SpriteX = (SpriteInfo >> 24)  & 0xFF;

  007df	8b 44 24 6c	 mov	 eax, DWORD PTR SpriteInfo$18[rsp]
  007e3	c1 e8 18	 shr	 eax, 24
  007e6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  007eb	88 44 24 52	 mov	 BYTE PTR SpriteX$12[rsp], al

; 321  : 
; 322  :                                 if((SpriteY + 1) == SprtPixY && SpriteX == SprtPixX)

  007ef	0f b6 44 24 51	 movzx	 eax, BYTE PTR SpriteY$11[rsp]
  007f4	ff c0		 inc	 eax
  007f6	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR SprtPixY$1[rsp]
  007fb	3b c1		 cmp	 eax, ecx
  007fd	0f 85 15 01 00
	00		 jne	 $LN49@ppuTick
  00803	0f b6 44 24 52	 movzx	 eax, BYTE PTR SpriteX$12[rsp]
  00808	0f b6 4c 24 31	 movzx	 ecx, BYTE PTR SprtPixX$2[rsp]
  0080d	3b c1		 cmp	 eax, ecx
  0080f	0f 85 03 01 00
	00		 jne	 $LN49@ppuTick

; 323  :                                 {
; 324  :                                     for(int y = 0; y < 8; ++y)

  00815	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR y$15[rsp], 0
  0081d	eb 0a		 jmp	 SHORT $LN13@ppuTick
$LN11@ppuTick:
  0081f	8b 44 24 60	 mov	 eax, DWORD PTR y$15[rsp]
  00823	ff c0		 inc	 eax
  00825	89 44 24 60	 mov	 DWORD PTR y$15[rsp], eax
$LN13@ppuTick:
  00829	83 7c 24 60 08	 cmp	 DWORD PTR y$15[rsp], 8
  0082e	0f 8d e4 00 00
	00		 jge	 $LN12@ppuTick

; 325  :                                     {
; 326  :                                         for(int x = 0; x < 8; ++x)

  00834	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR x$16[rsp], 0
  0083c	eb 0a		 jmp	 SHORT $LN16@ppuTick
$LN14@ppuTick:
  0083e	8b 44 24 64	 mov	 eax, DWORD PTR x$16[rsp]
  00842	ff c0		 inc	 eax
  00844	89 44 24 64	 mov	 DWORD PTR x$16[rsp], eax
$LN16@ppuTick:
  00848	83 7c 24 64 08	 cmp	 DWORD PTR x$16[rsp], 8
  0084d	0f 8d c0 00 00
	00		 jge	 $LN15@ppuTick

; 327  :                                         {
; 328  :                                             uint8 PatternValue = getPatternValue(x, y, SpriteTile, TempPatternBase, Ppu->MemoryBase);

  00853	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0085b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0085e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00863	44 0f b7 4c 24
	5c		 movzx	 r9d, WORD PTR TempPatternBase$[rsp]
  00869	44 0f b6 44 24
	53		 movzx	 r8d, BYTE PTR SpriteTile$13[rsp]
  0086f	0f b7 54 24 60	 movzx	 edx, WORD PTR y$15[rsp]
  00874	0f b7 4c 24 64	 movzx	 ecx, WORD PTR x$16[rsp]
  00879	e8 00 00 00 00	 call	 ?getPatternValue@@YAEGGEG_K@Z ; getPatternValue
  0087e	88 44 24 33	 mov	 BYTE PTR PatternValue$3[rsp], al

; 329  :                                             
; 330  :                                             uint8 TempColour[3] = {};

  00882	48 8d 44 24 54	 lea	 rax, QWORD PTR TempColour$14[rsp]
  00887	48 8b f8	 mov	 rdi, rax
  0088a	33 c0		 xor	 eax, eax
  0088c	b9 03 00 00 00	 mov	 ecx, 3
  00891	f3 aa		 rep stosb

; 331  :                                             if(PatternValue == 1)

  00893	0f b6 44 24 33	 movzx	 eax, BYTE PTR PatternValue$3[rsp]
  00898	83 f8 01	 cmp	 eax, 1
  0089b	75 0e		 jne	 SHORT $LN50@ppuTick

; 332  :                                                 TempColour[0] = 255;

  0089d	b8 01 00 00 00	 mov	 eax, 1
  008a2	48 6b c0 00	 imul	 rax, rax, 0
  008a6	c6 44 04 54 ff	 mov	 BYTE PTR TempColour$14[rsp+rax], 255 ; 000000ffH
$LN50@ppuTick:

; 333  :                                             if(PatternValue == 2)

  008ab	0f b6 44 24 33	 movzx	 eax, BYTE PTR PatternValue$3[rsp]
  008b0	83 f8 02	 cmp	 eax, 2
  008b3	75 0e		 jne	 SHORT $LN51@ppuTick

; 334  :                                                 TempColour[1] = 255;

  008b5	b8 01 00 00 00	 mov	 eax, 1
  008ba	48 6b c0 01	 imul	 rax, rax, 1
  008be	c6 44 04 54 ff	 mov	 BYTE PTR TempColour$14[rsp+rax], 255 ; 000000ffH
$LN51@ppuTick:

; 335  :                                             if(PatternValue == 3)

  008c3	0f b6 44 24 33	 movzx	 eax, BYTE PTR PatternValue$3[rsp]
  008c8	83 f8 03	 cmp	 eax, 3
  008cb	75 0e		 jne	 SHORT $LN52@ppuTick

; 336  :                                                 TempColour[2] = 255;

  008cd	b8 01 00 00 00	 mov	 eax, 1
  008d2	48 6b c0 02	 imul	 rax, rax, 2
  008d6	c6 44 04 54 ff	 mov	 BYTE PTR TempColour$14[rsp+rax], 255 ; 000000ffH
$LN52@ppuTick:

; 337  :                                             drawPixel(Ppu, x + SprtPixX, y + SprtPixY, TempColour);

  008db	0f b6 44 24 30	 movzx	 eax, BYTE PTR SprtPixY$1[rsp]
  008e0	8b 4c 24 60	 mov	 ecx, DWORD PTR y$15[rsp]
  008e4	03 c8		 add	 ecx, eax
  008e6	8b c1		 mov	 eax, ecx
  008e8	0f b6 4c 24 31	 movzx	 ecx, BYTE PTR SprtPixX$2[rsp]
  008ed	8b 54 24 64	 mov	 edx, DWORD PTR x$16[rsp]
  008f1	03 d1		 add	 edx, ecx
  008f3	8b ca		 mov	 ecx, edx
  008f5	4c 8d 4c 24 54	 lea	 r9, QWORD PTR TempColour$14[rsp]
  008fa	44 0f b7 c0	 movzx	 r8d, ax
  008fe	0f b7 d1	 movzx	 edx, cx
  00901	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00909	e8 00 00 00 00	 call	 ?drawPixel@@YAXPEAUppu@@GGPEAE@Z ; drawPixel

; 338  :                                         }

  0090e	e9 2b ff ff ff	 jmp	 $LN14@ppuTick
$LN15@ppuTick:

; 339  :                                     }

  00913	e9 07 ff ff ff	 jmp	 $LN11@ppuTick
$LN12@ppuTick:
$LN49@ppuTick:

; 340  :                                 }
; 341  :                         
; 342  :                             }

  00918	e9 6c fe ff ff	 jmp	 $LN8@ppuTick
$LN9@ppuTick:
$LN48@ppuTick:

; 343  :                         }
; 344  :                     }

  0091d	e9 21 fe ff ff	 jmp	 $LN5@ppuTick
$LN6@ppuTick:

; 345  : 
; 346  :                 }

  00922	e9 fa fd ff ff	 jmp	 $LN2@ppuTick
$LN3@ppuTick:
$LN47@ppuTick:
$LN45@ppuTick:
$LN44@ppuTick:

; 347  :             }
; 348  : 
; 349  : #if 0 
; 350  :             char TextBuffer[256];
; 351  :             _snprintf(TextBuffer, 256, "PixelPattern: %X AtrbValue: %X Complete: %X PaletteIndex: %X RGB: %d, %d, %d\n",
; 352  :                       PatternPixelValue, AttributeValue, PixelColourIndex, PaletteIndex, Colour[0], Colour[1], Colour[2]);
; 353  :             OutputDebugString(TextBuffer);
; 354  : 
; 355  : #endif
; 356  :         }
; 357  :     }
; 358  :     if(PostRenderLine)

  00927	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR PostRenderLine$[rsp], 0
  0092f	74 0a		 je	 SHORT $LN53@ppuTick

; 359  :     {
; 360  :         DrawScreen = true;

  00931	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?DrawScreen@@3HA, 1 ; DrawScreen
$LN53@ppuTick:

; 361  :         // NOTE: Ppu sits idle for this scanline
; 362  :     }
; 363  :     if(VBlankLine)

  0093b	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR VBlankLine$[rsp], 0
  00943	74 5a		 je	 SHORT $LN54@ppuTick

; 364  :     {
; 365  :         if(Ppu->Scanline == 241 && Ppu->ScanlineCycle == 1)

  00945	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0094d	0f b7 80 20 01
	00 00		 movzx	 eax, WORD PTR [rax+288]
  00954	3d f1 00 00 00	 cmp	 eax, 241		; 000000f1H
  00959	75 44		 jne	 SHORT $LN55@ppuTick
  0095b	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00963	0f b7 80 22 01
	00 00		 movzx	 eax, WORD PTR [rax+290]
  0096a	83 f8 01	 cmp	 eax, 1
  0096d	75 30		 jne	 SHORT $LN55@ppuTick

; 366  :         {
; 367  :             // TODO: if turning on NMI when in vblank. The nmi will be generated immediately.
; 368  :             if(Registers->Ctrl1 & (1 << 7))

  0096f	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  00974	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00977	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0097c	85 c0		 test	 eax, eax
  0097e	74 0a		 je	 SHORT $LN56@ppuTick

; 369  :             {
; 370  :                 NmiTriggered = true;

  00980	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?NmiTriggered@@3HA, 1 ; NmiTriggered
$LN56@ppuTick:

; 371  :             }
; 372  :             Registers->Status = Registers->Status | (1 << 7); // Set VBlank Status

  0098a	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  0098f	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00993	0f ba e8 07	 bts	 eax, 7
  00997	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Registers$[rsp]
  0099c	88 41 02	 mov	 BYTE PTR [rcx+2], al
$LN55@ppuTick:
$LN54@ppuTick:

; 373  :         }
; 374  :     }
; 375  :     if(PreRenderLine)

  0099f	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR PreRenderLine$[rsp], 0
  009a7	0f 84 8c 00 00
	00		 je	 $LN57@ppuTick

; 376  :     {
; 377  :         switch(Ppu->ScanlineCycle)

  009ad	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  009b5	0f b7 80 22 01
	00 00		 movzx	 eax, WORD PTR [rax+290]
  009bc	89 44 24 78	 mov	 DWORD PTR tv442[rsp], eax
  009c0	83 7c 24 78 01	 cmp	 DWORD PTR tv442[rsp], 1
  009c5	74 16		 je	 SHORT $LN58@ppuTick
  009c7	81 7c 24 78 41
	01 00 00	 cmp	 DWORD PTR tv442[rsp], 321 ; 00000141H
  009cf	74 4b		 je	 SHORT $LN59@ppuTick
  009d1	81 7c 24 78 49
	01 00 00	 cmp	 DWORD PTR tv442[rsp], 329 ; 00000149H
  009d9	74 41		 je	 SHORT $LN59@ppuTick
  009db	eb 5c		 jmp	 SHORT $LN17@ppuTick
$LN58@ppuTick:

; 378  :         {
; 379  :             case 1:
; 380  :             {
; 381  :                 Registers->Status = Registers->Status & ~(1 << 5); // Clear Sprite Overflow

  009dd	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  009e2	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  009e6	83 e0 df	 and	 eax, -33		; ffffffffffffffdfH
  009e9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Registers$[rsp]
  009ee	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 382  :                 Registers->Status = Registers->Status & ~(1 << 6); // Clear Sprite Zero Hit

  009f1	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  009f6	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  009fa	83 e0 bf	 and	 eax, -65		; ffffffffffffffbfH
  009fd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Registers$[rsp]
  00a02	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 383  :                 Registers->Status = Registers->Status & ~(1 << 7); // Clear Vblank status

  00a05	48 8b 44 24 38	 mov	 rax, QWORD PTR Registers$[rsp]
  00a0a	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00a0e	0f ba f0 07	 btr	 eax, 7
  00a12	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Registers$[rsp]
  00a17	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 384  :                 break;

  00a1a	eb 1d		 jmp	 SHORT $LN17@ppuTick
$LN59@ppuTick:

; 385  :             }
; 386  :             case 321:
; 387  :             case 329:
; 388  :             {
; 389  :                 Ppu->NameTableByte1 = Ppu->NameTableByte2;

  00a1c	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00a24	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00a2c	0f b6 89 2b 01
	00 00		 movzx	 ecx, BYTE PTR [rcx+299]
  00a33	88 88 2a 01 00
	00		 mov	 BYTE PTR [rax+298], cl
$LN17@ppuTick:
$LN57@ppuTick:

; 390  :                 //Ppu->NameTableByte2 = getNameTableValue(PixelFetchX, PixelFetchY, TableBaseNum, Ppu->MemoryBase);
; 391  :                 break;
; 392  :             }
; 393  :         }
; 394  :     }
; 395  : 
; 396  :     ++Ppu->ScanlineCycle;

  00a39	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00a41	0f b7 80 22 01
	00 00		 movzx	 eax, WORD PTR [rax+290]
  00a48	66 ff c0	 inc	 ax
  00a4b	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00a53	66 89 81 22 01
	00 00		 mov	 WORD PTR [rcx+290], ax

; 397  : 
; 398  :     if(Ppu->ScanlineCycle > 341)

  00a5a	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00a62	0f b7 80 22 01
	00 00		 movzx	 eax, WORD PTR [rax+290]
  00a69	3d 55 01 00 00	 cmp	 eax, 341		; 00000155H
  00a6e	7e 31		 jle	 SHORT $LN60@ppuTick

; 399  :     {
; 400  :         Ppu->Scanline += 1;

  00a70	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00a78	0f b7 80 20 01
	00 00		 movzx	 eax, WORD PTR [rax+288]
  00a7f	ff c0		 inc	 eax
  00a81	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00a89	66 89 81 20 01
	00 00		 mov	 WORD PTR [rcx+288], ax

; 401  :         Ppu->ScanlineCycle = 0;

  00a90	33 c0		 xor	 eax, eax
  00a92	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00a9a	66 89 81 22 01
	00 00		 mov	 WORD PTR [rcx+290], ax
$LN60@ppuTick:

; 402  :     }
; 403  : 
; 404  :     if(Ppu->Scanline == 262)

  00aa1	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00aa9	0f b7 80 20 01
	00 00		 movzx	 eax, WORD PTR [rax+288]
  00ab0	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  00ab5	75 11		 jne	 SHORT $LN61@ppuTick

; 405  :     {
; 406  :         Ppu->Scanline = 0;

  00ab7	33 c0		 xor	 eax, eax
  00ab9	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00ac1	66 89 81 20 01
	00 00		 mov	 WORD PTR [rcx+288], ax
$LN61@ppuTick:

; 407  :     }
; 408  : }

  00ac8	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  00acf	5f		 pop	 rdi
  00ad0	c3		 ret	 0
?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z ENDP	; ppuTick
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
Value$ = 32
BlockRelY$ = 33
Attribute$ = 34
BlockRelX$ = 35
AttributeByteY$ = 36
AttributeByteX$ = 37
AtrbByteAdrs$ = 40
X$ = 64
Y$ = 72
AtrbTableBaseAdrs$ = 80
MemoryOffset$ = 88
?getAttributeValue@@YAEGGG_K@Z PROC			; getAttributeValue

; 135  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000b	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00010	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00015	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 136  :     uint8 AttributeByteX = X / PIXELS_PER_ATRB_BYTE;

  00019	0f b7 44 24 40	 movzx	 eax, WORD PTR X$[rsp]
  0001e	99		 cdq
  0001f	83 e2 1f	 and	 edx, 31
  00022	03 c2		 add	 eax, edx
  00024	c1 f8 05	 sar	 eax, 5
  00027	88 44 24 25	 mov	 BYTE PTR AttributeByteX$[rsp], al

; 137  :     uint8 AttributeByteY = Y / PIXELS_PER_ATRB_BYTE;

  0002b	0f b7 44 24 48	 movzx	 eax, WORD PTR Y$[rsp]
  00030	99		 cdq
  00031	83 e2 1f	 and	 edx, 31
  00034	03 c2		 add	 eax, edx
  00036	c1 f8 05	 sar	 eax, 5
  00039	88 44 24 24	 mov	 BYTE PTR AttributeByteY$[rsp], al

; 138  :     
; 139  :     uint16 AtrbByteAdrs = (AtrbTableBaseAdrs + (AttributeByteY * ATRB_BYTE_PER_ROW)) + AttributeByteX;

  0003d	0f b7 44 24 50	 movzx	 eax, WORD PTR AtrbTableBaseAdrs$[rsp]
  00042	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR AttributeByteY$[rsp]
  00047	8d 04 c8	 lea	 eax, DWORD PTR [rax+rcx*8]
  0004a	0f b6 4c 24 25	 movzx	 ecx, BYTE PTR AttributeByteX$[rsp]
  0004f	03 c1		 add	 eax, ecx
  00051	66 89 44 24 28	 mov	 WORD PTR AtrbByteAdrs$[rsp], ax

; 140  :     uint8 Attribute = readPpu8(AtrbByteAdrs, MemoryOffset);

  00056	48 8b 54 24 58	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0005b	0f b7 4c 24 28	 movzx	 ecx, WORD PTR AtrbByteAdrs$[rsp]
  00060	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  00065	88 44 24 22	 mov	 BYTE PTR Attribute$[rsp], al

; 141  :     
; 142  :     uint8 BlockRelX = (X % PIXELS_PER_ATRB_BYTE) / 16;

  00069	0f b7 44 24 40	 movzx	 eax, WORD PTR X$[rsp]
  0006e	99		 cdq
  0006f	83 e2 1f	 and	 edx, 31
  00072	03 c2		 add	 eax, edx
  00074	83 e0 1f	 and	 eax, 31
  00077	2b c2		 sub	 eax, edx
  00079	99		 cdq
  0007a	83 e2 0f	 and	 edx, 15
  0007d	03 c2		 add	 eax, edx
  0007f	c1 f8 04	 sar	 eax, 4
  00082	88 44 24 23	 mov	 BYTE PTR BlockRelX$[rsp], al

; 143  :     uint8 BlockRelY = (Y % PIXELS_PER_ATRB_BYTE) / 16;

  00086	0f b7 44 24 48	 movzx	 eax, WORD PTR Y$[rsp]
  0008b	99		 cdq
  0008c	83 e2 1f	 and	 edx, 31
  0008f	03 c2		 add	 eax, edx
  00091	83 e0 1f	 and	 eax, 31
  00094	2b c2		 sub	 eax, edx
  00096	99		 cdq
  00097	83 e2 0f	 and	 edx, 15
  0009a	03 c2		 add	 eax, edx
  0009c	c1 f8 04	 sar	 eax, 4
  0009f	88 44 24 21	 mov	 BYTE PTR BlockRelY$[rsp], al

; 144  : 
; 145  :     uint8 Value;
; 146  :     
; 147  :     if(BlockRelX == 0)

  000a3	0f b6 44 24 23	 movzx	 eax, BYTE PTR BlockRelX$[rsp]
  000a8	85 c0		 test	 eax, eax
  000aa	75 2a		 jne	 SHORT $LN2@getAttribu

; 148  :         if(BlockRelY == 0)

  000ac	0f b6 44 24 21	 movzx	 eax, BYTE PTR BlockRelY$[rsp]
  000b1	85 c0		 test	 eax, eax
  000b3	75 0b		 jne	 SHORT $LN3@getAttribu

; 149  :             Value = Attribute;

  000b5	0f b6 44 24 22	 movzx	 eax, BYTE PTR Attribute$[rsp]
  000ba	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
  000be	eb 16		 jmp	 SHORT $LN4@getAttribu
$LN3@getAttribu:

; 150  :         else if(BlockRelY == 1)

  000c0	0f b6 44 24 21	 movzx	 eax, BYTE PTR BlockRelY$[rsp]
  000c5	83 f8 01	 cmp	 eax, 1
  000c8	75 0c		 jne	 SHORT $LN5@getAttribu

; 151  :             Value = Attribute >> 4;

  000ca	0f b6 44 24 22	 movzx	 eax, BYTE PTR Attribute$[rsp]
  000cf	c1 f8 04	 sar	 eax, 4
  000d2	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
$LN5@getAttribu:
$LN4@getAttribu:
$LN2@getAttribu:

; 152  :     if(BlockRelX == 1)

  000d6	0f b6 44 24 23	 movzx	 eax, BYTE PTR BlockRelX$[rsp]
  000db	83 f8 01	 cmp	 eax, 1
  000de	75 2d		 jne	 SHORT $LN6@getAttribu

; 153  :         if(BlockRelY == 0)

  000e0	0f b6 44 24 21	 movzx	 eax, BYTE PTR BlockRelY$[rsp]
  000e5	85 c0		 test	 eax, eax
  000e7	75 0e		 jne	 SHORT $LN7@getAttribu

; 154  :             Value = Attribute >> 2;

  000e9	0f b6 44 24 22	 movzx	 eax, BYTE PTR Attribute$[rsp]
  000ee	c1 f8 02	 sar	 eax, 2
  000f1	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
  000f5	eb 16		 jmp	 SHORT $LN8@getAttribu
$LN7@getAttribu:

; 155  :         else if(BlockRelY == 1)

  000f7	0f b6 44 24 21	 movzx	 eax, BYTE PTR BlockRelY$[rsp]
  000fc	83 f8 01	 cmp	 eax, 1
  000ff	75 0c		 jne	 SHORT $LN9@getAttribu

; 156  :             Value = Attribute >> 6;

  00101	0f b6 44 24 22	 movzx	 eax, BYTE PTR Attribute$[rsp]
  00106	c1 f8 06	 sar	 eax, 6
  00109	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
$LN9@getAttribu:
$LN8@getAttribu:
$LN6@getAttribu:

; 157  :     
; 158  :     Value = Value & 3;

  0010d	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  00112	83 e0 03	 and	 eax, 3
  00115	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 159  :     
; 160  :     return(Value);

  00119	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]

; 161  : }

  0011e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00122	c3		 ret	 0
?getAttributeValue@@YAEGGG_K@Z ENDP			; getAttributeValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
TileRelY$ = 32
TileRelX$ = 33
HighPattern$ = 34
LowPattern$ = 35
Value$ = 36
LowAddress$ = 40
HighAddress$ = 48
X$ = 80
Y$ = 88
NameTableValue$ = 96
PatternBase$ = 104
MemoryOffset$ = 112
?getPatternValue@@YAEGGEG_K@Z PROC			; getPatternValue

; 110  : {

  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000b	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00010	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00015	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 111  :     uint8 TileRelX = X % PIXEL_PER_TILE;

  00019	0f b7 44 24 50	 movzx	 eax, WORD PTR X$[rsp]
  0001e	99		 cdq
  0001f	83 e2 07	 and	 edx, 7
  00022	03 c2		 add	 eax, edx
  00024	83 e0 07	 and	 eax, 7
  00027	2b c2		 sub	 eax, edx
  00029	88 44 24 21	 mov	 BYTE PTR TileRelX$[rsp], al

; 112  :     uint8 TileRelY = Y % PIXEL_PER_TILE;

  0002d	0f b7 44 24 58	 movzx	 eax, WORD PTR Y$[rsp]
  00032	99		 cdq
  00033	83 e2 07	 and	 edx, 7
  00036	03 c2		 add	 eax, edx
  00038	83 e0 07	 and	 eax, 7
  0003b	2b c2		 sub	 eax, edx
  0003d	88 44 24 20	 mov	 BYTE PTR TileRelY$[rsp], al

; 113  :     
; 114  :     Assert(0 <= TileRelX && TileRelX < PIXEL_PER_TILE);

  00041	0f b6 44 24 21	 movzx	 eax, BYTE PTR TileRelX$[rsp]
  00046	85 c0		 test	 eax, eax
  00048	7c 0a		 jl	 SHORT $LN3@getPattern
  0004a	0f b6 44 24 21	 movzx	 eax, BYTE PTR TileRelX$[rsp]
  0004f	83 f8 08	 cmp	 eax, 8
  00052	7c 0b		 jl	 SHORT $LN2@getPattern
$LN3@getPattern:
  00054	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@getPattern:

; 115  :     Assert(0 <= TileRelY && TileRelY < PIXEL_PER_TILE);

  0005f	0f b6 44 24 20	 movzx	 eax, BYTE PTR TileRelY$[rsp]
  00064	85 c0		 test	 eax, eax
  00066	7c 0a		 jl	 SHORT $LN5@getPattern
  00068	0f b6 44 24 20	 movzx	 eax, BYTE PTR TileRelY$[rsp]
  0006d	83 f8 08	 cmp	 eax, 8
  00070	7c 0b		 jl	 SHORT $LN4@getPattern
$LN5@getPattern:
  00072	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN4@getPattern:

; 116  :   
; 117  :     uint64 LowAddress = (PatternBase + (NameTableValue * 16)) + TileRelY;

  0007d	0f b7 44 24 68	 movzx	 eax, WORD PTR PatternBase$[rsp]
  00082	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR NameTableValue$[rsp]
  00087	6b c9 10	 imul	 ecx, ecx, 16
  0008a	03 c1		 add	 eax, ecx
  0008c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR TileRelY$[rsp]
  00091	03 c1		 add	 eax, ecx
  00093	48 98		 cdqe
  00095	48 89 44 24 28	 mov	 QWORD PTR LowAddress$[rsp], rax

; 118  :     uint64 HighAddress = (PatternBase + (NameTableValue * 16) + 8) + TileRelY;

  0009a	0f b7 44 24 68	 movzx	 eax, WORD PTR PatternBase$[rsp]
  0009f	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR NameTableValue$[rsp]
  000a4	6b c9 10	 imul	 ecx, ecx, 16
  000a7	03 c1		 add	 eax, ecx
  000a9	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR TileRelY$[rsp]
  000ae	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  000b2	48 98		 cdqe
  000b4	48 89 44 24 30	 mov	 QWORD PTR HighAddress$[rsp], rax

; 119  :     
; 120  :     uint8 LowPattern = readPpu8(LowAddress, MemoryOffset);

  000b9	48 8b 54 24 70	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  000be	0f b7 4c 24 28	 movzx	 ecx, WORD PTR LowAddress$[rsp]
  000c3	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  000c8	88 44 24 23	 mov	 BYTE PTR LowPattern$[rsp], al

; 121  :     uint8 HighPattern = readPpu8(HighAddress, MemoryOffset);

  000cc	48 8b 54 24 70	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  000d1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR HighAddress$[rsp]
  000d6	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  000db	88 44 24 22	 mov	 BYTE PTR HighPattern$[rsp], al

; 122  : 
; 123  :     LowPattern  = (LowPattern >> (7 - TileRelX)) & 1;

  000df	0f b6 44 24 23	 movzx	 eax, BYTE PTR LowPattern$[rsp]
  000e4	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR TileRelX$[rsp]
  000e9	ba 07 00 00 00	 mov	 edx, 7
  000ee	2b d1		 sub	 edx, ecx
  000f0	8b ca		 mov	 ecx, edx
  000f2	d3 f8		 sar	 eax, cl
  000f4	83 e0 01	 and	 eax, 1
  000f7	88 44 24 23	 mov	 BYTE PTR LowPattern$[rsp], al

; 124  :     HighPattern = (HighPattern >> (7 - TileRelX)) & 1;

  000fb	0f b6 44 24 22	 movzx	 eax, BYTE PTR HighPattern$[rsp]
  00100	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR TileRelX$[rsp]
  00105	ba 07 00 00 00	 mov	 edx, 7
  0010a	2b d1		 sub	 edx, ecx
  0010c	8b ca		 mov	 ecx, edx
  0010e	d3 f8		 sar	 eax, cl
  00110	83 e0 01	 and	 eax, 1
  00113	88 44 24 22	 mov	 BYTE PTR HighPattern$[rsp], al

; 125  : 
; 126  :     uint8 Value = (HighPattern << 1) | LowPattern;

  00117	0f b6 44 24 22	 movzx	 eax, BYTE PTR HighPattern$[rsp]
  0011c	d1 e0		 shl	 eax, 1
  0011e	0f b6 4c 24 23	 movzx	 ecx, BYTE PTR LowPattern$[rsp]
  00123	0b c1		 or	 eax, ecx
  00125	88 44 24 24	 mov	 BYTE PTR Value$[rsp], al

; 127  :     
; 128  :     return(Value);

  00129	0f b6 44 24 24	 movzx	 eax, BYTE PTR Value$[rsp]

; 129  : }

  0012e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00132	c3		 ret	 0
?getPatternValue@@YAEGGEG_K@Z ENDP			; getPatternValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
Value$ = 32
TileY$ = 36
TileX$ = 40
Address$ = 44
X$ = 64
Y$ = 72
TableBaseAddress$ = 80
MemoryOffset$ = 88
?getNameTableValue@@YAEGGG_K@Z PROC			; getNameTableValue

; 95   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000b	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00010	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00015	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 96   :     uint16 TileX = X / PIXEL_PER_TILE;

  00019	0f b7 44 24 40	 movzx	 eax, WORD PTR X$[rsp]
  0001e	99		 cdq
  0001f	83 e2 07	 and	 edx, 7
  00022	03 c2		 add	 eax, edx
  00024	c1 f8 03	 sar	 eax, 3
  00027	66 89 44 24 28	 mov	 WORD PTR TileX$[rsp], ax

; 97   :     uint16 TileY = Y / PIXEL_PER_TILE;

  0002c	0f b7 44 24 48	 movzx	 eax, WORD PTR Y$[rsp]
  00031	99		 cdq
  00032	83 e2 07	 and	 edx, 7
  00035	03 c2		 add	 eax, edx
  00037	c1 f8 03	 sar	 eax, 3
  0003a	66 89 44 24 24	 mov	 WORD PTR TileY$[rsp], ax

; 98   :     
; 99   :     Assert(0 <= TileX && TileX < TILES_COUNT_X);

  0003f	0f b7 44 24 28	 movzx	 eax, WORD PTR TileX$[rsp]
  00044	85 c0		 test	 eax, eax
  00046	7c 0a		 jl	 SHORT $LN3@getNameTab
  00048	0f b7 44 24 28	 movzx	 eax, WORD PTR TileX$[rsp]
  0004d	83 f8 20	 cmp	 eax, 32			; 00000020H
  00050	7c 0b		 jl	 SHORT $LN2@getNameTab
$LN3@getNameTab:
  00052	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@getNameTab:

; 100  :     Assert(0 <= TileY && TileY < TILES_COUNT_Y);

  0005d	0f b7 44 24 24	 movzx	 eax, WORD PTR TileY$[rsp]
  00062	85 c0		 test	 eax, eax
  00064	7c 0a		 jl	 SHORT $LN5@getNameTab
  00066	0f b7 44 24 24	 movzx	 eax, WORD PTR TileY$[rsp]
  0006b	83 f8 1e	 cmp	 eax, 30
  0006e	7c 0b		 jl	 SHORT $LN4@getNameTab
$LN5@getNameTab:
  00070	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN4@getNameTab:

; 101  : 
; 102  :     uint16 Address = (TableBaseAddress + (TileY * TILES_COUNT_X)) + TileX;

  0007b	0f b7 44 24 50	 movzx	 eax, WORD PTR TableBaseAddress$[rsp]
  00080	0f b7 4c 24 24	 movzx	 ecx, WORD PTR TileY$[rsp]
  00085	6b c9 20	 imul	 ecx, ecx, 32		; 00000020H
  00088	03 c1		 add	 eax, ecx
  0008a	0f b7 4c 24 28	 movzx	 ecx, WORD PTR TileX$[rsp]
  0008f	03 c1		 add	 eax, ecx
  00091	66 89 44 24 2c	 mov	 WORD PTR Address$[rsp], ax

; 103  :     uint8 Value = readPpu8(Address, MemoryOffset);

  00096	48 8b 54 24 58	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0009b	0f b7 4c 24 2c	 movzx	 ecx, WORD PTR Address$[rsp]
  000a0	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  000a5	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 104  :     return(Value);

  000a9	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]

; 105  : }

  000ae	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b2	c3		 ret	 0
?getNameTableValue@@YAEGGG_K@Z ENDP			; getNameTableValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
Byte$ = 48
Address$ = 56
MemoryOffset$ = 64
?writePpu8@@YAXEG_K@Z PROC				; writePpu8

; 82   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 83   :     if(0x3000 <= Address && Address < 0x3F00)

  00012	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00017	3d 00 30 00 00	 cmp	 eax, 12288		; 00003000H
  0001c	7c 2b		 jl	 SHORT $LN2@writePpu8
  0001e	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00023	3d 00 3f 00 00	 cmp	 eax, 16128		; 00003f00H
  00028	7d 1f		 jge	 SHORT $LN2@writePpu8

; 84   :         Address = (Address % (0x3000 - 0x2000)) + 0x2000;

  0002a	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  0002f	99		 cdq
  00030	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  00036	03 c2		 add	 eax, edx
  00038	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0003d	2b c2		 sub	 eax, edx
  0003f	05 00 20 00 00	 add	 eax, 8192		; 00002000H
  00044	66 89 44 24 38	 mov	 WORD PTR Address$[rsp], ax
$LN2@writePpu8:

; 85   :     if(0x3F20 <= Address && Address < 0x4000)

  00049	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  0004e	3d 20 3f 00 00	 cmp	 eax, 16160		; 00003f20H
  00053	7c 26		 jl	 SHORT $LN3@writePpu8
  00055	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  0005a	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  0005f	7d 1a		 jge	 SHORT $LN3@writePpu8

; 86   :         Address = (Address % (0x3F20 - 0x3F00)) + 0x3F00;

  00061	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00066	99		 cdq
  00067	83 e2 1f	 and	 edx, 31
  0006a	03 c2		 add	 eax, edx
  0006c	83 e0 1f	 and	 eax, 31
  0006f	2b c2		 sub	 eax, edx
  00071	05 00 3f 00 00	 add	 eax, 16128		; 00003f00H
  00076	66 89 44 24 38	 mov	 WORD PTR Address$[rsp], ax
$LN3@writePpu8:

; 87   :     if(Address >= 0x4000)

  0007b	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00080	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  00085	7c 1a		 jl	 SHORT $LN4@writePpu8

; 88   :         Address = Address % 0x4000; 

  00087	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  0008c	99		 cdq
  0008d	81 e2 ff 3f 00
	00		 and	 edx, 16383		; 00003fffH
  00093	03 c2		 add	 eax, edx
  00095	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  0009a	2b c2		 sub	 eax, edx
  0009c	66 89 44 24 38	 mov	 WORD PTR Address$[rsp], ax
$LN4@writePpu8:

; 89   :     
; 90   :     write8(Byte, Address, MemoryOffset);

  000a1	4c 8b 44 24 40	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  000a6	0f b7 54 24 38	 movzx	 edx, WORD PTR Address$[rsp]
  000ab	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR Byte$[rsp]
  000b0	e8 00 00 00 00	 call	 ?write8@@YAXEG_K@Z	; write8

; 91   : }

  000b5	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b9	c3		 ret	 0
?writePpu8@@YAXEG_K@Z ENDP				; writePpu8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
Result$ = 32
Address$ = 64
MemoryOffset$ = 72
?readPpu8@@YAEG_K@Z PROC				; readPpu8

; 70   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 71   :     if(0x3000 <= Address && Address < 0x3F00)

  0000e	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00013	3d 00 30 00 00	 cmp	 eax, 12288		; 00003000H
  00018	7c 2b		 jl	 SHORT $LN2@readPpu8
  0001a	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0001f	3d 00 3f 00 00	 cmp	 eax, 16128		; 00003f00H
  00024	7d 1f		 jge	 SHORT $LN2@readPpu8

; 72   :         Address = (Address % (0x3000 - 0x2000)) + 0x2000;

  00026	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0002b	99		 cdq
  0002c	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  00032	03 c2		 add	 eax, edx
  00034	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00039	2b c2		 sub	 eax, edx
  0003b	05 00 20 00 00	 add	 eax, 8192		; 00002000H
  00040	66 89 44 24 40	 mov	 WORD PTR Address$[rsp], ax
$LN2@readPpu8:

; 73   :     if(0x3F20 <= Address && Address < 0x4000)

  00045	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0004a	3d 20 3f 00 00	 cmp	 eax, 16160		; 00003f20H
  0004f	7c 26		 jl	 SHORT $LN3@readPpu8
  00051	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00056	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  0005b	7d 1a		 jge	 SHORT $LN3@readPpu8

; 74   :         Address = (Address % (0x3F20 - 0x3F00)) + 0x3F00;

  0005d	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00062	99		 cdq
  00063	83 e2 1f	 and	 edx, 31
  00066	03 c2		 add	 eax, edx
  00068	83 e0 1f	 and	 eax, 31
  0006b	2b c2		 sub	 eax, edx
  0006d	05 00 3f 00 00	 add	 eax, 16128		; 00003f00H
  00072	66 89 44 24 40	 mov	 WORD PTR Address$[rsp], ax
$LN3@readPpu8:

; 75   :     if(Address >= 0x4000)

  00077	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0007c	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  00081	7c 1a		 jl	 SHORT $LN4@readPpu8

; 76   :         Address = Address % 0x4000; 

  00083	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00088	99		 cdq
  00089	81 e2 ff 3f 00
	00		 and	 edx, 16383		; 00003fffH
  0008f	03 c2		 add	 eax, edx
  00091	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  00096	2b c2		 sub	 eax, edx
  00098	66 89 44 24 40	 mov	 WORD PTR Address$[rsp], ax
$LN4@readPpu8:

; 77   : 
; 78   :     uint8 Result = read8(Address, MemoryOffset);

  0009d	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  000a2	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  000a7	e8 00 00 00 00	 call	 ?read8@@YAEG_K@Z	; read8
  000ac	88 44 24 20	 mov	 BYTE PTR Result$[rsp], al

; 79   :     return(Result);

  000b0	0f b6 44 24 20	 movzx	 eax, BYTE PTR Result$[rsp]

; 80   : }

  000b5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b9	c3		 ret	 0
?readPpu8@@YAEG_K@Z ENDP				; readPpu8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
;	COMDAT ?drawPixel@@YAXPEAUppu@@GGPEAE@Z
_TEXT	SEGMENT
CurrentPixel$ = 0
Ppu$ = 32
X$ = 40
Y$ = 48
Colour$ = 56
?drawPixel@@YAXPEAUppu@@GGPEAE@Z PROC			; drawPixel, COMDAT

; 64   : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000b	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	48 83 ec 18	 sub	 rsp, 24

; 65   :     uint32 *CurrentPixel = (Ppu->BasePixel + (Y * PIXEL_WIDTH)) + X;

  00019	0f b7 44 24 30	 movzx	 eax, WORD PTR Y$[rsp]
  0001e	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  00024	48 98		 cdqe
  00026	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0002b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0002f	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  00033	0f b7 4c 24 28	 movzx	 ecx, WORD PTR X$[rsp]
  00038	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  0003c	48 89 04 24	 mov	 QWORD PTR CurrentPixel$[rsp], rax

; 66   :     *CurrentPixel  = ((Colour[0] << 16) | (Colour[1] << 8) | Colour[2]);

  00040	b8 01 00 00 00	 mov	 eax, 1
  00045	48 6b c0 00	 imul	 rax, rax, 0
  00049	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Colour$[rsp]
  0004e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00052	c1 e0 10	 shl	 eax, 16
  00055	b9 01 00 00 00	 mov	 ecx, 1
  0005a	48 6b c9 01	 imul	 rcx, rcx, 1
  0005e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Colour$[rsp]
  00063	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00067	c1 e1 08	 shl	 ecx, 8
  0006a	0b c1		 or	 eax, ecx
  0006c	b9 01 00 00 00	 mov	 ecx, 1
  00071	48 6b c9 02	 imul	 rcx, rcx, 2
  00075	48 8b 54 24 38	 mov	 rdx, QWORD PTR Colour$[rsp]
  0007a	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0007e	0b c1		 or	 eax, ecx
  00080	48 8b 0c 24	 mov	 rcx, QWORD PTR CurrentPixel$[rsp]
  00084	89 01		 mov	 DWORD PTR [rcx], eax

; 67   : }

  00086	48 83 c4 18	 add	 rsp, 24
  0008a	c3		 ret	 0
?drawPixel@@YAXPEAUppu@@GGPEAE@Z ENDP			; drawPixel
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\palette.cpp
_TEXT	SEGMENT
Entry$ = 8
Colour$ = 16
?getPaletteValue@@YAXEPEAE@Z PROC			; getPaletteValue

; 31   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 32   :     Colour[0] = Palette[Entry][0];

  00009	0f b6 44 24 08	 movzx	 eax, BYTE PTR Entry$[rsp]
  0000e	48 6b c0 03	 imul	 rax, rax, 3
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Palette@@3PAY02EA ; Palette
  00019	48 03 c8	 add	 rcx, rax
  0001c	48 8b c1	 mov	 rax, rcx
  0001f	b9 01 00 00 00	 mov	 ecx, 1
  00024	48 6b c9 00	 imul	 rcx, rcx, 0
  00028	ba 01 00 00 00	 mov	 edx, 1
  0002d	48 6b d2 00	 imul	 rdx, rdx, 0
  00031	4c 8b 44 24 10	 mov	 r8, QWORD PTR Colour$[rsp]
  00036	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0003a	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 33   :     Colour[1] = Palette[Entry][1];

  0003e	0f b6 44 24 08	 movzx	 eax, BYTE PTR Entry$[rsp]
  00043	48 6b c0 03	 imul	 rax, rax, 3
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Palette@@3PAY02EA ; Palette
  0004e	48 03 c8	 add	 rcx, rax
  00051	48 8b c1	 mov	 rax, rcx
  00054	b9 01 00 00 00	 mov	 ecx, 1
  00059	48 6b c9 01	 imul	 rcx, rcx, 1
  0005d	ba 01 00 00 00	 mov	 edx, 1
  00062	48 6b d2 01	 imul	 rdx, rdx, 1
  00066	4c 8b 44 24 10	 mov	 r8, QWORD PTR Colour$[rsp]
  0006b	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0006f	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 34   :     Colour[2]  = Palette[Entry][2];

  00073	0f b6 44 24 08	 movzx	 eax, BYTE PTR Entry$[rsp]
  00078	48 6b c0 03	 imul	 rax, rax, 3
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Palette@@3PAY02EA ; Palette
  00083	48 03 c8	 add	 rcx, rax
  00086	48 8b c1	 mov	 rax, rcx
  00089	b9 01 00 00 00	 mov	 ecx, 1
  0008e	48 6b c9 02	 imul	 rcx, rcx, 2
  00092	ba 01 00 00 00	 mov	 edx, 1
  00097	48 6b d2 02	 imul	 rdx, rdx, 2
  0009b	4c 8b 44 24 10	 mov	 r8, QWORD PTR Colour$[rsp]
  000a0	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000a4	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 35   : }

  000a8	c3		 ret	 0
?getPaletteValue@@YAXEPEAE@Z ENDP			; getPaletteValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Address$ = 32
CyclesElapsed$ = 36
Instruction$ = 37
AddressMode$ = 38
InstrData$ = 40
InstrLength$ = 44
InstrCycles$ = 45
RelOffset$1 = 46
ZeroAddress$2 = 47
AddedAddress$3 = 48
ZeroAddress$4 = 49
AdditionalCycles$5 = 50
i$6 = 52
CrossedPage$ = 56
IndirectAddress$7 = 60
tv136 = 64
$T8 = 72
$T9 = 80
InstrName$ = 88
MemoryBase$ = 96
tv306 = 104
LogCpu$ = 112
__$ArrayPad$ = 128
Cpu$ = 176
?cpuTick@@YAEPEAUcpu@@@Z PROC				; cpuTick

; 321  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 322  :     uint64 MemoryBase = Cpu->MemoryBase;

  00020	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002c	48 89 44 24 60	 mov	 QWORD PTR MemoryBase$[rsp], rax

; 323  :     uint8 CyclesElapsed = 0;

  00031	c6 44 24 24 00	 mov	 BYTE PTR CyclesElapsed$[rsp], 0

; 324  : 
; 325  :     uint16 Address = 0;

  00036	33 c0		 xor	 eax, eax
  00038	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 326  :     bool32 CrossedPage = 0;

  0003d	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR CrossedPage$[rsp], 0

; 327  :     
; 328  :     uint8 Instruction;
; 329  :     uint8 AddressMode;
; 330  :     uint8 InstrLength;
; 331  :     char *InstrName;
; 332  :     uint8 InstrCycles;
; 333  :     uint8 InstrData[3]; // Stores data for each instruction
; 334  : 
; 335  :     // NOTE: Logging: Save Cpu before changes. Print out later
; 336  :     cpu LogCpu = *Cpu;

  00045	48 8d 44 24 70	 lea	 rax, QWORD PTR LogCpu$[rsp]
  0004a	48 8b f8	 mov	 rdi, rax
  0004d	48 8b b4 24 b0
	00 00 00	 mov	 rsi, QWORD PTR Cpu$[rsp]
  00055	b9 10 00 00 00	 mov	 ecx, 16
  0005a	f3 a4		 rep movsb

; 337  :     
; 338  :     if(NmiTriggered)

  0005c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?NmiTriggered@@3HA, 0 ; NmiTriggered
  00063	74 5b		 je	 SHORT $LN7@cpuTick

; 339  :     {
; 340  :         LogCpu.PrgCounter = NMI_VEC;

  00065	b8 fa ff 00 00	 mov	 eax, 65530		; 0000fffaH
  0006a	66 89 44 24 76	 mov	 WORD PTR LogCpu$[rsp+6], ax

; 341  :         Address = NMI_VEC;

  0006f	b8 fa ff 00 00	 mov	 eax, 65530		; 0000fffaH
  00074	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 342  :         AddressMode = IMPL;

  00079	c6 44 24 26 09	 mov	 BYTE PTR AddressMode$[rsp], 9

; 343  :         InstrLength = 0;

  0007e	c6 44 24 2c 00	 mov	 BYTE PTR InstrLength$[rsp], 0

; 344  :         InstrName = "NMI";

  00083	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88698
  0008a	48 89 44 24 58	 mov	 QWORD PTR InstrName$[rsp], rax

; 345  :         InstrCycles = 7;

  0008f	c6 44 24 2d 07	 mov	 BYTE PTR InstrCycles$[rsp], 7

; 346  :         InstrData[0] = 0;

  00094	b8 01 00 00 00	 mov	 eax, 1
  00099	48 6b c0 00	 imul	 rax, rax, 0
  0009d	48 89 44 24 48	 mov	 QWORD PTR $T8[rsp], rax
  000a2	48 83 7c 24 48
	03		 cmp	 QWORD PTR $T8[rsp], 3
  000a8	73 02		 jae	 SHORT $LN33@cpuTick
  000aa	eb 05		 jmp	 SHORT $LN34@cpuTick
$LN33@cpuTick:
  000ac	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN34@cpuTick:
  000b1	48 8b 44 24 48	 mov	 rax, QWORD PTR $T8[rsp]
  000b6	c6 44 04 28 00	 mov	 BYTE PTR InstrData$[rsp+rax], 0
  000bb	e9 16 01 00 00	 jmp	 $LN8@cpuTick
$LN7@cpuTick:

; 347  :     }
; 348  :     else if(IrqTriggered)

  000c0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IrqTriggered@@3HA, 0 ; IrqTriggered
  000c7	74 5b		 je	 SHORT $LN9@cpuTick

; 349  :     {
; 350  :         LogCpu.PrgCounter = IRQ_BRK_VEC;

  000c9	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000ce	66 89 44 24 76	 mov	 WORD PTR LogCpu$[rsp+6], ax

; 351  :         Address = IRQ_BRK_VEC;

  000d3	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000d8	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 352  :         AddressMode = IMPL;

  000dd	c6 44 24 26 09	 mov	 BYTE PTR AddressMode$[rsp], 9

; 353  :         InstrLength = 0;

  000e2	c6 44 24 2c 00	 mov	 BYTE PTR InstrLength$[rsp], 0

; 354  :         InstrName = "IRQ";

  000e7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88701
  000ee	48 89 44 24 58	 mov	 QWORD PTR InstrName$[rsp], rax

; 355  :         InstrCycles = 7;

  000f3	c6 44 24 2d 07	 mov	 BYTE PTR InstrCycles$[rsp], 7

; 356  :         InstrData[0] = 0;

  000f8	b8 01 00 00 00	 mov	 eax, 1
  000fd	48 6b c0 00	 imul	 rax, rax, 0
  00101	48 89 44 24 50	 mov	 QWORD PTR $T9[rsp], rax
  00106	48 83 7c 24 50
	03		 cmp	 QWORD PTR $T9[rsp], 3
  0010c	73 02		 jae	 SHORT $LN35@cpuTick
  0010e	eb 05		 jmp	 SHORT $LN36@cpuTick
$LN35@cpuTick:
  00110	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN36@cpuTick:
  00115	48 8b 44 24 50	 mov	 rax, QWORD PTR $T9[rsp]
  0011a	c6 44 04 28 00	 mov	 BYTE PTR InstrData$[rsp+rax], 0

; 357  :     }
; 358  :     else

  0011f	e9 b2 00 00 00	 jmp	 $LN10@cpuTick
$LN9@cpuTick:

; 359  :     {    
; 360  :         Instruction = readCpu8(Cpu->PrgCounter, MemoryBase);

  00124	48 8b 54 24 60	 mov	 rdx, QWORD PTR MemoryBase$[rsp]
  00129	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  00131	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00135	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  0013a	88 44 24 25	 mov	 BYTE PTR Instruction$[rsp], al

; 361  :         AddressMode = instAddressMode[Instruction];

  0013e	0f b6 44 24 25	 movzx	 eax, BYTE PTR Instruction$[rsp]
  00143	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instAddressMode@@3PAEA
  0014a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0014e	88 44 24 26	 mov	 BYTE PTR AddressMode$[rsp], al

; 362  :         InstrLength = instLength[Instruction];

  00152	0f b6 44 24 25	 movzx	 eax, BYTE PTR Instruction$[rsp]
  00157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instLength@@3PAEA
  0015e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00162	88 44 24 2c	 mov	 BYTE PTR InstrLength$[rsp], al

; 363  :         InstrName = instName[Instruction];

  00166	0f b6 44 24 25	 movzx	 eax, BYTE PTR Instruction$[rsp]
  0016b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instName@@3PAPEADA
  00172	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00176	48 89 44 24 58	 mov	 QWORD PTR InstrName$[rsp], rax

; 364  :         InstrCycles = instCycles[Instruction];

  0017b	0f b6 44 24 25	 movzx	 eax, BYTE PTR Instruction$[rsp]
  00180	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instCycles@@3PAEA
  00187	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018b	88 44 24 2d	 mov	 BYTE PTR InstrCycles$[rsp], al

; 365  : 
; 366  :         for(int i = 0; i < InstrLength; ++i)

  0018f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$6[rsp], 0
  00197	eb 0a		 jmp	 SHORT $LN4@cpuTick
$LN2@cpuTick:
  00199	8b 44 24 34	 mov	 eax, DWORD PTR i$6[rsp]
  0019d	ff c0		 inc	 eax
  0019f	89 44 24 34	 mov	 DWORD PTR i$6[rsp], eax
$LN4@cpuTick:
  001a3	0f b6 44 24 2c	 movzx	 eax, BYTE PTR InstrLength$[rsp]
  001a8	39 44 24 34	 cmp	 DWORD PTR i$6[rsp], eax
  001ac	7d 28		 jge	 SHORT $LN3@cpuTick

; 367  :         {
; 368  :             InstrData[i] = readCpu8(Cpu->PrgCounter + i, MemoryBase); 

  001ae	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  001b6	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  001ba	03 44 24 34	 add	 eax, DWORD PTR i$6[rsp]
  001be	48 8b 54 24 60	 mov	 rdx, QWORD PTR MemoryBase$[rsp]
  001c3	0f b7 c8	 movzx	 ecx, ax
  001c6	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  001cb	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$6[rsp]
  001d0	88 44 0c 28	 mov	 BYTE PTR InstrData$[rsp+rcx], al

; 369  :         }

  001d4	eb c3		 jmp	 SHORT $LN2@cpuTick
$LN3@cpuTick:
$LN10@cpuTick:
$LN8@cpuTick:

; 370  :     }
; 371  :     
; 372  :     switch(AddressMode)

  001d6	0f b6 44 24 26	 movzx	 eax, BYTE PTR AddressMode$[rsp]
  001db	89 44 24 40	 mov	 DWORD PTR tv136[rsp], eax
  001df	83 7c 24 40 0d	 cmp	 DWORD PTR tv136[rsp], 13
  001e4	0f 87 cb 02 00
	00		 ja	 $LN5@cpuTick
  001ea	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv136[rsp]
  001ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  001f6	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN37@cpuTick[rcx+rax*4]
  001fd	48 03 c1	 add	 rax, rcx
  00200	ff e0		 jmp	 rax

; 373  :     {
; 374  :         case ACM:
; 375  :             break;            

  00202	e9 ae 02 00 00	 jmp	 $LN5@cpuTick

; 376  :         case IMPL:
; 377  :             break;

  00207	e9 a9 02 00 00	 jmp	 $LN5@cpuTick
$LN13@cpuTick:

; 378  :         case IMED:
; 379  :             Address = Cpu->PrgCounter + 1;

  0020c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  00214	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00218	ff c0		 inc	 eax
  0021a	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 380  :             break;

  0021f	e9 91 02 00 00	 jmp	 $LN5@cpuTick
$LN14@cpuTick:

; 381  :         case ZERO:
; 382  :             Address = (uint16)InstrData[1];

  00224	b8 01 00 00 00	 mov	 eax, 1
  00229	48 6b c0 01	 imul	 rax, rax, 1
  0022d	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  00232	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 383  :             break;

  00237	e9 79 02 00 00	 jmp	 $LN5@cpuTick
$LN15@cpuTick:

; 384  :         case ZERX:
; 385  :             Address = ((uint16)InstrData[1] + Cpu->X) & 0xFF;

  0023c	b8 01 00 00 00	 mov	 eax, 1
  00241	48 6b c0 01	 imul	 rax, rax, 1
  00245	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  0024a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00252	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00256	03 c1		 add	 eax, ecx
  00258	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0025d	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 386  :             break;

  00262	e9 4e 02 00 00	 jmp	 $LN5@cpuTick
$LN16@cpuTick:

; 387  :         case ZERY:
; 388  :             Address = ((uint16)InstrData[1] + Cpu->Y) & 0xFF;

  00267	b8 01 00 00 00	 mov	 eax, 1
  0026c	48 6b c0 01	 imul	 rax, rax, 1
  00270	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  00275	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0027d	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  00281	03 c1		 add	 eax, ecx
  00283	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00288	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 389  :             break;

  0028d	e9 23 02 00 00	 jmp	 $LN5@cpuTick
$LN17@cpuTick:

; 390  :         case ABS:
; 391  :             Address = ((uint16)InstrData[2] << 8) | InstrData[1];

  00292	b8 01 00 00 00	 mov	 eax, 1
  00297	48 6b c0 02	 imul	 rax, rax, 2
  0029b	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  002a0	c1 e0 08	 shl	 eax, 8
  002a3	b9 01 00 00 00	 mov	 ecx, 1
  002a8	48 6b c9 01	 imul	 rcx, rcx, 1
  002ac	0f b6 4c 0c 28	 movzx	 ecx, BYTE PTR InstrData$[rsp+rcx]
  002b1	0b c1		 or	 eax, ecx
  002b3	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 392  :             break;

  002b8	e9 f8 01 00 00	 jmp	 $LN5@cpuTick
$LN18@cpuTick:

; 393  :         case ABSX:
; 394  :             Address = (((uint16)InstrData[2] << 8) | InstrData[1]) + Cpu->X;

  002bd	b8 01 00 00 00	 mov	 eax, 1
  002c2	48 6b c0 02	 imul	 rax, rax, 2
  002c6	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  002cb	c1 e0 08	 shl	 eax, 8
  002ce	b9 01 00 00 00	 mov	 ecx, 1
  002d3	48 6b c9 01	 imul	 rcx, rcx, 1
  002d7	0f b6 4c 0c 28	 movzx	 ecx, BYTE PTR InstrData$[rsp+rcx]
  002dc	0b c1		 or	 eax, ecx
  002de	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  002e6	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  002ea	03 c1		 add	 eax, ecx
  002ec	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 395  :             CrossedPage = crossedPageCheck(Address - Cpu->X, Address);

  002f1	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  002f6	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  002fe	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00302	2b c1		 sub	 eax, ecx
  00304	0f b7 54 24 20	 movzx	 edx, WORD PTR Address$[rsp]
  00309	0f b7 c8	 movzx	 ecx, ax
  0030c	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  00311	89 44 24 38	 mov	 DWORD PTR CrossedPage$[rsp], eax

; 396  :             break;

  00315	e9 9b 01 00 00	 jmp	 $LN5@cpuTick
$LN19@cpuTick:

; 397  :         case ABSY:
; 398  :             Address = (((uint16)InstrData[2] << 8) | InstrData[1]) + Cpu->Y;

  0031a	b8 01 00 00 00	 mov	 eax, 1
  0031f	48 6b c0 02	 imul	 rax, rax, 2
  00323	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  00328	c1 e0 08	 shl	 eax, 8
  0032b	b9 01 00 00 00	 mov	 ecx, 1
  00330	48 6b c9 01	 imul	 rcx, rcx, 1
  00334	0f b6 4c 0c 28	 movzx	 ecx, BYTE PTR InstrData$[rsp+rcx]
  00339	0b c1		 or	 eax, ecx
  0033b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00343	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  00347	03 c1		 add	 eax, ecx
  00349	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 399  :             CrossedPage = crossedPageCheck(Address - Cpu->Y, Address);

  0034e	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  00353	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0035b	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  0035f	2b c1		 sub	 eax, ecx
  00361	0f b7 54 24 20	 movzx	 edx, WORD PTR Address$[rsp]
  00366	0f b7 c8	 movzx	 ecx, ax
  00369	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0036e	89 44 24 38	 mov	 DWORD PTR CrossedPage$[rsp], eax

; 400  :             break;

  00372	e9 3e 01 00 00	 jmp	 $LN5@cpuTick
$LN20@cpuTick:

; 401  :         case REL:
; 402  :         {
; 403  :             int8 RelOffset = InstrData[1];

  00377	b8 01 00 00 00	 mov	 eax, 1
  0037c	48 6b c0 01	 imul	 rax, rax, 1
  00380	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  00385	88 44 24 2e	 mov	 BYTE PTR RelOffset$1[rsp], al

; 404  :             Address = Cpu->PrgCounter + 2 + RelOffset;

  00389	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  00391	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00395	0f be 4c 24 2e	 movsx	 ecx, BYTE PTR RelOffset$1[rsp]
  0039a	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  0039e	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 405  :             break;

  003a3	e9 0d 01 00 00	 jmp	 $LN5@cpuTick
$LN21@cpuTick:

; 406  :         }
; 407  :         case INDX:
; 408  :         {
; 409  :             uint8 ZeroAddress = InstrData[1];

  003a8	b8 01 00 00 00	 mov	 eax, 1
  003ad	48 6b c0 01	 imul	 rax, rax, 1
  003b1	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  003b6	88 44 24 2f	 mov	 BYTE PTR ZeroAddress$2[rsp], al

; 410  :             uint8 AddedAddress = (ZeroAddress + Cpu->X) & 0xFF;

  003ba	0f b6 44 24 2f	 movzx	 eax, BYTE PTR ZeroAddress$2[rsp]
  003bf	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  003c7	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  003cb	03 c1		 add	 eax, ecx
  003cd	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003d2	88 44 24 30	 mov	 BYTE PTR AddedAddress$3[rsp], al

; 411  :             Address = bugReadCpu16(AddedAddress, Cpu->MemoryBase);

  003d6	0f b6 44 24 30	 movzx	 eax, BYTE PTR AddedAddress$3[rsp]
  003db	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  003e3	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  003e7	0f b7 c8	 movzx	 ecx, ax
  003ea	e8 00 00 00 00	 call	 ?bugReadCpu16@@YAGG_K@Z	; bugReadCpu16
  003ef	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 412  :             break;

  003f4	e9 bc 00 00 00	 jmp	 $LN5@cpuTick
$LN22@cpuTick:

; 413  :         }
; 414  :         case INDY:
; 415  :         {
; 416  :             uint8 ZeroAddress = InstrData[1];

  003f9	b8 01 00 00 00	 mov	 eax, 1
  003fe	48 6b c0 01	 imul	 rax, rax, 1
  00402	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  00407	88 44 24 31	 mov	 BYTE PTR ZeroAddress$4[rsp], al

; 417  :             Address = bugReadCpu16(ZeroAddress, Cpu->MemoryBase) + Cpu->Y;

  0040b	0f b6 44 24 31	 movzx	 eax, BYTE PTR ZeroAddress$4[rsp]
  00410	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00418	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  0041c	0f b7 c8	 movzx	 ecx, ax
  0041f	e8 00 00 00 00	 call	 ?bugReadCpu16@@YAGG_K@Z	; bugReadCpu16
  00424	0f b7 c0	 movzx	 eax, ax
  00427	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0042f	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  00433	03 c1		 add	 eax, ecx
  00435	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 418  :             CrossedPage = crossedPageCheck(Address - Cpu->Y, Address);

  0043a	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  0043f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00447	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  0044b	2b c1		 sub	 eax, ecx
  0044d	0f b7 54 24 20	 movzx	 edx, WORD PTR Address$[rsp]
  00452	0f b7 c8	 movzx	 ecx, ax
  00455	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0045a	89 44 24 38	 mov	 DWORD PTR CrossedPage$[rsp], eax

; 419  :             break;

  0045e	eb 55		 jmp	 SHORT $LN5@cpuTick
$LN23@cpuTick:

; 420  :         }
; 421  :         case INDI:
; 422  :         {
; 423  :             uint16 IndirectAddress = ((uint16)InstrData[2] << 8) | InstrData[1];

  00460	b8 01 00 00 00	 mov	 eax, 1
  00465	48 6b c0 02	 imul	 rax, rax, 2
  00469	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  0046e	c1 e0 08	 shl	 eax, 8
  00471	b9 01 00 00 00	 mov	 ecx, 1
  00476	48 6b c9 01	 imul	 rcx, rcx, 1
  0047a	0f b6 4c 0c 28	 movzx	 ecx, BYTE PTR InstrData$[rsp+rcx]
  0047f	0b c1		 or	 eax, ecx
  00481	66 89 44 24 3c	 mov	 WORD PTR IndirectAddress$7[rsp], ax

; 424  :             Address = bugReadCpu16(IndirectAddress, Cpu->MemoryBase);

  00486	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  0048e	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00492	0f b7 4c 24 3c	 movzx	 ecx, WORD PTR IndirectAddress$7[rsp]
  00497	e8 00 00 00 00	 call	 ?bugReadCpu16@@YAGG_K@Z	; bugReadCpu16
  0049c	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 425  :             break;

  004a1	eb 12		 jmp	 SHORT $LN5@cpuTick
$LN24@cpuTick:

; 426  :         }
; 427  :         case NUL:
; 428  :         {
; 429  :             Assert(0);

  004a3	33 c0		 xor	 eax, eax
  004a5	83 f8 01	 cmp	 eax, 1
  004a8	74 0b		 je	 SHORT $LN25@cpuTick
  004aa	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN25@cpuTick:
$LN5@cpuTick:

; 430  :             break;
; 431  :         }        
; 432  :     }
; 433  :     
; 434  :     Cpu->PrgCounter += InstrLength;

  004b5	0f b6 44 24 2c	 movzx	 eax, BYTE PTR InstrLength$[rsp]
  004ba	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  004c2	0f b7 49 06	 movzx	 ecx, WORD PTR [rcx+6]
  004c6	03 c8		 add	 ecx, eax
  004c8	8b c1		 mov	 eax, ecx
  004ca	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  004d2	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 435  :     CyclesElapsed += InstrCycles;

  004d6	0f b6 44 24 2d	 movzx	 eax, BYTE PTR InstrCycles$[rsp]
  004db	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR CyclesElapsed$[rsp]
  004e0	03 c8		 add	 ecx, eax
  004e2	8b c1		 mov	 eax, ecx
  004e4	88 44 24 24	 mov	 BYTE PTR CyclesElapsed$[rsp], al

; 436  : 
; 437  :     if(NmiTriggered || IrqTriggered)

  004e8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?NmiTriggered@@3HA, 0 ; NmiTriggered
  004ef	75 09		 jne	 SHORT $LN28@cpuTick
  004f1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IrqTriggered@@3HA, 0 ; IrqTriggered
  004f8	74 39		 je	 SHORT $LN26@cpuTick
$LN28@cpuTick:

; 438  :     {
; 439  :         if(NmiTriggered)

  004fa	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?NmiTriggered@@3HA, 0 ; NmiTriggered
  00501	74 0c		 je	 SHORT $LN29@cpuTick

; 440  :         {
; 441  :             NmiTriggered = false;

  00503	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?NmiTriggered@@3HA, 0 ; NmiTriggered

; 442  :         }
; 443  :         else

  0050d	eb 0a		 jmp	 SHORT $LN30@cpuTick
$LN29@cpuTick:

; 444  :         {
; 445  :             IrqTriggered = false;

  0050f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?IrqTriggered@@3HA, 0 ; IrqTriggered
$LN30@cpuTick:

; 446  :         }
; 447  :         nmi_irq(Address, Cpu, AddressMode);

  00519	44 0f b6 44 24
	26		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0051f	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00527	0f b7 4c 24 20	 movzx	 ecx, WORD PTR Address$[rsp]
  0052c	e8 00 00 00 00	 call	 ?nmi_irq@@YAEGPEAUcpu@@E@Z ; nmi_irq

; 448  :     }
; 449  :     else

  00531	eb 66		 jmp	 SHORT $LN27@cpuTick
$LN26@cpuTick:

; 450  :     {
; 451  :         // NOTE: This is where the operation is executed, returning extra cycles, for branch ops
; 452  :         if(CrossedPage)

  00533	83 7c 24 38 00	 cmp	 DWORD PTR CrossedPage$[rsp], 0
  00538	74 1d		 je	 SHORT $LN31@cpuTick

; 453  :             CyclesElapsed += instBoundaryCheck[Instruction];

  0053a	0f b6 44 24 25	 movzx	 eax, BYTE PTR Instruction$[rsp]
  0053f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instBoundaryCheck@@3PAEA
  00546	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0054a	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR CyclesElapsed$[rsp]
  0054f	03 c8		 add	 ecx, eax
  00551	8b c1		 mov	 eax, ecx
  00553	88 44 24 24	 mov	 BYTE PTR CyclesElapsed$[rsp], al
$LN31@cpuTick:

; 454  :      
; 455  :         uint8 AdditionalCycles = instrOps[Instruction](Address, Cpu, AddressMode);

  00557	0f b6 44 24 25	 movzx	 eax, BYTE PTR Instruction$[rsp]
  0055c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instrOps@@3PAP6AEGPEAUcpu@@E@ZA ; instrOps
  00563	48 89 4c 24 68	 mov	 QWORD PTR tv306[rsp], rcx
  00568	44 0f b6 44 24
	26		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0056e	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00576	0f b7 4c 24 20	 movzx	 ecx, WORD PTR Address$[rsp]
  0057b	48 8b 7c 24 68	 mov	 rdi, QWORD PTR tv306[rsp]
  00580	ff 14 c7	 call	 QWORD PTR [rdi+rax*8]
  00583	88 44 24 32	 mov	 BYTE PTR AdditionalCycles$5[rsp], al

; 456  :         CyclesElapsed += AdditionalCycles;

  00587	0f b6 44 24 32	 movzx	 eax, BYTE PTR AdditionalCycles$5[rsp]
  0058c	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR CyclesElapsed$[rsp]
  00591	03 c8		 add	 ecx, eax
  00593	8b c1		 mov	 eax, ecx
  00595	88 44 24 24	 mov	 BYTE PTR CyclesElapsed$[rsp], al
$LN27@cpuTick:

; 457  :     }
; 458  : 
; 459  :     #if 0
; 460  :     char LogInstrData[16];
; 461  :     if(InstrLength == 3)
; 462  :         sprintf(LogInstrData, "%2X %2X %2X", InstrData[0], InstrData[1], InstrData[2]);
; 463  :     else if(InstrLength == 2)
; 464  :         sprintf(LogInstrData, "%2X %2X   ", InstrData[0], InstrData[1]);
; 465  :     else
; 466  :         sprintf(LogInstrData, "%2X      ", InstrData[0]);
; 467  : 
; 468  :     char LogOpInfo[64];
; 469  : //    sprintf(LogOpInfo, ""
; 470  :     
; 471  :     char LogCpuInfo[64];
; 472  :     sprintf(LogCpuInfo, "A:%2X X:%2X Y:%2X P:%2X SP:%2X  CYC: %d",
; 473  :             LogCpu.A, LogCpu.X, LogCpu.Y, LogCpu.Flags, LogCpu.StackPtr, CyclesElapsed);
; 474  : 
; 475  :     // NOTE: CPU Log options
; 476  :     char LogBuffer[1024];
; 477  :     sprintf(LogBuffer, "%4X %s    %s\n", LogCpu.PrgCounter, LogInstrData, LogCpuInfo);
; 478  :     OutputDebugString(LogBuffer);
; 479  : #endif
; 480  :     
; 481  :     return(CyclesElapsed);

  00599	0f b6 44 24 24	 movzx	 eax, BYTE PTR CyclesElapsed$[rsp]
$LN32@cpuTick:

; 482  : }

  0059e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005a6	48 33 cc	 xor	 rcx, rsp
  005a9	e8 00 00 00 00	 call	 __security_check_cookie
  005ae	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  005b5	5f		 pop	 rdi
  005b6	5e		 pop	 rsi
  005b7	c3		 ret	 0
$LN37@cpuTick:
  005b8	00 00 00 00	 DD	 $LN24@cpuTick
  005bc	00 00 00 00	 DD	 $LN5@cpuTick
  005c0	00 00 00 00	 DD	 $LN13@cpuTick
  005c4	00 00 00 00	 DD	 $LN14@cpuTick
  005c8	00 00 00 00	 DD	 $LN15@cpuTick
  005cc	00 00 00 00	 DD	 $LN16@cpuTick
  005d0	00 00 00 00	 DD	 $LN17@cpuTick
  005d4	00 00 00 00	 DD	 $LN18@cpuTick
  005d8	00 00 00 00	 DD	 $LN19@cpuTick
  005dc	00 00 00 00	 DD	 $LN5@cpuTick
  005e0	00 00 00 00	 DD	 $LN20@cpuTick
  005e4	00 00 00 00	 DD	 $LN21@cpuTick
  005e8	00 00 00 00	 DD	 $LN22@cpuTick
  005ec	00 00 00 00	 DD	 $LN23@cpuTick
?cpuTick@@YAEPEAUcpu@@@Z ENDP				; cpuTick
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?nmi_irq@@YAEGPEAUcpu@@E@Z PROC				; nmi_irq

; 306  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 307  :     uint8 HighByte = (uint8)(Cpu->PrgCounter >> 8);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0001c	c1 f8 08	 sar	 eax, 8
  0001f	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 308  :     uint8 LowByte = (uint8)Cpu->PrgCounter; 

  00023	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  0002c	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 309  :     push(HighByte, Cpu);

  00030	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00035	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR HighByte$[rsp]
  0003a	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 310  :     push(LowByte, Cpu);

  0003f	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00044	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  00049	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 311  : 
; 312  :     clearBreak(&Cpu->Flags);

  0004e	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00053	48 83 c0 03	 add	 rax, 3
  00057	48 8b c8	 mov	 rcx, rax
  0005a	e8 00 00 00 00	 call	 ?clearBreak@@YAXPEAE@Z	; clearBreak

; 313  :     push(Cpu->Flags, Cpu); 

  0005f	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00064	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00069	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  0006d	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 314  :     setInterrupt(&Cpu->Flags);

  00072	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00077	48 83 c0 03	 add	 rax, 3
  0007b	48 8b c8	 mov	 rcx, rax
  0007e	e8 00 00 00 00	 call	 ?setInterrupt@@YAXPEAE@Z ; setInterrupt

; 315  : 
; 316  :     Cpu->PrgCounter = readCpu16(Address, Cpu->MemoryBase);

  00083	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00088	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0008c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00091	e8 00 00 00 00	 call	 ?readCpu16@@YAGG_K@Z	; readCpu16
  00096	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0009b	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 317  :     return(0);

  0009f	32 c0		 xor	 al, al

; 318  : }

  000a1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a5	c3		 ret	 0
?nmi_irq@@YAEGPEAUcpu@@E@Z ENDP				; nmi_irq
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?xaa@@YAEGPEAUcpu@@E@Z PROC				; xaa

; 753  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 754  :     Assert(0);

  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 0b		 je	 SHORT $LN2@xaa
  00016	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@xaa:

; 755  :     return(0);

  00021	32 c0		 xor	 al, al

; 756  : }

  00023	c3		 ret	 0
?xaa@@YAEGPEAUcpu@@E@Z ENDP				; xaa
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?tas@@YAEGPEAUcpu@@E@Z PROC				; tas

; 747  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 748  :     Assert(0);

  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 0b		 je	 SHORT $LN2@tas
  00016	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@tas:

; 749  :     return(0);

  00021	32 c0		 xor	 al, al

; 750  : }

  00023	c3		 ret	 0
?tas@@YAEGPEAUcpu@@E@Z ENDP				; tas
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?sre@@YAEGPEAUcpu@@E@Z PROC				; sre

; 741  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 742  :     lsr(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?lsr@@YAEGPEAUcpu@@E@Z	; lsr

; 743  :     eor(Address, Cpu, AddressMode);

  00028	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0002e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00033	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00038	e8 00 00 00 00	 call	 ?eor@@YAEGPEAUcpu@@E@Z	; eor

; 744  :     return(0);

  0003d	32 c0		 xor	 al, al

; 745  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
?sre@@YAEGPEAUcpu@@E@Z ENDP				; sre
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?slo@@YAEGPEAUcpu@@E@Z PROC				; slo

; 735  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 736  :     asl(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?asl@@YAEGPEAUcpu@@E@Z	; asl

; 737  :     ora(Address, Cpu, AddressMode);

  00028	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0002e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00033	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00038	e8 00 00 00 00	 call	 ?ora@@YAEGPEAUcpu@@E@Z	; ora

; 738  :     return(0);

  0003d	32 c0		 xor	 al, al

; 739  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
?slo@@YAEGPEAUcpu@@E@Z ENDP				; slo
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?shy@@YAEGPEAUcpu@@E@Z PROC				; shy

; 730  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 731  :     Assert(0);

  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 0b		 je	 SHORT $LN2@shy
  00016	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@shy:

; 732  :     return(0);

  00021	32 c0		 xor	 al, al

; 733  : }

  00023	c3		 ret	 0
?shy@@YAEGPEAUcpu@@E@Z ENDP				; shy
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?shx@@YAEGPEAUcpu@@E@Z PROC				; shx

; 725  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 726  :     Assert(0);

  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 0b		 je	 SHORT $LN2@shx
  00016	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@shx:

; 727  :     return(0);

  00021	32 c0		 xor	 al, al

; 728  : }

  00023	c3		 ret	 0
?shx@@YAEGPEAUcpu@@E@Z ENDP				; shx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?sax@@YAEGPEAUcpu@@E@Z PROC				; sax

; 719  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 720  :     uint8 Value = Cpu->A & Cpu->X;

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00020	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00024	23 c1		 and	 eax, ecx
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 721  :     writeCpu8(Value, Address, Cpu->MemoryBase);    

  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002f	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00033	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  00038	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0003d	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEG_K@Z	; writeCpu8

; 722  :     return(0);

  00042	32 c0		 xor	 al, al

; 723  : }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
?sax@@YAEGPEAUcpu@@E@Z ENDP				; sax
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?rra@@YAEGPEAUcpu@@E@Z PROC				; rra

; 713  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 714  :     ror(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?ror@@YAEGPEAUcpu@@E@Z	; ror

; 715  :     adc(Address, Cpu, AddressMode);

  00028	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0002e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00033	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00038	e8 00 00 00 00	 call	 ?adc@@YAEGPEAUcpu@@E@Z	; adc

; 716  :     return(0);

  0003d	32 c0		 xor	 al, al

; 717  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
?rra@@YAEGPEAUcpu@@E@Z ENDP				; rra
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?rla@@YAEGPEAUcpu@@E@Z PROC				; rla

; 707  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 708  :     rol(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?rol@@YAEGPEAUcpu@@E@Z	; rol

; 709  :     AND(Address, Cpu, AddressMode);

  00028	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0002e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00033	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00038	e8 00 00 00 00	 call	 ?AND@@YAEGPEAUcpu@@E@Z	; AND

; 710  :     return(0);

  0003d	32 c0		 xor	 al, al

; 711  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
?rla@@YAEGPEAUcpu@@E@Z ENDP				; rla
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?lax@@YAEGPEAUcpu@@E@Z PROC				; lax

; 701  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 702  :     lda(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?lda@@YAEGPEAUcpu@@E@Z	; lda

; 703  :     ldx(Address, Cpu, AddressMode);

  00028	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0002e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00033	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00038	e8 00 00 00 00	 call	 ?ldx@@YAEGPEAUcpu@@E@Z	; ldx

; 704  :     return(0);

  0003d	32 c0		 xor	 al, al

; 705  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
?lax@@YAEGPEAUcpu@@E@Z ENDP				; lax
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?las@@YAEGPEAUcpu@@E@Z PROC				; las

; 697  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 698  :     return(0); 

  0000f	32 c0		 xor	 al, al

; 699  : }

  00011	c3		 ret	 0
?las@@YAEGPEAUcpu@@E@Z ENDP				; las
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?kil@@YAEGPEAUcpu@@E@Z PROC				; kil

; 692  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 693  :     //Assert(0);
; 694  :     return(0);

  0000f	32 c0		 xor	 al, al

; 695  : }

  00011	c3		 ret	 0
?kil@@YAEGPEAUcpu@@E@Z ENDP				; kil
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?isc@@YAEGPEAUcpu@@E@Z PROC				; isc

; 686  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 687  :     inc(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?inc@@YAEGPEAUcpu@@E@Z	; inc

; 688  :     sbc(Address, Cpu, AddressMode);

  00028	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0002e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00033	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00038	e8 00 00 00 00	 call	 ?sbc@@YAEGPEAUcpu@@E@Z	; sbc

; 689  :     return(0);

  0003d	32 c0		 xor	 al, al

; 690  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
?isc@@YAEGPEAUcpu@@E@Z ENDP				; isc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?dcp@@YAEGPEAUcpu@@E@Z PROC				; dcp

; 680  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 681  :     dec(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?dec@@YAEGPEAUcpu@@E@Z	; dec

; 682  :     cmp(Address, Cpu, AddressMode);

  00028	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0002e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00033	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00038	e8 00 00 00 00	 call	 ?cmp@@YAEGPEAUcpu@@E@Z	; cmp

; 683  :     return(0);

  0003d	32 c0		 xor	 al, al

; 684  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
?dcp@@YAEGPEAUcpu@@E@Z ENDP				; dcp
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
ANDValue$ = 32
Value$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?axs@@YAEGPEAUcpu@@E@Z PROC				; axs

; 663  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 664  :     uint8 Value = readCpu8(Address, Cpu->MemoryBase);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	88 44 24 21	 mov	 BYTE PTR Value$[rsp], al

; 665  : 
; 666  :     uint8 ANDValue = (Cpu->A & Cpu->X);

  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00032	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00037	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0003b	23 c1		 and	 eax, ecx
  0003d	88 44 24 20	 mov	 BYTE PTR ANDValue$[rsp], al

; 667  :     Cpu->X = ANDValue - Value;

  00041	0f b6 44 24 20	 movzx	 eax, BYTE PTR ANDValue$[rsp]
  00046	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR Value$[rsp]
  0004b	2b c1		 sub	 eax, ecx
  0004d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00052	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 668  : 
; 669  :     if(ANDValue >= Value)

  00055	0f b6 44 24 20	 movzx	 eax, BYTE PTR ANDValue$[rsp]
  0005a	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR Value$[rsp]
  0005f	3b c1		 cmp	 eax, ecx
  00061	7c 13		 jl	 SHORT $LN2@axs

; 670  :         setCarry(&Cpu->Flags);

  00063	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00068	48 83 c0 03	 add	 rax, 3
  0006c	48 8b c8	 mov	 rcx, rax
  0006f	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 671  :     else

  00074	eb 11		 jmp	 SHORT $LN3@axs
$LN2@axs:

; 672  :         clearCarry(&Cpu->Flags);

  00076	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0007b	48 83 c0 03	 add	 rax, 3
  0007f	48 8b c8	 mov	 rcx, rax
  00082	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN3@axs:

; 673  :     
; 674  :     setZero(Cpu->X, &Cpu->Flags);

  00087	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0008c	48 83 c0 03	 add	 rax, 3
  00090	48 8b d0	 mov	 rdx, rax
  00093	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00098	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  0009c	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 675  :     setNegative(Cpu->X, &Cpu->Flags);

  000a1	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000a6	48 83 c0 03	 add	 rax, 3
  000aa	48 8b d0	 mov	 rdx, rax
  000ad	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000b2	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  000b6	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 676  :     
; 677  :     return(0);

  000bb	32 c0		 xor	 al, al

; 678  : }

  000bd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c1	c3		 ret	 0
?axs@@YAEGPEAUcpu@@E@Z ENDP				; axs
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
bit6$ = 32
bit5$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?arr@@YAEGPEAUcpu@@E@Z PROC				; arr

; 639  : {

$LN9:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 640  :     AND(Address, Cpu, AddressMode);    

  00013	44 0f b6 44 24
	50		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?AND@@YAEGPEAUcpu@@E@Z	; AND

; 641  :     ror(Address, Cpu, ACM);

  00028	41 b0 01	 mov	 r8b, 1
  0002b	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00030	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00035	e8 00 00 00 00	 call	 ?ror@@YAEGPEAUcpu@@E@Z	; ror

; 642  : 
; 643  :     uint8 bit5 = Cpu->A & (1<<5);

  0003a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00042	83 e0 20	 and	 eax, 32			; 00000020H
  00045	88 44 24 21	 mov	 BYTE PTR bit5$[rsp], al

; 644  :     uint8 bit6 = Cpu->A & (1<<6);

  00049	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00051	83 e0 40	 and	 eax, 64			; 00000040H
  00054	88 44 24 20	 mov	 BYTE PTR bit6$[rsp], al

; 645  : 
; 646  :     if(bit6)

  00058	0f b6 44 24 20	 movzx	 eax, BYTE PTR bit6$[rsp]
  0005d	85 c0		 test	 eax, eax
  0005f	74 13		 je	 SHORT $LN2@arr

; 647  :         setCarry(&Cpu->Flags);

  00061	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00066	48 83 c0 03	 add	 rax, 3
  0006a	48 8b c8	 mov	 rcx, rax
  0006d	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 648  :     else

  00072	eb 11		 jmp	 SHORT $LN3@arr
$LN2@arr:

; 649  :         clearCarry(&Cpu->Flags);

  00074	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00079	48 83 c0 03	 add	 rax, 3
  0007d	48 8b c8	 mov	 rcx, rax
  00080	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN3@arr:

; 650  : 
; 651  :     if((bit5 && !bit6) || (!bit5 && bit6))

  00085	0f b6 44 24 21	 movzx	 eax, BYTE PTR bit5$[rsp]
  0008a	85 c0		 test	 eax, eax
  0008c	74 09		 je	 SHORT $LN7@arr
  0008e	0f b6 44 24 20	 movzx	 eax, BYTE PTR bit6$[rsp]
  00093	85 c0		 test	 eax, eax
  00095	74 12		 je	 SHORT $LN6@arr
$LN7@arr:
  00097	0f b6 44 24 21	 movzx	 eax, BYTE PTR bit5$[rsp]
  0009c	85 c0		 test	 eax, eax
  0009e	75 1c		 jne	 SHORT $LN4@arr
  000a0	0f b6 44 24 20	 movzx	 eax, BYTE PTR bit6$[rsp]
  000a5	85 c0		 test	 eax, eax
  000a7	74 13		 je	 SHORT $LN4@arr
$LN6@arr:

; 652  :         setOverflow(&Cpu->Flags);

  000a9	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000ae	48 83 c0 03	 add	 rax, 3
  000b2	48 8b c8	 mov	 rcx, rax
  000b5	e8 00 00 00 00	 call	 ?setOverflow@@YAXPEAE@Z	; setOverflow

; 653  :     else

  000ba	eb 11		 jmp	 SHORT $LN5@arr
$LN4@arr:

; 654  :         clearOverflow(&Cpu->Flags);

  000bc	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000c1	48 83 c0 03	 add	 rax, 3
  000c5	48 8b c8	 mov	 rcx, rax
  000c8	e8 00 00 00 00	 call	 ?clearOverflow@@YAXPEAE@Z ; clearOverflow
$LN5@arr:

; 655  :         
; 656  :     setZero(Cpu->A, &Cpu->Flags);

  000cd	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000d2	48 83 c0 03	 add	 rax, 3
  000d6	48 8b d0	 mov	 rdx, rax
  000d9	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000de	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000e1	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 657  :     setNegative(Cpu->A, &Cpu->Flags);

  000e6	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000eb	48 83 c0 03	 add	 rax, 3
  000ef	48 8b d0	 mov	 rdx, rax
  000f2	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000f7	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000fa	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 658  : 
; 659  :     
; 660  :     return(0);

  000ff	32 c0		 xor	 al, al

; 661  : }

  00101	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00105	c3		 ret	 0
?arr@@YAEGPEAUcpu@@E@Z ENDP				; arr
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?anc@@YAEGPEAUcpu@@E@Z PROC				; anc

; 628  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 629  :     AND(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?AND@@YAEGPEAUcpu@@E@Z	; AND

; 630  :     
; 631  :     if(isBitSet(NEGATIVE_BIT, Cpu->Flags))

  00028	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00031	b1 80		 mov	 cl, 128			; 00000080H
  00033	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00038	85 c0		 test	 eax, eax
  0003a	74 13		 je	 SHORT $LN2@anc

; 632  :         setCarry(&Cpu->Flags);

  0003c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	48 83 c0 03	 add	 rax, 3
  00045	48 8b c8	 mov	 rcx, rax
  00048	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 633  :     else

  0004d	eb 11		 jmp	 SHORT $LN3@anc
$LN2@anc:

; 634  :         clearCarry(&Cpu->Flags);

  0004f	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00054	48 83 c0 03	 add	 rax, 3
  00058	48 8b c8	 mov	 rcx, rax
  0005b	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN3@anc:

; 635  :     
; 636  :     return(0);

  00060	32 c0		 xor	 al, al

; 637  : }

  00062	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00066	c3		 ret	 0
?anc@@YAEGPEAUcpu@@E@Z ENDP				; anc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?alr@@YAEGPEAUcpu@@E@Z PROC				; alr

; 622  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 623  :     AND(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?AND@@YAEGPEAUcpu@@E@Z	; AND

; 624  :     lsr(Address, Cpu, ACM);

  00028	41 b0 01	 mov	 r8b, 1
  0002b	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00030	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00035	e8 00 00 00 00	 call	 ?lsr@@YAEGPEAUcpu@@E@Z	; lsr

; 625  :     return(0);

  0003a	32 c0		 xor	 al, al

; 626  : }

  0003c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00040	c3		 ret	 0
?alr@@YAEGPEAUcpu@@E@Z ENDP				; alr
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?ahx@@YAEGPEAUcpu@@E@Z PROC				; ahx

; 617  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 618  :     //Assert(0);
; 619  :     return(0);

  0000f	32 c0		 xor	 al, al

; 620  : }

  00011	c3		 ret	 0
?ahx@@YAEGPEAUcpu@@E@Z ENDP				; ahx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?txs@@YAEGPEAUcpu@@E@Z PROC				; txs

; 609  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 610  :     Cpu->StackPtr = Cpu->X;

  0000f	48 8b 44 24 10	 mov	 rax, QWORD PTR Cpu$[rsp]
  00014	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00019	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0001d	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 611  :     return(0);

  00020	32 c0		 xor	 al, al

; 612  : }

  00022	c3		 ret	 0
?txs@@YAEGPEAUcpu@@E@Z ENDP				; txs
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?tya@@YAEGPEAUcpu@@E@Z PROC				; tya

; 602  : {   

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 603  :     Cpu->A = Cpu->Y;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0001d	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  00021	88 08		 mov	 BYTE PTR [rax], cl

; 604  :     setZero(Cpu->A, &Cpu->Flags);

  00023	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	48 83 c0 03	 add	 rax, 3
  0002c	48 8b d0	 mov	 rdx, rax
  0002f	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00034	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00037	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 605  :     setNegative(Cpu->A, &Cpu->Flags);

  0003c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	48 83 c0 03	 add	 rax, 3
  00045	48 8b d0	 mov	 rdx, rax
  00048	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004d	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00050	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 606  :     return(0);

  00055	32 c0		 xor	 al, al

; 607  : }

  00057	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005b	c3		 ret	 0
?tya@@YAEGPEAUcpu@@E@Z ENDP				; tya
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?txa@@YAEGPEAUcpu@@E@Z PROC				; txa

; 595  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 596  :     Cpu->A = Cpu->X;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0001d	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00021	88 08		 mov	 BYTE PTR [rax], cl

; 597  :     setZero(Cpu->A, &Cpu->Flags);

  00023	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	48 83 c0 03	 add	 rax, 3
  0002c	48 8b d0	 mov	 rdx, rax
  0002f	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00034	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00037	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 598  :     setNegative(Cpu->A, &Cpu->Flags);

  0003c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	48 83 c0 03	 add	 rax, 3
  00045	48 8b d0	 mov	 rdx, rax
  00048	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004d	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00050	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 599  :     return(0);

  00055	32 c0		 xor	 al, al

; 600  : }

  00057	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005b	c3		 ret	 0
?txa@@YAEGPEAUcpu@@E@Z ENDP				; txa
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?tsx@@YAEGPEAUcpu@@E@Z PROC				; tsx

; 588  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 589  :     Cpu->X = Cpu->StackPtr;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0001d	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00021	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 590  :     setZero(Cpu->X, &Cpu->Flags);

  00024	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00029	48 83 c0 03	 add	 rax, 3
  0002d	48 8b d0	 mov	 rdx, rax
  00030	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00035	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00039	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 591  :     setNegative(Cpu->X, &Cpu->Flags);

  0003e	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00043	48 83 c0 03	 add	 rax, 3
  00047	48 8b d0	 mov	 rdx, rax
  0004a	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004f	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00053	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 592  :     return(0);

  00058	32 c0		 xor	 al, al

; 593  : }

  0005a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005e	c3		 ret	 0
?tsx@@YAEGPEAUcpu@@E@Z ENDP				; tsx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?tay@@YAEGPEAUcpu@@E@Z PROC				; tay

; 581  : {    

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 582  :     Cpu->Y = Cpu->A;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0001d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00020	88 48 02	 mov	 BYTE PTR [rax+2], cl

; 583  :     setZero(Cpu->Y, &Cpu->Flags);

  00023	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	48 83 c0 03	 add	 rax, 3
  0002c	48 8b d0	 mov	 rdx, rax
  0002f	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00034	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00038	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 584  :     setNegative(Cpu->Y, &Cpu->Flags);

  0003d	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00042	48 83 c0 03	 add	 rax, 3
  00046	48 8b d0	 mov	 rdx, rax
  00049	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004e	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00052	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 585  :     return(0);

  00057	32 c0		 xor	 al, al

; 586  : }

  00059	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005d	c3		 ret	 0
?tay@@YAEGPEAUcpu@@E@Z ENDP				; tay
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?tax@@YAEGPEAUcpu@@E@Z PROC				; tax

; 574  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 575  :     Cpu->X = Cpu->A;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0001d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00020	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 576  :     setZero(Cpu->X, &Cpu->Flags);

  00023	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	48 83 c0 03	 add	 rax, 3
  0002c	48 8b d0	 mov	 rdx, rax
  0002f	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00034	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00038	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 577  :     setNegative(Cpu->X, &Cpu->Flags);

  0003d	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00042	48 83 c0 03	 add	 rax, 3
  00046	48 8b d0	 mov	 rdx, rax
  00049	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004e	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00052	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 578  :     return(0);

  00057	32 c0		 xor	 al, al

; 579  : }

  00059	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005d	c3		 ret	 0
?tax@@YAEGPEAUcpu@@E@Z ENDP				; tax
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?sty@@YAEGPEAUcpu@@E@Z PROC				; sty

; 569  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 570  :     writeCpu8(Cpu->Y, Address, Cpu->MemoryBase);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  0001c	0f b7 54 24 30	 movzx	 edx, WORD PTR Address$[rsp]
  00021	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00026	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  0002a	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEG_K@Z	; writeCpu8

; 571  :     return(0);

  0002f	32 c0		 xor	 al, al

; 572  : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
?sty@@YAEGPEAUcpu@@E@Z ENDP				; sty
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?stx@@YAEGPEAUcpu@@E@Z PROC				; stx

; 564  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 565  :     writeCpu8(Cpu->X, Address, Cpu->MemoryBase);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  0001c	0f b7 54 24 30	 movzx	 edx, WORD PTR Address$[rsp]
  00021	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00026	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  0002a	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEG_K@Z	; writeCpu8

; 566  :     return(0);

  0002f	32 c0		 xor	 al, al

; 567  : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
?stx@@YAEGPEAUcpu@@E@Z ENDP				; stx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?sta@@YAEGPEAUcpu@@E@Z PROC				; sta

; 559  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 560  :     writeCpu8(Cpu->A, Address, Cpu->MemoryBase);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  0001c	0f b7 54 24 30	 movzx	 edx, WORD PTR Address$[rsp]
  00021	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00026	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00029	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEG_K@Z	; writeCpu8

; 561  :     return(0);

  0002e	32 c0		 xor	 al, al

; 562  : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
?sta@@YAEGPEAUcpu@@E@Z ENDP				; sta
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?sei@@YAEGPEAUcpu@@E@Z PROC				; sei

; 554  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 555  :     setInterrupt(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?setInterrupt@@YAXPEAE@Z ; setInterrupt

; 556  :     return(0);

  00024	32 c0		 xor	 al, al

; 557  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?sei@@YAEGPEAUcpu@@E@Z ENDP				; sei
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?sed@@YAEGPEAUcpu@@E@Z PROC				; sed

; 549  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 550  :     setDecimal(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?setDecimal@@YAXPEAE@Z	; setDecimal

; 551  :     return(0);

  00024	32 c0		 xor	 al, al

; 552  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?sed@@YAEGPEAUcpu@@E@Z ENDP				; sed
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?sec@@YAEGPEAUcpu@@E@Z PROC				; sec

; 544  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 545  :     setCarry(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 546  :     return(0);

  00024	32 c0		 xor	 al, al

; 547  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?sec@@YAEGPEAUcpu@@E@Z ENDP				; sec
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
A$ = 32
B$ = 33
C$ = 34
Sum$ = 36
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?sbc@@YAEGPEAUcpu@@E@Z PROC				; sbc

; 518  : {

$LN7:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 519  :     uint8 A = Cpu->A;

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001b	88 44 24 20	 mov	 BYTE PTR A$[rsp], al

; 520  :     uint8 B = ~readCpu8(Address, Cpu->MemoryBase); // NOTE: Using the inverse

  0001f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00024	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00028	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0002d	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00032	0f b6 c0	 movzx	 eax, al
  00035	f7 d0		 not	 eax
  00037	88 44 24 21	 mov	 BYTE PTR B$[rsp], al

; 521  :     uint8 C = isBitSet(CARRY_BIT, Cpu->Flags);

  0003b	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00040	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00044	b1 01		 mov	 cl, 1
  00046	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  0004b	88 44 24 22	 mov	 BYTE PTR C$[rsp], al

; 522  : 
; 523  :     uint16 Sum = (uint16)A + (uint16)B + (uint16)C;

  0004f	0f b6 44 24 20	 movzx	 eax, BYTE PTR A$[rsp]
  00054	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR B$[rsp]
  00059	03 c1		 add	 eax, ecx
  0005b	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR C$[rsp]
  00060	03 c1		 add	 eax, ecx
  00062	66 89 44 24 24	 mov	 WORD PTR Sum$[rsp], ax

; 524  : 
; 525  :     // Overflow check, taken from the web. One day find out how this works
; 526  :     if(((A ^ Sum) & (B ^ Sum) & 0x80) == 0x80)

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR A$[rsp]
  0006c	0f b7 4c 24 24	 movzx	 ecx, WORD PTR Sum$[rsp]
  00071	33 c1		 xor	 eax, ecx
  00073	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR B$[rsp]
  00078	0f b7 54 24 24	 movzx	 edx, WORD PTR Sum$[rsp]
  0007d	33 ca		 xor	 ecx, edx
  0007f	23 c1		 and	 eax, ecx
  00081	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00086	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0008b	75 13		 jne	 SHORT $LN2@sbc

; 527  :         setOverflow(&Cpu->Flags);

  0008d	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00092	48 83 c0 03	 add	 rax, 3
  00096	48 8b c8	 mov	 rcx, rax
  00099	e8 00 00 00 00	 call	 ?setOverflow@@YAXPEAE@Z	; setOverflow

; 528  :     else

  0009e	eb 11		 jmp	 SHORT $LN3@sbc
$LN2@sbc:

; 529  :         clearOverflow(&Cpu->Flags);

  000a0	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000a5	48 83 c0 03	 add	 rax, 3
  000a9	48 8b c8	 mov	 rcx, rax
  000ac	e8 00 00 00 00	 call	 ?clearOverflow@@YAXPEAE@Z ; clearOverflow
$LN3@sbc:

; 530  : 
; 531  :     if(Sum & 0x100)

  000b1	0f b7 44 24 24	 movzx	 eax, WORD PTR Sum$[rsp]
  000b6	25 00 01 00 00	 and	 eax, 256		; 00000100H
  000bb	85 c0		 test	 eax, eax
  000bd	74 13		 je	 SHORT $LN4@sbc

; 532  :         setCarry(&Cpu->Flags);

  000bf	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000c4	48 83 c0 03	 add	 rax, 3
  000c8	48 8b c8	 mov	 rcx, rax
  000cb	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 533  :     else

  000d0	eb 11		 jmp	 SHORT $LN5@sbc
$LN4@sbc:

; 534  :         clearCarry(&Cpu->Flags);

  000d2	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000d7	48 83 c0 03	 add	 rax, 3
  000db	48 8b c8	 mov	 rcx, rax
  000de	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN5@sbc:

; 535  : 
; 536  :     setZero(Sum, &Cpu->Flags);

  000e3	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000e8	48 83 c0 03	 add	 rax, 3
  000ec	48 8b d0	 mov	 rdx, rax
  000ef	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Sum$[rsp]
  000f4	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 537  :     setNegative(Sum, &Cpu->Flags);

  000f9	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000fe	48 83 c0 03	 add	 rax, 3
  00102	48 8b d0	 mov	 rdx, rax
  00105	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Sum$[rsp]
  0010a	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 538  : 
; 539  :     Cpu->A = (uint8)Sum;

  0010f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00114	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Sum$[rsp]
  00119	88 08		 mov	 BYTE PTR [rax], cl

; 540  : 
; 541  :     return(0);

  0011b	32 c0		 xor	 al, al

; 542  : }

  0011d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00121	c3		 ret	 0
?sbc@@YAEGPEAUcpu@@E@Z ENDP				; sbc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
ReturnAddress$ = 36
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?rts@@YAEGPEAUcpu@@E@Z PROC				; rts

; 510  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 511  :     uint8 LowByte = pop(Cpu);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  0001d	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 512  :     uint8 HighByte = pop(Cpu);

  00021	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00026	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  0002b	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 513  :     uint16 ReturnAddress = ((uint16)HighByte << 8) | (uint16)LowByte;

  0002f	0f b6 44 24 20	 movzx	 eax, BYTE PTR HighByte$[rsp]
  00034	c1 e0 08	 shl	 eax, 8
  00037	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  0003c	0b c1		 or	 eax, ecx
  0003e	66 89 44 24 24	 mov	 WORD PTR ReturnAddress$[rsp], ax

; 514  :     Cpu->PrgCounter = ReturnAddress + 1;

  00043	0f b7 44 24 24	 movzx	 eax, WORD PTR ReturnAddress$[rsp]
  00048	ff c0		 inc	 eax
  0004a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0004f	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 515  :     return(0);

  00053	32 c0		 xor	 al, al

; 516  : }

  00055	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00059	c3		 ret	 0
?rts@@YAEGPEAUcpu@@E@Z ENDP				; rts
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Flags$ = 32
HighByte$ = 33
LowByte$ = 34
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?rti@@YAEGPEAUcpu@@E@Z PROC				; rti

; 500  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 501  :     uint8 Flags = pop(Cpu);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  0001d	88 44 24 20	 mov	 BYTE PTR Flags$[rsp], al

; 502  :     Cpu->Flags = Flags;

  00021	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00026	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Flags$[rsp]
  0002b	88 48 03	 mov	 BYTE PTR [rax+3], cl

; 503  :     
; 504  :     uint8 LowByte = pop(Cpu);

  0002e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00033	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  00038	88 44 24 22	 mov	 BYTE PTR LowByte$[rsp], al

; 505  :     uint8 HighByte = pop(Cpu);

  0003c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00041	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  00046	88 44 24 21	 mov	 BYTE PTR HighByte$[rsp], al

; 506  :     Cpu->PrgCounter = ((uint16)HighByte << 8) | (uint16)LowByte;

  0004a	0f b6 44 24 21	 movzx	 eax, BYTE PTR HighByte$[rsp]
  0004f	c1 e0 08	 shl	 eax, 8
  00052	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  00057	0b c1		 or	 eax, ecx
  00059	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0005e	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 507  :     return(0);

  00062	32 c0		 xor	 al, al

; 508  : }

  00064	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00068	c3		 ret	 0
?rti@@YAEGPEAUcpu@@E@Z ENDP				; rti
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
CarrySet$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?ror@@YAEGPEAUcpu@@E@Z PROC				; ror

; 461  : {

$LN11:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 462  :     uint8 Value = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR Value$[rsp], 0

; 463  :     uint8 CarrySet = isBitSet(CARRY_BIT, Cpu->Flags);

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 01		 mov	 cl, 1
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	88 44 24 21	 mov	 BYTE PTR CarrySet$[rsp], al

; 464  :     
; 465  :     if(AddressMode == ACM)

  0002c	0f b6 44 24 50	 movzx	 eax, BYTE PTR AddressMode$[rsp]
  00031	83 f8 01	 cmp	 eax, 1
  00034	75 68		 jne	 SHORT $LN2@ror

; 466  :     {        
; 467  :         if(Cpu->A & 1)

  00036	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003e	83 e0 01	 and	 eax, 1
  00041	85 c0		 test	 eax, eax
  00043	74 13		 je	 SHORT $LN4@ror

; 468  :             setCarry(&Cpu->Flags);

  00045	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004a	48 83 c0 03	 add	 rax, 3
  0004e	48 8b c8	 mov	 rcx, rax
  00051	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 469  :         else

  00056	eb 11		 jmp	 SHORT $LN5@ror
$LN4@ror:

; 470  :             clearCarry(&Cpu->Flags);

  00058	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005d	48 83 c0 03	 add	 rax, 3
  00061	48 8b c8	 mov	 rcx, rax
  00064	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN5@ror:

; 471  :         
; 472  :         Value = Cpu->A >> 1;

  00069	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0006e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00071	d1 f8		 sar	 eax, 1
  00073	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 473  :         
; 474  :         if(CarrySet)

  00077	0f b6 44 24 21	 movzx	 eax, BYTE PTR CarrySet$[rsp]
  0007c	85 c0		 test	 eax, eax
  0007e	74 0d		 je	 SHORT $LN6@ror

; 475  :             Value = Value | (1 << 7);

  00080	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  00085	0f ba e8 07	 bts	 eax, 7
  00089	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
$LN6@ror:

; 476  :         
; 477  :         Cpu->A = Value;

  0008d	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00092	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00097	88 08		 mov	 BYTE PTR [rax], cl

; 478  :     }
; 479  :     else

  00099	e9 80 00 00 00	 jmp	 $LN3@ror
$LN2@ror:

; 480  :     {
; 481  :         Value = readCpu8(Address, Cpu->MemoryBase);

  0009e	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000a3	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000a7	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  000ac	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  000b1	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 482  :         if(Value & 1)

  000b5	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 13		 je	 SHORT $LN7@ror

; 483  :             setCarry(&Cpu->Flags);

  000c1	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000c6	48 83 c0 03	 add	 rax, 3
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 484  :         else

  000d2	eb 11		 jmp	 SHORT $LN8@ror
$LN7@ror:

; 485  :             clearCarry(&Cpu->Flags);

  000d4	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000d9	48 83 c0 03	 add	 rax, 3
  000dd	48 8b c8	 mov	 rcx, rax
  000e0	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN8@ror:

; 486  :         
; 487  :         Value = Value >> 1;

  000e5	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000ea	d1 f8		 sar	 eax, 1
  000ec	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 488  :         
; 489  :         if(CarrySet)

  000f0	0f b6 44 24 21	 movzx	 eax, BYTE PTR CarrySet$[rsp]
  000f5	85 c0		 test	 eax, eax
  000f7	74 0d		 je	 SHORT $LN9@ror

; 490  :             Value = Value | (1 << 7);

  000f9	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000fe	0f ba e8 07	 bts	 eax, 7
  00102	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
$LN9@ror:

; 491  :         
; 492  :         writeCpu8(Value, Address, Cpu->MemoryBase);

  00106	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0010b	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  0010f	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  00114	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00119	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEG_K@Z	; writeCpu8
$LN3@ror:

; 493  :     }
; 494  :     setZero(Value, &Cpu->Flags);

  0011e	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00123	48 83 c0 03	 add	 rax, 3
  00127	48 8b d0	 mov	 rdx, rax
  0012a	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0012f	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 495  :     setNegative(Value, &Cpu->Flags);

  00134	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00139	48 83 c0 03	 add	 rax, 3
  0013d	48 8b d0	 mov	 rdx, rax
  00140	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00145	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 496  :     return(0);

  0014a	32 c0		 xor	 al, al

; 497  : }

  0014c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00150	c3		 ret	 0
?ror@@YAEGPEAUcpu@@E@Z ENDP				; ror
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
CarrySet$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?rol@@YAEGPEAUcpu@@E@Z PROC				; rol

; 422  : {    

$LN11:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 423  :     uint8 Value = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR Value$[rsp], 0

; 424  :     uint8 CarrySet = isBitSet(CARRY_BIT, Cpu->Flags);

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 01		 mov	 cl, 1
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	88 44 24 21	 mov	 BYTE PTR CarrySet$[rsp], al

; 425  :     
; 426  :     if(AddressMode == ACM)

  0002c	0f b6 44 24 50	 movzx	 eax, BYTE PTR AddressMode$[rsp]
  00031	83 f8 01	 cmp	 eax, 1
  00034	75 69		 jne	 SHORT $LN2@rol

; 427  :     {        
; 428  :         if(Cpu->A & (1 << 7))

  00036	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003e	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00043	85 c0		 test	 eax, eax
  00045	74 13		 je	 SHORT $LN4@rol

; 429  :             setCarry(&Cpu->Flags);

  00047	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004c	48 83 c0 03	 add	 rax, 3
  00050	48 8b c8	 mov	 rcx, rax
  00053	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 430  :         else

  00058	eb 11		 jmp	 SHORT $LN5@rol
$LN4@rol:

; 431  :             clearCarry(&Cpu->Flags);

  0005a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005f	48 83 c0 03	 add	 rax, 3
  00063	48 8b c8	 mov	 rcx, rax
  00066	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN5@rol:

; 432  :         
; 433  :         Value = Cpu->A << 1;

  0006b	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00070	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00073	d1 e0		 shl	 eax, 1
  00075	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 434  :         
; 435  :         if(CarrySet)

  00079	0f b6 44 24 21	 movzx	 eax, BYTE PTR CarrySet$[rsp]
  0007e	85 c0		 test	 eax, eax
  00080	74 0c		 je	 SHORT $LN6@rol

; 436  :             Value = Value | 1;

  00082	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  00087	83 c8 01	 or	 eax, 1
  0008a	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
$LN6@rol:

; 437  :         
; 438  :         Cpu->A = Value;

  0008e	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00093	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00098	88 08		 mov	 BYTE PTR [rax], cl

; 439  :     }
; 440  :     else

  0009a	e9 81 00 00 00	 jmp	 $LN3@rol
$LN2@rol:

; 441  :     {
; 442  :         Value = readCpu8(Address, Cpu->MemoryBase);

  0009f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000a4	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000a8	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  000ad	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  000b2	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 443  :         if(Value & (1 << 7))

  000b6	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000bb	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000c0	85 c0		 test	 eax, eax
  000c2	74 13		 je	 SHORT $LN7@rol

; 444  :             setCarry(&Cpu->Flags);

  000c4	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000c9	48 83 c0 03	 add	 rax, 3
  000cd	48 8b c8	 mov	 rcx, rax
  000d0	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 445  :         else

  000d5	eb 11		 jmp	 SHORT $LN8@rol
$LN7@rol:

; 446  :             clearCarry(&Cpu->Flags);

  000d7	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000dc	48 83 c0 03	 add	 rax, 3
  000e0	48 8b c8	 mov	 rcx, rax
  000e3	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN8@rol:

; 447  :         
; 448  :         Value = Value << 1;

  000e8	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000ed	d1 e0		 shl	 eax, 1
  000ef	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 449  :         
; 450  :         if(CarrySet)

  000f3	0f b6 44 24 21	 movzx	 eax, BYTE PTR CarrySet$[rsp]
  000f8	85 c0		 test	 eax, eax
  000fa	74 0c		 je	 SHORT $LN9@rol

; 451  :             Value = Value | 1;

  000fc	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  00101	83 c8 01	 or	 eax, 1
  00104	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
$LN9@rol:

; 452  :         
; 453  :         writeCpu8(Value, Address, Cpu->MemoryBase);

  00108	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0010d	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00111	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  00116	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0011b	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEG_K@Z	; writeCpu8
$LN3@rol:

; 454  :     }
; 455  :     setZero(Value, &Cpu->Flags);

  00120	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00125	48 83 c0 03	 add	 rax, 3
  00129	48 8b d0	 mov	 rdx, rax
  0012c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00131	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 456  :     setNegative(Value, &Cpu->Flags);

  00136	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0013b	48 83 c0 03	 add	 rax, 3
  0013f	48 8b d0	 mov	 rdx, rax
  00142	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00147	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 457  :     return(0);

  0014c	32 c0		 xor	 al, al

; 458  : }

  0014e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00152	c3		 ret	 0
?rol@@YAEGPEAUcpu@@E@Z ENDP				; rol
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?plp@@YAEGPEAUcpu@@E@Z PROC				; plp

; 417  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 418  :     Cpu->Flags = pop(Cpu);

  00013	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  0001d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00022	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 419  :     return(0);

  00025	32 c0		 xor	 al, al

; 420  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
?plp@@YAEGPEAUcpu@@E@Z ENDP				; plp
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?pla@@YAEGPEAUcpu@@E@Z PROC				; pla

; 410  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 411  :     Cpu->A = pop(Cpu); 

  00013	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  0001d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00022	88 01		 mov	 BYTE PTR [rcx], al

; 412  :     setZero(Cpu->A, &Cpu->Flags);

  00024	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00029	48 83 c0 03	 add	 rax, 3
  0002d	48 8b d0	 mov	 rdx, rax
  00030	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00035	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00038	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 413  :     setNegative(Cpu->A, &Cpu->Flags);

  0003d	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00042	48 83 c0 03	 add	 rax, 3
  00046	48 8b d0	 mov	 rdx, rax
  00049	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004e	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00051	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 414  :     return(0);

  00056	32 c0		 xor	 al, al

; 415  : }

  00058	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005c	c3		 ret	 0
?pla@@YAEGPEAUcpu@@E@Z ENDP				; pla
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?php@@YAEGPEAUcpu@@E@Z PROC				; php

; 403  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 404  :     setBreak(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?setBreak@@YAXPEAE@Z	; setBreak

; 405  :     setBlank(&Cpu->Flags);

  00024	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00029	48 83 c0 03	 add	 rax, 3
  0002d	48 8b c8	 mov	 rcx, rax
  00030	e8 00 00 00 00	 call	 ?setBlank@@YAXPEAE@Z	; setBlank

; 406  :     push(Cpu->Flags, Cpu);

  00035	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0003a	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003f	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  00043	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 407  :     return(0);

  00048	32 c0		 xor	 al, al

; 408  : }

  0004a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004e	c3		 ret	 0
?php@@YAEGPEAUcpu@@E@Z ENDP				; php
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?pha@@YAEGPEAUcpu@@E@Z PROC				; pha

; 398  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 399  :     push(Cpu->A, Cpu);

  00013	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00018	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00020	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 400  :     return(0);

  00025	32 c0		 xor	 al, al

; 401  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
?pha@@YAEGPEAUcpu@@E@Z ENDP				; pha
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?ora@@YAEGPEAUcpu@@E@Z PROC				; ora

; 390  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 391  :     uint8 Value = readCpu8(Address, Cpu->MemoryBase);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 392  :     Cpu->A = Cpu->A | Value;

  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00032	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00037	0b c1		 or	 eax, ecx
  00039	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0003e	88 01		 mov	 BYTE PTR [rcx], al

; 393  :     setZero(Cpu->A, &Cpu->Flags);

  00040	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00045	48 83 c0 03	 add	 rax, 3
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00054	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 394  :     setNegative(Cpu->A, &Cpu->Flags);

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	48 83 c0 03	 add	 rax, 3
  00062	48 8b d0	 mov	 rdx, rax
  00065	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0006a	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0006d	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 395  :     return(0);

  00072	32 c0		 xor	 al, al

; 396  : }

  00074	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00078	c3		 ret	 0
?ora@@YAEGPEAUcpu@@E@Z ENDP				; ora
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?nop@@YAEGPEAUcpu@@E@Z PROC				; nop

; 386  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 387  :     return(0);

  0000f	32 c0		 xor	 al, al

; 388  : }

  00011	c3		 ret	 0
?nop@@YAEGPEAUcpu@@E@Z ENDP				; nop
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?lsr@@YAEGPEAUcpu@@E@Z PROC				; lsr

; 360  : {

$LN9:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 361  :     uint8 Value = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR Value$[rsp], 0

; 362  :     if(AddressMode == ACM)

  00018	0f b6 44 24 50	 movzx	 eax, BYTE PTR AddressMode$[rsp]
  0001d	83 f8 01	 cmp	 eax, 1
  00020	75 52		 jne	 SHORT $LN2@lsr

; 363  :     {        
; 364  :         if(Cpu->A & 1)

  00022	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00027	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002a	83 e0 01	 and	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	74 13		 je	 SHORT $LN4@lsr

; 365  :             setCarry(&Cpu->Flags);

  00031	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00036	48 83 c0 03	 add	 rax, 3
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 366  :         else

  00042	eb 11		 jmp	 SHORT $LN5@lsr
$LN4@lsr:

; 367  :             clearCarry(&Cpu->Flags);

  00044	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00049	48 83 c0 03	 add	 rax, 3
  0004d	48 8b c8	 mov	 rcx, rax
  00050	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN5@lsr:

; 368  :         Cpu->A = Cpu->A >> 1;

  00055	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005d	d1 f8		 sar	 eax, 1
  0005f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00064	88 01		 mov	 BYTE PTR [rcx], al

; 369  :         Value = Cpu->A;

  00066	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0006b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006e	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 370  :     }
; 371  :     else

  00072	eb 6a		 jmp	 SHORT $LN3@lsr
$LN2@lsr:

; 372  :     {
; 373  :         Value = readCpu8(Address, Cpu->MemoryBase);

  00074	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00079	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0007d	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00082	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00087	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 374  :         if(Value & 1)

  0008b	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  00090	83 e0 01	 and	 eax, 1
  00093	85 c0		 test	 eax, eax
  00095	74 13		 je	 SHORT $LN6@lsr

; 375  :             setCarry(&Cpu->Flags);

  00097	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0009c	48 83 c0 03	 add	 rax, 3
  000a0	48 8b c8	 mov	 rcx, rax
  000a3	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 376  :         else

  000a8	eb 11		 jmp	 SHORT $LN7@lsr
$LN6@lsr:

; 377  :             clearCarry(&Cpu->Flags);

  000aa	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000af	48 83 c0 03	 add	 rax, 3
  000b3	48 8b c8	 mov	 rcx, rax
  000b6	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN7@lsr:

; 378  :         Value = Value >> 1;

  000bb	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000c0	d1 f8		 sar	 eax, 1
  000c2	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 379  :         writeCpu8(Value, Address, Cpu->MemoryBase);

  000c6	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000cb	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  000cf	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  000d4	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  000d9	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEG_K@Z	; writeCpu8
$LN3@lsr:

; 380  :     }
; 381  :     setZero(Value, &Cpu->Flags);

  000de	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000e3	48 83 c0 03	 add	 rax, 3
  000e7	48 8b d0	 mov	 rdx, rax
  000ea	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  000ef	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 382  :     setNegative(Value, &Cpu->Flags);

  000f4	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000f9	48 83 c0 03	 add	 rax, 3
  000fd	48 8b d0	 mov	 rdx, rax
  00100	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00105	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 383  :     return(0);

  0010a	32 c0		 xor	 al, al

; 384  : }

  0010c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00110	c3		 ret	 0
?lsr@@YAEGPEAUcpu@@E@Z ENDP				; lsr
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?ldy@@YAEGPEAUcpu@@E@Z PROC				; ldy

; 352  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 353  :     uint8 Value = readCpu8(Address, Cpu->MemoryBase);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 354  :     Cpu->Y = Value;

  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00034	88 48 02	 mov	 BYTE PTR [rax+2], cl

; 355  :     setZero(Value, &Cpu->Flags);

  00037	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003c	48 83 c0 03	 add	 rax, 3
  00040	48 8b d0	 mov	 rdx, rax
  00043	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00048	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 356  :     setNegative(Value, &Cpu->Flags);

  0004d	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00052	48 83 c0 03	 add	 rax, 3
  00056	48 8b d0	 mov	 rdx, rax
  00059	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0005e	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 357  :     return(0);

  00063	32 c0		 xor	 al, al

; 358  : }

  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
?ldy@@YAEGPEAUcpu@@E@Z ENDP				; ldy
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?ldx@@YAEGPEAUcpu@@E@Z PROC				; ldx

; 344  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 345  :     uint8 Value = readCpu8(Address, Cpu->MemoryBase);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 346  :     Cpu->X = Value;

  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00034	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 347  :     setZero(Value, &Cpu->Flags);

  00037	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003c	48 83 c0 03	 add	 rax, 3
  00040	48 8b d0	 mov	 rdx, rax
  00043	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00048	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 348  :     setNegative(Value, &Cpu->Flags);

  0004d	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00052	48 83 c0 03	 add	 rax, 3
  00056	48 8b d0	 mov	 rdx, rax
  00059	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0005e	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 349  :     return(0);

  00063	32 c0		 xor	 al, al

; 350  : }

  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
?ldx@@YAEGPEAUcpu@@E@Z ENDP				; ldx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?lda@@YAEGPEAUcpu@@E@Z PROC				; lda

; 336  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 337  :     uint8 Value = readCpu8(Address, Cpu->MemoryBase);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 338  :     Cpu->A = Value;

  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00034	88 08		 mov	 BYTE PTR [rax], cl

; 339  :     setZero(Value, &Cpu->Flags);

  00036	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003b	48 83 c0 03	 add	 rax, 3
  0003f	48 8b d0	 mov	 rdx, rax
  00042	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00047	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 340  :     setNegative(Value, &Cpu->Flags);

  0004c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	48 83 c0 03	 add	 rax, 3
  00055	48 8b d0	 mov	 rdx, rax
  00058	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0005d	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 341  :     return(0);

  00062	32 c0		 xor	 al, al

; 342  : }

  00064	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00068	c3		 ret	 0
?lda@@YAEGPEAUcpu@@E@Z ENDP				; lda
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
ReturnAddress$ = 36
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?jsr@@YAEGPEAUcpu@@E@Z PROC				; jsr

; 324  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 325  :     uint16 ReturnAddress = Cpu->PrgCounter - 1;

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0001c	ff c8		 dec	 eax
  0001e	66 89 44 24 24	 mov	 WORD PTR ReturnAddress$[rsp], ax

; 326  :     uint8 HighByte = (uint8)(ReturnAddress >> 8);

  00023	0f b7 44 24 24	 movzx	 eax, WORD PTR ReturnAddress$[rsp]
  00028	c1 f8 08	 sar	 eax, 8
  0002b	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 327  :     uint8 LowByte = (uint8)ReturnAddress; 

  0002f	0f b6 44 24 24	 movzx	 eax, BYTE PTR ReturnAddress$[rsp]
  00034	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 328  : 
; 329  :     push(HighByte, Cpu);

  00038	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0003d	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR HighByte$[rsp]
  00042	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 330  :     push(LowByte, Cpu);

  00047	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0004c	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  00051	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 331  : 
; 332  :     Cpu->PrgCounter = Address;

  00056	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005b	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00060	66 89 48 06	 mov	 WORD PTR [rax+6], cx

; 333  :     return(0);

  00064	32 c0		 xor	 al, al

; 334  : }

  00066	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006a	c3		 ret	 0
?jsr@@YAEGPEAUcpu@@E@Z ENDP				; jsr
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?jmp@@YAEGPEAUcpu@@E@Z PROC				; jmp

; 319  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 320  :     Cpu->PrgCounter = Address;

  0000f	48 8b 44 24 10	 mov	 rax, QWORD PTR Cpu$[rsp]
  00014	0f b7 4c 24 08	 movzx	 ecx, WORD PTR Address$[rsp]
  00019	66 89 48 06	 mov	 WORD PTR [rax+6], cx

; 321  :     return(0);

  0001d	32 c0		 xor	 al, al

; 322  : }

  0001f	c3		 ret	 0
?jmp@@YAEGPEAUcpu@@E@Z ENDP				; jmp
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?iny@@YAEGPEAUcpu@@E@Z PROC				; iny

; 312  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 313  :     ++Cpu->Y;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0001c	fe c0		 inc	 al
  0001e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00023	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 314  :     setZero(Cpu->Y, &Cpu->Flags);

  00026	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	48 83 c0 03	 add	 rax, 3
  0002f	48 8b d0	 mov	 rdx, rax
  00032	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00037	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  0003b	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 315  :     setNegative(Cpu->Y, &Cpu->Flags);

  00040	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00045	48 83 c0 03	 add	 rax, 3
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00055	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 316  :     return(0);

  0005a	32 c0		 xor	 al, al

; 317  : }

  0005c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00060	c3		 ret	 0
?iny@@YAEGPEAUcpu@@E@Z ENDP				; iny
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?inx@@YAEGPEAUcpu@@E@Z PROC				; inx

; 305  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 306  :     ++Cpu->X;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0001c	fe c0		 inc	 al
  0001e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00023	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 307  :     setZero(Cpu->X, &Cpu->Flags);

  00026	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	48 83 c0 03	 add	 rax, 3
  0002f	48 8b d0	 mov	 rdx, rax
  00032	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00037	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  0003b	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 308  :     setNegative(Cpu->X, &Cpu->Flags);

  00040	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00045	48 83 c0 03	 add	 rax, 3
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00055	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 309  :     return(0);

  0005a	32 c0		 xor	 al, al

; 310  : }

  0005c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00060	c3		 ret	 0
?inx@@YAEGPEAUcpu@@E@Z ENDP				; inx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?inc@@YAEGPEAUcpu@@E@Z PROC				; inc

; 297  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 298  :     uint8 Value = readCpu8(Address, Cpu->MemoryBase) + 1;

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	0f b6 c0	 movzx	 eax, al
  00029	ff c0		 inc	 eax
  0002b	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 299  :     writeCpu8(Value, Address, Cpu->MemoryBase);

  0002f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00034	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00038	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003d	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00042	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEG_K@Z	; writeCpu8

; 300  :     setZero(Value, &Cpu->Flags);

  00047	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004c	48 83 c0 03	 add	 rax, 3
  00050	48 8b d0	 mov	 rdx, rax
  00053	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00058	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 301  :     setNegative(Value, &Cpu->Flags);

  0005d	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00062	48 83 c0 03	 add	 rax, 3
  00066	48 8b d0	 mov	 rdx, rax
  00069	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0006e	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 302  :     return(0);

  00073	32 c0		 xor	 al, al

; 303  : }

  00075	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00079	c3		 ret	 0
?inc@@YAEGPEAUcpu@@E@Z ENDP				; inc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?eor@@YAEGPEAUcpu@@E@Z PROC				; eor

; 289  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 290  :     uint8 Value = readCpu8(Address, Cpu->MemoryBase);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 291  :     Cpu->A = Cpu->A ^ Value;

  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00032	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00037	33 c1		 xor	 eax, ecx
  00039	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0003e	88 01		 mov	 BYTE PTR [rcx], al

; 292  :     setZero(Cpu->A, &Cpu->Flags);

  00040	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00045	48 83 c0 03	 add	 rax, 3
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00054	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 293  :     setNegative(Cpu->A, &Cpu->Flags);

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	48 83 c0 03	 add	 rax, 3
  00062	48 8b d0	 mov	 rdx, rax
  00065	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0006a	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0006d	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 294  :     return(0);

  00072	32 c0		 xor	 al, al

; 295  : }

  00074	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00078	c3		 ret	 0
?eor@@YAEGPEAUcpu@@E@Z ENDP				; eor
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?dey@@YAEGPEAUcpu@@E@Z PROC				; dey

; 282  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 283  :     --Cpu->Y;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0001c	fe c8		 dec	 al
  0001e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00023	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 284  :     setZero(Cpu->Y, &Cpu->Flags);

  00026	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	48 83 c0 03	 add	 rax, 3
  0002f	48 8b d0	 mov	 rdx, rax
  00032	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00037	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  0003b	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 285  :     setNegative(Cpu->Y, &Cpu->Flags);

  00040	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00045	48 83 c0 03	 add	 rax, 3
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00055	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 286  :     return(0);

  0005a	32 c0		 xor	 al, al

; 287  : }

  0005c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00060	c3		 ret	 0
?dey@@YAEGPEAUcpu@@E@Z ENDP				; dey
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?dex@@YAEGPEAUcpu@@E@Z PROC				; dex

; 275  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 276  :     --Cpu->X;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0001c	fe c8		 dec	 al
  0001e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00023	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 277  :     setZero(Cpu->X, &Cpu->Flags);

  00026	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	48 83 c0 03	 add	 rax, 3
  0002f	48 8b d0	 mov	 rdx, rax
  00032	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00037	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  0003b	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 278  :     setNegative(Cpu->X, &Cpu->Flags);

  00040	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00045	48 83 c0 03	 add	 rax, 3
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00055	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 279  :     return(0);

  0005a	32 c0		 xor	 al, al

; 280  : }

  0005c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00060	c3		 ret	 0
?dex@@YAEGPEAUcpu@@E@Z ENDP				; dex
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?dec@@YAEGPEAUcpu@@E@Z PROC				; dec

; 267  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 268  :     uint8 Value = readCpu8(Address, Cpu->MemoryBase) - 1;

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	0f b6 c0	 movzx	 eax, al
  00029	ff c8		 dec	 eax
  0002b	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 269  :     writeCpu8(Value, Address, Cpu->MemoryBase);

  0002f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00034	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00038	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003d	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00042	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEG_K@Z	; writeCpu8

; 270  :     setZero(Value, &Cpu->Flags);

  00047	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004c	48 83 c0 03	 add	 rax, 3
  00050	48 8b d0	 mov	 rdx, rax
  00053	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00058	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 271  :     setNegative(Value, &Cpu->Flags);

  0005d	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00062	48 83 c0 03	 add	 rax, 3
  00066	48 8b d0	 mov	 rdx, rax
  00069	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0006e	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 272  :     return(0);

  00073	32 c0		 xor	 al, al

; 273  : }

  00075	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00079	c3		 ret	 0
?dec@@YAEGPEAUcpu@@E@Z ENDP				; dec
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
CmpValue$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?cpy@@YAEGPEAUcpu@@E@Z PROC				; cpy

; 253  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 254  :     uint8 Value = readCpu8(Address, Cpu->MemoryBase);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 255  : 
; 256  :     if(Cpu->Y >= Value)

  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002f	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00033	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00038	3b c1		 cmp	 eax, ecx
  0003a	7c 13		 jl	 SHORT $LN2@cpy

; 257  :         setCarry(&Cpu->Flags);

  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	48 83 c0 03	 add	 rax, 3
  00045	48 8b c8	 mov	 rcx, rax
  00048	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 258  :     else

  0004d	eb 11		 jmp	 SHORT $LN3@cpy
$LN2@cpy:

; 259  :         clearCarry(&Cpu->Flags);

  0004f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00054	48 83 c0 03	 add	 rax, 3
  00058	48 8b c8	 mov	 rcx, rax
  0005b	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN3@cpy:

; 260  :     
; 261  :     uint8 CmpValue = Cpu->Y - Value;

  00060	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00065	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00069	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0006e	2b c1		 sub	 eax, ecx
  00070	88 44 24 21	 mov	 BYTE PTR CmpValue$[rsp], al

; 262  :     setZero(CmpValue, &Cpu->Flags);

  00074	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00079	48 83 c0 03	 add	 rax, 3
  0007d	48 8b d0	 mov	 rdx, rax
  00080	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  00085	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 263  :     setNegative(CmpValue, &Cpu->Flags);

  0008a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0008f	48 83 c0 03	 add	 rax, 3
  00093	48 8b d0	 mov	 rdx, rax
  00096	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  0009b	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 264  :     return(0);

  000a0	32 c0		 xor	 al, al

; 265  : }

  000a2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a6	c3		 ret	 0
?cpy@@YAEGPEAUcpu@@E@Z ENDP				; cpy
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
CmpValue$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?cpx@@YAEGPEAUcpu@@E@Z PROC				; cpx

; 239  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 240  :     uint8 Value = readCpu8(Address, Cpu->MemoryBase);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 241  : 
; 242  :     if(Cpu->X >= Value)

  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002f	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00033	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00038	3b c1		 cmp	 eax, ecx
  0003a	7c 13		 jl	 SHORT $LN2@cpx

; 243  :         setCarry(&Cpu->Flags);

  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	48 83 c0 03	 add	 rax, 3
  00045	48 8b c8	 mov	 rcx, rax
  00048	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 244  :     else

  0004d	eb 11		 jmp	 SHORT $LN3@cpx
$LN2@cpx:

; 245  :         clearCarry(&Cpu->Flags);

  0004f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00054	48 83 c0 03	 add	 rax, 3
  00058	48 8b c8	 mov	 rcx, rax
  0005b	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN3@cpx:

; 246  :     
; 247  :     uint8 CmpValue = Cpu->X - Value;

  00060	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00065	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00069	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0006e	2b c1		 sub	 eax, ecx
  00070	88 44 24 21	 mov	 BYTE PTR CmpValue$[rsp], al

; 248  :     setZero(CmpValue, &Cpu->Flags);

  00074	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00079	48 83 c0 03	 add	 rax, 3
  0007d	48 8b d0	 mov	 rdx, rax
  00080	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  00085	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 249  :     setNegative(CmpValue, &Cpu->Flags);

  0008a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0008f	48 83 c0 03	 add	 rax, 3
  00093	48 8b d0	 mov	 rdx, rax
  00096	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  0009b	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 250  :     return(0);

  000a0	32 c0		 xor	 al, al

; 251  : }

  000a2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a6	c3		 ret	 0
?cpx@@YAEGPEAUcpu@@E@Z ENDP				; cpx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
CmpValue$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?cmp@@YAEGPEAUcpu@@E@Z PROC				; cmp

; 225  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 226  :     uint8 Value = readCpu8(Address, Cpu->MemoryBase);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 227  : 
; 228  :     if(Cpu->A >= Value)

  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00032	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00037	3b c1		 cmp	 eax, ecx
  00039	7c 13		 jl	 SHORT $LN2@cmp

; 229  :         setCarry(&Cpu->Flags);

  0003b	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00040	48 83 c0 03	 add	 rax, 3
  00044	48 8b c8	 mov	 rcx, rax
  00047	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 230  :     else

  0004c	eb 11		 jmp	 SHORT $LN3@cmp
$LN2@cmp:

; 231  :         clearCarry(&Cpu->Flags);

  0004e	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00053	48 83 c0 03	 add	 rax, 3
  00057	48 8b c8	 mov	 rcx, rax
  0005a	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN3@cmp:

; 232  :     
; 233  :     uint8 CmpValue = Cpu->A - Value;

  0005f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00064	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00067	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0006c	2b c1		 sub	 eax, ecx
  0006e	88 44 24 21	 mov	 BYTE PTR CmpValue$[rsp], al

; 234  :     setZero(CmpValue, &Cpu->Flags);

  00072	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00077	48 83 c0 03	 add	 rax, 3
  0007b	48 8b d0	 mov	 rdx, rax
  0007e	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  00083	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 235  :     setNegative(CmpValue, &Cpu->Flags);

  00088	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0008d	48 83 c0 03	 add	 rax, 3
  00091	48 8b d0	 mov	 rdx, rax
  00094	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  00099	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 236  :     return(0);

  0009e	32 c0		 xor	 al, al

; 237  : }

  000a0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a4	c3		 ret	 0
?cmp@@YAEGPEAUcpu@@E@Z ENDP				; cmp
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?clv@@YAEGPEAUcpu@@E@Z PROC				; clv

; 220  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 221  :     clearOverflow(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?clearOverflow@@YAXPEAE@Z ; clearOverflow

; 222  :     return(0);

  00024	32 c0		 xor	 al, al

; 223  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?clv@@YAEGPEAUcpu@@E@Z ENDP				; clv
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?cli@@YAEGPEAUcpu@@E@Z PROC				; cli

; 215  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 216  :     clearInterrupt(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?clearInterrupt@@YAXPEAE@Z ; clearInterrupt

; 217  :     return(0);

  00024	32 c0		 xor	 al, al

; 218  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?cli@@YAEGPEAUcpu@@E@Z ENDP				; cli
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?cld@@YAEGPEAUcpu@@E@Z PROC				; cld

; 210  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 211  :     clearDecimal(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?clearDecimal@@YAXPEAE@Z ; clearDecimal

; 212  :     return(0);

  00024	32 c0		 xor	 al, al

; 213  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?cld@@YAEGPEAUcpu@@E@Z ENDP				; cld
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?clc@@YAEGPEAUcpu@@E@Z PROC				; clc

; 205  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 206  :     clearCarry(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry

; 207  :     return(0);

  00024	32 c0		 xor	 al, al

; 208  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?clc@@YAEGPEAUcpu@@E@Z ENDP				; clc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bvs@@YAEGPEAUcpu@@E@Z PROC				; bvs

; 192  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 193  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 194  :     if(isBitSet(OVERFLOW_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 40		 mov	 cl, 64			; 00000040H
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	74 3b		 je	 SHORT $LN2@bvs

; 195  :     {
; 196  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 197  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bvs

; 198  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bvs:

; 199  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bvs:

; 200  :     }   
; 201  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 202  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bvs@@YAEGPEAUcpu@@E@Z ENDP				; bvs
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bvc@@YAEGPEAUcpu@@E@Z PROC				; bvc

; 179  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 180  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 181  :     if(!isBitSet(OVERFLOW_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 40		 mov	 cl, 64			; 00000040H
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	75 3b		 jne	 SHORT $LN2@bvc

; 182  :     {
; 183  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 184  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bvc

; 185  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bvc:

; 186  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bvc:

; 187  :     }   
; 188  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 189  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bvc@@YAEGPEAUcpu@@E@Z ENDP				; bvc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?brk@@YAEGPEAUcpu@@E@Z PROC				; brk

; 163  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 164  :     uint8 HighByte = (uint8)(Cpu->PrgCounter >> 8);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0001c	c1 f8 08	 sar	 eax, 8
  0001f	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 165  :     uint8 LowByte = (uint8)Cpu->PrgCounter; 

  00023	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  0002c	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 166  :     push(HighByte, Cpu);

  00030	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00035	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR HighByte$[rsp]
  0003a	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 167  :     push(LowByte, Cpu);

  0003f	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00044	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  00049	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 168  : 
; 169  :     setBlank(&Cpu->Flags);

  0004e	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00053	48 83 c0 03	 add	 rax, 3
  00057	48 8b c8	 mov	 rcx, rax
  0005a	e8 00 00 00 00	 call	 ?setBlank@@YAXPEAE@Z	; setBlank

; 170  :     setBreak(&Cpu->Flags);

  0005f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00064	48 83 c0 03	 add	 rax, 3
  00068	48 8b c8	 mov	 rcx, rax
  0006b	e8 00 00 00 00	 call	 ?setBreak@@YAXPEAE@Z	; setBreak

; 171  :     push(Cpu->Flags, Cpu);

  00070	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00075	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0007a	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  0007e	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 172  :     setInterrupt(&Cpu->Flags);

  00083	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00088	48 83 c0 03	 add	 rax, 3
  0008c	48 8b c8	 mov	 rcx, rax
  0008f	e8 00 00 00 00	 call	 ?setInterrupt@@YAXPEAE@Z ; setInterrupt

; 173  : 
; 174  :     Cpu->PrgCounter = readCpu16(IRQ_BRK_VEC, Cpu->MemoryBase);

  00094	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00099	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0009d	66 b9 fe ff	 mov	 cx, 65534		; 0000fffeH
  000a1	e8 00 00 00 00	 call	 ?readCpu16@@YAGG_K@Z	; readCpu16
  000a6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  000ab	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 175  :     return(0);

  000af	32 c0		 xor	 al, al

; 176  : }

  000b1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b5	c3		 ret	 0
?brk@@YAEGPEAUcpu@@E@Z ENDP				; brk
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bpl@@YAEGPEAUcpu@@E@Z PROC				; bpl

; 150  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 151  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 152  :     if(!isBitSet(NEGATIVE_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 80		 mov	 cl, 128			; 00000080H
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	75 3b		 jne	 SHORT $LN2@bpl

; 153  :     {
; 154  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 155  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bpl

; 156  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bpl:

; 157  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bpl:

; 158  :     }   
; 159  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 160  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bpl@@YAEGPEAUcpu@@E@Z ENDP				; bpl
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bne@@YAEGPEAUcpu@@E@Z PROC				; bne

; 137  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 138  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 139  :     if(!isBitSet(ZERO_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 02		 mov	 cl, 2
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	75 3b		 jne	 SHORT $LN2@bne

; 140  :     {
; 141  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 142  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bne

; 143  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bne:

; 144  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bne:

; 145  :     }   
; 146  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 147  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bne@@YAEGPEAUcpu@@E@Z ENDP				; bne
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bmi@@YAEGPEAUcpu@@E@Z PROC				; bmi

; 124  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 125  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 126  :     if(isBitSet(NEGATIVE_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 80		 mov	 cl, 128			; 00000080H
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	74 3b		 je	 SHORT $LN2@bmi

; 127  :     {
; 128  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 129  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bmi

; 130  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bmi:

; 131  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bmi:

; 132  :     }   
; 133  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 134  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bmi@@YAEGPEAUcpu@@E@Z ENDP				; bmi
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bit@@YAEGPEAUcpu@@E@Z PROC				; bit

; 112  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 113  :     uint8 Value = readCpu8(Address, Cpu->MemoryBase);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 114  :     if(Value & (1 << 6))

  0002a	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  0002f	83 e0 40	 and	 eax, 64			; 00000040H
  00032	85 c0		 test	 eax, eax
  00034	74 13		 je	 SHORT $LN2@bit

; 115  :         setOverflow(&Cpu->Flags);

  00036	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003b	48 83 c0 03	 add	 rax, 3
  0003f	48 8b c8	 mov	 rcx, rax
  00042	e8 00 00 00 00	 call	 ?setOverflow@@YAXPEAE@Z	; setOverflow

; 116  :     else

  00047	eb 11		 jmp	 SHORT $LN3@bit
$LN2@bit:

; 117  :         clearOverflow(&Cpu->Flags);

  00049	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004e	48 83 c0 03	 add	 rax, 3
  00052	48 8b c8	 mov	 rcx, rax
  00055	e8 00 00 00 00	 call	 ?clearOverflow@@YAXPEAE@Z ; clearOverflow
$LN3@bit:

; 118  :     setNegative(Value, &Cpu->Flags);

  0005a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005f	48 83 c0 03	 add	 rax, 3
  00063	48 8b d0	 mov	 rdx, rax
  00066	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0006b	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 119  :     setZero(Cpu->A & Value, &Cpu->Flags);

  00070	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00075	48 83 c0 03	 add	 rax, 3
  00079	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0007e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00081	0f b6 54 24 20	 movzx	 edx, BYTE PTR Value$[rsp]
  00086	23 ca		 and	 ecx, edx
  00088	48 8b d0	 mov	 rdx, rax
  0008b	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 120  :     return(0);

  00090	32 c0		 xor	 al, al

; 121  : }

  00092	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00096	c3		 ret	 0
?bit@@YAEGPEAUcpu@@E@Z ENDP				; bit
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?beq@@YAEGPEAUcpu@@E@Z PROC				; beq

; 99   : {   

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 100  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 101  :     if(isBitSet(ZERO_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 02		 mov	 cl, 2
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	74 3b		 je	 SHORT $LN2@beq

; 102  :     {
; 103  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 104  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@beq

; 105  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@beq:

; 106  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@beq:

; 107  :     }   
; 108  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 109  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?beq@@YAEGPEAUcpu@@E@Z ENDP				; beq
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bcs@@YAEGPEAUcpu@@E@Z PROC				; bcs

; 87   : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 88   :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 89   :     if(isBitSet(CARRY_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 01		 mov	 cl, 1
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	74 3b		 je	 SHORT $LN2@bcs

; 90   :     {
; 91   :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 92   :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bcs

; 93   :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bcs:

; 94   :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bcs:

; 95   :     }   
; 96   :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 97   : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bcs@@YAEGPEAUcpu@@E@Z ENDP				; bcs
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Test$1 = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bcc@@YAEGPEAUcpu@@E@Z PROC				; bcc

; 71   : {

$LN6:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 72   :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 73   :     
; 74   :     if(!isBitSet(CARRY_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 01		 mov	 cl, 1
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	75 3d		 jne	 SHORT $LN2@bcc

; 75   :     {
; 76   :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 77   :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN4@bcc

; 78   :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN4@bcc:

; 79   :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx

; 80   :     }
; 81   :     else

  00067	eb 05		 jmp	 SHORT $LN3@bcc
$LN2@bcc:

; 82   :         uint8 Test =0;

  00069	c6 44 24 21 00	 mov	 BYTE PTR Test$1[rsp], 0
$LN3@bcc:

; 83   :     return(AddCycles);

  0006e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 84   : }

  00073	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00077	c3		 ret	 0
?bcc@@YAEGPEAUcpu@@E@Z ENDP				; bcc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?asl@@YAEGPEAUcpu@@E@Z PROC				; asl

; 44   : {

$LN9:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 45   :     uint8 Value = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR Value$[rsp], 0

; 46   :     if(AddressMode == ACM)

  00018	0f b6 44 24 50	 movzx	 eax, BYTE PTR AddressMode$[rsp]
  0001d	83 f8 01	 cmp	 eax, 1
  00020	75 51		 jne	 SHORT $LN2@asl

; 47   :     {        
; 48   :         if(Cpu->A & (1 << 7))

  00022	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00027	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002a	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0002f	85 c0		 test	 eax, eax
  00031	74 13		 je	 SHORT $LN4@asl

; 49   :             setCarry(&Cpu->Flags);

  00033	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00038	48 83 c0 03	 add	 rax, 3
  0003c	48 8b c8	 mov	 rcx, rax
  0003f	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 50   :         else

  00044	eb 11		 jmp	 SHORT $LN5@asl
$LN4@asl:

; 51   :             clearCarry(&Cpu->Flags);

  00046	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004b	48 83 c0 03	 add	 rax, 3
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN5@asl:

; 52   :         Value = Cpu->A << 1;

  00057	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005f	d1 e0		 shl	 eax, 1
  00061	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 53   :         Cpu->A = Value;

  00065	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0006a	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0006f	88 08		 mov	 BYTE PTR [rax], cl

; 54   :     }
; 55   :     else

  00071	eb 6c		 jmp	 SHORT $LN3@asl
$LN2@asl:

; 56   :     {
; 57   :         Value = readCpu8(Address, Cpu->MemoryBase);

  00073	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00078	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0007c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00081	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00086	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 58   :         if(Value & (1 << 7))

  0008a	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  0008f	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00094	85 c0		 test	 eax, eax
  00096	74 13		 je	 SHORT $LN6@asl

; 59   :             setCarry(&Cpu->Flags);

  00098	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0009d	48 83 c0 03	 add	 rax, 3
  000a1	48 8b c8	 mov	 rcx, rax
  000a4	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 60   :         else

  000a9	eb 11		 jmp	 SHORT $LN7@asl
$LN6@asl:

; 61   :             clearCarry(&Cpu->Flags);

  000ab	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000b0	48 83 c0 03	 add	 rax, 3
  000b4	48 8b c8	 mov	 rcx, rax
  000b7	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN7@asl:

; 62   :         Value = Value << 1;

  000bc	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000c1	d1 e0		 shl	 eax, 1
  000c3	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 63   :         writeCpu8(Value, Address, Cpu->MemoryBase);

  000c7	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000cc	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  000d0	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  000d5	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  000da	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEG_K@Z	; writeCpu8
$LN3@asl:

; 64   :     }
; 65   :     setZero(Value, &Cpu->Flags);

  000df	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000e4	48 83 c0 03	 add	 rax, 3
  000e8	48 8b d0	 mov	 rdx, rax
  000eb	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  000f0	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 66   :     setNegative(Value, &Cpu->Flags);

  000f5	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000fa	48 83 c0 03	 add	 rax, 3
  000fe	48 8b d0	 mov	 rdx, rax
  00101	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00106	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 67   :     return(0);

  0010b	32 c0		 xor	 al, al

; 68   : }

  0010d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00111	c3		 ret	 0
?asl@@YAEGPEAUcpu@@E@Z ENDP				; asl
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?AND@@YAEGPEAUcpu@@E@Z PROC				; AND

; 35   : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 36   :     uint8 Value = readCpu8(Address, Cpu->MemoryBase);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 37   :     Cpu->A = Cpu->A & Value;

  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00032	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00037	23 c1		 and	 eax, ecx
  00039	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0003e	88 01		 mov	 BYTE PTR [rcx], al

; 38   :     setZero(Cpu->A, &Cpu->Flags);

  00040	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00045	48 83 c0 03	 add	 rax, 3
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00054	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 39   :     setNegative(Cpu->A, &Cpu->Flags);

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	48 83 c0 03	 add	 rax, 3
  00062	48 8b d0	 mov	 rdx, rax
  00065	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0006a	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0006d	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 40   :     return(0);

  00072	32 c0		 xor	 al, al

; 41   : }

  00074	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00078	c3		 ret	 0
?AND@@YAEGPEAUcpu@@E@Z ENDP				; AND
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
A$ = 32
B$ = 33
C$ = 34
Sum$ = 36
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?adc@@YAEGPEAUcpu@@E@Z PROC				; adc

; 9    : {

$LN7:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 10   :     uint8 A = Cpu->A;

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001b	88 44 24 20	 mov	 BYTE PTR A$[rsp], al

; 11   :     uint8 B = readCpu8(Address, Cpu->MemoryBase);

  0001f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00024	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00028	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0002d	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00032	88 44 24 21	 mov	 BYTE PTR B$[rsp], al

; 12   :     uint8 C = isBitSet(CARRY_BIT, Cpu->Flags);

  00036	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003b	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  0003f	b1 01		 mov	 cl, 1
  00041	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00046	88 44 24 22	 mov	 BYTE PTR C$[rsp], al

; 13   : 
; 14   :     uint16 Sum = (uint16)A + (uint16)B + (uint16)C;

  0004a	0f b6 44 24 20	 movzx	 eax, BYTE PTR A$[rsp]
  0004f	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR B$[rsp]
  00054	03 c1		 add	 eax, ecx
  00056	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR C$[rsp]
  0005b	03 c1		 add	 eax, ecx
  0005d	66 89 44 24 24	 mov	 WORD PTR Sum$[rsp], ax

; 15   : 
; 16   :     // Overflow check, taken from the web. One day find out how this works
; 17   :     if(((A ^ Sum) & (B ^ Sum) & 0x80) == 0x80)

  00062	0f b6 44 24 20	 movzx	 eax, BYTE PTR A$[rsp]
  00067	0f b7 4c 24 24	 movzx	 ecx, WORD PTR Sum$[rsp]
  0006c	33 c1		 xor	 eax, ecx
  0006e	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR B$[rsp]
  00073	0f b7 54 24 24	 movzx	 edx, WORD PTR Sum$[rsp]
  00078	33 ca		 xor	 ecx, edx
  0007a	23 c1		 and	 eax, ecx
  0007c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00081	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00086	75 13		 jne	 SHORT $LN2@adc

; 18   :         setOverflow(&Cpu->Flags);

  00088	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0008d	48 83 c0 03	 add	 rax, 3
  00091	48 8b c8	 mov	 rcx, rax
  00094	e8 00 00 00 00	 call	 ?setOverflow@@YAXPEAE@Z	; setOverflow

; 19   :     else

  00099	eb 11		 jmp	 SHORT $LN3@adc
$LN2@adc:

; 20   :         clearOverflow(&Cpu->Flags);

  0009b	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000a0	48 83 c0 03	 add	 rax, 3
  000a4	48 8b c8	 mov	 rcx, rax
  000a7	e8 00 00 00 00	 call	 ?clearOverflow@@YAXPEAE@Z ; clearOverflow
$LN3@adc:

; 21   : 
; 22   :     if(Sum & 0x100)

  000ac	0f b7 44 24 24	 movzx	 eax, WORD PTR Sum$[rsp]
  000b1	25 00 01 00 00	 and	 eax, 256		; 00000100H
  000b6	85 c0		 test	 eax, eax
  000b8	74 13		 je	 SHORT $LN4@adc

; 23   :         setCarry(&Cpu->Flags);

  000ba	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000bf	48 83 c0 03	 add	 rax, 3
  000c3	48 8b c8	 mov	 rcx, rax
  000c6	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 24   :     else

  000cb	eb 11		 jmp	 SHORT $LN5@adc
$LN4@adc:

; 25   :         clearCarry(&Cpu->Flags);

  000cd	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000d2	48 83 c0 03	 add	 rax, 3
  000d6	48 8b c8	 mov	 rcx, rax
  000d9	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN5@adc:

; 26   : 
; 27   :     setZero(Sum, &Cpu->Flags);

  000de	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000e3	48 83 c0 03	 add	 rax, 3
  000e7	48 8b d0	 mov	 rdx, rax
  000ea	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Sum$[rsp]
  000ef	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 28   :     setNegative(Sum, &Cpu->Flags);

  000f4	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000f9	48 83 c0 03	 add	 rax, 3
  000fd	48 8b d0	 mov	 rdx, rax
  00100	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Sum$[rsp]
  00105	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 29   : 
; 30   :     Cpu->A = (uint8)Sum;

  0010a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0010f	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Sum$[rsp]
  00114	88 08		 mov	 BYTE PTR [rax], cl

; 31   :     return(0);

  00116	32 c0		 xor	 al, al

; 32   : }

  00118	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0011c	c3		 ret	 0
?adc@@YAEGPEAUcpu@@E@Z ENDP				; adc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?crossedPageCheck@@YAHGG@Z
_TEXT	SEGMENT
tv69 = 0
Before$ = 32
Now$ = 40
?crossedPageCheck@@YAHGG@Z PROC				; crossedPageCheck, COMDAT

; 166  : inline bool32 crossedPageCheck(uint16 Before, uint16 Now) { return((Before & 0xFF00) != (Now & 0xFF00));}

$LN5:
  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 18	 sub	 rsp, 24
  0000e	0f b7 44 24 20	 movzx	 eax, WORD PTR Before$[rsp]
  00013	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00018	0f b7 4c 24 28	 movzx	 ecx, WORD PTR Now$[rsp]
  0001d	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00023	3b c1		 cmp	 eax, ecx
  00025	74 09		 je	 SHORT $LN3@crossedPag
  00027	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv69[rsp], 1
  0002e	eb 07		 jmp	 SHORT $LN4@crossedPag
$LN3@crossedPag:
  00030	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv69[rsp], 0
$LN4@crossedPag:
  00037	8b 04 24	 mov	 eax, DWORD PTR tv69[rsp]
  0003a	48 83 c4 18	 add	 rsp, 24
  0003e	c3		 ret	 0
?crossedPageCheck@@YAHGG@Z ENDP				; crossedPageCheck
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?isBitSet@@YAHEE@Z
_TEXT	SEGMENT
Bit$ = 8
Flags$ = 16
?isBitSet@@YAHEE@Z PROC					; isBitSet, COMDAT

; 165  : inline bool32 isBitSet(uint8 Bit, uint8 Flags) { return(Bit & Flags); }

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00008	0f b6 44 24 08	 movzx	 eax, BYTE PTR Bit$[rsp]
  0000d	0f b6 4c 24 10	 movzx	 ecx, BYTE PTR Flags$[rsp]
  00012	23 c1		 and	 eax, ecx
  00014	c3		 ret	 0
?isBitSet@@YAHEE@Z ENDP					; isBitSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setNegative@@YAXEPEAE@Z
_TEXT	SEGMENT
Value$ = 8
Flags$ = 16
?setNegative@@YAXEPEAE@Z PROC				; setNegative, COMDAT

; 159  : {  

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 160  :     if(Value >= 0x00 && Value <= 0x7F)

  00009	0f b6 44 24 08	 movzx	 eax, BYTE PTR Value$[rsp]
  0000e	85 c0		 test	 eax, eax
  00010	7c 1f		 jl	 SHORT $LN2@setNegativ
  00012	0f b6 44 24 08	 movzx	 eax, BYTE PTR Value$[rsp]
  00017	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  0001a	7f 15		 jg	 SHORT $LN2@setNegativ

; 161  :         *Flags = *Flags & ~NEGATIVE_BIT; // clear negative flag

  0001c	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  00021	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00024	0f ba f0 07	 btr	 eax, 7
  00028	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  0002d	88 01		 mov	 BYTE PTR [rcx], al

; 162  :     else

  0002f	eb 13		 jmp	 SHORT $LN3@setNegativ
$LN2@setNegativ:

; 163  :         *Flags = *Flags | NEGATIVE_BIT; // set negative flag

  00031	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  00036	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00039	0f ba e8 07	 bts	 eax, 7
  0003d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  00042	88 01		 mov	 BYTE PTR [rcx], al
$LN3@setNegativ:

; 164  : }

  00044	c3		 ret	 0
?setNegative@@YAXEPEAE@Z ENDP				; setNegative
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setZero@@YAXEPEAE@Z
_TEXT	SEGMENT
Value$ = 8
Flags$ = 16
?setZero@@YAXEPEAE@Z PROC				; setZero, COMDAT

; 152  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 153  :     if(Value == 0x00)

  00009	0f b6 44 24 08	 movzx	 eax, BYTE PTR Value$[rsp]
  0000e	85 c0		 test	 eax, eax
  00010	75 14		 jne	 SHORT $LN2@setZero

; 154  :         *Flags = *Flags | ZERO_BIT;

  00012	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  00017	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001a	83 c8 02	 or	 eax, 2
  0001d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  00022	88 01		 mov	 BYTE PTR [rcx], al

; 155  :     else

  00024	eb 12		 jmp	 SHORT $LN3@setZero
$LN2@setZero:

; 156  :         *Flags = *Flags & ~ZERO_BIT;

  00026	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  0002b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002e	83 e0 fd	 and	 eax, -3
  00031	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  00036	88 01		 mov	 BYTE PTR [rcx], al
$LN3@setZero:

; 157  : }

  00038	c3		 ret	 0
?setZero@@YAXEPEAE@Z ENDP				; setZero
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearOverflow@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearOverflow@@YAXPEAE@Z PROC				; clearOverflow, COMDAT

; 150  : inline void clearOverflow(uint8 *Flags)  { *Flags = *Flags & ~OVERFLOW_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 bf	 and	 eax, -65		; ffffffffffffffbfH
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?clearOverflow@@YAXPEAE@Z ENDP				; clearOverflow
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setOverflow@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setOverflow@@YAXPEAE@Z PROC				; setOverflow, COMDAT

; 149  : inline void setOverflow(uint8 *Flags)    { *Flags = *Flags | OVERFLOW_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 40	 or	 eax, 64			; 00000040H
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?setOverflow@@YAXPEAE@Z ENDP				; setOverflow
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setBlank@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setBlank@@YAXPEAE@Z PROC				; setBlank, COMDAT

; 147  : inline void setBlank(uint8 *Flags)       { *Flags = *Flags | BLANK_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 20	 or	 eax, 32			; 00000020H
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?setBlank@@YAXPEAE@Z ENDP				; setBlank
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearBreak@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearBreak@@YAXPEAE@Z PROC				; clearBreak, COMDAT

; 146  : inline void clearBreak(uint8 *Flags)     { *Flags = *Flags & ~BREAK_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 ef	 and	 eax, -17
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?clearBreak@@YAXPEAE@Z ENDP				; clearBreak
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setBreak@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setBreak@@YAXPEAE@Z PROC				; setBreak, COMDAT

; 145  : inline void setBreak(uint8 *Flags)       { *Flags = *Flags | BREAK_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 10	 or	 eax, 16
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?setBreak@@YAXPEAE@Z ENDP				; setBreak
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearDecimal@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearDecimal@@YAXPEAE@Z PROC				; clearDecimal, COMDAT

; 144  : inline void clearDecimal(uint8 *Flags)   { *Flags = *Flags & ~DECIMAL_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 f7	 and	 eax, -9
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?clearDecimal@@YAXPEAE@Z ENDP				; clearDecimal
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setDecimal@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setDecimal@@YAXPEAE@Z PROC				; setDecimal, COMDAT

; 143  : inline void setDecimal(uint8 *Flags)     { *Flags = *Flags | DECIMAL_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 08	 or	 eax, 8
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?setDecimal@@YAXPEAE@Z ENDP				; setDecimal
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearInterrupt@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearInterrupt@@YAXPEAE@Z PROC				; clearInterrupt, COMDAT

; 142  : inline void clearInterrupt(uint8 *Flags) { *Flags = *Flags & ~INTERRUPT_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 fb	 and	 eax, -5
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?clearInterrupt@@YAXPEAE@Z ENDP				; clearInterrupt
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setInterrupt@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setInterrupt@@YAXPEAE@Z PROC				; setInterrupt, COMDAT

; 141  : inline void setInterrupt(uint8 *Flags)   { *Flags = *Flags | INTERRUPT_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 04	 or	 eax, 4
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?setInterrupt@@YAXPEAE@Z ENDP				; setInterrupt
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearCarry@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearCarry@@YAXPEAE@Z PROC				; clearCarry, COMDAT

; 140  : inline void clearCarry(uint8 *Flags)     { *Flags = *Flags & ~CARRY_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 fe	 and	 eax, -2
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?clearCarry@@YAXPEAE@Z ENDP				; clearCarry
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setCarry@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setCarry@@YAXPEAE@Z PROC				; setCarry, COMDAT

; 139  : inline void setCarry(uint8 *Flags)       { *Flags = *Flags | CARRY_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 01	 or	 eax, 1
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?setCarry@@YAXPEAE@Z ENDP				; setCarry
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Value$ = 32
Cpu$ = 64
?pop@@YAEPEAUcpu@@@Z PROC				; pop

; 124  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 125  :     ++Cpu->StackPtr;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR Cpu$[rsp]
  0000e	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00012	fe c0		 inc	 al
  00014	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00019	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 126  :     uint8 Value = readCpu8((uint16)Cpu->StackPtr | STACK_ADDRESS, Cpu->MemoryBase);

  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR Cpu$[rsp]
  00021	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00025	0f ba e8 08	 bts	 eax, 8
  00029	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0002e	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00032	0f b7 c8	 movzx	 ecx, ax
  00035	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  0003a	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 127  :     return(Value);

  0003e	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]

; 128  : }

  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	c3		 ret	 0
?pop@@YAEPEAUcpu@@@Z ENDP				; pop
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Byte$ = 48
Cpu$ = 56
?push@@YAXEPEAUcpu@@@Z PROC				; push

; 119  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 120  :     writeCpu8(Byte, (uint16)Cpu->StackPtr | STACK_ADDRESS, Cpu->MemoryBase);

  0000d	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00012	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00016	0f ba e8 08	 bts	 eax, 8
  0001a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0001f	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  00023	0f b7 d0	 movzx	 edx, ax
  00026	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR Byte$[rsp]
  0002b	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEG_K@Z	; writeCpu8

; 121  :     --Cpu->StackPtr;  

  00030	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00035	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00039	fe c8		 dec	 al
  0003b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00040	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 122  : }

  00043	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00047	c3		 ret	 0
?push@@YAXEPEAUcpu@@@Z ENDP				; push
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
Byte2Adrs$ = 36
NewAddress$ = 40
Address$ = 64
MemoryOffset$ = 72
?bugReadCpu16@@YAGG_K@Z PROC				; bugReadCpu16

; 106  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 107  :     // NOTE: This is a bug in the nes 6502 that will wrap the value instead of going to new page.
; 108  :     //       Only happens with indirect addressing.
; 109  :     
; 110  :     uint8 LowByte = readCpu8(Address, MemoryOffset);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00013	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00018	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  0001d	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 111  :     uint16 Byte2Adrs = (Address & 0xFF00) | (uint16)((uint8)(Address + 1));

  00021	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00026	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  0002b	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00030	ff c1		 inc	 ecx
  00032	0f b6 c9	 movzx	 ecx, cl
  00035	0b c1		 or	 eax, ecx
  00037	66 89 44 24 24	 mov	 WORD PTR Byte2Adrs$[rsp], ax

; 112  :     uint8 HighByte = readCpu8(Byte2Adrs, MemoryOffset);

  0003c	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00041	0f b7 4c 24 24	 movzx	 ecx, WORD PTR Byte2Adrs$[rsp]
  00046	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  0004b	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 113  :         
; 114  :     uint16 NewAddress = (HighByte << 8) | LowByte;

  0004f	0f b6 44 24 20	 movzx	 eax, BYTE PTR HighByte$[rsp]
  00054	c1 e0 08	 shl	 eax, 8
  00057	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  0005c	0b c1		 or	 eax, ecx
  0005e	66 89 44 24 28	 mov	 WORD PTR NewAddress$[rsp], ax

; 115  :     return(NewAddress);

  00063	0f b7 44 24 28	 movzx	 eax, WORD PTR NewAddress$[rsp]

; 116  : }

  00068	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006c	c3		 ret	 0
?bugReadCpu16@@YAGG_K@Z ENDP				; bugReadCpu16
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
NewAddress$ = 36
Address$ = 64
MemoryOffset$ = 72
?readCpu16@@YAGG_K@Z PROC				; readCpu16

; 95   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 96   :     // NOTE: Little Endian
; 97   :     uint8 LowByte = readCpu8(Address, MemoryOffset);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00013	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00018	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  0001d	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 98   :     uint8 HighByte = readCpu8(Address+1, MemoryOffset);

  00021	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00026	ff c0		 inc	 eax
  00028	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0002d	0f b7 c8	 movzx	 ecx, ax
  00030	e8 00 00 00 00	 call	 ?readCpu8@@YAEG_K@Z	; readCpu8
  00035	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 99   :         
; 100  :     uint16 NewAddress = (HighByte << 8) | LowByte;

  00039	0f b6 44 24 20	 movzx	 eax, BYTE PTR HighByte$[rsp]
  0003e	c1 e0 08	 shl	 eax, 8
  00041	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  00046	0b c1		 or	 eax, ecx
  00048	66 89 44 24 24	 mov	 WORD PTR NewAddress$[rsp], ax

; 101  :     return(NewAddress);

  0004d	0f b7 44 24 24	 movzx	 eax, WORD PTR NewAddress$[rsp]

; 102  : }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
?readCpu16@@YAGG_K@Z ENDP				; readCpu16
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
OamAddress$1 = 32
index$2 = 36
NewAddress$3 = 40
Byte$ = 64
Address$ = 72
MemoryOffset$ = 80
?writeCpu8@@YAXEG_K@Z PROC				; writeCpu8

; 53   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 54   :     // NOTE: Mirrors the address for the 2kb ram 
; 55   :     if(0x800 <= Address && Address < 0x2000)

  00012	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  00017	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  0001c	7c 26		 jl	 SHORT $LN5@writeCpu8
  0001e	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  00023	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  00028	7d 1a		 jge	 SHORT $LN5@writeCpu8

; 56   :         Address = (Address % 0x800);

  0002a	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  0002f	99		 cdq
  00030	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  00036	03 c2		 add	 eax, edx
  00038	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0003d	2b c2		 sub	 eax, edx
  0003f	66 89 44 24 48	 mov	 WORD PTR Address$[rsp], ax
$LN5@writeCpu8:

; 57   :     // NOTE: Mirror for PPU Registers
; 58   :     if(0x2008 <= Address && Address < 0x4000)

  00044	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  00049	3d 08 20 00 00	 cmp	 eax, 8200		; 00002008H
  0004e	7c 26		 jl	 SHORT $LN6@writeCpu8
  00050	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  00055	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  0005a	7d 1a		 jge	 SHORT $LN6@writeCpu8

; 59   :         Address = (Address % (0x2008 - 0x2000)) + 0x2000;

  0005c	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  00061	99		 cdq
  00062	83 e2 07	 and	 edx, 7
  00065	03 c2		 add	 eax, edx
  00067	83 e0 07	 and	 eax, 7
  0006a	2b c2		 sub	 eax, edx
  0006c	05 00 20 00 00	 add	 eax, 8192		; 00002000H
  00071	66 89 44 24 48	 mov	 WORD PTR Address$[rsp], ax
$LN6@writeCpu8:

; 60   :     if(0x8000 < Address || Address == 0x2002)

  00076	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  0007b	3d 00 80 00 00	 cmp	 eax, 32768		; 00008000H
  00080	7f 0c		 jg	 SHORT $LN8@writeCpu8
  00082	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  00087	3d 02 20 00 00	 cmp	 eax, 8194		; 00002002H
  0008c	75 12		 jne	 SHORT $LN7@writeCpu8
$LN8@writeCpu8:

; 61   :         Assert(0); // TODO: Writing to Program ROM, bank switching?     

  0008e	33 c0		 xor	 eax, eax
  00090	83 f8 01	 cmp	 eax, 1
  00093	74 0b		 je	 SHORT $LN9@writeCpu8
  00095	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN9@writeCpu8:
$LN7@writeCpu8:

; 62   :     
; 63   :     write8(Byte, Address, MemoryOffset);

  000a0	4c 8b 44 24 50	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  000a5	0f b7 54 24 48	 movzx	 edx, WORD PTR Address$[rsp]
  000aa	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR Byte$[rsp]
  000af	e8 00 00 00 00	 call	 ?write8@@YAXEG_K@Z	; write8

; 64   : 
; 65   :     if(Address == 0x2004) // OAM data

  000b4	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  000b9	3d 04 20 00 00	 cmp	 eax, 8196		; 00002004H
  000be	75 0a		 jne	 SHORT $LN10@writeCpu8

; 66   :         OamDataChange = true;

  000c0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?OamDataChange@@3HA, 1 ; OamDataChange
$LN10@writeCpu8:

; 67   :     if(Address == 0x2005) // Scroll address

  000ca	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  000cf	3d 05 20 00 00	 cmp	 eax, 8197		; 00002005H
  000d4	75 0a		 jne	 SHORT $LN11@writeCpu8

; 68   :         ScrollAdrsChange = true;

  000d6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?ScrollAdrsChange@@3HA, 1 ; ScrollAdrsChange
$LN11@writeCpu8:

; 69   :     if(Address == 0x2006) // Writing to ppu io address register

  000e0	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  000e5	3d 06 20 00 00	 cmp	 eax, 8198		; 00002006H
  000ea	75 0a		 jne	 SHORT $LN12@writeCpu8

; 70   :         VRamAdrsChange = true;

  000ec	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?VRamAdrsChange@@3HA, 1 ; VRamAdrsChange
$LN12@writeCpu8:

; 71   :     if(Address == 0x2007) // Write to IO for ppu. Happens after two writes to 0x2006

  000f6	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  000fb	3d 07 20 00 00	 cmp	 eax, 8199		; 00002007H
  00100	75 0a		 jne	 SHORT $LN13@writeCpu8

; 72   :         IOWriteFromCpu = true;

  00102	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?IOWriteFromCpu@@3HA, 1 ; IOWriteFromCpu
$LN13@writeCpu8:

; 73   : 
; 74   : 
; 75   :     // NOTE: OAM DMA Write
; 76   :     if(Address == 0x4014)

  0010c	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  00111	3d 14 40 00 00	 cmp	 eax, 16404		; 00004014H
  00116	0f 85 87 00 00
	00		 jne	 $LN14@writeCpu8

; 77   :     {
; 78   :         uint8 OamAddress = read8(0x2003, MemoryOffset);

  0011c	48 8b 54 24 50	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00121	66 b9 03 20	 mov	 cx, 8195		; 00002003H
  00125	e8 00 00 00 00	 call	 ?read8@@YAEG_K@Z	; read8
  0012a	88 44 24 20	 mov	 BYTE PTR OamAddress$1[rsp], al

; 79   : 
; 80   :         if(OamData == 0)

  0012e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?OamData@@3PEAEEA, 0
  00136	75 12		 jne	 SHORT $LN15@writeCpu8

; 81   :         {
; 82   :             Assert(0);

  00138	33 c0		 xor	 eax, eax
  0013a	83 f8 01	 cmp	 eax, 1
  0013d	74 0b		 je	 SHORT $LN16@writeCpu8
  0013f	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN16@writeCpu8:
$LN15@writeCpu8:

; 83   :         }
; 84   :         
; 85   :         for(uint16 index = OamAddress; index < OAM_SIZE; ++index)

  0014a	0f b6 44 24 20	 movzx	 eax, BYTE PTR OamAddress$1[rsp]
  0014f	66 89 44 24 24	 mov	 WORD PTR index$2[rsp], ax
  00154	eb 0d		 jmp	 SHORT $LN4@writeCpu8
$LN2@writeCpu8:
  00156	0f b7 44 24 24	 movzx	 eax, WORD PTR index$2[rsp]
  0015b	66 ff c0	 inc	 ax
  0015e	66 89 44 24 24	 mov	 WORD PTR index$2[rsp], ax
$LN4@writeCpu8:
  00163	0f b7 44 24 24	 movzx	 eax, WORD PTR index$2[rsp]
  00168	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0016d	7d 34		 jge	 SHORT $LN3@writeCpu8

; 86   :         {
; 87   :             uint16 NewAddress = (Byte << 8) | index; 

  0016f	0f b6 44 24 40	 movzx	 eax, BYTE PTR Byte$[rsp]
  00174	c1 e0 08	 shl	 eax, 8
  00177	0f b7 4c 24 24	 movzx	 ecx, WORD PTR index$2[rsp]
  0017c	0b c1		 or	 eax, ecx
  0017e	66 89 44 24 28	 mov	 WORD PTR NewAddress$3[rsp], ax

; 88   :             OamData[index] = read8(NewAddress, MemoryOffset);

  00183	48 8b 54 24 50	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  00188	0f b7 4c 24 28	 movzx	 ecx, WORD PTR NewAddress$3[rsp]
  0018d	e8 00 00 00 00	 call	 ?read8@@YAEG_K@Z	; read8
  00192	0f b7 4c 24 24	 movzx	 ecx, WORD PTR index$2[rsp]
  00197	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?OamData@@3PEAEEA
  0019e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 89   :         }

  001a1	eb b3		 jmp	 SHORT $LN2@writeCpu8
$LN3@writeCpu8:
$LN14@writeCpu8:

; 90   :         
; 91   :     }
; 92   : }

  001a3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001a7	c3		 ret	 0
?writeCpu8@@YAXEG_K@Z ENDP				; writeCpu8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Value$ = 32
ResetValue$1 = 33
Address$ = 64
MemoryOffset$ = 72
?readCpu8@@YAEG_K@Z PROC				; readCpu8

; 26   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 27   :     // NOTE: Mirrors the address for the 2kb ram 
; 28   :     if(0x800 <= Address && Address < 0x2000)

  0000e	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00013	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  00018	7c 26		 jl	 SHORT $LN2@readCpu8
  0001a	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0001f	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  00024	7d 1a		 jge	 SHORT $LN2@readCpu8

; 29   :         Address = (Address % 0x800);

  00026	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0002b	99		 cdq
  0002c	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  00032	03 c2		 add	 eax, edx
  00034	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00039	2b c2		 sub	 eax, edx
  0003b	66 89 44 24 40	 mov	 WORD PTR Address$[rsp], ax
$LN2@readCpu8:

; 30   :     // NOTE: Mirror for PPU Registers
; 31   :     if(0x2008 <= Address && Address < 0x4000)

  00040	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00045	3d 08 20 00 00	 cmp	 eax, 8200		; 00002008H
  0004a	7c 26		 jl	 SHORT $LN3@readCpu8
  0004c	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00051	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  00056	7d 1a		 jge	 SHORT $LN3@readCpu8

; 32   :         Address = (Address % (0x2008 - 0x2000)) + 0x2000;

  00058	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0005d	99		 cdq
  0005e	83 e2 07	 and	 edx, 7
  00061	03 c2		 add	 eax, edx
  00063	83 e0 07	 and	 eax, 7
  00066	2b c2		 sub	 eax, edx
  00068	05 00 20 00 00	 add	 eax, 8192		; 00002000H
  0006d	66 89 44 24 40	 mov	 WORD PTR Address$[rsp], ax
$LN3@readCpu8:

; 33   :     
; 34   :     if(Address == 0x2007) // Reading from the IO of ppu. First read is junk, unless its the colour palette

  00072	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00077	3d 07 20 00 00	 cmp	 eax, 8199		; 00002007H
  0007c	75 0a		 jne	 SHORT $LN4@readCpu8

; 35   :         IOReadFromCpu = true;

  0007e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?IOReadFromCpu@@3HA, 1 ; IOReadFromCpu
$LN4@readCpu8:

; 36   :         
; 37   :     uint8 Value = read8(Address, MemoryOffset);

  00088	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0008d	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00092	e8 00 00 00 00	 call	 ?read8@@YAEG_K@Z	; read8
  00097	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 38   :             
; 39   :     if(Address == 0x2002)

  0009b	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  000a0	3d 02 20 00 00	 cmp	 eax, 8194		; 00002002H
  000a5	75 35		 jne	 SHORT $LN5@readCpu8

; 40   :     {
; 41   :         // NOTE: Will reset 2005 and 2006 registers, and turn off bit 7 of 0x2002
; 42   :         ResetScrollIOAdrs = true;

  000a7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?ResetScrollIOAdrs@@3HA, 1 ; ResetScrollIOAdrs

; 43   :         ResetVRamIOAdrs = true;

  000b1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?ResetVRamIOAdrs@@3HA, 1 ; ResetVRamIOAdrs

; 44   :         
; 45   :         uint8 ResetValue = Value & ~(1 << 7);

  000bb	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000c0	0f ba f0 07	 btr	 eax, 7
  000c4	88 44 24 21	 mov	 BYTE PTR ResetValue$1[rsp], al

; 46   :         write8(ResetValue, Address, MemoryOffset);

  000c8	4c 8b 44 24 48	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  000cd	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  000d2	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ResetValue$1[rsp]
  000d7	e8 00 00 00 00	 call	 ?write8@@YAXEG_K@Z	; write8
$LN5@readCpu8:

; 47   :     }
; 48   :     
; 49   :     return(Value);

  000dc	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]

; 50   : }

  000e1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e5	c3		 ret	 0
?readCpu8@@YAEG_K@Z ENDP				; readCpu8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
BytesRead$1 = 64
FileData$ = 72
FileHandle$ = 80
Filesize$2 = 88
Filename$ = 112
Size$ = 120
?LoadFile@@YAPEAXPEADPEAI@Z PROC			; LoadFile

; 285  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 286  :     void *FileData = 0;

  0000e	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR FileData$[rsp], 0

; 287  :     
; 288  :     HANDLE FileHandle = CreateFileA(Filename, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);

  00017	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00020	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00028	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  00030	45 33 c9	 xor	 r9d, r9d
  00033	41 b8 01 00 00
	00		 mov	 r8d, 1
  00039	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  0003e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Filename$[rsp]
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileA
  00049	48 89 44 24 50	 mov	 QWORD PTR FileHandle$[rsp], rax

; 289  :     if(FileHandle != INVALID_HANDLE_VALUE)

  0004e	48 83 7c 24 50
	ff		 cmp	 QWORD PTR FileHandle$[rsp], -1
  00054	0f 84 8d 00 00
	00		 je	 $LN2@LoadFile

; 290  :     {
; 291  :         LARGE_INTEGER Filesize;
; 292  :         if(GetFileSizeEx(FileHandle, &Filesize))

  0005a	48 8d 54 24 58	 lea	 rdx, QWORD PTR Filesize$2[rsp]
  0005f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR FileHandle$[rsp]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileSizeEx
  0006a	85 c0		 test	 eax, eax
  0006c	74 77		 je	 SHORT $LN4@LoadFile

; 293  :         {
; 294  :             FileData = VirtualAlloc(0, Filesize.LowPart, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);

  0006e	8b 44 24 58	 mov	 eax, DWORD PTR Filesize$2[rsp]
  00072	41 b9 04 00 00
	00		 mov	 r9d, 4
  00078	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  0007e	8b d0		 mov	 edx, eax
  00080	33 c9		 xor	 ecx, ecx
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  00088	48 89 44 24 48	 mov	 QWORD PTR FileData$[rsp], rax

; 295  :             if(FileData)

  0008d	48 83 7c 24 48
	00		 cmp	 QWORD PTR FileData$[rsp], 0
  00093	74 50		 je	 SHORT $LN6@LoadFile

; 296  :             {
; 297  :                 DWORD BytesRead;
; 298  :                 if(ReadFile(FileHandle, FileData, Filesize.LowPart, &BytesRead, 0) &&

  00095	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0009e	4c 8d 4c 24 40	 lea	 r9, QWORD PTR BytesRead$1[rsp]
  000a3	44 8b 44 24 58	 mov	 r8d, DWORD PTR Filesize$2[rsp]
  000a8	48 8b 54 24 48	 mov	 rdx, QWORD PTR FileData$[rsp]
  000ad	48 8b 4c 24 50	 mov	 rcx, QWORD PTR FileHandle$[rsp]
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReadFile
  000b8	85 c0		 test	 eax, eax
  000ba	74 17		 je	 SHORT $LN8@LoadFile
  000bc	8b 44 24 40	 mov	 eax, DWORD PTR BytesRead$1[rsp]
  000c0	39 44 24 58	 cmp	 DWORD PTR Filesize$2[rsp], eax
  000c4	75 0d		 jne	 SHORT $LN8@LoadFile

; 299  :                    (Filesize.LowPart == BytesRead))
; 300  :                 {
; 301  :                     *Size = (uint32)BytesRead;

  000c6	48 8b 44 24 78	 mov	 rax, QWORD PTR Size$[rsp]
  000cb	8b 4c 24 40	 mov	 ecx, DWORD PTR BytesRead$1[rsp]
  000cf	89 08		 mov	 DWORD PTR [rax], ecx

; 302  :                     // It worked!
; 303  :                 }
; 304  :                 else

  000d1	eb 12		 jmp	 SHORT $LN9@LoadFile
$LN8@LoadFile:

; 305  :                 {
; 306  :                     Assert(0);

  000d3	33 c0		 xor	 eax, eax
  000d5	83 f8 01	 cmp	 eax, 1
  000d8	74 0b		 je	 SHORT $LN10@LoadFile
  000da	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN10@LoadFile:
$LN9@LoadFile:
$LN6@LoadFile:
$LN4@LoadFile:

; 307  :                 }
; 308  :             }
; 309  :             else
; 310  :             {
; 311  :             }   
; 312  :         }
; 313  :         else
; 314  :         {
; 315  :         }
; 316  :     }
; 317  :     else

  000e5	eb 12		 jmp	 SHORT $LN3@LoadFile
$LN2@LoadFile:

; 318  :     {
; 319  :         Assert(0);

  000e7	33 c0		 xor	 eax, eax
  000e9	83 f8 01	 cmp	 eax, 1
  000ec	74 0b		 je	 SHORT $LN11@LoadFile
  000ee	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN11@LoadFile:
$LN3@LoadFile:

; 320  :     }
; 321  :     return(FileData);

  000f9	48 8b 44 24 48	 mov	 rax, QWORD PTR FileData$[rsp]

; 322  : }

  000fe	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00102	c3		 ret	 0
?LoadFile@@YAPEAXPEADPEAI@Z ENDP			; LoadFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
tv64 = 32
NameSize$1 = 36
tv162 = 40
tv67 = 44
tv70 = 48
tv73 = 52
tv81 = 56
tv87 = 60
tv93 = 64
tv131 = 68
tv137 = 72
tv143 = 76
tv149 = 80
tv155 = 84
tv75 = 88
WasDown$2 = 96
IsDown$3 = 100
AltPressed$4 = 104
FileOpened$5 = 108
Result$ = 112
newRom$6 = 128
tempFileName$7 = 288
__$ArrayPad$ = 544
WindowHandle$ = 576
Message$ = 584
wParam$ = 592
lParam$ = 600
?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z PROC		; WinInputCallback

; 116  : {

$LN60:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec 30 02
	00 00		 sub	 rsp, 560		; 00000230H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 117  :     LRESULT Result = 0;

  0002d	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR Result$[rsp], 0

; 118  :     
; 119  :     switch(Message) 

  00036	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR Message$[rsp]
  0003d	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  00041	83 7c 24 20 10	 cmp	 DWORD PTR tv64[rsp], 16
  00046	77 21		 ja	 SHORT $LN57@WinInputCa
  00048	83 7c 24 20 10	 cmp	 DWORD PTR tv64[rsp], 16
  0004d	74 67		 je	 SHORT $LN10@WinInputCa
  0004f	83 7c 24 20 01	 cmp	 DWORD PTR tv64[rsp], 1
  00054	74 56		 je	 SHORT $LN8@WinInputCa
  00056	83 7c 24 20 02	 cmp	 DWORD PTR tv64[rsp], 2
  0005b	74 68		 je	 SHORT $LN11@WinInputCa
  0005d	83 7c 24 20 05	 cmp	 DWORD PTR tv64[rsp], 5
  00062	74 4d		 je	 SHORT $LN9@WinInputCa
  00064	e9 0a 05 00 00	 jmp	 $LN33@WinInputCa
$LN57@WinInputCa:
  00069	81 7c 24 20 00
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 256 ; 00000100H
  00071	0f 82 fc 04 00
	00		 jb	 $LN33@WinInputCa
  00077	81 7c 24 20 01
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 257 ; 00000101H
  0007f	76 49		 jbe	 SHORT $LN12@WinInputCa
  00081	81 7c 24 20 03
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 259 ; 00000103H
  00089	0f 86 e4 04 00
	00		 jbe	 $LN33@WinInputCa
  0008f	81 7c 24 20 05
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 261 ; 00000105H
  00097	76 31		 jbe	 SHORT $LN12@WinInputCa
  00099	81 7c 24 20 11
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 273 ; 00000111H
  000a1	0f 84 3d 03 00
	00		 je	 $LN26@WinInputCa
  000a7	e9 c7 04 00 00	 jmp	 $LN33@WinInputCa
$LN8@WinInputCa:

; 120  :     { 
; 121  :         case WM_CREATE:
; 122  :         {
; 123  :             // Initialize the window. 
; 124  :             break; 

  000ac	e9 ec 04 00 00	 jmp	 $LN2@WinInputCa
$LN9@WinInputCa:

; 125  :         }
; 126  :         
; 127  :         case WM_SIZE:
; 128  :         {
; 129  :             // Set the size and position of the window. 
; 130  :             break;

  000b1	e9 e7 04 00 00	 jmp	 $LN2@WinInputCa
$LN10@WinInputCa:

; 131  :         }
; 132  :         case WM_CLOSE:
; 133  :         {
; 134  :             GlobalRunning = false;

  000b6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0

; 135  :             break;

  000c0	e9 d8 04 00 00	 jmp	 $LN2@WinInputCa
$LN11@WinInputCa:

; 136  :         }
; 137  :         case WM_DESTROY:
; 138  :         {
; 139  :             break;

  000c5	e9 d3 04 00 00	 jmp	 $LN2@WinInputCa
$LN12@WinInputCa:

; 140  :         }
; 141  :         case WM_SYSKEYDOWN:
; 142  :         case WM_SYSKEYUP:
; 143  :         case WM_KEYDOWN:
; 144  :         case WM_KEYUP:
; 145  :         {
; 146  :             bool32 IsDown = ((lParam & (1<<31)) == 0);

  000ca	48 8b 84 24 58
	02 00 00	 mov	 rax, QWORD PTR lParam$[rsp]
  000d2	48 25 00 00 00
	80		 and	 rax, -2147483648	; ffffffff80000000H
  000d8	48 85 c0	 test	 rax, rax
  000db	75 0a		 jne	 SHORT $LN35@WinInputCa
  000dd	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  000e5	eb 08		 jmp	 SHORT $LN36@WinInputCa
$LN35@WinInputCa:
  000e7	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN36@WinInputCa:
  000ef	8b 44 24 2c	 mov	 eax, DWORD PTR tv67[rsp]
  000f3	89 44 24 64	 mov	 DWORD PTR IsDown$3[rsp], eax

; 147  :             bool32 WasDown = ((lParam & (1<<30)) != 0);

  000f7	48 8b 84 24 58
	02 00 00	 mov	 rax, QWORD PTR lParam$[rsp]
  000ff	48 25 00 00 00
	40		 and	 rax, 1073741824		; 40000000H
  00105	48 85 c0	 test	 rax, rax
  00108	74 0a		 je	 SHORT $LN37@WinInputCa
  0010a	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00112	eb 08		 jmp	 SHORT $LN38@WinInputCa
$LN37@WinInputCa:
  00114	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN38@WinInputCa:
  0011c	8b 44 24 30	 mov	 eax, DWORD PTR tv70[rsp]
  00120	89 44 24 60	 mov	 DWORD PTR WasDown$2[rsp], eax

; 148  : 
; 149  :             // NOTE: Alt only on SYSDOWN messages
; 150  :             bool32 AltPressed = ((lParam & (1<<29)) != 0);

  00124	48 8b 84 24 58
	02 00 00	 mov	 rax, QWORD PTR lParam$[rsp]
  0012c	48 25 00 00 00
	20		 and	 rax, 536870912		; 20000000H
  00132	48 85 c0	 test	 rax, rax
  00135	74 0a		 je	 SHORT $LN39@WinInputCa
  00137	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  0013f	eb 08		 jmp	 SHORT $LN40@WinInputCa
$LN39@WinInputCa:
  00141	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN40@WinInputCa:
  00149	8b 44 24 34	 mov	 eax, DWORD PTR tv73[rsp]
  0014d	89 44 24 68	 mov	 DWORD PTR AltPressed$4[rsp], eax

; 151  :               
; 152  :             if(IsDown != WasDown)

  00151	8b 44 24 60	 mov	 eax, DWORD PTR WasDown$2[rsp]
  00155	39 44 24 64	 cmp	 DWORD PTR IsDown$3[rsp], eax
  00159	0f 84 80 02 00
	00		 je	 $LN13@WinInputCa

; 153  :             {               
; 154  :                 switch(wParam)

  0015f	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR wParam$[rsp]
  00167	48 89 44 24 58	 mov	 QWORD PTR tv75[rsp], rax
  0016c	48 8b 44 24 58	 mov	 rax, QWORD PTR tv75[rsp]
  00171	48 83 e8 0d	 sub	 rax, 13
  00175	48 89 44 24 58	 mov	 QWORD PTR tv75[rsp], rax
  0017a	48 83 7c 24 58
	66		 cmp	 QWORD PTR tv75[rsp], 102 ; 00000066H
  00180	0f 87 59 02 00
	00		 ja	 $LN4@WinInputCa
  00186	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:__ImageBase
  0018d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv75[rsp]
  00192	0f b6 8c 08 00
	00 00 00	 movzx	 ecx, BYTE PTR $LN58@WinInputCa[rax+rcx]
  0019a	8b 8c 88 00 00
	00 00		 mov	 ecx, DWORD PTR $LN59@WinInputCa[rax+rcx*4]
  001a1	48 03 c8	 add	 rcx, rax
  001a4	ff e1		 jmp	 rcx
$LN14@WinInputCa:

; 155  :                 {
; 156  :                     // NOTE: Up and down changes the octave the keys are in
; 157  :                     case VK_UP:
; 158  :                     {
; 159  :                         WinInput.buttons[input::B_UP] = !WinInput.buttons[input::B_UP];

  001a6	b8 04 00 00 00	 mov	 eax, 4
  001ab	48 6b c0 04	 imul	 rax, rax, 4
  001af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  001b6	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  001ba	75 0a		 jne	 SHORT $LN41@WinInputCa
  001bc	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  001c4	eb 08		 jmp	 SHORT $LN42@WinInputCa
$LN41@WinInputCa:
  001c6	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN42@WinInputCa:
  001ce	b8 04 00 00 00	 mov	 eax, 4
  001d3	48 6b c0 04	 imul	 rax, rax, 4
  001d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  001de	8b 54 24 38	 mov	 edx, DWORD PTR tv81[rsp]
  001e2	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 160  :                         break;

  001e5	e9 f5 01 00 00	 jmp	 $LN4@WinInputCa
$LN15@WinInputCa:

; 161  :                     }
; 162  :                     case VK_DOWN:
; 163  :                     {
; 164  :                         WinInput.buttons[input::B_DOWN] = !WinInput.buttons[input::B_DOWN];

  001ea	b8 04 00 00 00	 mov	 eax, 4
  001ef	48 6b c0 05	 imul	 rax, rax, 5
  001f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  001fa	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  001fe	75 0a		 jne	 SHORT $LN43@WinInputCa
  00200	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv87[rsp], 1
  00208	eb 08		 jmp	 SHORT $LN44@WinInputCa
$LN43@WinInputCa:
  0020a	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
$LN44@WinInputCa:
  00212	b8 04 00 00 00	 mov	 eax, 4
  00217	48 6b c0 05	 imul	 rax, rax, 5
  0021b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00222	8b 54 24 3c	 mov	 edx, DWORD PTR tv87[rsp]
  00226	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 165  :                         break;

  00229	e9 b1 01 00 00	 jmp	 $LN4@WinInputCa
$LN16@WinInputCa:

; 166  :                     }
; 167  :                     case VK_LEFT:
; 168  :                     {
; 169  :                         WinInput.buttons[input::B_LEFT] = !WinInput.buttons[input::B_LEFT];

  0022e	b8 04 00 00 00	 mov	 eax, 4
  00233	48 6b c0 06	 imul	 rax, rax, 6
  00237	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0023e	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  00242	75 0a		 jne	 SHORT $LN45@WinInputCa
  00244	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  0024c	eb 08		 jmp	 SHORT $LN46@WinInputCa
$LN45@WinInputCa:
  0024e	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN46@WinInputCa:
  00256	b8 04 00 00 00	 mov	 eax, 4
  0025b	48 6b c0 06	 imul	 rax, rax, 6
  0025f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00266	8b 54 24 40	 mov	 edx, DWORD PTR tv93[rsp]
  0026a	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 170  :                         break;

  0026d	e9 6d 01 00 00	 jmp	 $LN4@WinInputCa
$LN17@WinInputCa:

; 171  :                     }
; 172  :                     case VK_RIGHT:
; 173  :                     {
; 174  :                         WinInput.buttons[input::B_RIGHT] = !WinInput.buttons[input::B_RIGHT];

  00272	b8 04 00 00 00	 mov	 eax, 4
  00277	48 6b c0 07	 imul	 rax, rax, 7
  0027b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00282	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  00286	75 0a		 jne	 SHORT $LN47@WinInputCa
  00288	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  00290	eb 08		 jmp	 SHORT $LN48@WinInputCa
$LN47@WinInputCa:
  00292	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN48@WinInputCa:
  0029a	b8 04 00 00 00	 mov	 eax, 4
  0029f	48 6b c0 07	 imul	 rax, rax, 7
  002a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  002aa	8b 54 24 44	 mov	 edx, DWORD PTR tv131[rsp]
  002ae	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 175  :                         break;

  002b1	e9 29 01 00 00	 jmp	 $LN4@WinInputCa
$LN18@WinInputCa:

; 176  :                     }
; 177  :                     case 'Z':
; 178  :                     {
; 179  :                         WinInput.buttons[input::B_A] = !WinInput.buttons[input::B_A];

  002b6	b8 04 00 00 00	 mov	 eax, 4
  002bb	48 6b c0 00	 imul	 rax, rax, 0
  002bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  002c6	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  002ca	75 0a		 jne	 SHORT $LN49@WinInputCa
  002cc	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv137[rsp], 1
  002d4	eb 08		 jmp	 SHORT $LN50@WinInputCa
$LN49@WinInputCa:
  002d6	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN50@WinInputCa:
  002de	b8 04 00 00 00	 mov	 eax, 4
  002e3	48 6b c0 00	 imul	 rax, rax, 0
  002e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  002ee	8b 54 24 48	 mov	 edx, DWORD PTR tv137[rsp]
  002f2	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 180  :                         break;

  002f5	e9 e5 00 00 00	 jmp	 $LN4@WinInputCa
$LN19@WinInputCa:

; 181  :                     }
; 182  :                     case 'X':
; 183  :                     {
; 184  :                         WinInput.buttons[input::B_B] = !WinInput.buttons[input::B_B];

  002fa	b8 04 00 00 00	 mov	 eax, 4
  002ff	48 6b c0 01	 imul	 rax, rax, 1
  00303	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0030a	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  0030e	75 0a		 jne	 SHORT $LN51@WinInputCa
  00310	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv143[rsp], 1
  00318	eb 08		 jmp	 SHORT $LN52@WinInputCa
$LN51@WinInputCa:
  0031a	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv143[rsp], 0
$LN52@WinInputCa:
  00322	b8 04 00 00 00	 mov	 eax, 4
  00327	48 6b c0 01	 imul	 rax, rax, 1
  0032b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00332	8b 54 24 4c	 mov	 edx, DWORD PTR tv143[rsp]
  00336	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 185  :                         break;

  00339	e9 a1 00 00 00	 jmp	 $LN4@WinInputCa
$LN20@WinInputCa:

; 186  :                     }
; 187  :                     case VK_RETURN:
; 188  :                     {
; 189  :                         WinInput.buttons[input::B_START] = !WinInput.buttons[input::B_START];

  0033e	b8 04 00 00 00	 mov	 eax, 4
  00343	48 6b c0 03	 imul	 rax, rax, 3
  00347	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0034e	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  00352	75 0a		 jne	 SHORT $LN53@WinInputCa
  00354	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv149[rsp], 1
  0035c	eb 08		 jmp	 SHORT $LN54@WinInputCa
$LN53@WinInputCa:
  0035e	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
$LN54@WinInputCa:
  00366	b8 04 00 00 00	 mov	 eax, 4
  0036b	48 6b c0 03	 imul	 rax, rax, 3
  0036f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00376	8b 54 24 50	 mov	 edx, DWORD PTR tv149[rsp]
  0037a	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 190  :                         break;

  0037d	eb 60		 jmp	 SHORT $LN4@WinInputCa
$LN21@WinInputCa:

; 191  :                     }
; 192  :                     case VK_SHIFT:
; 193  :                     {
; 194  :                         WinInput.buttons[input::B_SELECT] = !WinInput.buttons[input::B_SELECT];

  0037f	b8 04 00 00 00	 mov	 eax, 4
  00384	48 6b c0 02	 imul	 rax, rax, 2
  00388	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0038f	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  00393	75 0a		 jne	 SHORT $LN55@WinInputCa
  00395	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv155[rsp], 1
  0039d	eb 08		 jmp	 SHORT $LN56@WinInputCa
$LN55@WinInputCa:
  0039f	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv155[rsp], 0
$LN56@WinInputCa:
  003a7	b8 04 00 00 00	 mov	 eax, 4
  003ac	48 6b c0 02	 imul	 rax, rax, 2
  003b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  003b7	8b 54 24 54	 mov	 edx, DWORD PTR tv155[rsp]
  003bb	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 195  :                         break;

  003be	eb 1f		 jmp	 SHORT $LN4@WinInputCa

; 196  :                     }
; 197  :                     case VK_SPACE:
; 198  :                     {                        
; 199  :                         break;

  003c0	eb 1d		 jmp	 SHORT $LN4@WinInputCa
$LN23@WinInputCa:

; 200  :                     }
; 201  :                     case VK_ESCAPE:
; 202  :                     {
; 203  :                         GlobalRunning = false;

  003c2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0

; 204  :                         break;

  003cc	eb 11		 jmp	 SHORT $LN4@WinInputCa
$LN24@WinInputCa:

; 205  :                     }
; 206  :                     case VK_F4:
; 207  :                     {
; 208  :                         if(AltPressed)

  003ce	83 7c 24 68 00	 cmp	 DWORD PTR AltPressed$4[rsp], 0
  003d3	74 0a		 je	 SHORT $LN25@WinInputCa

; 209  :                         {
; 210  :                             GlobalRunning = false;

  003d5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0
$LN25@WinInputCa:
$LN4@WinInputCa:
$LN13@WinInputCa:

; 211  :                         }
; 212  :                         break;
; 213  :                     }
; 214  :                 }
; 215  :             }
; 216  :             break;

  003df	e9 b9 01 00 00	 jmp	 $LN2@WinInputCa
$LN26@WinInputCa:

; 217  :         }
; 218  :         
; 219  :         case WM_COMMAND:
; 220  :         {
; 221  :             switch(LOWORD(wParam))

  003e4	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR wParam$[rsp]
  003ec	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  003f2	0f b7 c0	 movzx	 eax, ax
  003f5	89 44 24 28	 mov	 DWORD PTR tv162[rsp], eax
  003f9	81 7c 24 28 e9
	03 00 00	 cmp	 DWORD PTR tv162[rsp], 1001 ; 000003e9H
  00401	74 21		 je	 SHORT $LN27@WinInputCa
  00403	81 7c 24 28 ea
	03 00 00	 cmp	 DWORD PTR tv162[rsp], 1002 ; 000003eaH
  0040b	0f 84 36 01 00
	00		 je	 $LN31@WinInputCa
  00411	81 7c 24 28 eb
	03 00 00	 cmp	 DWORD PTR tv162[rsp], 1003 ; 000003ebH
  00419	0f 84 48 01 00
	00		 je	 $LN32@WinInputCa
  0041f	e9 4d 01 00 00	 jmp	 $LN6@WinInputCa
$LN27@WinInputCa:

; 222  :             {
; 223  :                 case ID_OPEN_ROM_ITEM:
; 224  :                 {
; 225  :                     char tempFileName[256];
; 226  :                     
; 227  :                     OPENFILENAMEA newRom = {};

  00424	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR newRom$6[rsp]
  0042c	48 8b f8	 mov	 rdi, rax
  0042f	33 c0		 xor	 eax, eax
  00431	b9 98 00 00 00	 mov	 ecx, 152		; 00000098H
  00436	f3 aa		 rep stosb

; 228  :                     newRom.lStructSize = sizeof(OPENFILENAME);

  00438	c7 84 24 80 00
	00 00 98 00 00
	00		 mov	 DWORD PTR newRom$6[rsp], 152 ; 00000098H

; 229  :                     newRom.hwndOwner = WindowHandle;

  00443	48 8b 84 24 40
	02 00 00	 mov	 rax, QWORD PTR WindowHandle$[rsp]
  0044b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR newRom$6[rsp+8], rax

; 230  :                     newRom.lpstrFile = tempFileName;

  00453	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR tempFileName$7[rsp]
  0045b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR newRom$6[rsp+48], rax

; 231  :                     newRom.lpstrFile[0] = '\0';

  00463	b8 01 00 00 00	 mov	 eax, 1
  00468	48 6b c0 00	 imul	 rax, rax, 0
  0046c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR newRom$6[rsp+48]
  00474	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 232  :                     newRom.nMaxFile = sizeof(tempFileName);

  00478	c7 84 24 b8 00
	00 00 00 01 00
	00		 mov	 DWORD PTR newRom$6[rsp+56], 256 ; 00000100H

; 233  :                     newRom.lpstrFilter = ".nes\0*.nes\0";

  00483	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG87667
  0048a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR newRom$6[rsp+24], rax

; 234  :                     newRom.nFilterIndex =1;

  00492	c7 84 24 ac 00
	00 00 01 00 00
	00		 mov	 DWORD PTR newRom$6[rsp+44], 1

; 235  :                     newRom.lpstrFileTitle = NULL ;

  0049d	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR newRom$6[rsp+64], 0

; 236  :                     newRom.nMaxFileTitle = 0 ;

  004a9	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR newRom$6[rsp+72], 0

; 237  :                     newRom.lpstrInitialDir=NULL ;

  004b4	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR newRom$6[rsp+80], 0

; 238  :                     newRom.Flags = OFN_PATHMUSTEXIST|OFN_FILEMUSTEXIST ;

  004c0	c7 84 24 e0 00
	00 00 00 18 00
	00		 mov	 DWORD PTR newRom$6[rsp+96], 6144 ; 00001800H

; 239  : 
; 240  :                     bool32 FileOpened = GetOpenFileName(&newRom); 

  004cb	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR newRom$6[rsp]
  004d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetOpenFileNameA
  004d9	89 44 24 6c	 mov	 DWORD PTR FileOpened$5[rsp], eax

; 241  :                     
; 242  :                     if(FileOpened) // If exists then restart emulator with new file 

  004dd	83 7c 24 6c 00	 cmp	 DWORD PTR FileOpened$5[rsp], 0
  004e2	74 61		 je	 SHORT $LN28@WinInputCa

; 243  :                     {
; 244  :                         ZeroMemory(&RomFileName, sizeof(RomFileName));

  004e4	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  004ea	33 d2		 xor	 edx, edx
  004ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?RomFileName@@3PADA
  004f3	e8 00 00 00 00	 call	 memset

; 245  :                         uint8 NameSize = strlen(tempFileName);

  004f8	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR tempFileName$7[rsp]
  00500	e8 00 00 00 00	 call	 strlen
  00505	88 44 24 24	 mov	 BYTE PTR NameSize$1[rsp], al

; 246  :                         cpyMemory((uint8 *)RomFileName, (uint8 *)tempFileName, NameSize);

  00509	0f b6 44 24 24	 movzx	 eax, BYTE PTR NameSize$1[rsp]
  0050e	44 0f b7 c0	 movzx	 r8d, ax
  00512	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR tempFileName$7[rsp]
  0051a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?RomFileName@@3PADA
  00521	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 247  :                         
; 248  :                         if(PowerOn)

  00526	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PowerOn@@3HA, 0
  0052d	74 0c		 je	 SHORT $LN29@WinInputCa

; 249  :                         {
; 250  :                             ResetHit = true;

  0052f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?ResetHit@@3HA, 1

; 251  :                         }
; 252  :                         else

  00539	eb 0a		 jmp	 SHORT $LN30@WinInputCa
$LN29@WinInputCa:

; 253  :                         {
; 254  :                             PowerHit = true;

  0053b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?PowerHit@@3HA, 1
$LN30@WinInputCa:
$LN28@WinInputCa:

; 255  :                         }
; 256  :                     }
; 257  :                     
; 258  :                     break;

  00545	eb 2a		 jmp	 SHORT $LN6@WinInputCa
$LN31@WinInputCa:

; 259  :                 }
; 260  :                 case ID_CLOSE_ROM_ITEM:
; 261  :                 {
; 262  :                     ZeroMemory(&RomFileName, sizeof(RomFileName));

  00547	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0054d	33 d2		 xor	 edx, edx
  0054f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?RomFileName@@3PADA
  00556	e8 00 00 00 00	 call	 memset

; 263  :                     PowerHit = true;

  0055b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?PowerHit@@3HA, 1

; 264  :                     break;

  00565	eb 0a		 jmp	 SHORT $LN6@WinInputCa
$LN32@WinInputCa:

; 265  :                 }
; 266  :                 case ID_QUIT_ITEM:
; 267  :                 {
; 268  :                     GlobalRunning = false;

  00567	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0
$LN6@WinInputCa:

; 269  :                     break;
; 270  :                 }
; 271  :             }
; 272  :             break;

  00571	eb 2a		 jmp	 SHORT $LN2@WinInputCa
$LN33@WinInputCa:

; 273  :         }
; 274  :                 
; 275  :         default:
; 276  :         {
; 277  :             Result = DefWindowProc(WindowHandle, Message, wParam, lParam);

  00573	4c 8b 8c 24 58
	02 00 00	 mov	 r9, QWORD PTR lParam$[rsp]
  0057b	4c 8b 84 24 50
	02 00 00	 mov	 r8, QWORD PTR wParam$[rsp]
  00583	8b 94 24 48 02
	00 00		 mov	 edx, DWORD PTR Message$[rsp]
  0058a	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR WindowHandle$[rsp]
  00592	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DefWindowProcA
  00598	48 89 44 24 70	 mov	 QWORD PTR Result$[rsp], rax
$LN2@WinInputCa:

; 278  :             break;
; 279  :         }
; 280  :     }
; 281  :     return Result;

  0059d	48 8b 44 24 70	 mov	 rax, QWORD PTR Result$[rsp]

; 282  : }

  005a2	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005aa	48 33 cc	 xor	 rcx, rsp
  005ad	e8 00 00 00 00	 call	 __security_check_cookie
  005b2	48 81 c4 30 02
	00 00		 add	 rsp, 560		; 00000230H
  005b9	5f		 pop	 rdi
  005ba	c3		 ret	 0
  005bb	90		 npad	 1
$LN59@WinInputCa:
  005bc	00 00 00 00	 DD	 $LN20@WinInputCa
  005c0	00 00 00 00	 DD	 $LN21@WinInputCa
  005c4	00 00 00 00	 DD	 $LN23@WinInputCa
  005c8	00 00 00 00	 DD	 $LN16@WinInputCa
  005cc	00 00 00 00	 DD	 $LN14@WinInputCa
  005d0	00 00 00 00	 DD	 $LN17@WinInputCa
  005d4	00 00 00 00	 DD	 $LN15@WinInputCa
  005d8	00 00 00 00	 DD	 $LN19@WinInputCa
  005dc	00 00 00 00	 DD	 $LN18@WinInputCa
  005e0	00 00 00 00	 DD	 $LN24@WinInputCa
  005e4	00 00 00 00	 DD	 $LN4@WinInputCa
$LN58@WinInputCa:
  005e8	00		 DB	 0
  005e9	0a		 DB	 10
  005ea	0a		 DB	 10
  005eb	01		 DB	 1
  005ec	0a		 DB	 10
  005ed	0a		 DB	 10
  005ee	0a		 DB	 10
  005ef	0a		 DB	 10
  005f0	0a		 DB	 10
  005f1	0a		 DB	 10
  005f2	0a		 DB	 10
  005f3	0a		 DB	 10
  005f4	0a		 DB	 10
  005f5	0a		 DB	 10
  005f6	02		 DB	 2
  005f7	0a		 DB	 10
  005f8	0a		 DB	 10
  005f9	0a		 DB	 10
  005fa	0a		 DB	 10
  005fb	0a		 DB	 10
  005fc	0a		 DB	 10
  005fd	0a		 DB	 10
  005fe	0a		 DB	 10
  005ff	0a		 DB	 10
  00600	03		 DB	 3
  00601	04		 DB	 4
  00602	05		 DB	 5
  00603	06		 DB	 6
  00604	0a		 DB	 10
  00605	0a		 DB	 10
  00606	0a		 DB	 10
  00607	0a		 DB	 10
  00608	0a		 DB	 10
  00609	0a		 DB	 10
  0060a	0a		 DB	 10
  0060b	0a		 DB	 10
  0060c	0a		 DB	 10
  0060d	0a		 DB	 10
  0060e	0a		 DB	 10
  0060f	0a		 DB	 10
  00610	0a		 DB	 10
  00611	0a		 DB	 10
  00612	0a		 DB	 10
  00613	0a		 DB	 10
  00614	0a		 DB	 10
  00615	0a		 DB	 10
  00616	0a		 DB	 10
  00617	0a		 DB	 10
  00618	0a		 DB	 10
  00619	0a		 DB	 10
  0061a	0a		 DB	 10
  0061b	0a		 DB	 10
  0061c	0a		 DB	 10
  0061d	0a		 DB	 10
  0061e	0a		 DB	 10
  0061f	0a		 DB	 10
  00620	0a		 DB	 10
  00621	0a		 DB	 10
  00622	0a		 DB	 10
  00623	0a		 DB	 10
  00624	0a		 DB	 10
  00625	0a		 DB	 10
  00626	0a		 DB	 10
  00627	0a		 DB	 10
  00628	0a		 DB	 10
  00629	0a		 DB	 10
  0062a	0a		 DB	 10
  0062b	0a		 DB	 10
  0062c	0a		 DB	 10
  0062d	0a		 DB	 10
  0062e	0a		 DB	 10
  0062f	0a		 DB	 10
  00630	0a		 DB	 10
  00631	0a		 DB	 10
  00632	0a		 DB	 10
  00633	07		 DB	 7
  00634	0a		 DB	 10
  00635	08		 DB	 8
  00636	0a		 DB	 10
  00637	0a		 DB	 10
  00638	0a		 DB	 10
  00639	0a		 DB	 10
  0063a	0a		 DB	 10
  0063b	0a		 DB	 10
  0063c	0a		 DB	 10
  0063d	0a		 DB	 10
  0063e	0a		 DB	 10
  0063f	0a		 DB	 10
  00640	0a		 DB	 10
  00641	0a		 DB	 10
  00642	0a		 DB	 10
  00643	0a		 DB	 10
  00644	0a		 DB	 10
  00645	0a		 DB	 10
  00646	0a		 DB	 10
  00647	0a		 DB	 10
  00648	0a		 DB	 10
  00649	0a		 DB	 10
  0064a	0a		 DB	 10
  0064b	0a		 DB	 10
  0064c	0a		 DB	 10
  0064d	0a		 DB	 10
  0064e	09		 DB	 9
?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z ENDP		; WinInputCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Value$ = 0
NewAddress$ = 8
Address$ = 32
MemoryOffset$ = 40
?read8@@YAEG_K@Z PROC					; read8

; 96   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 97   :     uint8 *NewAddress = (uint8 *)(Address + MemoryOffset);

  0000e	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  00013	48 03 44 24 28	 add	 rax, QWORD PTR MemoryOffset$[rsp]
  00018	48 89 44 24 08	 mov	 QWORD PTR NewAddress$[rsp], rax

; 98   :     uint8 Value = *NewAddress;

  0001d	48 8b 44 24 08	 mov	 rax, QWORD PTR NewAddress$[rsp]
  00022	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00025	88 04 24	 mov	 BYTE PTR Value$[rsp], al

; 99   :     return(Value);

  00028	0f b6 04 24	 movzx	 eax, BYTE PTR Value$[rsp]

; 100  : }

  0002c	48 83 c4 18	 add	 rsp, 24
  00030	c3		 ret	 0
?read8@@YAEG_K@Z ENDP					; read8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
NewAddress$ = 0
Byte$ = 32
Address$ = 40
MemoryOffset$ = 48
?write8@@YAXEG_K@Z PROC					; write8

; 90   : {   

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	48 83 ec 18	 sub	 rsp, 24

; 91   :     uint8 *NewAddress = (uint8 *)(Address + MemoryOffset);

  00012	0f b7 44 24 28	 movzx	 eax, WORD PTR Address$[rsp]
  00017	48 03 44 24 30	 add	 rax, QWORD PTR MemoryOffset$[rsp]
  0001c	48 89 04 24	 mov	 QWORD PTR NewAddress$[rsp], rax

; 92   :     *NewAddress = Byte;

  00020	48 8b 04 24	 mov	 rax, QWORD PTR NewAddress$[rsp]
  00024	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Byte$[rsp]
  00029	88 08		 mov	 BYTE PTR [rax], cl

; 93   : }

  0002b	48 83 c4 18	 add	 rsp, 24
  0002f	c3		 ret	 0
?write8@@YAXEG_K@Z ENDP					; write8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Byte$1 = 0
Dest$ = 32
Src$ = 40
Size$ = 48
?cpyMemory@@YAXPEAE0G@Z PROC				; cpyMemory

; 83   : {

  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	48 83 ec 18	 sub	 rsp, 24

; 84   :     // NOTE: Very basic copy. Not bounds protection
; 85   :     for(uint16 Byte = 0; Byte < Size; ++Byte)

  00014	33 c0		 xor	 eax, eax
  00016	66 89 04 24	 mov	 WORD PTR Byte$1[rsp], ax
  0001a	eb 0b		 jmp	 SHORT $LN4@cpyMemory
$LN2@cpyMemory:
  0001c	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  00020	66 ff c0	 inc	 ax
  00023	66 89 04 24	 mov	 WORD PTR Byte$1[rsp], ax
$LN4@cpyMemory:
  00027	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  0002b	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Size$[rsp]
  00030	3b c1		 cmp	 eax, ecx
  00032	7d 1c		 jge	 SHORT $LN3@cpyMemory

; 86   :         Dest[Byte] = Src[Byte];

  00034	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  00038	0f b7 0c 24	 movzx	 ecx, WORD PTR Byte$1[rsp]
  0003c	48 8b 54 24 20	 mov	 rdx, QWORD PTR Dest$[rsp]
  00041	4c 8b 44 24 28	 mov	 r8, QWORD PTR Src$[rsp]
  00046	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0004b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0004e	eb cc		 jmp	 SHORT $LN2@cpyMemory
$LN3@cpyMemory:

; 87   : }

  00050	48 83 c4 18	 add	 rsp, 24
  00054	c3		 ret	 0
?cpyMemory@@YAXPEAE0G@Z ENDP				; cpyMemory
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
MSElapsed$ = 32
Counter$ = 40
CounterElapsed$ = 48
PerfCountFrequency$ = 80
?getMilliSeconds@@YAM_K@Z PROC				; getMilliSeconds

; 71   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 72   :     LARGE_INTEGER Counter;
; 73   :     QueryPerformanceCounter(&Counter);

  00009	48 8d 4c 24 28	 lea	 rcx, QWORD PTR Counter$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_QueryPerformanceCounter

; 74   :     
; 75   :     uint64 CounterElapsed = Counter.QuadPart;

  00014	48 8b 44 24 28	 mov	 rax, QWORD PTR Counter$[rsp]
  00019	48 89 44 24 30	 mov	 QWORD PTR CounterElapsed$[rsp], rax

; 76   :     real32 MSElapsed = ((1000.0f * (real32)CounterElapsed) / (real32)PerfCountFrequency);

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR CounterElapsed$[rsp]
  00023	f3 48 0f 2a c0	 cvtsi2ss xmm0, rax
  00028	48 85 c0	 test	 rax, rax
  0002b	7d 08		 jge	 SHORT $LN4@getMilliSe
  0002d	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@5f800000
$LN4@getMilliSe:
  00035	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@447a0000
  0003d	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00041	0f 28 c1	 movaps	 xmm0, xmm1
  00044	48 8b 44 24 50	 mov	 rax, QWORD PTR PerfCountFrequency$[rsp]
  00049	f3 48 0f 2a c8	 cvtsi2ss xmm1, rax
  0004e	48 85 c0	 test	 rax, rax
  00051	7d 08		 jge	 SHORT $LN3@getMilliSe
  00053	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@5f800000
$LN3@getMilliSe:
  0005b	f3 0f 5e c1	 divss	 xmm0, xmm1
  0005f	f3 0f 11 44 24
	20		 movss	 DWORD PTR MSElapsed$[rsp], xmm0

; 77   : 
; 78   :     return(MSElapsed);

  00065	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR MSElapsed$[rsp]

; 79   : }

  0006b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006f	c3		 ret	 0
?getMilliSeconds@@YAM_K@Z ENDP				; getMilliSeconds
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
i$1 = 96
ResScale$ = 97
WindowHeight$ = 100
WindowWidth$ = 104
RenderScaleHeight$ = 108
RenderScaleWidth$ = 112
InitialWindowPosY$ = 116
InitialWindowPosX$ = 120
TickCycles$2 = 124
Window$3 = 128
CpuMemorySize$4 = 136
CpuCyclesElapsed$5 = 140
CurrentSecs$6 = 144
PrevSecs$7 = 148
SubMenu$8 = 152
PpuMemorySize$9 = 160
CpuClockRateHz$10 = 164
ElapsedSecs$11 = 168
WindowMenu$12 = 176
Memory$13 = 184
CpuMemoryBase$14 = 192
DeviceContext$15 = 200
PerfCountFrequency$ = 208
CpuCyclesPerMS$16 = 216
WinPerfCountFrequency$ = 224
PpuRegisterLocation$17 = 232
PpuMemoryBase$18 = 240
WindowClass$ = 256
Message$19 = 336
Cartridge$20 = 384
ScreenBackBuffer$ = 464
Cpu$21 = 544
Ppu$22 = 560
__$ArrayPad$ = 864
WindowInstance$ = 896
PrevWindowInstance$ = 904
CommandLine$ = 912
CommandShow$ = 920
WinMain	PROC

; 556  : {

$LN20:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 70 03
	00 00		 sub	 rsp, 880		; 00000370H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 60
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 557  : 
; 558  :     LARGE_INTEGER WinPerfCountFrequency;
; 559  :     QueryPerformanceFrequency(&WinPerfCountFrequency); 

  0002e	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR WinPerfCountFrequency$[rsp]
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_QueryPerformanceFrequency

; 560  :     uint64 PerfCountFrequency = WinPerfCountFrequency.QuadPart;            

  0003c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR WinPerfCountFrequency$[rsp]
  00044	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR PerfCountFrequency$[rsp], rax

; 561  : 
; 562  :     /**************************************/
; 563  :     /* NOTE : Screen back buffer creation */
; 564  :     
; 565  :     uint16 RenderScaleWidth = 256, RenderScaleHeight = 240;

  0004c	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00051	66 89 44 24 70	 mov	 WORD PTR RenderScaleWidth$[rsp], ax
  00056	b8 f0 00 00 00	 mov	 eax, 240		; 000000f0H
  0005b	66 89 44 24 6c	 mov	 WORD PTR RenderScaleHeight$[rsp], ax

; 566  :     uint8 ResScale = 5;

  00060	c6 44 24 61 05	 mov	 BYTE PTR ResScale$[rsp], 5

; 567  :     uint16 WindowWidth = RenderScaleWidth * ResScale, WindowHeight = RenderScaleHeight * ResScale;

  00065	0f b7 44 24 70	 movzx	 eax, WORD PTR RenderScaleWidth$[rsp]
  0006a	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR ResScale$[rsp]
  0006f	0f af c1	 imul	 eax, ecx
  00072	66 89 44 24 68	 mov	 WORD PTR WindowWidth$[rsp], ax
  00077	0f b7 44 24 6c	 movzx	 eax, WORD PTR RenderScaleHeight$[rsp]
  0007c	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR ResScale$[rsp]
  00081	0f af c1	 imul	 eax, ecx
  00084	66 89 44 24 64	 mov	 WORD PTR WindowHeight$[rsp], ax

; 568  :     screen_buffer ScreenBackBuffer = {};

  00089	48 8d 84 24 d0
	01 00 00	 lea	 rax, QWORD PTR ScreenBackBuffer$[rsp]
  00091	48 8b f8	 mov	 rdi, rax
  00094	33 c0		 xor	 eax, eax
  00096	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  0009b	f3 aa		 rep stosb

; 569  :     createBackBuffer(&ScreenBackBuffer, RenderScaleWidth, RenderScaleHeight);

  0009d	44 0f b7 44 24
	6c		 movzx	 r8d, WORD PTR RenderScaleHeight$[rsp]
  000a3	0f b7 54 24 70	 movzx	 edx, WORD PTR RenderScaleWidth$[rsp]
  000a8	48 8d 8c 24 d0
	01 00 00	 lea	 rcx, QWORD PTR ScreenBackBuffer$[rsp]
  000b0	e8 00 00 00 00	 call	 ?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z ; createBackBuffer

; 570  :         
; 571  :     /**************************/
; 572  :     /* NOTE : Window creation */
; 573  : 
; 574  :     WNDCLASSA WindowClass = {};

  000b5	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR WindowClass$[rsp]
  000bd	48 8b f8	 mov	 rdi, rax
  000c0	33 c0		 xor	 eax, eax
  000c2	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  000c7	f3 aa		 rep stosb

; 575  :     WindowClass.style = CS_HREDRAW | CS_VREDRAW;

  000c9	c7 84 24 00 01
	00 00 03 00 00
	00		 mov	 DWORD PTR WindowClass$[rsp], 3

; 576  :     WindowClass.lpfnWndProc = WinInputCallback;

  000d4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z ; WinInputCallback
  000db	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR WindowClass$[rsp+8], rax

; 577  :     WindowClass.hInstance = WindowInstance;

  000e3	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR WindowInstance$[rsp]
  000eb	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR WindowClass$[rsp+24], rax

; 578  :     WindowClass.lpszClassName = "NesEmu";

  000f3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG89123
  000fa	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR WindowClass$[rsp+64], rax

; 579  : 
; 580  :     uint16 InitialWindowPosX = 0;

  00102	33 c0		 xor	 eax, eax
  00104	66 89 44 24 78	 mov	 WORD PTR InitialWindowPosX$[rsp], ax

; 581  :     uint16 InitialWindowPosY = 0;

  00109	33 c0		 xor	 eax, eax
  0010b	66 89 44 24 74	 mov	 WORD PTR InitialWindowPosY$[rsp], ax

; 582  :     
; 583  :     if(RegisterClassA(&WindowClass))

  00110	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR WindowClass$[rsp]
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegisterClassA
  0011e	0f b7 c0	 movzx	 eax, ax
  00121	85 c0		 test	 eax, eax
  00123	0f 84 11 05 00
	00		 je	 $LN9@WinMain

; 584  :     {        
; 585  :         HWND Window = CreateWindowExA(0, WindowClass.lpszClassName, "NesEmu", WS_OVERLAPPEDWINDOW|WS_VISIBLE,

  00129	0f b7 44 24 64	 movzx	 eax, WORD PTR WindowHeight$[rsp]
  0012e	0f b7 4c 24 68	 movzx	 ecx, WORD PTR WindowWidth$[rsp]
  00133	0f b7 54 24 74	 movzx	 edx, WORD PTR InitialWindowPosY$[rsp]
  00138	0f b7 7c 24 78	 movzx	 edi, WORD PTR InitialWindowPosX$[rsp]
  0013d	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR [rsp+88], 0
  00146	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR WindowInstance$[rsp]
  0014e	4c 89 44 24 50	 mov	 QWORD PTR [rsp+80], r8
  00153	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  0015c	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00165	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00169	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  0016d	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  00171	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  00175	41 b9 00 00 cf
	10		 mov	 r9d, 282001408		; 10cf0000H
  0017b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG89126
  00182	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR WindowClass$[rsp+64]
  0018a	33 c9		 xor	 ecx, ecx
  0018c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateWindowExA
  00192	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR Window$3[rsp], rax

; 586  :                                       InitialWindowPosX, InitialWindowPosY, WindowWidth, WindowHeight,
; 587  :                                       0, 0, WindowInstance, 0);
; 588  : 
; 589  :         if(Window) // If window was created successfully

  0019a	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR Window$3[rsp], 0
  001a3	0f 84 7d 04 00
	00		 je	 $LN11@WinMain

; 590  :         {
; 591  :             HMENU WindowMenu = CreateMenu();

  001a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateMenu
  001af	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR WindowMenu$12[rsp], rax

; 592  :             HMENU SubMenu = CreatePopupMenu();

  001b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreatePopupMenu
  001bd	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR SubMenu$8[rsp], rax

; 593  :             
; 594  :             AppendMenu(SubMenu, MF_STRING, ID_OPEN_ROM_ITEM, "&Open Rom");

  001c5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG89129
  001cc	41 b8 e9 03 00
	00		 mov	 r8d, 1001		; 000003e9H
  001d2	33 d2		 xor	 edx, edx
  001d4	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR SubMenu$8[rsp]
  001dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_AppendMenuA

; 595  :             AppendMenu(SubMenu, MF_STRING, ID_CLOSE_ROM_ITEM, "&Close Rom");

  001e2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG89130
  001e9	41 b8 ea 03 00
	00		 mov	 r8d, 1002		; 000003eaH
  001ef	33 d2		 xor	 edx, edx
  001f1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR SubMenu$8[rsp]
  001f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_AppendMenuA

; 596  :             AppendMenu(SubMenu, MF_STRING, ID_QUIT_ITEM, "&Quit");

  001ff	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG89131
  00206	41 b8 eb 03 00
	00		 mov	 r8d, 1003		; 000003ebH
  0020c	33 d2		 xor	 edx, edx
  0020e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR SubMenu$8[rsp]
  00216	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_AppendMenuA

; 597  :             AppendMenu(WindowMenu, MF_STRING | MF_POPUP, (uint64)SubMenu, "&File");

  0021c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG89132
  00223	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR SubMenu$8[rsp]
  0022b	ba 10 00 00 00	 mov	 edx, 16
  00230	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR WindowMenu$12[rsp]
  00238	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_AppendMenuA

; 598  : 
; 599  :             SetMenu(Window, WindowMenu);

  0023e	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR WindowMenu$12[rsp]
  00246	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Window$3[rsp]
  0024e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetMenu

; 600  : 
; 601  :             /**************************************************************************/
; 602  :             /* NOTE : creation and initialization of Emulators Cpu, Ppu, and Cartridge structures */
; 603  : 
; 604  : 
; 605  :             // Memory allocation for the Cpu and Ppu.
; 606  :             uint32 CpuMemorySize = Kilobytes(64);

  00254	c7 84 24 88 00
	00 00 00 00 01
	00		 mov	 DWORD PTR CpuMemorySize$4[rsp], 65536 ; 00010000H

; 607  :             uint32 PpuMemorySize = Kilobytes(64);

  0025f	c7 84 24 a0 00
	00 00 00 00 01
	00		 mov	 DWORD PTR PpuMemorySize$9[rsp], 65536 ; 00010000H

; 608  : 
; 609  :             uint8 * Memory = (uint8 *)VirtualAlloc(0, (size_t)(CpuMemorySize + PpuMemorySize), MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);

  0026a	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR PpuMemorySize$9[rsp]
  00271	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR CpuMemorySize$4[rsp]
  00278	03 c8		 add	 ecx, eax
  0027a	8b c1		 mov	 eax, ecx
  0027c	8b c0		 mov	 eax, eax
  0027e	41 b9 04 00 00
	00		 mov	 r9d, 4
  00284	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  0028a	8b d0		 mov	 edx, eax
  0028c	33 c9		 xor	 ecx, ecx
  0028e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  00294	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR Memory$13[rsp], rax

; 610  : 
; 611  :             uint64 CpuMemoryBase = (uint64)Memory;

  0029c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR Memory$13[rsp]
  002a4	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR CpuMemoryBase$14[rsp], rax

; 612  :             uint64 PpuMemoryBase = (uint64)Memory + CpuMemorySize;

  002ac	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR CpuMemorySize$4[rsp]
  002b3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR Memory$13[rsp]
  002bb	48 03 c8	 add	 rcx, rax
  002be	48 8b c1	 mov	 rax, rcx
  002c1	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR PpuMemoryBase$18[rsp], rax

; 613  : 
; 614  :             // Cpu Init             
; 615  :             cpu Cpu = {};

  002c9	48 8d 84 24 20
	02 00 00	 lea	 rax, QWORD PTR Cpu$21[rsp]
  002d1	48 8b f8	 mov	 rdi, rax
  002d4	33 c0		 xor	 eax, eax
  002d6	b9 10 00 00 00	 mov	 ecx, 16
  002db	f3 aa		 rep stosb

; 616  : 
; 617  :             initCPU(&Cpu, CpuMemoryBase);

  002dd	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR CpuMemoryBase$14[rsp]
  002e5	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR Cpu$21[rsp]
  002ed	e8 00 00 00 00	 call	 ?initCPU@@YAXPEAUcpu@@_K@Z ; initCPU

; 618  : 
; 619  :             // Ppu Init            
; 620  :             ppu Ppu = {};

  002f2	48 8d 84 24 30
	02 00 00	 lea	 rax, QWORD PTR Ppu$22[rsp]
  002fa	48 8b f8	 mov	 rdi, rax
  002fd	33 c0		 xor	 eax, eax
  002ff	b9 30 01 00 00	 mov	 ecx, 304		; 00000130H
  00304	f3 aa		 rep stosb

; 621  :             
; 622  :             uint64 PpuRegisterLocation = CpuMemoryBase + PPU_REG_ADRS;

  00306	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR CpuMemoryBase$14[rsp]
  0030e	48 05 00 20 00
	00		 add	 rax, 8192		; 00002000H
  00314	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR PpuRegisterLocation$17[rsp], rax

; 623  :             initPpu(&Ppu, PpuMemoryBase, (uint32 *)ScreenBackBuffer.Memory, (ppu_registers *)PpuRegisterLocation);

  0031c	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR PpuRegisterLocation$17[rsp]
  00324	4c 8b 84 24 00
	02 00 00	 mov	 r8, QWORD PTR ScreenBackBuffer$[rsp+48]
  0032c	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR PpuMemoryBase$18[rsp]
  00334	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR Ppu$22[rsp]
  0033c	e8 00 00 00 00	 call	 ?initPpu@@YAXPEAUppu@@_KPEAIPEAUppu_registers@@@Z ; initPpu

; 624  : 
; 625  :             // Cartidge Loading            
; 626  :             cartridge Cartridge = {};

  00341	48 8d 84 24 80
	01 00 00	 lea	 rax, QWORD PTR Cartridge$20[rsp]
  00349	48 8b f8	 mov	 rdi, rax
  0034c	33 c0		 xor	 eax, eax
  0034e	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00353	f3 aa		 rep stosb

; 627  : 
; 628  :             loadCartridge(&Cartridge, "Donkey Kong.nes", &Cpu, &Ppu);

  00355	4c 8d 8c 24 30
	02 00 00	 lea	 r9, QWORD PTR Ppu$22[rsp]
  0035d	4c 8d 84 24 20
	02 00 00	 lea	 r8, QWORD PTR Cpu$21[rsp]
  00365	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG89133
  0036c	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Cartridge$20[rsp]
  00374	e8 00 00 00 00	 call	 ?loadCartridge@@YAXPEAUcartridge@@PEADPEAUcpu@@PEAUppu@@@Z ; loadCartridge

; 629  : 
; 630  :             // NOTE: Load the program counter with the reset vector
; 631  :             Cpu.PrgCounter = readCpu16(RESET_VEC, Cpu.MemoryBase);

  00379	48 8b 94 24 28
	02 00 00	 mov	 rdx, QWORD PTR Cpu$21[rsp+8]
  00381	66 b9 fc ff	 mov	 cx, 65532		; 0000fffcH
  00385	e8 00 00 00 00	 call	 ?readCpu16@@YAGG_K@Z	; readCpu16
  0038a	66 89 84 24 26
	02 00 00	 mov	 WORD PTR Cpu$21[rsp+6], ax

; 632  : 
; 633  : 
; 634  :             /*****************/
; 635  :             /* NOTE : Timing */
; 636  :             
; 637  :             real32 CpuClockRateHz = 1789772.727272728;

  00392	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@49da7a66
  0039a	f3 0f 11 84 24
	a4 00 00 00	 movss	 DWORD PTR CpuClockRateHz$10[rsp], xmm0

; 638  :             real32 CpuCyclesPerMS = CpuClockRateHz / 1000.0;

  003a3	f3 0f 5a 84 24
	a4 00 00 00	 cvtss2sd xmm0, DWORD PTR CpuClockRateHz$10[rsp]
  003ac	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@408f400000000000
  003b4	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  003b8	f3 0f 11 84 24
	d8 00 00 00	 movss	 DWORD PTR CpuCyclesPerMS$16[rsp], xmm0

; 639  :             
; 640  :             uint32 CpuCyclesElapsed = 0;

  003c1	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR CpuCyclesElapsed$5[rsp], 0

; 641  :             uint32 TickCycles = 0;

  003cc	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR TickCycles$2[rsp], 0

; 642  :             
; 643  :             real32 ElapsedSecs = 0;

  003d4	0f 57 c0	 xorps	 xmm0, xmm0
  003d7	f3 0f 11 84 24
	a8 00 00 00	 movss	 DWORD PTR ElapsedSecs$11[rsp], xmm0

; 644  :             real32 CurrentSecs, PrevSecs = getMilliSeconds(PerfCountFrequency) / 1000.0f;

  003e0	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR PerfCountFrequency$[rsp]
  003e8	e8 00 00 00 00	 call	 ?getMilliSeconds@@YAM_K@Z ; getMilliSeconds
  003ed	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@447a0000
  003f5	f3 0f 11 84 24
	94 00 00 00	 movss	 DWORD PTR PrevSecs$7[rsp], xmm0

; 645  : 
; 646  :             /********************/
; 647  :             /* NOTE : Main Loop */
; 648  :             
; 649  :             GlobalRunning = true; 

  003fe	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 1
$LN2@WinMain:

; 650  :             while(GlobalRunning)

  00408	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?GlobalRunning@@3HA, 0
  0040f	0f 84 0f 02 00
	00		 je	 $LN3@WinMain

; 651  :             {
; 652  :                 MSG Message = {}; 

  00415	48 8d 84 24 50
	01 00 00	 lea	 rax, QWORD PTR Message$19[rsp]
  0041d	48 8b f8	 mov	 rdi, rax
  00420	33 c0		 xor	 eax, eax
  00422	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00427	f3 aa		 rep stosb
$LN4@WinMain:

; 653  :                 while (PeekMessage(&Message, Window, 0, 0, PM_REMOVE))

  00429	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00431	45 33 c9	 xor	 r9d, r9d
  00434	45 33 c0	 xor	 r8d, r8d
  00437	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR Window$3[rsp]
  0043f	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR Message$19[rsp]
  00447	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PeekMessageA
  0044d	85 c0		 test	 eax, eax
  0044f	74 1e		 je	 SHORT $LN5@WinMain

; 654  :                 {
; 655  :                     TranslateMessage(&Message);

  00451	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR Message$19[rsp]
  00459	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TranslateMessage

; 656  :                     DispatchMessage(&Message);

  0045f	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR Message$19[rsp]
  00467	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DispatchMessageA

; 657  :                 }

  0046d	eb ba		 jmp	 SHORT $LN4@WinMain
$LN5@WinMain:

; 658  : 
; 659  :                 if(PowerHit)

  0046f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PowerHit@@3HA, 0
  00476	74 27		 je	 SHORT $LN13@WinMain

; 660  :                 {
; 661  :                     PowerHit = false;

  00478	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PowerHit@@3HA, 0

; 662  :                     power(&Cpu, &Ppu, &Cartridge);

  00482	4c 8d 84 24 80
	01 00 00	 lea	 r8, QWORD PTR Cartridge$20[rsp]
  0048a	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR Ppu$22[rsp]
  00492	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR Cpu$21[rsp]
  0049a	e8 00 00 00 00	 call	 ?power@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z ; power
$LN13@WinMain:

; 663  :                 }
; 664  :                 
; 665  :                 if(ResetHit)

  0049f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ResetHit@@3HA, 0
  004a6	74 4b		 je	 SHORT $LN14@WinMain

; 666  :                 {
; 667  :                     ResetHit = false;

  004a8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ResetHit@@3HA, 0

; 668  :                     loadCartridge(&Cartridge, RomFileName, &Cpu, &Ppu);

  004b2	4c 8d 8c 24 30
	02 00 00	 lea	 r9, QWORD PTR Ppu$22[rsp]
  004ba	4c 8d 84 24 20
	02 00 00	 lea	 r8, QWORD PTR Cpu$21[rsp]
  004c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?RomFileName@@3PADA
  004c9	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Cartridge$20[rsp]
  004d1	e8 00 00 00 00	 call	 ?loadCartridge@@YAXPEAUcartridge@@PEADPEAUcpu@@PEAUppu@@@Z ; loadCartridge

; 669  :                     reset(&Cpu, &Ppu, &Cartridge);

  004d6	4c 8d 84 24 80
	01 00 00	 lea	 r8, QWORD PTR Cartridge$20[rsp]
  004de	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR Ppu$22[rsp]
  004e6	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR Cpu$21[rsp]
  004ee	e8 00 00 00 00	 call	 ?reset@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z ; reset
$LN14@WinMain:

; 670  :                 }
; 671  : 
; 672  :                 
; 673  :                 if(PowerOn)

  004f3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PowerOn@@3HA, 0
  004fa	74 61		 je	 SHORT $LN15@WinMain

; 674  :                 {
; 675  :                     TickCycles = cpuTick(&Cpu);

  004fc	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR Cpu$21[rsp]
  00504	e8 00 00 00 00	 call	 ?cpuTick@@YAEPEAUcpu@@@Z ; cpuTick
  00509	0f b6 c0	 movzx	 eax, al
  0050c	89 44 24 7c	 mov	 DWORD PTR TickCycles$2[rsp], eax

; 676  :                     
; 677  :                     for(uint8 i = 0; i < (3*TickCycles); ++i)

  00510	c6 44 24 60 00	 mov	 BYTE PTR i$1[rsp], 0
  00515	eb 0b		 jmp	 SHORT $LN8@WinMain
$LN6@WinMain:
  00517	0f b6 44 24 60	 movzx	 eax, BYTE PTR i$1[rsp]
  0051c	fe c0		 inc	 al
  0051e	88 44 24 60	 mov	 BYTE PTR i$1[rsp], al
$LN8@WinMain:
  00522	0f b6 44 24 60	 movzx	 eax, BYTE PTR i$1[rsp]
  00527	6b 4c 24 7c 03	 imul	 ecx, DWORD PTR TickCycles$2[rsp], 3
  0052c	3b c1		 cmp	 eax, ecx
  0052e	73 17		 jae	 SHORT $LN7@WinMain

; 678  :                     {
; 679  :                         ppuTick(&ScreenBackBuffer, &Ppu);

  00530	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR Ppu$22[rsp]
  00538	48 8d 8c 24 d0
	01 00 00	 lea	 rcx, QWORD PTR ScreenBackBuffer$[rsp]
  00540	e8 00 00 00 00	 call	 ?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z ; ppuTick

; 680  :                     }

  00545	eb d0		 jmp	 SHORT $LN6@WinMain
$LN7@WinMain:

; 681  : 
; 682  :                     CpuCyclesElapsed += TickCycles;

  00547	8b 44 24 7c	 mov	 eax, DWORD PTR TickCycles$2[rsp]
  0054b	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR CpuCyclesElapsed$5[rsp]
  00552	03 c8		 add	 ecx, eax
  00554	8b c1		 mov	 eax, ecx
  00556	89 84 24 8c 00
	00 00		 mov	 DWORD PTR CpuCyclesElapsed$5[rsp], eax
$LN15@WinMain:

; 683  :                 }
; 684  :                 
; 685  :                 if(DrawScreen) // NOTE: Gets called everytime the vblank happens in Ppu TODO: Should it be the end of vblank?

  0055d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DrawScreen@@3HA, 0 ; DrawScreen
  00564	74 6e		 je	 SHORT $LN16@WinMain

; 686  :                 {
; 687  :                     DrawScreen = false; 

  00566	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?DrawScreen@@3HA, 0 ; DrawScreen

; 688  :                     getWindowSize(Window, &WindowWidth, &WindowHeight);

  00570	4c 8d 44 24 64	 lea	 r8, QWORD PTR WindowHeight$[rsp]
  00575	48 8d 54 24 68	 lea	 rdx, QWORD PTR WindowWidth$[rsp]
  0057a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Window$3[rsp]
  00582	e8 00 00 00 00	 call	 ?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z ; getWindowSize

; 689  :                 
; 690  :                     // NOTE: Drawing the backbuffer to the window 
; 691  :                     HDC DeviceContext = GetDC(Window);

  00587	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Window$3[rsp]
  0058f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetDC
  00595	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR DeviceContext$15[rsp], rax

; 692  :                     drawScreenBuffer(&ScreenBackBuffer, DeviceContext,

  0059d	44 0f b7 4c 24
	64		 movzx	 r9d, WORD PTR WindowHeight$[rsp]
  005a3	44 0f b7 44 24
	68		 movzx	 r8d, WORD PTR WindowWidth$[rsp]
  005a9	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR DeviceContext$15[rsp]
  005b1	48 8d 8c 24 d0
	01 00 00	 lea	 rcx, QWORD PTR ScreenBackBuffer$[rsp]
  005b9	e8 00 00 00 00	 call	 ?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z ; drawScreenBuffer

; 693  :                                      WindowWidth, WindowHeight);
; 694  :                     ReleaseDC(Window, DeviceContext);

  005be	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR DeviceContext$15[rsp]
  005c6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Window$3[rsp]
  005ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReleaseDC
$LN16@WinMain:

; 695  :                 }
; 696  : 
; 697  :                 
; 698  :                 CurrentSecs = getMilliSeconds(PerfCountFrequency) / 1000.0f;

  005d4	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR PerfCountFrequency$[rsp]
  005dc	e8 00 00 00 00	 call	 ?getMilliSeconds@@YAM_K@Z ; getMilliSeconds
  005e1	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@447a0000
  005e9	f3 0f 11 84 24
	90 00 00 00	 movss	 DWORD PTR CurrentSecs$6[rsp], xmm0

; 699  :                 ElapsedSecs = CurrentSecs - PrevSecs;

  005f2	f3 0f 10 84 24
	90 00 00 00	 movss	 xmm0, DWORD PTR CurrentSecs$6[rsp]
  005fb	f3 0f 5c 84 24
	94 00 00 00	 subss	 xmm0, DWORD PTR PrevSecs$7[rsp]
  00604	f3 0f 11 84 24
	a8 00 00 00	 movss	 DWORD PTR ElapsedSecs$11[rsp], xmm0

; 700  :                 PrevSecs = CurrentSecs;

  0060d	f3 0f 10 84 24
	90 00 00 00	 movss	 xmm0, DWORD PTR CurrentSecs$6[rsp]
  00616	f3 0f 11 84 24
	94 00 00 00	 movss	 DWORD PTR PrevSecs$7[rsp], xmm0

; 701  :             }

  0061f	e9 e4 fd ff ff	 jmp	 $LN2@WinMain
$LN3@WinMain:

; 702  : 
; 703  :         }
; 704  :         else

  00624	eb 12		 jmp	 SHORT $LN12@WinMain
$LN11@WinMain:

; 705  :         {
; 706  :             // NOTE: Window failed to create
; 707  :             // TODO: Handle this in a better way
; 708  :             Assert(0);

  00626	33 c0		 xor	 eax, eax
  00628	83 f8 01	 cmp	 eax, 1
  0062b	74 0b		 je	 SHORT $LN17@WinMain
  0062d	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN17@WinMain:
$LN12@WinMain:

; 709  :         }
; 710  :     }
; 711  :     else

  00638	eb 12		 jmp	 SHORT $LN10@WinMain
$LN9@WinMain:

; 712  :     {
; 713  :         // NOTE: Failed to register window
; 714  :         // TODO: Handle this in a better way
; 715  :         Assert(0);

  0063a	33 c0		 xor	 eax, eax
  0063c	83 f8 01	 cmp	 eax, 1
  0063f	74 0b		 je	 SHORT $LN18@WinMain
  00641	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN18@WinMain:
$LN10@WinMain:

; 716  :     }
; 717  :     return(0);

  0064c	33 c0		 xor	 eax, eax

; 718  : } 

  0064e	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00656	48 33 cc	 xor	 rcx, rsp
  00659	e8 00 00 00 00	 call	 __security_check_cookie
  0065e	48 81 c4 70 03
	00 00		 add	 rsp, 880		; 00000370H
  00665	5f		 pop	 rdi
  00666	c3		 ret	 0
WinMain	ENDP
_TEXT	ENDS
END
