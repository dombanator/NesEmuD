; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?nromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ; nromInit
PUBLIC	?mmc1Init@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ; mmc1Init
PUBLIC	?unromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ; unromInit
PUBLIC	?mapperInit@@3PAP6AXPEAUcartridge@@PEAUcpu@@PEAUppu@@@ZA ; mapperInit
PUBLIC	?nromUpdate@@YAXPEAUcpu@@PEAUcartridge@@@Z	; nromUpdate
PUBLIC	?mmc1Update@@YAXPEAUcpu@@PEAUcartridge@@@Z	; mmc1Update
PUBLIC	?unromUpdate@@YAXPEAUcpu@@PEAUcartridge@@@Z	; unromUpdate
PUBLIC	?mapperUpdate@@3PAP6AXPEAUcpu@@PEAUcartridge@@@ZA ; mapperUpdate
PUBLIC	?adc@@YAEGPEAUcpu@@E@Z				; adc
PUBLIC	?AND@@YAEGPEAUcpu@@E@Z				; AND
PUBLIC	?asl@@YAEGPEAUcpu@@E@Z				; asl
PUBLIC	?bcc@@YAEGPEAUcpu@@E@Z				; bcc
PUBLIC	?bcs@@YAEGPEAUcpu@@E@Z				; bcs
PUBLIC	?beq@@YAEGPEAUcpu@@E@Z				; beq
PUBLIC	?bit@@YAEGPEAUcpu@@E@Z				; bit
PUBLIC	?bmi@@YAEGPEAUcpu@@E@Z				; bmi
PUBLIC	?bne@@YAEGPEAUcpu@@E@Z				; bne
PUBLIC	?bpl@@YAEGPEAUcpu@@E@Z				; bpl
PUBLIC	?brk@@YAEGPEAUcpu@@E@Z				; brk
PUBLIC	?bvc@@YAEGPEAUcpu@@E@Z				; bvc
PUBLIC	?bvs@@YAEGPEAUcpu@@E@Z				; bvs
PUBLIC	?clc@@YAEGPEAUcpu@@E@Z				; clc
PUBLIC	?cld@@YAEGPEAUcpu@@E@Z				; cld
PUBLIC	?cli@@YAEGPEAUcpu@@E@Z				; cli
PUBLIC	?clv@@YAEGPEAUcpu@@E@Z				; clv
PUBLIC	?cmp@@YAEGPEAUcpu@@E@Z				; cmp
PUBLIC	?cpx@@YAEGPEAUcpu@@E@Z				; cpx
PUBLIC	?cpy@@YAEGPEAUcpu@@E@Z				; cpy
PUBLIC	?dec@@YAEGPEAUcpu@@E@Z				; dec
PUBLIC	?dex@@YAEGPEAUcpu@@E@Z				; dex
PUBLIC	?dey@@YAEGPEAUcpu@@E@Z				; dey
PUBLIC	?eor@@YAEGPEAUcpu@@E@Z				; eor
PUBLIC	?inc@@YAEGPEAUcpu@@E@Z				; inc
PUBLIC	?inx@@YAEGPEAUcpu@@E@Z				; inx
PUBLIC	?iny@@YAEGPEAUcpu@@E@Z				; iny
PUBLIC	?jmp@@YAEGPEAUcpu@@E@Z				; jmp
PUBLIC	?jsr@@YAEGPEAUcpu@@E@Z				; jsr
PUBLIC	?lda@@YAEGPEAUcpu@@E@Z				; lda
PUBLIC	?ldx@@YAEGPEAUcpu@@E@Z				; ldx
PUBLIC	?ldy@@YAEGPEAUcpu@@E@Z				; ldy
PUBLIC	?lsr@@YAEGPEAUcpu@@E@Z				; lsr
PUBLIC	?nop@@YAEGPEAUcpu@@E@Z				; nop
PUBLIC	?ora@@YAEGPEAUcpu@@E@Z				; ora
PUBLIC	?pha@@YAEGPEAUcpu@@E@Z				; pha
PUBLIC	?php@@YAEGPEAUcpu@@E@Z				; php
PUBLIC	?pla@@YAEGPEAUcpu@@E@Z				; pla
PUBLIC	?plp@@YAEGPEAUcpu@@E@Z				; plp
PUBLIC	?rol@@YAEGPEAUcpu@@E@Z				; rol
PUBLIC	?ror@@YAEGPEAUcpu@@E@Z				; ror
PUBLIC	?rti@@YAEGPEAUcpu@@E@Z				; rti
PUBLIC	?rts@@YAEGPEAUcpu@@E@Z				; rts
PUBLIC	?sbc@@YAEGPEAUcpu@@E@Z				; sbc
PUBLIC	?sec@@YAEGPEAUcpu@@E@Z				; sec
PUBLIC	?sed@@YAEGPEAUcpu@@E@Z				; sed
PUBLIC	?sei@@YAEGPEAUcpu@@E@Z				; sei
PUBLIC	?sta@@YAEGPEAUcpu@@E@Z				; sta
PUBLIC	?stx@@YAEGPEAUcpu@@E@Z				; stx
PUBLIC	?sty@@YAEGPEAUcpu@@E@Z				; sty
PUBLIC	?tax@@YAEGPEAUcpu@@E@Z				; tax
PUBLIC	?tay@@YAEGPEAUcpu@@E@Z				; tay
PUBLIC	?tsx@@YAEGPEAUcpu@@E@Z				; tsx
PUBLIC	?txa@@YAEGPEAUcpu@@E@Z				; txa
PUBLIC	?tya@@YAEGPEAUcpu@@E@Z				; tya
PUBLIC	?txs@@YAEGPEAUcpu@@E@Z				; txs
PUBLIC	?ahx@@YAEGPEAUcpu@@E@Z				; ahx
PUBLIC	?alr@@YAEGPEAUcpu@@E@Z				; alr
PUBLIC	?anc@@YAEGPEAUcpu@@E@Z				; anc
PUBLIC	?arr@@YAEGPEAUcpu@@E@Z				; arr
PUBLIC	?axs@@YAEGPEAUcpu@@E@Z				; axs
PUBLIC	?dcp@@YAEGPEAUcpu@@E@Z				; dcp
PUBLIC	?isc@@YAEGPEAUcpu@@E@Z				; isc
PUBLIC	?kil@@YAEGPEAUcpu@@E@Z				; kil
PUBLIC	?las@@YAEGPEAUcpu@@E@Z				; las
PUBLIC	?lax@@YAEGPEAUcpu@@E@Z				; lax
PUBLIC	?rla@@YAEGPEAUcpu@@E@Z				; rla
PUBLIC	?rra@@YAEGPEAUcpu@@E@Z				; rra
PUBLIC	?sax@@YAEGPEAUcpu@@E@Z				; sax
PUBLIC	?shx@@YAEGPEAUcpu@@E@Z				; shx
PUBLIC	?shy@@YAEGPEAUcpu@@E@Z				; shy
PUBLIC	?slo@@YAEGPEAUcpu@@E@Z				; slo
PUBLIC	?sre@@YAEGPEAUcpu@@E@Z				; sre
PUBLIC	?tas@@YAEGPEAUcpu@@E@Z				; tas
PUBLIC	?xaa@@YAEGPEAUcpu@@E@Z				; xaa
PUBLIC	?instrOps@@3PAP6AEGPEAUcpu@@E@ZA		; instrOps
PUBLIC	?NmiTriggered@@3HA				; NmiTriggered
PUBLIC	?IrqTriggered@@3HA				; IrqTriggered
PUBLIC	?VRamAdrsChange@@3HA				; VRamAdrsChange
PUBLIC	?OamDataChange@@3HA				; OamDataChange
PUBLIC	?IOWriteFromCpu@@3HA				; IOWriteFromCpu
PUBLIC	?ScrollAdrsChange@@3HA				; ScrollAdrsChange
PUBLIC	?VRamAdrsOnPalette@@3HA				; VRamAdrsOnPalette
PUBLIC	?IOReadFromCpu@@3HA				; IOReadFromCpu
PUBLIC	?ResetVRamIOAdrs@@3HA				; ResetVRamIOAdrs
PUBLIC	?ResetScrollIOAdrs@@3HA				; ResetScrollIOAdrs
PUBLIC	?DrawScreen@@3HA				; DrawScreen
PUBLIC	?Palette@@3PAY02EA				; Palette
_BSS	SEGMENT
?WinInput@@3Uinput@@A DB 020H DUP (?)			; WinInput
?MapperExtWrite@@3HA DD 01H DUP (?)			; MapperExtWrite
?PowerHit@@3HA DD 01H DUP (?)				; PowerHit
?ResetHit@@3HA DD 01H DUP (?)				; ResetHit
	ALIGN	8

?OamData@@3PEAEEA DQ 01H DUP (?)			; OamData
?NmiTriggered@@3HA DD 01H DUP (?)			; NmiTriggered
?IrqTriggered@@3HA DD 01H DUP (?)			; IrqTriggered
?VRamAdrsChange@@3HA DD 01H DUP (?)			; VRamAdrsChange
?OamDataChange@@3HA DD 01H DUP (?)			; OamDataChange
?IOWriteFromCpu@@3HA DD 01H DUP (?)			; IOWriteFromCpu
?ScrollAdrsChange@@3HA DD 01H DUP (?)			; ScrollAdrsChange
?VRamAdrsOnPalette@@3HA DD 01H DUP (?)			; VRamAdrsOnPalette
?IOReadFromCpu@@3HA DD 01H DUP (?)			; IOReadFromCpu
?ResetVRamIOAdrs@@3HA DD 01H DUP (?)			; ResetVRamIOAdrs
?ResetScrollIOAdrs@@3HA DD 01H DUP (?)			; ResetScrollIOAdrs
?DrawScreen@@3HA DD 01H DUP (?)				; DrawScreen
_BSS	ENDS
_DATA	SEGMENT
?mapperInit@@3PAP6AXPEAUcartridge@@PEAUcpu@@PEAUppu@@@ZA DQ FLAT:?nromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ; mapperInit
	DQ	FLAT:?mmc1Init@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z
	DQ	FLAT:?unromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z
?mapperUpdate@@3PAP6AXPEAUcpu@@PEAUcartridge@@@ZA DQ FLAT:?nromUpdate@@YAXPEAUcpu@@PEAUcartridge@@@Z ; mapperUpdate
	DQ	FLAT:?mmc1Update@@YAXPEAUcpu@@PEAUcartridge@@@Z
	DQ	FLAT:?unromUpdate@@YAXPEAUcpu@@PEAUcartridge@@@Z
?instCycles@@3PAEA DB 07H				; instCycles
	DB	06H
	DB	00H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
	DB	06H
	DB	06H
	DB	00H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	04H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
	DB	06H
	DB	06H
	DB	00H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	03H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
	DB	06H
	DB	06H
	DB	00H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	04H
	DB	02H
	DB	02H
	DB	02H
	DB	05H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
	DB	02H
	DB	06H
	DB	02H
	DB	06H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	02H
	DB	06H
	DB	00H
	DB	06H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	02H
	DB	05H
	DB	02H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	02H
	DB	06H
	DB	02H
	DB	06H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	02H
	DB	05H
	DB	00H
	DB	05H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	02H
	DB	04H
	DB	02H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	02H
	DB	06H
	DB	02H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
	DB	02H
	DB	06H
	DB	02H
	DB	08H
	DB	03H
	DB	03H
	DB	05H
	DB	05H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	05H
	DB	00H
	DB	08H
	DB	04H
	DB	04H
	DB	06H
	DB	06H
	DB	02H
	DB	04H
	DB	02H
	DB	07H
	DB	04H
	DB	04H
	DB	07H
	DB	07H
?instBoundaryCheck@@3PAEA DB 00H			; instBoundaryCheck
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
?PowerOn@@3HA DD 01H					; PowerOn
	ORG $+12
?instrOps@@3PAP6AEGPEAUcpu@@E@ZA DQ FLAT:?brk@@YAEGPEAUcpu@@E@Z ; instrOps
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?asl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?php@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?asl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?anc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?asl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bpl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?asl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?clc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ora@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?asl@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?slo@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?jsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bit@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rol@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?plp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rol@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?anc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bit@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rol@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bmi@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rol@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sec@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?AND@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rol@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rti@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?pha@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?alr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?jmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bvc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cli@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?eor@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lsr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sre@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rts@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ror@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?pla@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ror@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?arr@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?jmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ror@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bvs@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ror@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sei@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?adc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ror@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?rra@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sty@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?stx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dey@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?txa@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?xaa@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sty@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?stx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bcc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ahx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sty@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?stx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?tya@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?txs@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?tas@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?shy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sta@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?shx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ahx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?tay@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?tax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bcs@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?clv@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?tsx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?las@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lda@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?ldx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?lax@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dec@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?iny@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dex@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?axs@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpy@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dec@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?bne@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dec@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cld@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cmp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dec@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?dcp@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?inc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?inx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?cpx@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?inc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?beq@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?kil@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?inc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sed@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?nop@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?sbc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?inc@@YAEGPEAUcpu@@E@Z
	DQ	FLAT:?isc@@YAEGPEAUcpu@@E@Z
?Palette@@3PAY02EA DB 075H				; Palette
	DB	075H
	DB	075H
	DB	027H
	DB	01bH
	DB	08fH
	DB	00H
	DB	00H
	DB	0abH
	DB	047H
	DB	00H
	DB	09fH
	DB	08fH
	DB	00H
	DB	077H
	DB	0abH
	DB	00H
	DB	013H
	DB	0a7H
	DB	00H
	DB	00H
	DB	07fH
	DB	0bH
	DB	00H
	DB	043H
	DB	02fH
	DB	00H
	DB	00H
	DB	047H
	DB	00H
	DB	00H
	DB	051H
	DB	00H
	DB	00H
	DB	03fH
	DB	017H
	DB	01bH
	DB	03fH
	DB	05fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0bcH
	DB	0bcH
	DB	0bcH
	DB	00H
	DB	073H
	DB	0efH
	DB	023H
	DB	03bH
	DB	0efH
	DB	083H
	DB	00H
	DB	0f3H
	DB	0bfH
	DB	00H
	DB	0bfH
	DB	0e7H
	DB	00H
	DB	05bH
	DB	0dbH
	DB	02bH
	DB	00H
	DB	0cbH
	DB	04fH
	DB	0fH
	DB	08bH
	DB	073H
	DB	00H
	DB	00H
	DB	097H
	DB	00H
	DB	00H
	DB	0abH
	DB	00H
	DB	00H
	DB	093H
	DB	03bH
	DB	00H
	DB	083H
	DB	08bH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	03fH
	DB	0bfH
	DB	0ffH
	DB	05fH
	DB	097H
	DB	0ffH
	DB	0a7H
	DB	08bH
	DB	0fdH
	DB	0f7H
	DB	07bH
	DB	0ffH
	DB	0ffH
	DB	077H
	DB	0b7H
	DB	0ffH
	DB	077H
	DB	063H
	DB	0ffH
	DB	09bH
	DB	03bH
	DB	0f3H
	DB	0bfH
	DB	03fH
	DB	083H
	DB	0d3H
	DB	013H
	DB	04fH
	DB	0dfH
	DB	04bH
	DB	058H
	DB	0f8H
	DB	098H
	DB	00H
	DB	0ebH
	DB	0dbH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0abH
	DB	0e7H
	DB	0ffH
	DB	0c7H
	DB	0d7H
	DB	0ffH
	DB	0d7H
	DB	0cbH
	DB	0ffH
	DB	0ffH
	DB	0c7H
	DB	0ffH
	DB	0ffH
	DB	0c7H
	DB	0dbH
	DB	0ffH
	DB	0bfH
	DB	0b3H
	DB	0ffH
	DB	0dbH
	DB	0abH
	DB	0ffH
	DB	0e7H
	DB	0a3H
	DB	0e3H
	DB	0ffH
	DB	0a3H
	DB	0abH
	DB	0f3H
	DB	0bfH
	DB	0b3H
	DB	0ffH
	DB	0cfH
	DB	09fH
	DB	0ffH
	DB	0f3H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
?instAddressMode@@3PAEA DB 09H				; instAddressMode
	DB	0bH
	DB	09H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	01H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	06H
	DB	0bH
	DB	09H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	01H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	09H
	DB	0bH
	DB	09H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	01H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	09H
	DB	0bH
	DB	09H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	01H
	DB	02H
	DB	0dH
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	02H
	DB	0bH
	DB	02H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	09H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	02H
	DB	0bH
	DB	02H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	09H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	02H
	DB	0bH
	DB	02H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	09H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	02H
	DB	0bH
	DB	02H
	DB	0bH
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	09H
	DB	02H
	DB	09H
	DB	02H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0aH
	DB	0cH
	DB	09H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	09H
	DB	08H
	DB	09H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
?instLength@@3PAEA DB 02H				; instLength
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	03H
	DB	01H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
?instName@@3PAPEADA DQ FLAT:$SG87892			; instName
	DQ	FLAT:$SG87893
	DQ	FLAT:$SG87894
	DQ	FLAT:$SG87895
	DQ	FLAT:$SG87896
	DQ	FLAT:$SG87897
	DQ	FLAT:$SG87898
	DQ	FLAT:$SG87899
	DQ	FLAT:$SG87900
	DQ	FLAT:$SG87901
	DQ	FLAT:$SG87902
	DQ	FLAT:$SG87903
	DQ	FLAT:$SG87904
	DQ	FLAT:$SG87905
	DQ	FLAT:$SG87906
	DQ	FLAT:$SG87907
	DQ	FLAT:$SG87908
	DQ	FLAT:$SG87909
	DQ	FLAT:$SG87910
	DQ	FLAT:$SG87911
	DQ	FLAT:$SG87912
	DQ	FLAT:$SG87913
	DQ	FLAT:$SG87914
	DQ	FLAT:$SG87915
	DQ	FLAT:$SG87916
	DQ	FLAT:$SG87917
	DQ	FLAT:$SG87918
	DQ	FLAT:$SG87919
	DQ	FLAT:$SG87920
	DQ	FLAT:$SG87921
	DQ	FLAT:$SG87922
	DQ	FLAT:$SG87923
	DQ	FLAT:$SG87924
	DQ	FLAT:$SG87925
	DQ	FLAT:$SG87926
	DQ	FLAT:$SG87927
	DQ	FLAT:$SG87928
	DQ	FLAT:$SG87929
	DQ	FLAT:$SG87930
	DQ	FLAT:$SG87931
	DQ	FLAT:$SG87932
	DQ	FLAT:$SG87933
	DQ	FLAT:$SG87934
	DQ	FLAT:$SG87935
	DQ	FLAT:$SG87936
	DQ	FLAT:$SG87937
	DQ	FLAT:$SG87938
	DQ	FLAT:$SG87939
	DQ	FLAT:$SG87940
	DQ	FLAT:$SG87941
	DQ	FLAT:$SG87942
	DQ	FLAT:$SG87943
	DQ	FLAT:$SG87944
	DQ	FLAT:$SG87945
	DQ	FLAT:$SG87946
	DQ	FLAT:$SG87947
	DQ	FLAT:$SG87948
	DQ	FLAT:$SG87949
	DQ	FLAT:$SG87950
	DQ	FLAT:$SG87951
	DQ	FLAT:$SG87952
	DQ	FLAT:$SG87953
	DQ	FLAT:$SG87954
	DQ	FLAT:$SG87955
	DQ	FLAT:$SG87956
	DQ	FLAT:$SG87957
	DQ	FLAT:$SG87958
	DQ	FLAT:$SG87959
	DQ	FLAT:$SG87960
	DQ	FLAT:$SG87961
	DQ	FLAT:$SG87962
	DQ	FLAT:$SG87963
	DQ	FLAT:$SG87964
	DQ	FLAT:$SG87965
	DQ	FLAT:$SG87966
	DQ	FLAT:$SG87967
	DQ	FLAT:$SG87968
	DQ	FLAT:$SG87969
	DQ	FLAT:$SG87970
	DQ	FLAT:$SG87971
	DQ	FLAT:$SG87972
	DQ	FLAT:$SG87973
	DQ	FLAT:$SG87974
	DQ	FLAT:$SG87975
	DQ	FLAT:$SG87976
	DQ	FLAT:$SG87977
	DQ	FLAT:$SG87978
	DQ	FLAT:$SG87979
	DQ	FLAT:$SG87980
	DQ	FLAT:$SG87981
	DQ	FLAT:$SG87982
	DQ	FLAT:$SG87983
	DQ	FLAT:$SG87984
	DQ	FLAT:$SG87985
	DQ	FLAT:$SG87986
	DQ	FLAT:$SG87987
	DQ	FLAT:$SG87988
	DQ	FLAT:$SG87989
	DQ	FLAT:$SG87990
	DQ	FLAT:$SG87991
	DQ	FLAT:$SG87992
	DQ	FLAT:$SG87993
	DQ	FLAT:$SG87994
	DQ	FLAT:$SG87995
	DQ	FLAT:$SG87996
	DQ	FLAT:$SG87997
	DQ	FLAT:$SG87998
	DQ	FLAT:$SG87999
	DQ	FLAT:$SG88000
	DQ	FLAT:$SG88001
	DQ	FLAT:$SG88002
	DQ	FLAT:$SG88003
	DQ	FLAT:$SG88004
	DQ	FLAT:$SG88005
	DQ	FLAT:$SG88006
	DQ	FLAT:$SG88007
	DQ	FLAT:$SG88008
	DQ	FLAT:$SG88009
	DQ	FLAT:$SG88010
	DQ	FLAT:$SG88011
	DQ	FLAT:$SG88012
	DQ	FLAT:$SG88013
	DQ	FLAT:$SG88014
	DQ	FLAT:$SG88015
	DQ	FLAT:$SG88016
	DQ	FLAT:$SG88017
	DQ	FLAT:$SG88018
	DQ	FLAT:$SG88019
	DQ	FLAT:$SG88020
	DQ	FLAT:$SG88021
	DQ	FLAT:$SG88022
	DQ	FLAT:$SG88023
	DQ	FLAT:$SG88024
	DQ	FLAT:$SG88025
	DQ	FLAT:$SG88026
	DQ	FLAT:$SG88027
	DQ	FLAT:$SG88028
	DQ	FLAT:$SG88029
	DQ	FLAT:$SG88030
	DQ	FLAT:$SG88031
	DQ	FLAT:$SG88032
	DQ	FLAT:$SG88033
	DQ	FLAT:$SG88034
	DQ	FLAT:$SG88035
	DQ	FLAT:$SG88036
	DQ	FLAT:$SG88037
	DQ	FLAT:$SG88038
	DQ	FLAT:$SG88039
	DQ	FLAT:$SG88040
	DQ	FLAT:$SG88041
	DQ	FLAT:$SG88042
	DQ	FLAT:$SG88043
	DQ	FLAT:$SG88044
	DQ	FLAT:$SG88045
	DQ	FLAT:$SG88046
	DQ	FLAT:$SG88047
	DQ	FLAT:$SG88048
	DQ	FLAT:$SG88049
	DQ	FLAT:$SG88050
	DQ	FLAT:$SG88051
	DQ	FLAT:$SG88052
	DQ	FLAT:$SG88053
	DQ	FLAT:$SG88054
	DQ	FLAT:$SG88055
	DQ	FLAT:$SG88056
	DQ	FLAT:$SG88057
	DQ	FLAT:$SG88058
	DQ	FLAT:$SG88059
	DQ	FLAT:$SG88060
	DQ	FLAT:$SG88061
	DQ	FLAT:$SG88062
	DQ	FLAT:$SG88063
	DQ	FLAT:$SG88064
	DQ	FLAT:$SG88065
	DQ	FLAT:$SG88066
	DQ	FLAT:$SG88067
	DQ	FLAT:$SG88068
	DQ	FLAT:$SG88069
	DQ	FLAT:$SG88070
	DQ	FLAT:$SG88071
	DQ	FLAT:$SG88072
	DQ	FLAT:$SG88073
	DQ	FLAT:$SG88074
	DQ	FLAT:$SG88075
	DQ	FLAT:$SG88076
	DQ	FLAT:$SG88077
	DQ	FLAT:$SG88078
	DQ	FLAT:$SG88079
	DQ	FLAT:$SG88080
	DQ	FLAT:$SG88081
	DQ	FLAT:$SG88082
	DQ	FLAT:$SG88083
	DQ	FLAT:$SG88084
	DQ	FLAT:$SG88085
	DQ	FLAT:$SG88086
	DQ	FLAT:$SG88087
	DQ	FLAT:$SG88088
	DQ	FLAT:$SG88089
	DQ	FLAT:$SG88090
	DQ	FLAT:$SG88091
	DQ	FLAT:$SG88092
	DQ	FLAT:$SG88093
	DQ	FLAT:$SG88094
	DQ	FLAT:$SG88095
	DQ	FLAT:$SG88096
	DQ	FLAT:$SG88097
	DQ	FLAT:$SG88098
	DQ	FLAT:$SG88099
	DQ	FLAT:$SG88100
	DQ	FLAT:$SG88101
	DQ	FLAT:$SG88102
	DQ	FLAT:$SG88103
	DQ	FLAT:$SG88104
	DQ	FLAT:$SG88105
	DQ	FLAT:$SG88106
	DQ	FLAT:$SG88107
	DQ	FLAT:$SG88108
	DQ	FLAT:$SG88109
	DQ	FLAT:$SG88110
	DQ	FLAT:$SG88111
	DQ	FLAT:$SG88112
	DQ	FLAT:$SG88113
	DQ	FLAT:$SG88114
	DQ	FLAT:$SG88115
	DQ	FLAT:$SG88116
	DQ	FLAT:$SG88117
	DQ	FLAT:$SG88118
	DQ	FLAT:$SG88119
	DQ	FLAT:$SG88120
	DQ	FLAT:$SG88121
	DQ	FLAT:$SG88122
	DQ	FLAT:$SG88123
	DQ	FLAT:$SG88124
	DQ	FLAT:$SG88125
	DQ	FLAT:$SG88126
	DQ	FLAT:$SG88127
	DQ	FLAT:$SG88128
	DQ	FLAT:$SG88129
	DQ	FLAT:$SG88130
	DQ	FLAT:$SG88131
	DQ	FLAT:$SG88132
	DQ	FLAT:$SG88133
	DQ	FLAT:$SG88134
	DQ	FLAT:$SG88135
	DQ	FLAT:$SG88136
	DQ	FLAT:$SG88137
	DQ	FLAT:$SG88138
	DQ	FLAT:$SG88139
	DQ	FLAT:$SG88140
	DQ	FLAT:$SG88141
	DQ	FLAT:$SG88142
	DQ	FLAT:$SG88143
	DQ	FLAT:$SG88144
	DQ	FLAT:$SG88145
	DQ	FLAT:$SG88146
	DQ	FLAT:$SG88147
_DATA	ENDS
CONST	SEGMENT
$SG88064 DB	'LDY', 00H
$SG88065 DB	'LDA', 00H
$SG88066 DB	'LDX', 00H
$SG88067 DB	'LAX', 00H
$SG88068 DB	'BCS', 00H
$SG88069 DB	'LDA', 00H
$SG88070 DB	'KIL', 00H
$SG88071 DB	'LAX', 00H
$SG88072 DB	'LDY', 00H
$SG88073 DB	'LDA', 00H
$SG88074 DB	'LDX', 00H
$SG88075 DB	'LAX', 00H
$SG88076 DB	'CLV', 00H
$SG88077 DB	'LDA', 00H
$SG88078 DB	'TSX', 00H
$SG88079 DB	'LAS', 00H
$SG88080 DB	'LDY', 00H
$SG88081 DB	'LDA', 00H
$SG88082 DB	'LDX', 00H
$SG88083 DB	'LAX', 00H
$SG88084 DB	'CPY', 00H
$SG88085 DB	'CMP', 00H
$SG88086 DB	'NOP', 00H
$SG88087 DB	'DCP', 00H
$SG88088 DB	'CPY', 00H
$SG88089 DB	'CMP', 00H
$SG88090 DB	'DEC', 00H
$SG88091 DB	'DCP', 00H
$SG88092 DB	'INY', 00H
$SG88093 DB	'CMP', 00H
$SG88094 DB	'DEX', 00H
$SG88095 DB	'AXS', 00H
$SG88096 DB	'CPY', 00H
$SG88097 DB	'CMP', 00H
$SG88098 DB	'DEC', 00H
$SG88099 DB	'DCP', 00H
$SG88100 DB	'BNE', 00H
$SG88101 DB	'CMP', 00H
$SG88102 DB	'KIL', 00H
$SG88103 DB	'DCP', 00H
$SG88104 DB	'NOP', 00H
$SG88105 DB	'CMP', 00H
$SG88106 DB	'DEC', 00H
$SG88107 DB	'DCP', 00H
$SG88108 DB	'CLD', 00H
$SG88109 DB	'CMP', 00H
$SG88110 DB	'NOP', 00H
$SG88111 DB	'DCP', 00H
$SG88112 DB	'NOP', 00H
$SG88113 DB	'CMP', 00H
$SG88114 DB	'DEC', 00H
$SG88115 DB	'DCP', 00H
$SG88116 DB	'CPX', 00H
$SG88117 DB	'SBC', 00H
$SG88118 DB	'NOP', 00H
$SG88119 DB	'ISC', 00H
$SG88120 DB	'CPX', 00H
$SG88121 DB	'SBC', 00H
$SG88122 DB	'INC', 00H
$SG88123 DB	'ISC', 00H
$SG88124 DB	'INX', 00H
$SG88125 DB	'SBC', 00H
$SG88126 DB	'NOP', 00H
$SG88127 DB	'SBC', 00H
$SG88128 DB	'CPX', 00H
$SG88129 DB	'SBC', 00H
$SG88130 DB	'INC', 00H
$SG88131 DB	'ISC', 00H
$SG88132 DB	'BEQ', 00H
$SG88133 DB	'SBC', 00H
$SG88134 DB	'KIL', 00H
$SG88135 DB	'ISC', 00H
$SG88136 DB	'NOP', 00H
$SG88137 DB	'SBC', 00H
$SG88138 DB	'INC', 00H
$SG88139 DB	'ISC', 00H
$SG88140 DB	'SED', 00H
$SG88141 DB	'SBC', 00H
$SG88142 DB	'NOP', 00H
$SG88143 DB	'ISC', 00H
$SG88144 DB	'NOP', 00H
$SG88145 DB	'SBC', 00H
$SG88146 DB	'INC', 00H
$SG88147 DB	'ISC', 00H
$SG89256 DB	'NesEmu', 00H
	ORG $+1
$SG89259 DB	'NesEmu', 00H
	ORG $+1
$SG89262 DB	'&Open Rom', 00H
	ORG $+2
$SG88730 DB	'NMI', 00H
$SG89263 DB	'&Close Rom', 00H
	ORG $+1
$SG89264 DB	'&Quit', 00H
	ORG $+2
$SG89265 DB	'&File', 00H
	ORG $+2
$SG88733 DB	'IRQ', 00H
$SG89266 DB	'Balloon Fight.nes', 00H
	ORG $+2
$SG87892 DB	'BRK', 00H
$SG87668 DB	'.nes', 00H, '*.nes', 00H, 00H
$SG87893 DB	'ORA', 00H
$SG87894 DB	'KIL', 00H
$SG87895 DB	'SLO', 00H
$SG87896 DB	'NOP', 00H
$SG87897 DB	'ORA', 00H
$SG87898 DB	'ASL', 00H
$SG87899 DB	'SLO', 00H
$SG87900 DB	'PHP', 00H
$SG87901 DB	'ORA', 00H
$SG87902 DB	'ASL', 00H
$SG87903 DB	'ANC', 00H
$SG87904 DB	'NOP', 00H
$SG87905 DB	'ORA', 00H
$SG87906 DB	'ASL', 00H
$SG87907 DB	'SLO', 00H
$SG87908 DB	'BPL', 00H
$SG87909 DB	'ORA', 00H
$SG87910 DB	'KIL', 00H
$SG87911 DB	'SLO', 00H
$SG87912 DB	'NOP', 00H
$SG87913 DB	'ORA', 00H
$SG87914 DB	'ASL', 00H
$SG87915 DB	'SLO', 00H
$SG87916 DB	'CLC', 00H
$SG87917 DB	'ORA', 00H
$SG87918 DB	'NOP', 00H
$SG87919 DB	'SLO', 00H
$SG87920 DB	'NOP', 00H
$SG87921 DB	'ORA', 00H
$SG87922 DB	'ASL', 00H
$SG87923 DB	'SLO', 00H
$SG87924 DB	'JSR', 00H
$SG87925 DB	'AND', 00H
$SG87926 DB	'KIL', 00H
$SG87927 DB	'RLA', 00H
$SG87928 DB	'BIT', 00H
$SG87929 DB	'AND', 00H
$SG87930 DB	'ROL', 00H
$SG87931 DB	'RLA', 00H
$SG87932 DB	'PLP', 00H
$SG87933 DB	'AND', 00H
$SG87934 DB	'ROL', 00H
$SG87935 DB	'ANC', 00H
$SG87936 DB	'BIT', 00H
$SG87937 DB	'AND', 00H
$SG87938 DB	'ROL', 00H
$SG87939 DB	'RLA', 00H
$SG87940 DB	'BMI', 00H
$SG87941 DB	'AND', 00H
$SG87942 DB	'KIL', 00H
$SG87943 DB	'RLA', 00H
$SG87944 DB	'NOP', 00H
$SG87945 DB	'AND', 00H
$SG87946 DB	'ROL', 00H
$SG87947 DB	'RLA', 00H
$SG87948 DB	'SEC', 00H
$SG87949 DB	'AND', 00H
$SG87950 DB	'NOP', 00H
$SG87951 DB	'RLA', 00H
$SG87952 DB	'NOP', 00H
$SG87953 DB	'AND', 00H
$SG87954 DB	'ROL', 00H
$SG87955 DB	'RLA', 00H
$SG87956 DB	'RTI', 00H
$SG87957 DB	'EOR', 00H
$SG87958 DB	'KIL', 00H
$SG87959 DB	'SRE', 00H
$SG87960 DB	'NOP', 00H
$SG87961 DB	'EOR', 00H
$SG87962 DB	'LSR', 00H
$SG87963 DB	'SRE', 00H
$SG87964 DB	'PHA', 00H
$SG87965 DB	'EOR', 00H
$SG87966 DB	'LSR', 00H
$SG87967 DB	'ALR', 00H
$SG87968 DB	'JMP', 00H
$SG87969 DB	'EOR', 00H
$SG87970 DB	'LSR', 00H
$SG87971 DB	'SRE', 00H
$SG87972 DB	'BVC', 00H
$SG87973 DB	'EOR', 00H
$SG87974 DB	'KIL', 00H
$SG87975 DB	'SRE', 00H
$SG87976 DB	'NOP', 00H
$SG87977 DB	'EOR', 00H
$SG87978 DB	'LSR', 00H
$SG87979 DB	'SRE', 00H
$SG87980 DB	'CLI', 00H
$SG87981 DB	'EOR', 00H
$SG87982 DB	'NOP', 00H
$SG87983 DB	'SRE', 00H
$SG87984 DB	'NOP', 00H
$SG87985 DB	'EOR', 00H
$SG87986 DB	'LSR', 00H
$SG87987 DB	'SRE', 00H
$SG87988 DB	'RTS', 00H
$SG87989 DB	'ADC', 00H
$SG87990 DB	'KIL', 00H
$SG87991 DB	'RRA', 00H
$SG87992 DB	'NOP', 00H
$SG87993 DB	'ADC', 00H
$SG87994 DB	'ROR', 00H
$SG87995 DB	'RRA', 00H
$SG87996 DB	'PLA', 00H
$SG87997 DB	'ADC', 00H
$SG87998 DB	'ROR', 00H
$SG87999 DB	'ARR', 00H
$SG88000 DB	'JMP', 00H
$SG88001 DB	'ADC', 00H
$SG88002 DB	'ROR', 00H
$SG88003 DB	'RRA', 00H
$SG88004 DB	'BVS', 00H
$SG88005 DB	'ADC', 00H
$SG88006 DB	'KIL', 00H
$SG88007 DB	'RRA', 00H
$SG88008 DB	'NOP', 00H
$SG88009 DB	'ADC', 00H
$SG88010 DB	'ROR', 00H
$SG88011 DB	'RRA', 00H
$SG88012 DB	'SEI', 00H
$SG88013 DB	'ADC', 00H
$SG88014 DB	'NOP', 00H
$SG88015 DB	'RRA', 00H
$SG88016 DB	'NOP', 00H
$SG88017 DB	'ADC', 00H
$SG88018 DB	'ROR', 00H
$SG88019 DB	'RRA', 00H
$SG88020 DB	'NOP', 00H
$SG88021 DB	'STA', 00H
$SG88022 DB	'NOP', 00H
$SG88023 DB	'SAX', 00H
$SG88024 DB	'STY', 00H
$SG88025 DB	'STA', 00H
$SG88026 DB	'STX', 00H
$SG88027 DB	'SAX', 00H
$SG88028 DB	'DEY', 00H
$SG88029 DB	'NOP', 00H
$SG88030 DB	'TXA', 00H
$SG88031 DB	'XAA', 00H
$SG88032 DB	'STY', 00H
$SG88033 DB	'STA', 00H
$SG88034 DB	'STX', 00H
$SG88035 DB	'SAX', 00H
$SG88036 DB	'BCC', 00H
$SG88037 DB	'STA', 00H
$SG88038 DB	'KIL', 00H
$SG88039 DB	'AHX', 00H
$SG88040 DB	'STY', 00H
$SG88041 DB	'STA', 00H
$SG88042 DB	'STX', 00H
$SG88043 DB	'SAX', 00H
$SG88044 DB	'TYA', 00H
$SG88045 DB	'STA', 00H
$SG88046 DB	'TXS', 00H
$SG88047 DB	'TAS', 00H
$SG88048 DB	'SHY', 00H
$SG88049 DB	'STA', 00H
$SG88050 DB	'SHX', 00H
$SG88051 DB	'AHX', 00H
$SG88052 DB	'LDY', 00H
$SG88053 DB	'LDA', 00H
$SG88054 DB	'LDX', 00H
$SG88055 DB	'LAX', 00H
$SG88056 DB	'LDY', 00H
$SG88057 DB	'LDA', 00H
$SG88058 DB	'LDX', 00H
$SG88059 DB	'LAX', 00H
$SG88060 DB	'TAY', 00H
$SG88061 DB	'LDA', 00H
$SG88062 DB	'TAX', 00H
$SG88063 DB	'LAX', 00H
CONST	ENDS
PUBLIC	WinMain
PUBLIC	?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z	; WinInputCallback
PUBLIC	?setCarry@@YAXPEAE@Z				; setCarry
PUBLIC	?clearCarry@@YAXPEAE@Z				; clearCarry
PUBLIC	?setInterrupt@@YAXPEAE@Z			; setInterrupt
PUBLIC	?clearInterrupt@@YAXPEAE@Z			; clearInterrupt
PUBLIC	?setDecimal@@YAXPEAE@Z				; setDecimal
PUBLIC	?clearDecimal@@YAXPEAE@Z			; clearDecimal
PUBLIC	?setBreak@@YAXPEAE@Z				; setBreak
PUBLIC	?clearBreak@@YAXPEAE@Z				; clearBreak
PUBLIC	?setBlank@@YAXPEAE@Z				; setBlank
PUBLIC	?setOverflow@@YAXPEAE@Z				; setOverflow
PUBLIC	?clearOverflow@@YAXPEAE@Z			; clearOverflow
PUBLIC	?setZero@@YAXEPEAE@Z				; setZero
PUBLIC	?setNegative@@YAXEPEAE@Z			; setNegative
PUBLIC	?isBitSet@@YAHEE@Z				; isBitSet
PUBLIC	?crossedPageCheck@@YAHGG@Z			; crossedPageCheck
PUBLIC	?getPaletteValue@@YAXEPEAE@Z			; getPaletteValue
PUBLIC	?drawPixel@@YAXPEAUppu@@GGPEAE@Z		; drawPixel
PUBLIC	?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z	; ppuTick
PUBLIC	__real@408f400000000000
PUBLIC	__real@447a0000
PUBLIC	__real@49da7a66
PUBLIC	__real@5f800000
EXTRN	__report_rangecheckfailure:PROC
EXTRN	memset:PROC
EXTRN	strlen:PROC
EXTRN	__imp_CreateFileA:PROC
EXTRN	__imp_GetFileSizeEx:PROC
EXTRN	__imp_ReadFile:PROC
EXTRN	__imp_QueryPerformanceCounter:PROC
EXTRN	__imp_QueryPerformanceFrequency:PROC
EXTRN	__imp_VirtualAlloc:PROC
EXTRN	__imp_VirtualFree:PROC
EXTRN	__imp_StretchDIBits:PROC
EXTRN	__imp_TranslateMessage:PROC
EXTRN	__imp_DispatchMessageA:PROC
EXTRN	__imp_PeekMessageA:PROC
EXTRN	__imp_DefWindowProcA:PROC
EXTRN	__imp_RegisterClassA:PROC
EXTRN	__imp_CreateWindowExA:PROC
EXTRN	__imp_SetMenu:PROC
EXTRN	__imp_CreateMenu:PROC
EXTRN	__imp_CreatePopupMenu:PROC
EXTRN	__imp_AppendMenuA:PROC
EXTRN	__imp_GetDC:PROC
EXTRN	__imp_ReleaseDC:PROC
EXTRN	__imp_GetClientRect:PROC
EXTRN	__imp_GetOpenFileNameA:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_BSS	SEGMENT
?GlobalRunning@@3HA DD 01H DUP (?)			; GlobalRunning
?RomFileName@@3PADA DB 0100H DUP (?)			; RomFileName
_BSS	ENDS
pdata	SEGMENT
$pdata$WinMain DD imagerel $LN21
	DD	imagerel $LN21+1717
	DD	imagerel $unwind$WinMain
$pdata$?getMilliSeconds@@YAM_K@Z DD imagerel ?getMilliSeconds@@YAM_K@Z
	DD	imagerel ?getMilliSeconds@@YAM_K@Z+112
	DD	imagerel $unwind$?getMilliSeconds@@YAM_K@Z
$pdata$?cpyMemory@@YAXPEAE0G@Z DD imagerel ?cpyMemory@@YAXPEAE0G@Z
	DD	imagerel ?cpyMemory@@YAXPEAE0G@Z+85
	DD	imagerel $unwind$?cpyMemory@@YAXPEAE0G@Z
$pdata$?write8@@YAXEG_K@Z DD imagerel ?write8@@YAXEG_K@Z
	DD	imagerel ?write8@@YAXEG_K@Z+48
	DD	imagerel $unwind$?write8@@YAXEG_K@Z
$pdata$?read8@@YAEG_K@Z DD imagerel ?read8@@YAEG_K@Z
	DD	imagerel ?read8@@YAEG_K@Z+49
	DD	imagerel $unwind$?read8@@YAEG_K@Z
$pdata$?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z DD imagerel $LN60
	DD	imagerel $LN60+1495
	DD	imagerel $unwind$?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z
$pdata$?LoadFile@@YAPEAXPEADPEAI@Z DD imagerel ?LoadFile@@YAPEAXPEADPEAI@Z
	DD	imagerel ?LoadFile@@YAPEAXPEADPEAI@Z+239
	DD	imagerel $unwind$?LoadFile@@YAPEAXPEADPEAI@Z
$pdata$?readCpu8@@YAEGPEAUcpu@@@Z DD imagerel ?readCpu8@@YAEGPEAUcpu@@@Z
	DD	imagerel ?readCpu8@@YAEGPEAUcpu@@@Z+525
	DD	imagerel $unwind$?readCpu8@@YAEGPEAUcpu@@@Z
$pdata$?writeCpu8@@YAXEGPEAUcpu@@@Z DD imagerel ?writeCpu8@@YAXEGPEAUcpu@@@Z
	DD	imagerel ?writeCpu8@@YAXEGPEAUcpu@@@Z+736
	DD	imagerel $unwind$?writeCpu8@@YAXEGPEAUcpu@@@Z
$pdata$?readCpu16@@YAGGPEAUcpu@@@Z DD imagerel ?readCpu16@@YAGGPEAUcpu@@@Z
	DD	imagerel ?readCpu16@@YAGGPEAUcpu@@@Z+87
	DD	imagerel $unwind$?readCpu16@@YAGGPEAUcpu@@@Z
$pdata$?bugReadCpu16@@YAGGPEAUcpu@@@Z DD imagerel ?bugReadCpu16@@YAGGPEAUcpu@@@Z
	DD	imagerel ?bugReadCpu16@@YAGGPEAUcpu@@@Z+109
	DD	imagerel $unwind$?bugReadCpu16@@YAGGPEAUcpu@@@Z
$pdata$?push@@YAXEPEAUcpu@@@Z DD imagerel ?push@@YAXEPEAUcpu@@@Z
	DD	imagerel ?push@@YAXEPEAUcpu@@@Z+68
	DD	imagerel $unwind$?push@@YAXEPEAUcpu@@@Z
$pdata$?pop@@YAEPEAUcpu@@@Z DD imagerel ?pop@@YAEPEAUcpu@@@Z
	DD	imagerel ?pop@@YAEPEAUcpu@@@Z+68
	DD	imagerel $unwind$?pop@@YAEPEAUcpu@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?crossedPageCheck@@YAHGG@Z DD imagerel $LN5
	DD	imagerel $LN5+63
	DD	imagerel $unwind$?crossedPageCheck@@YAHGG@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?adc@@YAEGPEAUcpu@@E@Z DD imagerel $LN7
	DD	imagerel $LN7+281
	DD	imagerel $unwind$?adc@@YAEGPEAUcpu@@E@Z
$pdata$?AND@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+117
	DD	imagerel $unwind$?AND@@YAEGPEAUcpu@@E@Z
$pdata$?asl@@YAEGPEAUcpu@@E@Z DD imagerel $LN9
	DD	imagerel $LN9+266
	DD	imagerel $unwind$?asl@@YAEGPEAUcpu@@E@Z
$pdata$?bcc@@YAEGPEAUcpu@@E@Z DD imagerel $LN6
	DD	imagerel $LN6+120
	DD	imagerel $unwind$?bcc@@YAEGPEAUcpu@@E@Z
$pdata$?bcs@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bcs@@YAEGPEAUcpu@@E@Z
$pdata$?beq@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?beq@@YAEGPEAUcpu@@E@Z
$pdata$?bit@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+147
	DD	imagerel $unwind$?bit@@YAEGPEAUcpu@@E@Z
$pdata$?bmi@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bmi@@YAEGPEAUcpu@@E@Z
$pdata$?bne@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bne@@YAEGPEAUcpu@@E@Z
$pdata$?bpl@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bpl@@YAEGPEAUcpu@@E@Z
$pdata$?brk@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+178
	DD	imagerel $unwind$?brk@@YAEGPEAUcpu@@E@Z
$pdata$?bvc@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bvc@@YAEGPEAUcpu@@E@Z
$pdata$?bvs@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$?bvs@@YAEGPEAUcpu@@E@Z
$pdata$?clc@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?clc@@YAEGPEAUcpu@@E@Z
$pdata$?cld@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?cld@@YAEGPEAUcpu@@E@Z
$pdata$?cli@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?cli@@YAEGPEAUcpu@@E@Z
$pdata$?clv@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?clv@@YAEGPEAUcpu@@E@Z
$pdata$?cmp@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+161
	DD	imagerel $unwind$?cmp@@YAEGPEAUcpu@@E@Z
$pdata$?cpx@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+163
	DD	imagerel $unwind$?cpx@@YAEGPEAUcpu@@E@Z
$pdata$?cpy@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+163
	DD	imagerel $unwind$?cpy@@YAEGPEAUcpu@@E@Z
$pdata$?dec@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+114
	DD	imagerel $unwind$?dec@@YAEGPEAUcpu@@E@Z
$pdata$?dex@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?dex@@YAEGPEAUcpu@@E@Z
$pdata$?dey@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?dey@@YAEGPEAUcpu@@E@Z
$pdata$?eor@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+117
	DD	imagerel $unwind$?eor@@YAEGPEAUcpu@@E@Z
$pdata$?inc@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+114
	DD	imagerel $unwind$?inc@@YAEGPEAUcpu@@E@Z
$pdata$?inx@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?inx@@YAEGPEAUcpu@@E@Z
$pdata$?iny@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?iny@@YAEGPEAUcpu@@E@Z
$pdata$?jsr@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$?jsr@@YAEGPEAUcpu@@E@Z
$pdata$?lda@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+101
	DD	imagerel $unwind$?lda@@YAEGPEAUcpu@@E@Z
$pdata$?ldx@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+102
	DD	imagerel $unwind$?ldx@@YAEGPEAUcpu@@E@Z
$pdata$?ldy@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+102
	DD	imagerel $unwind$?ldy@@YAEGPEAUcpu@@E@Z
$pdata$?lsr@@YAEGPEAUcpu@@E@Z DD imagerel $LN9
	DD	imagerel $LN9+265
	DD	imagerel $unwind$?lsr@@YAEGPEAUcpu@@E@Z
$pdata$?ora@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+117
	DD	imagerel $unwind$?ora@@YAEGPEAUcpu@@E@Z
$pdata$?pha@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?pha@@YAEGPEAUcpu@@E@Z
$pdata$?php@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?php@@YAEGPEAUcpu@@E@Z
$pdata$?pla@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$?pla@@YAEGPEAUcpu@@E@Z
$pdata$?plp@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?plp@@YAEGPEAUcpu@@E@Z
$pdata$?rol@@YAEGPEAUcpu@@E@Z DD imagerel $LN11
	DD	imagerel $LN11+328
	DD	imagerel $unwind$?rol@@YAEGPEAUcpu@@E@Z
$pdata$?ror@@YAEGPEAUcpu@@E@Z DD imagerel $LN11
	DD	imagerel $LN11+326
	DD	imagerel $unwind$?ror@@YAEGPEAUcpu@@E@Z
$pdata$?rti@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+105
	DD	imagerel $unwind$?rti@@YAEGPEAUcpu@@E@Z
$pdata$?rts@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$?rts@@YAEGPEAUcpu@@E@Z
$pdata$?sbc@@YAEGPEAUcpu@@E@Z DD imagerel $LN7
	DD	imagerel $LN7+286
	DD	imagerel $unwind$?sbc@@YAEGPEAUcpu@@E@Z
$pdata$?sec@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?sec@@YAEGPEAUcpu@@E@Z
$pdata$?sed@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?sed@@YAEGPEAUcpu@@E@Z
$pdata$?sei@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?sei@@YAEGPEAUcpu@@E@Z
$pdata$?sta@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?sta@@YAEGPEAUcpu@@E@Z
$pdata$?stx@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$?stx@@YAEGPEAUcpu@@E@Z
$pdata$?sty@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$?sty@@YAEGPEAUcpu@@E@Z
$pdata$?tax@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+94
	DD	imagerel $unwind$?tax@@YAEGPEAUcpu@@E@Z
$pdata$?tay@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+94
	DD	imagerel $unwind$?tay@@YAEGPEAUcpu@@E@Z
$pdata$?tsx@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$?tsx@@YAEGPEAUcpu@@E@Z
$pdata$?txa@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+92
	DD	imagerel $unwind$?txa@@YAEGPEAUcpu@@E@Z
$pdata$?tya@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+92
	DD	imagerel $unwind$?tya@@YAEGPEAUcpu@@E@Z
$pdata$?alr@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?alr@@YAEGPEAUcpu@@E@Z
$pdata$?anc@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+103
	DD	imagerel $unwind$?anc@@YAEGPEAUcpu@@E@Z
$pdata$?arr@@YAEGPEAUcpu@@E@Z DD imagerel $LN9
	DD	imagerel $LN9+262
	DD	imagerel $unwind$?arr@@YAEGPEAUcpu@@E@Z
$pdata$?axs@@YAEGPEAUcpu@@E@Z DD imagerel $LN5
	DD	imagerel $LN5+190
	DD	imagerel $unwind$?axs@@YAEGPEAUcpu@@E@Z
$pdata$?dcp@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?dcp@@YAEGPEAUcpu@@E@Z
$pdata$?isc@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?isc@@YAEGPEAUcpu@@E@Z
$pdata$?lax@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?lax@@YAEGPEAUcpu@@E@Z
$pdata$?rla@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?rla@@YAEGPEAUcpu@@E@Z
$pdata$?rra@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?rra@@YAEGPEAUcpu@@E@Z
$pdata$?sax@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$?sax@@YAEGPEAUcpu@@E@Z
$pdata$?shy@@YAEGPEAUcpu@@E@Z DD imagerel $LN4
	DD	imagerel $LN4+127
	DD	imagerel $unwind$?shy@@YAEGPEAUcpu@@E@Z
$pdata$?slo@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?slo@@YAEGPEAUcpu@@E@Z
$pdata$?sre@@YAEGPEAUcpu@@E@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?sre@@YAEGPEAUcpu@@E@Z
$pdata$?nmi_irq@@YAEGPEAUcpu@@E@Z DD imagerel ?nmi_irq@@YAEGPEAUcpu@@E@Z
	DD	imagerel ?nmi_irq@@YAEGPEAUcpu@@E@Z+162
	DD	imagerel $unwind$?nmi_irq@@YAEGPEAUcpu@@E@Z
$pdata$?cpuTick@@YAEPEAUcpu@@PEAUinput@@@Z DD imagerel ?cpuTick@@YAEPEAUcpu@@PEAUinput@@@Z
	DD	imagerel ?cpuTick@@YAEPEAUcpu@@PEAUinput@@@Z+1580
	DD	imagerel $unwind$?cpuTick@@YAEPEAUcpu@@PEAUinput@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?drawPixel@@YAXPEAUppu@@GGPEAE@Z DD imagerel $LN3
	DD	imagerel $LN3+139
	DD	imagerel $unwind$?drawPixel@@YAXPEAUppu@@GGPEAE@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?readPpu8@@YAEG_K@Z DD imagerel ?readPpu8@@YAEG_K@Z
	DD	imagerel ?readPpu8@@YAEG_K@Z+186
	DD	imagerel $unwind$?readPpu8@@YAEG_K@Z
$pdata$?writePpu8@@YAXEG_K@Z DD imagerel ?writePpu8@@YAXEG_K@Z
	DD	imagerel ?writePpu8@@YAXEG_K@Z+186
	DD	imagerel $unwind$?writePpu8@@YAXEG_K@Z
$pdata$?getNameTableValue@@YAEGGG_K@Z DD imagerel ?getNameTableValue@@YAEGGG_K@Z
	DD	imagerel ?getNameTableValue@@YAEGGG_K@Z+179
	DD	imagerel $unwind$?getNameTableValue@@YAEGGG_K@Z
$pdata$?getPatternValue@@YAEGGEG_K@Z DD imagerel ?getPatternValue@@YAEGGEG_K@Z
	DD	imagerel ?getPatternValue@@YAEGGEG_K@Z+307
	DD	imagerel $unwind$?getPatternValue@@YAEGGEG_K@Z
$pdata$?getAttributeValue@@YAEGGG_K@Z DD imagerel ?getAttributeValue@@YAEGGG_K@Z
	DD	imagerel ?getAttributeValue@@YAEGGG_K@Z+291
	DD	imagerel $unwind$?getAttributeValue@@YAEGGG_K@Z
$pdata$?evaluateSecondaryOam@@YAXPEAEPEAUoam_sprite@@G@Z DD imagerel ?evaluateSecondaryOam@@YAXPEAEPEAUoam_sprite@@G@Z
	DD	imagerel ?evaluateSecondaryOam@@YAXPEAEPEAUoam_sprite@@G@Z+226
	DD	imagerel $unwind$?evaluateSecondaryOam@@YAXPEAEPEAUoam_sprite@@G@Z
$pdata$?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z DD imagerel $LN81
	DD	imagerel $LN81+3434
	DD	imagerel $unwind$?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z
$pdata$?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z DD imagerel ?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z
	DD	imagerel ?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z+108
	DD	imagerel $unwind$?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z
$pdata$?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z DD imagerel ?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z
	DD	imagerel ?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z+262
	DD	imagerel $unwind$?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z
$pdata$?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z DD imagerel ?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z
	DD	imagerel ?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z+165
	DD	imagerel $unwind$?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z
$pdata$?nromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z DD imagerel $LN7
	DD	imagerel $LN7+241
	DD	imagerel $unwind$?nromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z
$pdata$?mmc1Init@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z DD imagerel $LN3
	DD	imagerel $LN3+156
	DD	imagerel $unwind$?mmc1Init@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z
$pdata$?unromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z DD imagerel $LN3
	DD	imagerel $LN3+156
	DD	imagerel $unwind$?unromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z
$pdata$?mmc1Update@@YAXPEAUcpu@@PEAUcartridge@@@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$?mmc1Update@@YAXPEAUcpu@@PEAUcartridge@@@Z
$pdata$?unromUpdate@@YAXPEAUcpu@@PEAUcartridge@@@Z DD imagerel $LN3
	DD	imagerel $LN3+100
	DD	imagerel $unwind$?unromUpdate@@YAXPEAUcpu@@PEAUcartridge@@@Z
$pdata$?loadCartridge@@YAXPEAUcartridge@@PEADPEAUcpu@@PEAUppu@@@Z DD imagerel ?loadCartridge@@YAXPEAUcartridge@@PEADPEAUcpu@@PEAUppu@@@Z
	DD	imagerel ?loadCartridge@@YAXPEAUcartridge@@PEADPEAUcpu@@PEAUppu@@@Z+584
	DD	imagerel $unwind$?loadCartridge@@YAXPEAUcartridge@@PEADPEAUcpu@@PEAUppu@@@Z
$pdata$?power@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z DD imagerel ?power@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z
	DD	imagerel ?power@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z+404
	DD	imagerel $unwind$?power@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z
$pdata$?reset@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z DD imagerel ?reset@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z
	DD	imagerel ?reset@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z+84
	DD	imagerel $unwind$?reset@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z
pdata	ENDS
;	COMDAT __real@5f800000
CONST	SEGMENT
__real@5f800000 DD 05f800000r			; 1.84467e+19
CONST	ENDS
;	COMDAT __real@49da7a66
CONST	SEGMENT
__real@49da7a66 DD 049da7a66r			; 1.78977e+06
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?drawPixel@@YAXPEAUppu@@GGPEAE@Z DD 011901H
	DD	02219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?crossedPageCheck@@YAHGG@Z DD 010e01H
	DD	0220eH
xdata	ENDS
xdata	SEGMENT
$unwind$WinMain DD 032e19H
	DD	084011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0410H
$unwind$?getMilliSeconds@@YAM_K@Z DD 010901H
	DD	08209H
$unwind$?cpyMemory@@YAXPEAE0G@Z DD 011401H
	DD	02214H
$unwind$?write8@@YAXEG_K@Z DD 011201H
	DD	02212H
$unwind$?read8@@YAEG_K@Z DD 010e01H
	DD	0220eH
$unwind$?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z DD 032d19H
	DD	046011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	0220H
$unwind$?LoadFile@@YAPEAXPEADPEAI@Z DD 010e01H
	DD	0c20eH
$unwind$?readCpu8@@YAEGPEAUcpu@@@Z DD 010e01H
	DD	0620eH
$unwind$?writeCpu8@@YAXEGPEAUcpu@@@Z DD 011201H
	DD	06212H
$unwind$?readCpu16@@YAGGPEAUcpu@@@Z DD 010e01H
	DD	0620eH
$unwind$?bugReadCpu16@@YAGGPEAUcpu@@@Z DD 010e01H
	DD	0620eH
$unwind$?push@@YAXEPEAUcpu@@@Z DD 010d01H
	DD	0420dH
$unwind$?pop@@YAEPEAUcpu@@@Z DD 010901H
	DD	06209H
$unwind$?adc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?AND@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?asl@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bcc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bcs@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?beq@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bit@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bmi@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bne@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bpl@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?brk@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bvc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?bvs@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?clc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?cld@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?cli@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?clv@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?cmp@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?cpx@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?cpy@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?dec@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?dex@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?dey@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?eor@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?inc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?inx@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?iny@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?jsr@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?lda@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?ldx@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?ldy@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?lsr@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?ora@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?pha@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?php@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?pla@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?plp@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?rol@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?ror@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?rti@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?rts@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?sbc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?sec@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?sed@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?sei@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?sta@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?stx@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?sty@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?tax@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?tay@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?tsx@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?txa@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?tya@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?alr@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?anc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?arr@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?axs@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?dcp@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?isc@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?lax@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?rla@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?rra@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?sax@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?shy@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?slo@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?sre@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	04213H
$unwind$?nmi_irq@@YAEGPEAUcpu@@E@Z DD 011301H
	DD	06213H
$unwind$?cpuTick@@YAEPEAUcpu@@PEAUinput@@@Z DD 042519H
	DD	01f0113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$?readPpu8@@YAEG_K@Z DD 010e01H
	DD	0620eH
$unwind$?writePpu8@@YAXEG_K@Z DD 011201H
	DD	04212H
$unwind$?getNameTableValue@@YAEGGG_K@Z DD 011901H
	DD	06219H
$unwind$?getPatternValue@@YAEGGEG_K@Z DD 011901H
	DD	08219H
$unwind$?getAttributeValue@@YAEGGG_K@Z DD 011901H
	DD	06219H
$unwind$?evaluateSecondaryOam@@YAXPEAEPEAUoam_sprite@@G@Z DD 021501H
	DD	070113215H
$unwind$?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z DD 031201H
	DD	01c0112H
	DD	0700bH
$unwind$?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z DD 012219H
	DD	08213H
	DD	imagerel __GSHandlerCheck
	DD	030H
$unwind$?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z DD 011401H
	DD	06214H
$unwind$?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z DD 011a01H
	DD	0e21aH
$unwind$?nromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z DD 011301H
	DD	08213H
$unwind$?mmc1Init@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z DD 011301H
	DD	08213H
$unwind$?unromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z DD 011301H
	DD	08213H
$unwind$?mmc1Update@@YAXPEAUcpu@@PEAUcartridge@@@Z DD 010e01H
	DD	0220eH
$unwind$?unromUpdate@@YAXPEAUcpu@@PEAUcartridge@@@Z DD 010e01H
	DD	0620eH
$unwind$?loadCartridge@@YAXPEAUcartridge@@PEADPEAUcpu@@PEAUppu@@@Z DD 011801H
	DD	08218H
$unwind$?power@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z DD 042a19H
	DD	0490118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0230H
$unwind$?reset@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z DD 011301H
	DD	04213H
xdata	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Cpu$ = 48
Ppu$ = 56
Cartridge$ = 64
?reset@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z PROC	; reset

; 608  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 609  :     Cpu->PrgCounter = readCpu16(RESET_VEC, Cpu);

  00013	48 8b 54 24 30	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00018	66 b9 fc ff	 mov	 cx, 65532		; 0000fffcH
  0001c	e8 00 00 00 00	 call	 ?readCpu16@@YAGGPEAUcpu@@@Z ; readCpu16
  00021	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00026	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 610  : 
; 611  :     // NOTE: The status after reset was taken from nesdev
; 612  :     Cpu->StackPtr -= 3;

  0002a	48 8b 44 24 30	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002f	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00033	83 e8 03	 sub	 eax, 3
  00036	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0003b	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 613  :     setInterrupt(&Cpu->Flags);

  0003e	48 8b 44 24 30	 mov	 rax, QWORD PTR Cpu$[rsp]
  00043	48 83 c0 03	 add	 rax, 3
  00047	48 8b c8	 mov	 rcx, rax
  0004a	e8 00 00 00 00	 call	 ?setInterrupt@@YAXPEAE@Z ; setInterrupt

; 614  :     // TODO: APU on reset
; 615  : }

  0004f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00053	c3		 ret	 0
?reset@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z ENDP	; reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
tv65 = 32
MemoryBase$1 = 40
BasePixel$2 = 48
Registers$3 = 56
$T4 = 64
$T5 = 176
__$ArrayPad$ = 560
Cpu$ = 608
Ppu$ = 616
Cartridge$ = 624
?power@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z PROC	; power

; 582  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 48 02
	00 00		 sub	 rsp, 584		; 00000248H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 30
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 583  :     PowerOn = !PowerOn;

  0002a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PowerOn@@3HA, 0
  00031	75 0a		 jne	 SHORT $LN5@power
  00033	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv65[rsp], 1
  0003b	eb 08		 jmp	 SHORT $LN6@power
$LN5@power:
  0003d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv65[rsp], 0
$LN6@power:
  00045	8b 44 24 20	 mov	 eax, DWORD PTR tv65[rsp]
  00049	89 05 00 00 00
	00		 mov	 DWORD PTR ?PowerOn@@3HA, eax

; 584  : 
; 585  :     if(PowerOn)

  0004f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PowerOn@@3HA, 0
  00056	74 46		 je	 SHORT $LN2@power

; 586  :     {
; 587  :         loadCartridge(Cartridge, RomFileName, Cpu, Ppu);

  00058	4c 8b 8c 24 68
	02 00 00	 mov	 r9, QWORD PTR Ppu$[rsp]
  00060	4c 8b 84 24 60
	02 00 00	 mov	 r8, QWORD PTR Cpu$[rsp]
  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?RomFileName@@3PADA
  0006f	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00077	e8 00 00 00 00	 call	 ?loadCartridge@@YAXPEAUcartridge@@PEADPEAUcpu@@PEAUppu@@@Z ; loadCartridge

; 588  :         Cpu->PrgCounter = readCpu16(RESET_VEC, Cpu);        

  0007c	48 8b 94 24 60
	02 00 00	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00084	66 b9 fc ff	 mov	 cx, 65532		; 0000fffcH
  00088	e8 00 00 00 00	 call	 ?readCpu16@@YAGGPEAUcpu@@@Z ; readCpu16
  0008d	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00095	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 589  :     }
; 590  :     else

  00099	e9 dc 00 00 00	 jmp	 $LN3@power
$LN2@power:

; 591  :     {
; 592  :         uint64 MemoryBase = Cpu->MemoryBase;

  0009e	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  000a6	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000aa	48 89 44 24 28	 mov	 QWORD PTR MemoryBase$1[rsp], rax

; 593  :         *Cpu = {};

  000af	48 8d 44 24 40	 lea	 rax, QWORD PTR $T4[rsp]
  000b4	48 8b f8	 mov	 rdi, rax
  000b7	33 c0		 xor	 eax, eax
  000b9	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  000be	f3 aa		 rep stosb
  000c0	48 8d 44 24 40	 lea	 rax, QWORD PTR $T4[rsp]
  000c5	48 8b bc 24 60
	02 00 00	 mov	 rdi, QWORD PTR Cpu$[rsp]
  000cd	48 8b f0	 mov	 rsi, rax
  000d0	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  000d5	f3 a4		 rep movsb

; 594  :         Cpu->MemoryBase = MemoryBase;

  000d7	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  000df	48 8b 4c 24 28	 mov	 rcx, QWORD PTR MemoryBase$1[rsp]
  000e4	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 595  : 
; 596  :         MemoryBase = Ppu->MemoryBase;

  000e8	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  000f0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000f3	48 89 44 24 28	 mov	 QWORD PTR MemoryBase$1[rsp], rax

; 597  :         uint32 *BasePixel = Ppu->BasePixel;

  000f8	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00100	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00104	48 89 44 24 30	 mov	 QWORD PTR BasePixel$2[rsp], rax

; 598  :         ppu_registers *Registers = Ppu->Registers; 

  00109	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00111	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00115	48 89 44 24 38	 mov	 QWORD PTR Registers$3[rsp], rax

; 599  :         *Ppu = {};

  0011a	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR $T5[rsp]
  00122	48 8b f8	 mov	 rdi, rax
  00125	33 c0		 xor	 eax, eax
  00127	b9 80 01 00 00	 mov	 ecx, 384		; 00000180H
  0012c	f3 aa		 rep stosb
  0012e	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR $T5[rsp]
  00136	48 8b bc 24 68
	02 00 00	 mov	 rdi, QWORD PTR Ppu$[rsp]
  0013e	48 8b f0	 mov	 rsi, rax
  00141	b9 80 01 00 00	 mov	 ecx, 384		; 00000180H
  00146	f3 a4		 rep movsb

; 600  :         Ppu->MemoryBase = MemoryBase;

  00148	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00150	48 8b 4c 24 28	 mov	 rcx, QWORD PTR MemoryBase$1[rsp]
  00155	48 89 08	 mov	 QWORD PTR [rax], rcx

; 601  :         Ppu->BasePixel = BasePixel;

  00158	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00160	48 8b 4c 24 30	 mov	 rcx, QWORD PTR BasePixel$2[rsp]
  00165	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 602  :         Ppu->Registers = Registers;

  00169	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00171	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Registers$3[rsp]
  00176	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
$LN3@power:

; 603  :     }
; 604  : }

  0017a	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00182	48 33 cc	 xor	 rcx, rsp
  00185	e8 00 00 00 00	 call	 __security_check_cookie
  0018a	48 81 c4 48 02
	00 00		 add	 rsp, 584		; 00000248H
  00191	5f		 pop	 rdi
  00192	5e		 pop	 rsi
  00193	c3		 ret	 0
?power@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z ENDP	; power
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Flags6$1 = 32
Flags7$2 = 33
RomData$3 = 40
tv175 = 48
Cartridge$ = 80
FileName$ = 88
Cpu$ = 96
Ppu$ = 104
?loadCartridge@@YAXPEAUcartridge@@PEADPEAUcpu@@PEAUppu@@@Z PROC ; loadCartridge

; 533  : {    

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 534  :     // Reading rom file
; 535  :     Cartridge->FileName = FileName;

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR FileName$[rsp]
  00022	48 89 08	 mov	 QWORD PTR [rax], rcx

; 536  :     Cartridge->FileSize;
; 537  :     Cartridge->Data = (uint8 *)LoadFile(FileName, &Cartridge->FileSize);

  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0002a	48 83 c0 08	 add	 rax, 8
  0002e	48 8b d0	 mov	 rdx, rax
  00031	48 8b 4c 24 58	 mov	 rcx, QWORD PTR FileName$[rsp]
  00036	e8 00 00 00 00	 call	 ?LoadFile@@YAPEAXPEADPEAI@Z ; LoadFile
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00040	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 538  : 
; 539  :     if(Cartridge->FileSize == 0)

  00044	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00049	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0004d	75 14		 jne	 SHORT $LN2@loadCartri

; 540  :     {
; 541  :         PowerOn = false;

  0004f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PowerOn@@3HA, 0

; 542  :         return;

  00059	e9 e5 01 00 00	 jmp	 $LN1@loadCartri

; 543  :     }
; 544  :     else

  0005e	e9 e0 01 00 00	 jmp	 $LN3@loadCartri
$LN2@loadCartri:

; 545  :     {
; 546  :         PowerOn = true;

  00063	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?PowerOn@@3HA, 1

; 547  :     
; 548  :         uint8 * RomData = Cartridge->Data;

  0006d	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00072	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00076	48 89 44 24 28	 mov	 QWORD PTR RomData$3[rsp], rax

; 549  :         
; 550  :         // NOTE: Check for correct header
; 551  :         if(RomData[0] != 'N' || RomData[1] != 'E' || RomData[2] != 'S' || RomData[3] != 0x1A)

  0007b	b8 01 00 00 00	 mov	 eax, 1
  00080	48 6b c0 00	 imul	 rax, rax, 0
  00084	48 8b 4c 24 28	 mov	 rcx, QWORD PTR RomData$3[rsp]
  00089	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0008d	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  00090	75 45		 jne	 SHORT $LN5@loadCartri
  00092	b8 01 00 00 00	 mov	 eax, 1
  00097	48 6b c0 01	 imul	 rax, rax, 1
  0009b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR RomData$3[rsp]
  000a0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000a4	83 f8 45	 cmp	 eax, 69			; 00000045H
  000a7	75 2e		 jne	 SHORT $LN5@loadCartri
  000a9	b8 01 00 00 00	 mov	 eax, 1
  000ae	48 6b c0 02	 imul	 rax, rax, 2
  000b2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR RomData$3[rsp]
  000b7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000bb	83 f8 53	 cmp	 eax, 83			; 00000053H
  000be	75 17		 jne	 SHORT $LN5@loadCartri
  000c0	b8 01 00 00 00	 mov	 eax, 1
  000c5	48 6b c0 03	 imul	 rax, rax, 3
  000c9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR RomData$3[rsp]
  000ce	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000d2	83 f8 1a	 cmp	 eax, 26
  000d5	74 12		 je	 SHORT $LN4@loadCartri
$LN5@loadCartri:

; 552  :             Assert(0);   

  000d7	33 c0		 xor	 eax, eax
  000d9	83 f8 01	 cmp	 eax, 1
  000dc	74 0b		 je	 SHORT $LN6@loadCartri
  000de	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN6@loadCartri:
$LN4@loadCartri:

; 553  : 
; 554  :         // NOTE: Read header
; 555  :         Cartridge->PrgBankCount = RomData[4];

  000e9	b8 01 00 00 00	 mov	 eax, 1
  000ee	48 6b c0 04	 imul	 rax, rax, 4
  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  000f7	48 8b 54 24 28	 mov	 rdx, QWORD PTR RomData$3[rsp]
  000fc	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00100	88 41 18	 mov	 BYTE PTR [rcx+24], al

; 556  :         Cartridge->ChrBankCount = RomData[5];

  00103	b8 01 00 00 00	 mov	 eax, 1
  00108	48 6b c0 05	 imul	 rax, rax, 5
  0010c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00111	48 8b 54 24 28	 mov	 rdx, QWORD PTR RomData$3[rsp]
  00116	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  0011a	88 41 28	 mov	 BYTE PTR [rcx+40], al

; 557  :         uint8 Flags6            = RomData[6];        

  0011d	b8 01 00 00 00	 mov	 eax, 1
  00122	48 6b c0 06	 imul	 rax, rax, 6
  00126	48 8b 4c 24 28	 mov	 rcx, QWORD PTR RomData$3[rsp]
  0012b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0012f	88 44 24 20	 mov	 BYTE PTR Flags6$1[rsp], al

; 558  :         uint8 Flags7            = RomData[7];

  00133	b8 01 00 00 00	 mov	 eax, 1
  00138	48 6b c0 07	 imul	 rax, rax, 7
  0013c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR RomData$3[rsp]
  00141	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00145	88 44 24 21	 mov	 BYTE PTR Flags7$2[rsp], al

; 559  :         Cartridge->PrgRamSize   = RomData[8];

  00149	b8 01 00 00 00	 mov	 eax, 1
  0014e	48 6b c0 08	 imul	 rax, rax, 8
  00152	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00157	48 8b 54 24 28	 mov	 rdx, QWORD PTR RomData$3[rsp]
  0015c	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00160	88 41 38	 mov	 BYTE PTR [rcx+56], al

; 560  :         
; 561  :         Cartridge->UseVertMirror       = Flags6 & (1);

  00163	0f b6 44 24 20	 movzx	 eax, BYTE PTR Flags6$1[rsp]
  00168	83 e0 01	 and	 eax, 1
  0016b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00170	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 562  :         Cartridge->HasBatteryRam       = Flags6 & (1 << 1);

  00173	0f b6 44 24 20	 movzx	 eax, BYTE PTR Flags6$1[rsp]
  00178	83 e0 02	 and	 eax, 2
  0017b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00180	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 563  :         Cartridge->HasTrainer          = Flags6 & (1 << 2);

  00183	0f b6 44 24 20	 movzx	 eax, BYTE PTR Flags6$1[rsp]
  00188	83 e0 04	 and	 eax, 4
  0018b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00190	89 41 44	 mov	 DWORD PTR [rcx+68], eax

; 564  :         Cartridge->UseFourScreenMirror = Flags6 & (1 << 3);

  00193	0f b6 44 24 20	 movzx	 eax, BYTE PTR Flags6$1[rsp]
  00198	83 e0 08	 and	 eax, 8
  0019b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  001a0	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 565  :         Cartridge->MapperNum           = (Flags7 & 0xF0) | (Flags6 >> 4);

  001a3	0f b6 44 24 21	 movzx	 eax, BYTE PTR Flags7$2[rsp]
  001a8	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  001ad	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Flags6$1[rsp]
  001b2	c1 f9 04	 sar	 ecx, 4
  001b5	0b c1		 or	 eax, ecx
  001b7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  001bc	88 41 39	 mov	 BYTE PTR [rcx+57], al

; 566  : 
; 567  :         Cartridge->PrgData = RomData + 16; // PrgData starts after the header info(16 bytes)

  001bf	48 8b 44 24 28	 mov	 rax, QWORD PTR RomData$3[rsp]
  001c4	48 83 c0 10	 add	 rax, 16
  001c8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  001cd	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 568  : 
; 569  :         if(Cartridge->HasTrainer)

  001d1	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  001d6	83 78 44 00	 cmp	 DWORD PTR [rax+68], 0
  001da	74 18		 je	 SHORT $LN7@loadCartri

; 570  :         {
; 571  :             Cartridge->PrgData += 512; // Trainer size 512 bytes

  001dc	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  001e1	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001e5	48 05 00 02 00
	00		 add	 rax, 512		; 00000200H
  001eb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  001f0	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
$LN7@loadCartri:

; 572  :         }
; 573  : 
; 574  :         Cartridge->ChrData = Cartridge->PrgData + (Cartridge->PrgBankCount * Kilobytes(16));

  001f4	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  001f9	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  001fd	48 69 c0 00 40
	00 00		 imul	 rax, rax, 16384		; 00004000H
  00204	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00209	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0020d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00212	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 575  : 
; 576  :         mapperInit[Cartridge->MapperNum](Cartridge, Cpu, Ppu);

  00216	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0021b	0f b6 40 39	 movzx	 eax, BYTE PTR [rax+57]
  0021f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mapperInit@@3PAP6AXPEAUcartridge@@PEAUcpu@@PEAUppu@@@ZA ; mapperInit
  00226	48 89 4c 24 30	 mov	 QWORD PTR tv175[rsp], rcx
  0022b	4c 8b 44 24 68	 mov	 r8, QWORD PTR Ppu$[rsp]
  00230	48 8b 54 24 60	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00235	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  0023a	4c 8b 4c 24 30	 mov	 r9, QWORD PTR tv175[rsp]
  0023f	41 ff 14 c1	 call	 QWORD PTR [r9+rax*8]
$LN3@loadCartri:
$LN1@loadCartri:

; 577  :     }
; 578  : }

  00243	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00247	c3		 ret	 0
?loadCartridge@@YAXPEAUcartridge@@PEADPEAUcpu@@PEAUppu@@@Z ENDP ; loadCartridge
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
BankNumber$ = 32
MemPrgBank1$ = 36
BankToCpy$ = 40
Cpu$ = 64
Cartridge$ = 72
?unromUpdate@@YAXPEAUcpu@@PEAUcartridge@@@Z PROC	; unromUpdate

; 519  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 520  :     uint16 MemPrgBank1 = 0x8000;

  0000e	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00013	66 89 44 24 24	 mov	 WORD PTR MemPrgBank1$[rsp], ax

; 521  :     uint8 BankNumber = Cpu->MapperReg;

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 40 10	 movzx	 eax, BYTE PTR [rax+16]
  00021	88 44 24 20	 mov	 BYTE PTR BankNumber$[rsp], al

; 522  :     
; 523  :     uint8 * BankToCpy = Cartridge->PrgData + (BankNumber * Kilobytes(16));

  00025	0f b6 44 24 20	 movzx	 eax, BYTE PTR BankNumber$[rsp]
  0002a	48 69 c0 00 40
	00 00		 imul	 rax, rax, 16384		; 00004000H
  00031	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  00036	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0003a	48 89 44 24 28	 mov	 QWORD PTR BankToCpy$[rsp], rax

; 524  :     cpyMemory((uint8 *)MemPrgBank1 + Cpu->MemoryBase, BankToCpy, Kilobytes(16));

  0003f	0f b7 44 24 24	 movzx	 eax, WORD PTR MemPrgBank1$[rsp]
  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00049	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  0004d	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  00052	48 8b 54 24 28	 mov	 rdx, QWORD PTR BankToCpy$[rsp]
  00057	48 8b c8	 mov	 rcx, rax
  0005a	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 525  : }

  0005f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00063	c3		 ret	 0
?unromUpdate@@YAXPEAUcpu@@PEAUcartridge@@@Z ENDP	; unromUpdate
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
MemPrgBank1$ = 0
MemPrgBank2$ = 4
Cpu$ = 32
Cartridge$ = 40
?mmc1Update@@YAXPEAUcpu@@PEAUcartridge@@@Z PROC		; mmc1Update

; 507  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 508  :     uint16 MemPrgBank1 = 0x8000;

  0000e	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00013	66 89 04 24	 mov	 WORD PTR MemPrgBank1$[rsp], ax

; 509  :     uint16 MemPrgBank2 = 0xC000;

  00017	b8 00 c0 00 00	 mov	 eax, 49152		; 0000c000H
  0001c	66 89 44 24 04	 mov	 WORD PTR MemPrgBank2$[rsp], ax

; 510  : /*
; 511  :     uint8 * BankToCpy1 = Cartridge->PrgData;
; 512  :     uint8 * BankToCpy2 = Cartridge->PrgData + ((Cartridge->PrgBankCount - 1) * Kilobytes(16));       
; 513  :     cpyMemory((uint8 *)MemPrgBank1 + Cpu->MemoryBase, BankToCpy1, Kilobytes(16));
; 514  :     cpyMemory((uint8 *)MemPrgBank2 + Cpu->MemoryBase, BankToCpy2, Kilobytes(16));
; 515  : */  
; 516  :  }

  00021	48 83 c4 18	 add	 rsp, 24
  00025	c3		 ret	 0
?mmc1Update@@YAXPEAUcpu@@PEAUcartridge@@@Z ENDP		; mmc1Update
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Cpu$ = 8
Cartridge$ = 16
?nromUpdate@@YAXPEAUcpu@@PEAUcartridge@@@Z PROC		; nromUpdate

; 502  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 503  :     Assert(0);

  0000a	33 c0		 xor	 eax, eax
  0000c	83 f8 01	 cmp	 eax, 1
  0000f	74 0b		 je	 SHORT $LN2@nromUpdate
  00011	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@nromUpdate:

; 504  : }

  0001c	c3		 ret	 0
?nromUpdate@@YAXPEAUcpu@@PEAUcartridge@@@Z ENDP		; nromUpdate
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
MemPrgBank1$ = 32
MemPrgBank2$ = 36
BankToCpy1$ = 40
BankToCpy2$ = 48
Cartridge$ = 80
Cpu$ = 88
Ppu$ = 96
?unromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z PROC	; unromInit

; 482  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 483  :     uint16 MemPrgBank1 = 0x8000;

  00013	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00018	66 89 44 24 20	 mov	 WORD PTR MemPrgBank1$[rsp], ax

; 484  :     uint16 MemPrgBank2 = 0xC000;

  0001d	b8 00 c0 00 00	 mov	 eax, 49152		; 0000c000H
  00022	66 89 44 24 24	 mov	 WORD PTR MemPrgBank2$[rsp], ax

; 485  : 
; 486  :     uint8 * BankToCpy1 = Cartridge->PrgData;

  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0002c	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00030	48 89 44 24 28	 mov	 QWORD PTR BankToCpy1$[rsp], rax

; 487  :     uint8 * BankToCpy2 = Cartridge->PrgData + ((Cartridge->PrgBankCount - 1) * Kilobytes(16));

  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0003a	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  0003e	ff c8		 dec	 eax
  00040	48 98		 cdqe
  00042	48 69 c0 00 40
	00 00		 imul	 rax, rax, 16384		; 00004000H
  00049	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  0004e	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00052	48 89 44 24 30	 mov	 QWORD PTR BankToCpy2$[rsp], rax

; 488  :            
; 489  :     cpyMemory((uint8 *)MemPrgBank1 + Cpu->MemoryBase, BankToCpy1, Kilobytes(16));

  00057	0f b7 44 24 20	 movzx	 eax, WORD PTR MemPrgBank1$[rsp]
  0005c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00061	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00065	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  0006a	48 8b 54 24 28	 mov	 rdx, QWORD PTR BankToCpy1$[rsp]
  0006f	48 8b c8	 mov	 rcx, rax
  00072	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 490  :     cpyMemory((uint8 *)MemPrgBank2 + Cpu->MemoryBase, BankToCpy2, Kilobytes(16));

  00077	0f b7 44 24 24	 movzx	 eax, WORD PTR MemPrgBank2$[rsp]
  0007c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00081	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00085	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  0008a	48 8b 54 24 30	 mov	 rdx, QWORD PTR BankToCpy2$[rsp]
  0008f	48 8b c8	 mov	 rcx, rax
  00092	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 491  : }

  00097	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009b	c3		 ret	 0
?unromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ENDP	; unromInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
MemPrgBank1$ = 32
MemPrgBank2$ = 36
BankToCpy1$ = 40
BankToCpy2$ = 48
Cartridge$ = 80
Cpu$ = 88
Ppu$ = 96
?mmc1Init@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z PROC	; mmc1Init

; 470  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 471  :     uint16 MemPrgBank1 = 0x8000;

  00013	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00018	66 89 44 24 20	 mov	 WORD PTR MemPrgBank1$[rsp], ax

; 472  :     uint16 MemPrgBank2 = 0xC000;

  0001d	b8 00 c0 00 00	 mov	 eax, 49152		; 0000c000H
  00022	66 89 44 24 24	 mov	 WORD PTR MemPrgBank2$[rsp], ax

; 473  : 
; 474  :     uint8 * BankToCpy1 = Cartridge->PrgData;

  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0002c	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00030	48 89 44 24 28	 mov	 QWORD PTR BankToCpy1$[rsp], rax

; 475  :     uint8 * BankToCpy2 = Cartridge->PrgData + ((Cartridge->PrgBankCount - 1) * Kilobytes(16));

  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0003a	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  0003e	ff c8		 dec	 eax
  00040	48 98		 cdqe
  00042	48 69 c0 00 40
	00 00		 imul	 rax, rax, 16384		; 00004000H
  00049	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cartridge$[rsp]
  0004e	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00052	48 89 44 24 30	 mov	 QWORD PTR BankToCpy2$[rsp], rax

; 476  :            
; 477  :     cpyMemory((uint8 *)MemPrgBank1 + Cpu->MemoryBase, BankToCpy1, Kilobytes(16));

  00057	0f b7 44 24 20	 movzx	 eax, WORD PTR MemPrgBank1$[rsp]
  0005c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00061	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00065	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  0006a	48 8b 54 24 28	 mov	 rdx, QWORD PTR BankToCpy1$[rsp]
  0006f	48 8b c8	 mov	 rcx, rax
  00072	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 478  :     cpyMemory((uint8 *)MemPrgBank2 + Cpu->MemoryBase, BankToCpy2, Kilobytes(16));

  00077	0f b7 44 24 24	 movzx	 eax, WORD PTR MemPrgBank2$[rsp]
  0007c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00081	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00085	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  0008a	48 8b 54 24 30	 mov	 rdx, QWORD PTR BankToCpy2$[rsp]
  0008f	48 8b c8	 mov	 rcx, rax
  00092	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 479  :  }

  00097	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009b	c3		 ret	 0
?mmc1Init@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ENDP	; mmc1Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
MemPrgBank1$ = 32
MemPrgBank2$ = 36
BankToCpy1$ = 40
BankToCpy2$ = 48
Cartridge$ = 80
Cpu$ = 88
Ppu$ = 96
?nromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z PROC	; nromInit

; 441  : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 442  :     uint16 MemPrgBank1 = 0x8000;

  00013	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00018	66 89 44 24 20	 mov	 WORD PTR MemPrgBank1$[rsp], ax

; 443  :     uint16 MemPrgBank2 = 0xC000;

  0001d	b8 00 c0 00 00	 mov	 eax, 49152		; 0000c000H
  00022	66 89 44 24 24	 mov	 WORD PTR MemPrgBank2$[rsp], ax

; 444  : 
; 445  :     uint8 * BankToCpy1;
; 446  :     uint8 * BankToCpy2;
; 447  :         
; 448  :     if(Cartridge->PrgBankCount == 1)

  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0002c	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  00030	83 f8 01	 cmp	 eax, 1
  00033	75 1e		 jne	 SHORT $LN2@nromInit

; 449  :     {
; 450  :         BankToCpy1 = Cartridge->PrgData;

  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  0003a	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0003e	48 89 44 24 28	 mov	 QWORD PTR BankToCpy1$[rsp], rax

; 451  :         BankToCpy2 = Cartridge->PrgData;

  00043	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00048	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0004c	48 89 44 24 30	 mov	 QWORD PTR BankToCpy2$[rsp], rax
  00051	eb 30		 jmp	 SHORT $LN3@nromInit
$LN2@nromInit:

; 452  :     }
; 453  :     else if(Cartridge->PrgBankCount == 2)

  00053	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00058	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  0005c	83 f8 02	 cmp	 eax, 2
  0005f	75 22		 jne	 SHORT $LN4@nromInit

; 454  :     {
; 455  :         BankToCpy1 = Cartridge->PrgData;

  00061	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00066	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0006a	48 89 44 24 28	 mov	 QWORD PTR BankToCpy1$[rsp], rax

; 456  :         BankToCpy2 = Cartridge->PrgData + Kilobytes(16);

  0006f	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  00074	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00078	48 05 00 40 00
	00		 add	 rax, 16384		; 00004000H
  0007e	48 89 44 24 30	 mov	 QWORD PTR BankToCpy2$[rsp], rax
$LN4@nromInit:
$LN3@nromInit:

; 457  :     }
; 458  :         
; 459  :     cpyMemory((uint8 *)MemPrgBank1 + Cpu->MemoryBase, BankToCpy1, Kilobytes(16));

  00083	0f b7 44 24 20	 movzx	 eax, WORD PTR MemPrgBank1$[rsp]
  00088	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0008d	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00091	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  00096	48 8b 54 24 28	 mov	 rdx, QWORD PTR BankToCpy1$[rsp]
  0009b	48 8b c8	 mov	 rcx, rax
  0009e	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 460  :     cpyMemory((uint8 *)MemPrgBank2 + Cpu->MemoryBase, BankToCpy2, Kilobytes(16));

  000a3	0f b7 44 24 24	 movzx	 eax, WORD PTR MemPrgBank2$[rsp]
  000a8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Cpu$[rsp]
  000ad	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  000b1	66 41 b8 00 40	 mov	 r8w, 16384		; 00004000H
  000b6	48 8b 54 24 30	 mov	 rdx, QWORD PTR BankToCpy2$[rsp]
  000bb	48 8b c8	 mov	 rcx, rax
  000be	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 461  : 
; 462  :     // Map CHR Data to Ppu
; 463  :     if(Cartridge->ChrBankCount == 1)

  000c3	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  000c8	0f b6 40 28	 movzx	 eax, BYTE PTR [rax+40]
  000cc	83 f8 01	 cmp	 eax, 1
  000cf	75 1b		 jne	 SHORT $LN5@nromInit

; 464  :     {
; 465  :         cpyMemory((uint8 *)Ppu->MemoryBase, Cartridge->ChrData, Kilobytes(8));

  000d1	66 41 b8 00 20	 mov	 r8w, 8192		; 00002000H
  000d6	48 8b 44 24 50	 mov	 rax, QWORD PTR Cartridge$[rsp]
  000db	48 8b 50 30	 mov	 rdx, QWORD PTR [rax+48]
  000df	48 8b 44 24 60	 mov	 rax, QWORD PTR Ppu$[rsp]
  000e4	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000e7	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory
$LN5@nromInit:

; 466  :     }
; 467  : }

  000ec	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f0	c3		 ret	 0
?nromInit@@YAXPEAUcartridge@@PEAUcpu@@PEAUppu@@@Z ENDP	; nromInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Ppu$ = 8
MemoryBase$ = 16
BasePixel$ = 24
PpuRegisters$ = 32
?initPpu@@YAXPEAUppu@@_KPEAIPEAUppu_registers@@@Z PROC	; initPpu

; 406  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 407  :     OamData = Ppu->Oam;

  00014	48 8b 44 24 08	 mov	 rax, QWORD PTR Ppu$[rsp]
  00019	48 83 c0 20	 add	 rax, 32			; 00000020H
  0001d	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?OamData@@3PEAEEA, rax

; 408  : 
; 409  :     Ppu->MemoryBase = MemoryBase;

  00024	48 8b 44 24 08	 mov	 rax, QWORD PTR Ppu$[rsp]
  00029	48 8b 4c 24 10	 mov	 rcx, QWORD PTR MemoryBase$[rsp]
  0002e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 410  :     Ppu->Registers = PpuRegisters;

  00031	48 8b 44 24 08	 mov	 rax, QWORD PTR Ppu$[rsp]
  00036	48 8b 4c 24 20	 mov	 rcx, QWORD PTR PpuRegisters$[rsp]
  0003b	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 411  :     Ppu->BasePixel = BasePixel;

  0003f	48 8b 44 24 08	 mov	 rax, QWORD PTR Ppu$[rsp]
  00044	48 8b 4c 24 18	 mov	 rcx, QWORD PTR BasePixel$[rsp]
  00049	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 412  : }

  0004d	c3		 ret	 0
?initPpu@@YAXPEAUppu@@_KPEAIPEAUppu_registers@@@Z ENDP	; initPpu
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Cpu$ = 8
MemoryBase$ = 16
?initCpu@@YAXPEAUcpu@@_K@Z PROC				; initCpu

; 399  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 400  :     Cpu->MemoryBase = MemoryBase;

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR Cpu$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR MemoryBase$[rsp]
  00014	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 401  : }

  00018	c3		 ret	 0
?initCpu@@YAXPEAUcpu@@_K@Z ENDP				; initCpu
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
BackBuffer$ = 128
DeviceContext$ = 136
WindowWidth$ = 144
WindowHeight$ = 152
?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z PROC ; drawScreenBuffer

; 387  : {                

  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000c	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00011	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00016	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 388  :     StretchDIBits(DeviceContext,

  0001a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  00022	0f b7 8c 24 98
	00 00 00	 movzx	 ecx, WORD PTR WindowHeight$[rsp]
  0002a	0f b7 94 24 90
	00 00 00	 movzx	 edx, WORD PTR WindowWidth$[rsp]
  00032	c7 44 24 60 20
	00 cc 00	 mov	 DWORD PTR [rsp+96], 13369376 ; 00cc0020H
  0003a	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR [rsp+88], 0
  00042	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00047	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  0004f	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00053	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00058	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  00060	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00063	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00067	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR BackBuffer$[rsp]
  0006f	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00072	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00076	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  0007e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00086	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0008a	44 8b ca	 mov	 r9d, edx
  0008d	45 33 c0	 xor	 r8d, r8d
  00090	33 d2		 xor	 edx, edx
  00092	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR DeviceContext$[rsp]
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_StretchDIBits

; 389  :                   0, 0, WindowWidth, WindowHeight,
; 390  :                   0, 0, BackBuffer->Width, BackBuffer->Height,
; 391  :                   BackBuffer->Memory,
; 392  :                   &BackBuffer->Info,
; 393  :                   DIB_RGB_COLORS, SRCCOPY);
; 394  : }

  000a0	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000a4	c3		 ret	 0
?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z ENDP ; drawScreenBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
MemorySize$ = 32
Buffer$ = 64
Width$ = 72
Height$ = 80
?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z PROC	; createBackBuffer

; 361  : {

  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 362  :     // TODO: This is based on Handmade Hero code. Will need to reference and look at licences later on
; 363  :     //       website: handmadehero.org
; 364  :     if(Buffer->Memory)

  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  00019	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  0001e	74 17		 je	 SHORT $LN2@createBack

; 365  :     {
; 366  :         VirtualFree(Buffer->Memory, 0, MEM_RELEASE);

  00020	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00026	33 d2		 xor	 edx, edx
  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  0002d	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualFree
$LN2@createBack:

; 367  :     }
; 368  : 
; 369  :     Buffer->Width = Width;

  00037	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  00041	89 41 38	 mov	 DWORD PTR [rcx+56], eax

; 370  :     Buffer->Height = Height;

  00044	0f b7 44 24 50	 movzx	 eax, WORD PTR Height$[rsp]
  00049	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  0004e	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 371  :     Buffer->BytesPerPixel = 4; // TODO: Check if this is wrong. Should it be 3 instead? No alpha value

  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  00056	c7 40 44 04 00
	00 00		 mov	 DWORD PTR [rax+68], 4

; 372  : 
; 373  :     Buffer->Info.bmiHeader.biSize = sizeof(Buffer->Info.bmiHeader);

  0005d	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  00062	c7 00 28 00 00
	00		 mov	 DWORD PTR [rax], 40	; 00000028H

; 374  :     Buffer->Info.bmiHeader.biWidth = Width;

  00068	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  0006d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  00072	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 375  :     Buffer->Info.bmiHeader.biHeight = -Height; // Negative tells windows that we raster top to bottom

  00075	0f b7 44 24 50	 movzx	 eax, WORD PTR Height$[rsp]
  0007a	f7 d8		 neg	 eax
  0007c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  00081	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 376  :     Buffer->Info.bmiHeader.biPlanes = 1;

  00084	b8 01 00 00 00	 mov	 eax, 1
  00089	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  0008e	66 89 41 0c	 mov	 WORD PTR [rcx+12], ax

; 377  :     Buffer->Info.bmiHeader.biBitCount = 32;

  00092	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  0009c	66 89 41 0e	 mov	 WORD PTR [rcx+14], ax

; 378  :     Buffer->Info.bmiHeader.biCompression = BI_RGB;

  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR Buffer$[rsp]
  000a5	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 379  : 
; 380  :     int MemorySize = Width * Height * Buffer->BytesPerPixel;

  000ac	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  000b1	0f b7 4c 24 50	 movzx	 ecx, WORD PTR Height$[rsp]
  000b6	0f af c1	 imul	 eax, ecx
  000b9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000be	0f af 41 44	 imul	 eax, DWORD PTR [rcx+68]
  000c2	89 44 24 20	 mov	 DWORD PTR MemorySize$[rsp], eax

; 381  :     Buffer->Memory = VirtualAlloc(0, MemorySize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE); 

  000c6	48 63 44 24 20	 movsxd	 rax, DWORD PTR MemorySize$[rsp]
  000cb	41 b9 04 00 00
	00		 mov	 r9d, 4
  000d1	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  000d7	48 8b d0	 mov	 rdx, rax
  000da	33 c9		 xor	 ecx, ecx
  000dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  000e2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000e7	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 382  :     Buffer->Pitch = Width * Buffer->BytesPerPixel;

  000eb	0f b7 44 24 48	 movzx	 eax, WORD PTR Width$[rsp]
  000f0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000f5	0f af 41 44	 imul	 eax, DWORD PTR [rcx+68]
  000f9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Buffer$[rsp]
  000fe	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 383  : }

  00101	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00105	c3		 ret	 0
?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z ENDP	; createBackBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
ClientRect$ = 32
__$ArrayPad$ = 48
Window$ = 80
Width$ = 88
Height$ = 96
?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z PROC		; getWindowSize

; 352  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 353  :     RECT ClientRect;
; 354  :     GetClientRect(Window, &ClientRect);

  00022	48 8d 54 24 20	 lea	 rdx, QWORD PTR ClientRect$[rsp]
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Window$[rsp]
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetClientRect

; 355  :     *Width = ClientRect.right - ClientRect.left;

  00032	8b 44 24 20	 mov	 eax, DWORD PTR ClientRect$[rsp]
  00036	8b 4c 24 28	 mov	 ecx, DWORD PTR ClientRect$[rsp+8]
  0003a	2b c8		 sub	 ecx, eax
  0003c	8b c1		 mov	 eax, ecx
  0003e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Width$[rsp]
  00043	66 89 01	 mov	 WORD PTR [rcx], ax

; 356  :     *Height = ClientRect.bottom - ClientRect.top;

  00046	8b 44 24 24	 mov	 eax, DWORD PTR ClientRect$[rsp+4]
  0004a	8b 4c 24 2c	 mov	 ecx, DWORD PTR ClientRect$[rsp+12]
  0004e	2b c8		 sub	 ecx, eax
  00050	8b c1		 mov	 eax, ecx
  00052	48 8b 4c 24 60	 mov	 rcx, QWORD PTR Height$[rsp]
  00057	66 89 01	 mov	 WORD PTR [rcx], ax

; 357  : }

  0005a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0005f	48 33 cc	 xor	 rcx, rsp
  00062	e8 00 00 00 00	 call	 __security_check_cookie
  00067	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006b	c3		 ret	 0
?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z ENDP		; getWindowSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
TileRelY$1 = 48
SpriteIdx$2 = 49
SpriteIdx$3 = 50
NameTableBaseNum$ = 51
RelX$4 = 52
SpriteColourIndex$5 = 53
PixelX$6 = 56
Registers$ = 64
PatternLow$7 = 72
PatternHigh$8 = 73
HighPattern$9 = 74
LowPattern$10 = 75
PixColourHigh$11 = 76
Value$12 = 77
BgrdColourIndex$13 = 78
SpritePatternBase$ = 80
NameTableBaseAdrs$ = 84
PixelY$14 = 88
Sprite$15 = 92
NameTableValue$16 = 96
AttributeValue$17 = 97
PatternPixelValue$18 = 98
BgrdPaletteIndex$19 = 99
SprtPaletteIndex$20 = 100
BgrdPatternBase$ = 104
Colour$21 = 108
BgrdBaseColour$22 = 112
SprtPixTransparent$23 = 116
tv572 = 120
Sprite8x16$ = 124
Sprite$24 = 128
tv162 = 136
tv241 = 140
tv245 = 144
tv252 = 148
tv256 = 152
tv520 = 156
BackgroundEnabled$ = 160
SpritesEnabled$ = 164
VisibleLine$ = 168
FlippedVert$25 = 172
FlippedHorz$26 = 176
Priority$27 = 180
PostRenderLine$ = 184
VBlankLine$ = 188
PreRenderLine$ = 192
LowAddress$28 = 200
HighAddress$29 = 208
BackBuffer$ = 240
Ppu$ = 248
?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z PROC	; ppuTick

; 209  : {    

$LN81:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H

; 210  :     ppu_registers *Registers = Ppu->Registers;

  00012	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0001a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0001e	48 89 44 24 40	 mov	 QWORD PTR Registers$[rsp], rax

; 211  : 
; 212  :     if(OamDataChange)

  00023	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?OamDataChange@@3HA, 0 ; OamDataChange
  0002a	74 3b		 je	 SHORT $LN10@ppuTick

; 213  :     {
; 214  :         OamDataChange = false;

  0002c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?OamDataChange@@3HA, 0 ; OamDataChange

; 215  :         Ppu->Oam[Registers->OamAddress] = Registers->OamIO;

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  0003b	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0003f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00047	48 8b 54 24 40	 mov	 rdx, QWORD PTR Registers$[rsp]
  0004c	0f b6 52 04	 movzx	 edx, BYTE PTR [rdx+4]
  00050	88 54 01 20	 mov	 BYTE PTR [rcx+rax+32], dl

; 216  :         ++Registers->OamAddress;

  00054	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00059	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0005d	fe c0		 inc	 al
  0005f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Registers$[rsp]
  00064	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN10@ppuTick:

; 217  :     }
; 218  :     
; 219  :     if(ScrollAdrsChange)

  00067	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ScrollAdrsChange@@3HA, 0 ; ScrollAdrsChange
  0006e	74 36		 je	 SHORT $LN11@ppuTick

; 220  :     {
; 221  :         ScrollAdrsChange = false;

  00070	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ScrollAdrsChange@@3HA, 0 ; ScrollAdrsChange

; 222  :         Ppu->ScrollPosition = (Ppu->ScrollPosition << 8) | (uint16)Registers->ScrollAddress;

  0007a	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00082	0f b7 80 76 01
	00 00		 movzx	 eax, WORD PTR [rax+374]
  00089	c1 e0 08	 shl	 eax, 8
  0008c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Registers$[rsp]
  00091	0f b6 49 05	 movzx	 ecx, BYTE PTR [rcx+5]
  00095	0b c1		 or	 eax, ecx
  00097	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0009f	66 89 81 76 01
	00 00		 mov	 WORD PTR [rcx+374], ax
$LN11@ppuTick:

; 223  :     }
; 224  :     
; 225  :     // NOTE: This is where data is transferred from Cpu via IO registers
; 226  :     if(VRamAdrsChange)

  000a6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?VRamAdrsChange@@3HA, 0 ; VRamAdrsChange
  000ad	0f 84 89 00 00
	00		 je	 $LN12@ppuTick

; 227  :     {
; 228  :         VRamAdrsChange = false;

  000b3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?VRamAdrsChange@@3HA, 0 ; VRamAdrsChange

; 229  :         Ppu->VRamIOAddress = (Ppu->VRamIOAddress << 8) | (uint16)Registers->VRamAddress;

  000bd	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  000c5	0f b7 80 74 01
	00 00		 movzx	 eax, WORD PTR [rax+372]
  000cc	c1 e0 08	 shl	 eax, 8
  000cf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Registers$[rsp]
  000d4	0f b6 49 06	 movzx	 ecx, BYTE PTR [rcx+6]
  000d8	0b c1		 or	 eax, ecx
  000da	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  000e2	66 89 81 74 01
	00 00		 mov	 WORD PTR [rcx+372], ax

; 230  :         
; 231  :         // NOTE: If address is on the pallette. Then IO register is updated immediately
; 232  :         if(0x3F00 <= Ppu->VRamIOAddress && Ppu->VRamIOAddress <= 0x3FFF)

  000e9	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  000f1	0f b7 80 74 01
	00 00		 movzx	 eax, WORD PTR [rax+372]
  000f8	3d 00 3f 00 00	 cmp	 eax, 16128		; 00003f00H
  000fd	7c 3d		 jl	 SHORT $LN13@ppuTick
  000ff	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00107	0f b7 80 74 01
	00 00		 movzx	 eax, WORD PTR [rax+372]
  0010e	3d ff 3f 00 00	 cmp	 eax, 16383		; 00003fffH
  00113	7f 27		 jg	 SHORT $LN13@ppuTick

; 233  :             Registers->VRamIO = readPpu8(Ppu->VRamIOAddress, Ppu->MemoryBase);

  00115	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0011d	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00120	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00128	0f b7 88 74 01
	00 00		 movzx	 ecx, WORD PTR [rax+372]
  0012f	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  00134	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Registers$[rsp]
  00139	88 41 07	 mov	 BYTE PTR [rcx+7], al
$LN13@ppuTick:
$LN12@ppuTick:

; 234  :     }
; 235  : 
; 236  :     if(IOWriteFromCpu)

  0013c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IOWriteFromCpu@@3HA, 0 ; IOWriteFromCpu
  00143	0f 84 85 00 00
	00		 je	 $LN14@ppuTick

; 237  :     {
; 238  :         IOWriteFromCpu = false;

  00149	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?IOWriteFromCpu@@3HA, 0 ; IOWriteFromCpu

; 239  :         
; 240  :         writePpu8(Registers->VRamIO, Ppu->VRamIOAddress, Ppu->MemoryBase);

  00153	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0015b	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  0015e	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00166	0f b7 90 74 01
	00 00		 movzx	 edx, WORD PTR [rax+372]
  0016d	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00172	0f b6 48 07	 movzx	 ecx, BYTE PTR [rax+7]
  00176	e8 00 00 00 00	 call	 ?writePpu8@@YAXEG_K@Z	; writePpu8

; 241  :         if(Registers->Ctrl1 & (1 << 2))

  0017b	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00180	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00183	83 e0 04	 and	 eax, 4
  00186	85 c0		 test	 eax, eax
  00188	74 23		 je	 SHORT $LN15@ppuTick

; 242  :             Ppu->VRamIOAddress += 32;

  0018a	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00192	0f b7 80 74 01
	00 00		 movzx	 eax, WORD PTR [rax+372]
  00199	83 c0 20	 add	 eax, 32			; 00000020H
  0019c	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  001a4	66 89 81 74 01
	00 00		 mov	 WORD PTR [rcx+372], ax

; 243  :         else

  001ab	eb 21		 jmp	 SHORT $LN16@ppuTick
$LN15@ppuTick:

; 244  :             ++Ppu->VRamIOAddress;

  001ad	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  001b5	0f b7 80 74 01
	00 00		 movzx	 eax, WORD PTR [rax+372]
  001bc	66 ff c0	 inc	 ax
  001bf	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  001c7	66 89 81 74 01
	00 00		 mov	 WORD PTR [rcx+372], ax
$LN16@ppuTick:
$LN14@ppuTick:

; 245  :     }
; 246  : 
; 247  :     VRamAdrsOnPalette = (0x3F00 <= Ppu->VRamIOAddress && Ppu->VRamIOAddress <= 0x3FFF);

  001ce	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  001d6	0f b7 80 74 01
	00 00		 movzx	 eax, WORD PTR [rax+372]
  001dd	3d 00 3f 00 00	 cmp	 eax, 16128		; 00003f00H
  001e2	7c 23		 jl	 SHORT $LN69@ppuTick
  001e4	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  001ec	0f b7 80 74 01
	00 00		 movzx	 eax, WORD PTR [rax+372]
  001f3	3d ff 3f 00 00	 cmp	 eax, 16383		; 00003fffH
  001f8	7f 0d		 jg	 SHORT $LN69@ppuTick
  001fa	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv162[rsp], 1
  00205	eb 0b		 jmp	 SHORT $LN70@ppuTick
$LN69@ppuTick:
  00207	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv162[rsp], 0
$LN70@ppuTick:
  00212	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv162[rsp]
  00219	89 05 00 00 00
	00		 mov	 DWORD PTR ?VRamAdrsOnPalette@@3HA, eax ; VRamAdrsOnPalette

; 248  :     
; 249  :     if(IOReadFromCpu)

  0021f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IOReadFromCpu@@3HA, 0 ; IOReadFromCpu
  00226	0f 84 09 01 00
	00		 je	 $LN17@ppuTick

; 250  :     {
; 251  :         IOReadFromCpu = false;

  0022c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?IOReadFromCpu@@3HA, 0 ; IOReadFromCpu

; 252  : 
; 253  :         if(VRamAdrsOnPalette)

  00236	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?VRamAdrsOnPalette@@3HA, 0 ; VRamAdrsOnPalette
  0023d	74 7c		 je	 SHORT $LN18@ppuTick

; 254  :         {
; 255  :             if(Registers->Ctrl1 & (1 << 2))

  0023f	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00244	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00247	83 e0 04	 and	 eax, 4
  0024a	85 c0		 test	 eax, eax
  0024c	74 23		 je	 SHORT $LN20@ppuTick

; 256  :                 Ppu->VRamIOAddress += 32;

  0024e	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00256	0f b7 80 74 01
	00 00		 movzx	 eax, WORD PTR [rax+372]
  0025d	83 c0 20	 add	 eax, 32			; 00000020H
  00260	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00268	66 89 81 74 01
	00 00		 mov	 WORD PTR [rcx+372], ax

; 257  :             else

  0026f	eb 21		 jmp	 SHORT $LN21@ppuTick
$LN20@ppuTick:

; 258  :                 ++Ppu->VRamIOAddress;

  00271	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00279	0f b7 80 74 01
	00 00		 movzx	 eax, WORD PTR [rax+372]
  00280	66 ff c0	 inc	 ax
  00283	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0028b	66 89 81 74 01
	00 00		 mov	 WORD PTR [rcx+372], ax
$LN21@ppuTick:

; 259  :             Registers->VRamIO = readPpu8(Ppu->VRamIOAddress, Ppu->MemoryBase);

  00292	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0029a	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0029d	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  002a5	0f b7 88 74 01
	00 00		 movzx	 ecx, WORD PTR [rax+372]
  002ac	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  002b1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Registers$[rsp]
  002b6	88 41 07	 mov	 BYTE PTR [rcx+7], al

; 260  :         }
; 261  :         else

  002b9	eb 7a		 jmp	 SHORT $LN19@ppuTick
$LN18@ppuTick:

; 262  :         {
; 263  :             Registers->VRamIO = readPpu8(Ppu->VRamIOAddress, Ppu->MemoryBase);

  002bb	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  002c3	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  002c6	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  002ce	0f b7 88 74 01
	00 00		 movzx	 ecx, WORD PTR [rax+372]
  002d5	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  002da	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Registers$[rsp]
  002df	88 41 07	 mov	 BYTE PTR [rcx+7], al

; 264  :             if(Registers->Ctrl1 & (1 << 2))

  002e2	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  002e7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002ea	83 e0 04	 and	 eax, 4
  002ed	85 c0		 test	 eax, eax
  002ef	74 23		 je	 SHORT $LN22@ppuTick

; 265  :                 Ppu->VRamIOAddress += 32;

  002f1	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  002f9	0f b7 80 74 01
	00 00		 movzx	 eax, WORD PTR [rax+372]
  00300	83 c0 20	 add	 eax, 32			; 00000020H
  00303	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0030b	66 89 81 74 01
	00 00		 mov	 WORD PTR [rcx+372], ax

; 266  :             else

  00312	eb 21		 jmp	 SHORT $LN23@ppuTick
$LN22@ppuTick:

; 267  :                 ++Ppu->VRamIOAddress;

  00314	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0031c	0f b7 80 74 01
	00 00		 movzx	 eax, WORD PTR [rax+372]
  00323	66 ff c0	 inc	 ax
  00326	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0032e	66 89 81 74 01
	00 00		 mov	 WORD PTR [rcx+372], ax
$LN23@ppuTick:
$LN19@ppuTick:
$LN17@ppuTick:

; 268  :         }
; 269  :     }
; 270  :     
; 271  :     if(ResetVRamIOAdrs)

  00335	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ResetVRamIOAdrs@@3HA, 0 ; ResetVRamIOAdrs
  0033c	74 1b		 je	 SHORT $LN24@ppuTick

; 272  :     {
; 273  :         Ppu->VRamIOAddress = 0;

  0033e	33 c0		 xor	 eax, eax
  00340	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00348	66 89 81 74 01
	00 00		 mov	 WORD PTR [rcx+372], ax

; 274  :         ResetVRamIOAdrs = false;

  0034f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ResetVRamIOAdrs@@3HA, 0 ; ResetVRamIOAdrs
$LN24@ppuTick:

; 275  :     }
; 276  :     if(ResetScrollIOAdrs)

  00359	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ResetScrollIOAdrs@@3HA, 0 ; ResetScrollIOAdrs
  00360	74 1b		 je	 SHORT $LN25@ppuTick

; 277  :     {
; 278  :         Ppu->ScrollPosition = 0;

  00362	33 c0		 xor	 eax, eax
  00364	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0036c	66 89 81 76 01
	00 00		 mov	 WORD PTR [rcx+374], ax

; 279  :         ResetScrollIOAdrs = false;

  00373	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ResetScrollIOAdrs@@3HA, 0 ; ResetScrollIOAdrs
$LN25@ppuTick:

; 280  :     }
; 281  :     
; 282  : 
; 283  :     uint16 Sprite8x16 = Registers->Ctrl1 & (1 << 5);

  0037d	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00382	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00385	83 e0 20	 and	 eax, 32			; 00000020H
  00388	66 89 44 24 7c	 mov	 WORD PTR Sprite8x16$[rsp], ax

; 284  : 
; 285  :         
; 286  :     uint16 SpritePatternBase = 0x0000;

  0038d	33 c0		 xor	 eax, eax
  0038f	66 89 44 24 50	 mov	 WORD PTR SpritePatternBase$[rsp], ax

; 287  :     if(Registers->Ctrl1 & (1 << 3))

  00394	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00399	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0039c	83 e0 08	 and	 eax, 8
  0039f	85 c0		 test	 eax, eax
  003a1	74 0a		 je	 SHORT $LN26@ppuTick

; 288  :         SpritePatternBase = 0x1000;

  003a3	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  003a8	66 89 44 24 50	 mov	 WORD PTR SpritePatternBase$[rsp], ax
$LN26@ppuTick:

; 289  : 
; 290  :     uint16 BgrdPatternBase = 0x0000;

  003ad	33 c0		 xor	 eax, eax
  003af	66 89 44 24 68	 mov	 WORD PTR BgrdPatternBase$[rsp], ax

; 291  :     if(Registers->Ctrl1 & (1 << 4))

  003b4	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  003b9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003bc	83 e0 10	 and	 eax, 16
  003bf	85 c0		 test	 eax, eax
  003c1	74 0a		 je	 SHORT $LN27@ppuTick

; 292  :         BgrdPatternBase = 0x1000;

  003c3	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  003c8	66 89 44 24 68	 mov	 WORD PTR BgrdPatternBase$[rsp], ax
$LN27@ppuTick:

; 293  : 
; 294  :     uint8 NameTableBaseNum = Registers->Ctrl1 & 3;

  003cd	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  003d2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003d5	83 e0 03	 and	 eax, 3
  003d8	88 44 24 33	 mov	 BYTE PTR NameTableBaseNum$[rsp], al

; 295  :     uint16 NameTableBaseAdrs; 
; 296  :     if(NameTableBaseNum == 0)

  003dc	0f b6 44 24 33	 movzx	 eax, BYTE PTR NameTableBaseNum$[rsp]
  003e1	85 c0		 test	 eax, eax
  003e3	75 0c		 jne	 SHORT $LN28@ppuTick

; 297  :         NameTableBaseAdrs = 0x2000;

  003e5	b8 00 20 00 00	 mov	 eax, 8192		; 00002000H
  003ea	66 89 44 24 54	 mov	 WORD PTR NameTableBaseAdrs$[rsp], ax
  003ef	eb 40		 jmp	 SHORT $LN29@ppuTick
$LN28@ppuTick:

; 298  :     else if(NameTableBaseNum == 1)

  003f1	0f b6 44 24 33	 movzx	 eax, BYTE PTR NameTableBaseNum$[rsp]
  003f6	83 f8 01	 cmp	 eax, 1
  003f9	75 0c		 jne	 SHORT $LN30@ppuTick

; 299  :         NameTableBaseAdrs = 0x2400;

  003fb	b8 00 24 00 00	 mov	 eax, 9216		; 00002400H
  00400	66 89 44 24 54	 mov	 WORD PTR NameTableBaseAdrs$[rsp], ax
  00405	eb 2a		 jmp	 SHORT $LN31@ppuTick
$LN30@ppuTick:

; 300  :     else if(NameTableBaseNum == 2)

  00407	0f b6 44 24 33	 movzx	 eax, BYTE PTR NameTableBaseNum$[rsp]
  0040c	83 f8 02	 cmp	 eax, 2
  0040f	75 0c		 jne	 SHORT $LN32@ppuTick

; 301  :         NameTableBaseAdrs = 0x2800;

  00411	b8 00 28 00 00	 mov	 eax, 10240		; 00002800H
  00416	66 89 44 24 54	 mov	 WORD PTR NameTableBaseAdrs$[rsp], ax
  0041b	eb 14		 jmp	 SHORT $LN33@ppuTick
$LN32@ppuTick:

; 302  :     else if(NameTableBaseNum == 3)

  0041d	0f b6 44 24 33	 movzx	 eax, BYTE PTR NameTableBaseNum$[rsp]
  00422	83 f8 03	 cmp	 eax, 3
  00425	75 0a		 jne	 SHORT $LN34@ppuTick

; 303  :         NameTableBaseAdrs = 0x2C00;

  00427	b8 00 2c 00 00	 mov	 eax, 11264		; 00002c00H
  0042c	66 89 44 24 54	 mov	 WORD PTR NameTableBaseAdrs$[rsp], ax
$LN34@ppuTick:
$LN33@ppuTick:
$LN31@ppuTick:
$LN29@ppuTick:

; 304  : 
; 305  :     bool32 BackgroundEnabled = Registers->Ctrl2 & (1 << 3);

  00431	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00436	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0043a	83 e0 08	 and	 eax, 8
  0043d	89 84 24 a0 00
	00 00		 mov	 DWORD PTR BackgroundEnabled$[rsp], eax

; 306  :     bool32 SpritesEnabled = Registers->Ctrl2 & (1 << 4);

  00444	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00449	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0044d	83 e0 10	 and	 eax, 16
  00450	89 84 24 a4 00
	00 00		 mov	 DWORD PTR SpritesEnabled$[rsp], eax

; 307  :     
; 308  :     bool32 VisibleLine = (0 <= Ppu->Scanline && Ppu->Scanline <= 239);

  00457	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0045f	0f b7 80 70 01
	00 00		 movzx	 eax, WORD PTR [rax+368]
  00466	85 c0		 test	 eax, eax
  00468	7c 23		 jl	 SHORT $LN71@ppuTick
  0046a	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00472	0f b7 80 70 01
	00 00		 movzx	 eax, WORD PTR [rax+368]
  00479	3d ef 00 00 00	 cmp	 eax, 239		; 000000efH
  0047e	7f 0d		 jg	 SHORT $LN71@ppuTick
  00480	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv241[rsp], 1
  0048b	eb 0b		 jmp	 SHORT $LN72@ppuTick
$LN71@ppuTick:
  0048d	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv241[rsp], 0
$LN72@ppuTick:
  00498	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv241[rsp]
  0049f	89 84 24 a8 00
	00 00		 mov	 DWORD PTR VisibleLine$[rsp], eax

; 309  :     bool32 PostRenderLine = (Ppu->Scanline == 240);

  004a6	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  004ae	0f b7 80 70 01
	00 00		 movzx	 eax, WORD PTR [rax+368]
  004b5	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  004ba	75 0d		 jne	 SHORT $LN73@ppuTick
  004bc	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv245[rsp], 1
  004c7	eb 0b		 jmp	 SHORT $LN74@ppuTick
$LN73@ppuTick:
  004c9	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv245[rsp], 0
$LN74@ppuTick:
  004d4	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv245[rsp]
  004db	89 84 24 b8 00
	00 00		 mov	 DWORD PTR PostRenderLine$[rsp], eax

; 310  :     bool32 VBlankLine = (241 <= Ppu->Scanline && Ppu->Scanline <= 260);

  004e2	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  004ea	0f b7 80 70 01
	00 00		 movzx	 eax, WORD PTR [rax+368]
  004f1	3d f1 00 00 00	 cmp	 eax, 241		; 000000f1H
  004f6	7c 23		 jl	 SHORT $LN75@ppuTick
  004f8	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00500	0f b7 80 70 01
	00 00		 movzx	 eax, WORD PTR [rax+368]
  00507	3d 04 01 00 00	 cmp	 eax, 260		; 00000104H
  0050c	7f 0d		 jg	 SHORT $LN75@ppuTick
  0050e	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv252[rsp], 1
  00519	eb 0b		 jmp	 SHORT $LN76@ppuTick
$LN75@ppuTick:
  0051b	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv252[rsp], 0
$LN76@ppuTick:
  00526	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR tv252[rsp]
  0052d	89 84 24 bc 00
	00 00		 mov	 DWORD PTR VBlankLine$[rsp], eax

; 311  :     bool32 PreRenderLine = (Ppu->Scanline == 261);

  00534	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0053c	0f b7 80 70 01
	00 00		 movzx	 eax, WORD PTR [rax+368]
  00543	3d 05 01 00 00	 cmp	 eax, 261		; 00000105H
  00548	75 0d		 jne	 SHORT $LN77@ppuTick
  0054a	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv256[rsp], 1
  00555	eb 0b		 jmp	 SHORT $LN78@ppuTick
$LN77@ppuTick:
  00557	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv256[rsp], 0
$LN78@ppuTick:
  00562	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv256[rsp]
  00569	89 84 24 c0 00
	00 00		 mov	 DWORD PTR PreRenderLine$[rsp], eax

; 312  : 
; 313  :     if(VisibleLine)

  00570	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR VisibleLine$[rsp], 0
  00578	0f 84 42 06 00
	00		 je	 $LN35@ppuTick

; 314  :     {
; 315  :         // NOTE: At the moment I am going to just produce a pixel per cycle with fetching happening each time.
; 316  :         // TODO: Timing of fetches so less loading happens, using fine X scrolling to move through bytes
; 317  : 
; 318  :         // NOTE: Do sprite Evaluation
; 319  :         if(Ppu->ScanlineCycle == 0)

  0057e	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00586	0f b7 80 72 01
	00 00		 movzx	 eax, WORD PTR [rax+370]
  0058d	85 c0		 test	 eax, eax
  0058f	0f 85 de 01 00
	00		 jne	 $LN36@ppuTick

; 320  :         {
; 321  :             evaluateSecondaryOam(Ppu->Oam, Ppu->PreparedSprites, Ppu->Scanline);

  00595	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0059d	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  005a3	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  005ab	48 83 c1 20	 add	 rcx, 32			; 00000020H
  005af	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR Ppu$[rsp]
  005b7	44 0f b7 82 70
	01 00 00	 movzx	 r8d, WORD PTR [rdx+368]
  005bf	48 8b d0	 mov	 rdx, rax
  005c2	e8 00 00 00 00	 call	 ?evaluateSecondaryOam@@YAXPEAEPEAUoam_sprite@@G@Z ; evaluateSecondaryOam

; 322  :             
; 323  :             for(uint8 SpriteIdx = 0; SpriteIdx < SECOND_OAM_SPRITE_NUM; ++SpriteIdx)

  005c7	c6 44 24 31 00	 mov	 BYTE PTR SpriteIdx$2[rsp], 0
  005cc	eb 0b		 jmp	 SHORT $LN4@ppuTick
$LN2@ppuTick:
  005ce	0f b6 44 24 31	 movzx	 eax, BYTE PTR SpriteIdx$2[rsp]
  005d3	fe c0		 inc	 al
  005d5	88 44 24 31	 mov	 BYTE PTR SpriteIdx$2[rsp], al
$LN4@ppuTick:
  005d9	0f b6 44 24 31	 movzx	 eax, BYTE PTR SpriteIdx$2[rsp]
  005de	83 f8 08	 cmp	 eax, 8
  005e1	0f 8d 8c 01 00
	00		 jge	 $LN3@ppuTick

; 324  :             {
; 325  :                 oam_sprite Sprite = Ppu->PreparedSprites[SpriteIdx];

  005e7	0f b6 44 24 31	 movzx	 eax, BYTE PTR SpriteIdx$2[rsp]
  005ec	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  005f4	8b 84 81 20 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+288]
  005fb	89 44 24 5c	 mov	 DWORD PTR Sprite$15[rsp], eax

; 326  : 
; 327  :                 bool32 FlippedVert = Sprite.Atrb & (1 << 7);

  005ff	0f b6 44 24 5e	 movzx	 eax, BYTE PTR Sprite$15[rsp+2]
  00604	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00609	89 84 24 ac 00
	00 00		 mov	 DWORD PTR FlippedVert$25[rsp], eax

; 328  :                 
; 329  :                 if((Sprite.Y+1) != 0 && Sprite.X != 0)

  00610	0f b6 44 24 5c	 movzx	 eax, BYTE PTR Sprite$15[rsp]
  00615	ff c0		 inc	 eax
  00617	85 c0		 test	 eax, eax
  00619	0f 84 4f 01 00
	00		 je	 $LN37@ppuTick
  0061f	0f b6 44 24 5f	 movzx	 eax, BYTE PTR Sprite$15[rsp+3]
  00624	85 c0		 test	 eax, eax
  00626	0f 84 42 01 00
	00		 je	 $LN37@ppuTick

; 330  :                 {
; 331  :                     uint8 TileRelY = (uint8)(Ppu->Scanline - (Sprite.Y+1)) % (uint8)PIXEL_PER_TILE;    

  0062c	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00634	0f b7 80 70 01
	00 00		 movzx	 eax, WORD PTR [rax+368]
  0063b	0f b6 4c 24 5c	 movzx	 ecx, BYTE PTR Sprite$15[rsp]
  00640	ff c1		 inc	 ecx
  00642	2b c1		 sub	 eax, ecx
  00644	0f b6 c0	 movzx	 eax, al
  00647	99		 cdq
  00648	83 e2 07	 and	 edx, 7
  0064b	03 c2		 add	 eax, edx
  0064d	83 e0 07	 and	 eax, 7
  00650	2b c2		 sub	 eax, edx
  00652	88 44 24 30	 mov	 BYTE PTR TileRelY$1[rsp], al

; 332  :                     Assert(0 <= TileRelY && TileRelY < PIXEL_PER_TILE);

  00656	0f b6 44 24 30	 movzx	 eax, BYTE PTR TileRelY$1[rsp]
  0065b	85 c0		 test	 eax, eax
  0065d	7c 0a		 jl	 SHORT $LN39@ppuTick
  0065f	0f b6 44 24 30	 movzx	 eax, BYTE PTR TileRelY$1[rsp]
  00664	83 f8 08	 cmp	 eax, 8
  00667	7c 0b		 jl	 SHORT $LN38@ppuTick
$LN39@ppuTick:
  00669	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN38@ppuTick:

; 333  : 
; 334  :                     uint64 LowAddress;
; 335  :                     uint64 HighAddress;
; 336  :                     
; 337  :                     if(FlippedVert)

  00674	83 bc 24 ac 00
	00 00 00	 cmp	 DWORD PTR FlippedVert$25[rsp], 0
  0067c	74 56		 je	 SHORT $LN40@ppuTick

; 338  :                     {
; 339  :                         LowAddress = (SpritePatternBase + (Sprite.Tile * 16)) + (7 - TileRelY);

  0067e	0f b7 44 24 50	 movzx	 eax, WORD PTR SpritePatternBase$[rsp]
  00683	0f b6 4c 24 5d	 movzx	 ecx, BYTE PTR Sprite$15[rsp+1]
  00688	6b c9 10	 imul	 ecx, ecx, 16
  0068b	03 c1		 add	 eax, ecx
  0068d	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR TileRelY$1[rsp]
  00692	ba 07 00 00 00	 mov	 edx, 7
  00697	2b d1		 sub	 edx, ecx
  00699	8b ca		 mov	 ecx, edx
  0069b	03 c1		 add	 eax, ecx
  0069d	48 98		 cdqe
  0069f	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR LowAddress$28[rsp], rax

; 340  :                         HighAddress = (SpritePatternBase + (Sprite.Tile * 16) + 8) + (7 - TileRelY);

  006a7	0f b7 44 24 50	 movzx	 eax, WORD PTR SpritePatternBase$[rsp]
  006ac	0f b6 4c 24 5d	 movzx	 ecx, BYTE PTR Sprite$15[rsp+1]
  006b1	6b c9 10	 imul	 ecx, ecx, 16
  006b4	03 c1		 add	 eax, ecx
  006b6	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR TileRelY$1[rsp]
  006bb	ba 07 00 00 00	 mov	 edx, 7
  006c0	2b d1		 sub	 edx, ecx
  006c2	8b ca		 mov	 ecx, edx
  006c4	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  006c8	48 98		 cdqe
  006ca	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR HighAddress$29[rsp], rax

; 341  :                     }
; 342  :                     else

  006d2	eb 42		 jmp	 SHORT $LN41@ppuTick
$LN40@ppuTick:

; 343  :                     {
; 344  :                         LowAddress = (SpritePatternBase + (Sprite.Tile * 16)) + TileRelY;

  006d4	0f b7 44 24 50	 movzx	 eax, WORD PTR SpritePatternBase$[rsp]
  006d9	0f b6 4c 24 5d	 movzx	 ecx, BYTE PTR Sprite$15[rsp+1]
  006de	6b c9 10	 imul	 ecx, ecx, 16
  006e1	03 c1		 add	 eax, ecx
  006e3	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR TileRelY$1[rsp]
  006e8	03 c1		 add	 eax, ecx
  006ea	48 98		 cdqe
  006ec	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR LowAddress$28[rsp], rax

; 345  :                         HighAddress = (SpritePatternBase + (Sprite.Tile * 16) + 8) + TileRelY;

  006f4	0f b7 44 24 50	 movzx	 eax, WORD PTR SpritePatternBase$[rsp]
  006f9	0f b6 4c 24 5d	 movzx	 ecx, BYTE PTR Sprite$15[rsp+1]
  006fe	6b c9 10	 imul	 ecx, ecx, 16
  00701	03 c1		 add	 eax, ecx
  00703	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR TileRelY$1[rsp]
  00708	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  0070c	48 98		 cdqe
  0070e	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR HighAddress$29[rsp], rax
$LN41@ppuTick:

; 346  :                     }
; 347  :                     
; 348  :                     Ppu->SpriteTileLow[SpriteIdx] = readPpu8(LowAddress, Ppu->MemoryBase);

  00716	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0071e	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00721	0f b7 8c 24 c8
	00 00 00	 movzx	 ecx, WORD PTR LowAddress$28[rsp]
  00729	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  0072e	0f b6 4c 24 31	 movzx	 ecx, BYTE PTR SpriteIdx$2[rsp]
  00733	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR Ppu$[rsp]
  0073b	88 84 0a 40 01
	00 00		 mov	 BYTE PTR [rdx+rcx+320], al

; 349  :                     Ppu->SpriteTileHigh[SpriteIdx] = readPpu8(HighAddress, Ppu->MemoryBase);

  00742	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0074a	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0074d	0f b7 8c 24 d0
	00 00 00	 movzx	 ecx, WORD PTR HighAddress$29[rsp]
  00755	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  0075a	0f b6 4c 24 31	 movzx	 ecx, BYTE PTR SpriteIdx$2[rsp]
  0075f	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR Ppu$[rsp]
  00767	88 84 0a 48 01
	00 00		 mov	 BYTE PTR [rdx+rcx+328], al
$LN37@ppuTick:

; 350  :                 }
; 351  :             }

  0076e	e9 5b fe ff ff	 jmp	 $LN2@ppuTick
$LN3@ppuTick:
$LN36@ppuTick:

; 352  :         }
; 353  :         
; 354  :         if(1 <= Ppu->ScanlineCycle && Ppu->ScanlineCycle <= PIXEL_WIDTH)

  00773	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  0077b	0f b7 80 72 01
	00 00		 movzx	 eax, WORD PTR [rax+370]
  00782	83 f8 01	 cmp	 eax, 1
  00785	0f 8c 35 04 00
	00		 jl	 $LN42@ppuTick
  0078b	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00793	0f b7 80 72 01
	00 00		 movzx	 eax, WORD PTR [rax+370]
  0079a	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0079f	0f 8f 1b 04 00
	00		 jg	 $LN42@ppuTick

; 355  :         {
; 356  :             uint16 PixelX = Ppu->ScanlineCycle - 1;

  007a5	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  007ad	0f b7 80 72 01
	00 00		 movzx	 eax, WORD PTR [rax+370]
  007b4	ff c8		 dec	 eax
  007b6	66 89 44 24 38	 mov	 WORD PTR PixelX$6[rsp], ax

; 357  :             uint16 PixelY = Ppu->Scanline;

  007bb	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  007c3	0f b7 80 70 01
	00 00		 movzx	 eax, WORD PTR [rax+368]
  007ca	66 89 44 24 58	 mov	 WORD PTR PixelY$14[rsp], ax

; 358  :             
; 359  :             /* *********************** */
; 360  :             /* Background Calculations */
; 361  :             
; 362  :             uint8 NameTableValue = getNameTableValue(PixelX, PixelY, NameTableBaseAdrs, Ppu->MemoryBase);

  007cf	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  007d7	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  007da	44 0f b7 44 24
	54		 movzx	 r8d, WORD PTR NameTableBaseAdrs$[rsp]
  007e0	0f b7 54 24 58	 movzx	 edx, WORD PTR PixelY$14[rsp]
  007e5	0f b7 4c 24 38	 movzx	 ecx, WORD PTR PixelX$6[rsp]
  007ea	e8 00 00 00 00	 call	 ?getNameTableValue@@YAEGGG_K@Z ; getNameTableValue
  007ef	88 44 24 60	 mov	 BYTE PTR NameTableValue$16[rsp], al

; 363  :             uint8 PatternPixelValue = getPatternValue(PixelX, PixelY, NameTableValue, BgrdPatternBase, Ppu->MemoryBase);

  007f3	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  007fb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007fe	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00803	44 0f b7 4c 24
	68		 movzx	 r9d, WORD PTR BgrdPatternBase$[rsp]
  00809	44 0f b6 44 24
	60		 movzx	 r8d, BYTE PTR NameTableValue$16[rsp]
  0080f	0f b7 54 24 58	 movzx	 edx, WORD PTR PixelY$14[rsp]
  00814	0f b7 4c 24 38	 movzx	 ecx, WORD PTR PixelX$6[rsp]
  00819	e8 00 00 00 00	 call	 ?getPatternValue@@YAEGGEG_K@Z ; getPatternValue
  0081e	88 44 24 62	 mov	 BYTE PTR PatternPixelValue$18[rsp], al

; 364  :             uint8 AttributeValue = getAttributeValue(PixelX, PixelY, NameTableBaseAdrs + ATTRIBUTE_OFFSET, Ppu->MemoryBase);

  00822	0f b7 44 24 54	 movzx	 eax, WORD PTR NameTableBaseAdrs$[rsp]
  00827	05 c0 03 00 00	 add	 eax, 960		; 000003c0H
  0082c	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00834	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  00837	44 0f b7 c0	 movzx	 r8d, ax
  0083b	0f b7 54 24 58	 movzx	 edx, WORD PTR PixelY$14[rsp]
  00840	0f b7 4c 24 38	 movzx	 ecx, WORD PTR PixelX$6[rsp]
  00845	e8 00 00 00 00	 call	 ?getAttributeValue@@YAEGGG_K@Z ; getAttributeValue
  0084a	88 44 24 61	 mov	 BYTE PTR AttributeValue$17[rsp], al

; 365  :             uint8 BgrdColourIndex = (AttributeValue << 2) | PatternPixelValue;

  0084e	0f b6 44 24 61	 movzx	 eax, BYTE PTR AttributeValue$17[rsp]
  00853	c1 e0 02	 shl	 eax, 2
  00856	0f b6 4c 24 62	 movzx	 ecx, BYTE PTR PatternPixelValue$18[rsp]
  0085b	0b c1		 or	 eax, ecx
  0085d	88 44 24 4e	 mov	 BYTE PTR BgrdColourIndex$13[rsp], al

; 366  : 
; 367  :             /* ******************* */
; 368  :             /* Sprite Calculations */
; 369  : 
; 370  : #define NO_COLOUR 0xFF
; 371  :             oam_sprite *Sprite;
; 372  :             uint8 SpriteColourIndex = NO_COLOUR;

  00861	c6 44 24 35 ff	 mov	 BYTE PTR SpriteColourIndex$5[rsp], 255 ; 000000ffH

; 373  : 
; 374  :             if(Sprite8x16)

  00866	0f b7 44 24 7c	 movzx	 eax, WORD PTR Sprite8x16$[rsp]
  0086b	85 c0		 test	 eax, eax
  0086d	74 12		 je	 SHORT $LN43@ppuTick

; 375  :                 Assert(0);

  0086f	33 c0		 xor	 eax, eax
  00871	83 f8 01	 cmp	 eax, 1
  00874	74 0b		 je	 SHORT $LN44@ppuTick
  00876	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN44@ppuTick:
$LN43@ppuTick:

; 376  :                 
; 377  :             for(int8 SpriteIdx = SECOND_OAM_SPRITE_NUM - 1; SpriteIdx >= 0; --SpriteIdx)

  00881	c6 44 24 32 07	 mov	 BYTE PTR SpriteIdx$3[rsp], 7
  00886	eb 0b		 jmp	 SHORT $LN7@ppuTick
$LN5@ppuTick:
  00888	0f b6 44 24 32	 movzx	 eax, BYTE PTR SpriteIdx$3[rsp]
  0088d	fe c8		 dec	 al
  0088f	88 44 24 32	 mov	 BYTE PTR SpriteIdx$3[rsp], al
$LN7@ppuTick:
  00893	0f be 44 24 32	 movsx	 eax, BYTE PTR SpriteIdx$3[rsp]
  00898	85 c0		 test	 eax, eax
  0089a	0f 8c 98 01 00
	00		 jl	 $LN6@ppuTick

; 378  :             {
; 379  :                 Sprite = Ppu->PreparedSprites + SpriteIdx; 

  008a0	48 0f be 44 24
	32		 movsx	 rax, BYTE PTR SpriteIdx$3[rsp]
  008a6	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  008ae	48 8d 84 81 20
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+288]
  008b6	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR Sprite$24[rsp], rax

; 380  : 
; 381  :                 bool32 FlippedHorz = Sprite->Atrb & (1 << 6);

  008be	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Sprite$24[rsp]
  008c6	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  008ca	83 e0 40	 and	 eax, 64			; 00000040H
  008cd	89 84 24 b0 00
	00 00		 mov	 DWORD PTR FlippedHorz$26[rsp], eax

; 382  :                 
; 383  :                 
; 384  :                 if(Sprite->X != 0 && PixelX >= Sprite->X && PixelX < (Sprite->X + 8)) 

  008d4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Sprite$24[rsp]
  008dc	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  008e0	85 c0		 test	 eax, eax
  008e2	0f 84 4b 01 00
	00		 je	 $LN45@ppuTick
  008e8	0f b7 44 24 38	 movzx	 eax, WORD PTR PixelX$6[rsp]
  008ed	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Sprite$24[rsp]
  008f5	0f b6 49 03	 movzx	 ecx, BYTE PTR [rcx+3]
  008f9	3b c1		 cmp	 eax, ecx
  008fb	0f 8c 32 01 00
	00		 jl	 $LN45@ppuTick
  00901	0f b7 44 24 38	 movzx	 eax, WORD PTR PixelX$6[rsp]
  00906	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Sprite$24[rsp]
  0090e	0f b6 49 03	 movzx	 ecx, BYTE PTR [rcx+3]
  00912	83 c1 08	 add	 ecx, 8
  00915	3b c1		 cmp	 eax, ecx
  00917	0f 8d 16 01 00
	00		 jge	 $LN45@ppuTick

; 385  :                 {
; 386  :                     uint8 PixColourHigh = Sprite->Atrb & 3; 

  0091d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Sprite$24[rsp]
  00925	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00929	83 e0 03	 and	 eax, 3
  0092c	88 44 24 4c	 mov	 BYTE PTR PixColourHigh$11[rsp], al

; 387  :                     uint8 PatternLow = Ppu->SpriteTileLow[SpriteIdx];

  00930	48 0f be 44 24
	32		 movsx	 rax, BYTE PTR SpriteIdx$3[rsp]
  00936	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0093e	0f b6 84 01 40
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+320]
  00946	88 44 24 48	 mov	 BYTE PTR PatternLow$7[rsp], al

; 388  :                     uint8 PatternHigh = Ppu->SpriteTileHigh[SpriteIdx];

  0094a	48 0f be 44 24
	32		 movsx	 rax, BYTE PTR SpriteIdx$3[rsp]
  00950	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00958	0f b6 84 01 48
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+328]
  00960	88 44 24 49	 mov	 BYTE PTR PatternHigh$8[rsp], al

; 389  :                         
; 390  :                     uint8 RelX = (PixelX - Sprite->X) % 8 ; 

  00964	0f b7 44 24 38	 movzx	 eax, WORD PTR PixelX$6[rsp]
  00969	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Sprite$24[rsp]
  00971	0f b6 49 03	 movzx	 ecx, BYTE PTR [rcx+3]
  00975	2b c1		 sub	 eax, ecx
  00977	99		 cdq
  00978	83 e2 07	 and	 edx, 7
  0097b	03 c2		 add	 eax, edx
  0097d	83 e0 07	 and	 eax, 7
  00980	2b c2		 sub	 eax, edx
  00982	88 44 24 34	 mov	 BYTE PTR RelX$4[rsp], al

; 391  : 
; 392  :                     uint8 LowPattern;
; 393  :                     uint8 HighPattern;
; 394  :                     
; 395  :                     if(FlippedHorz)

  00986	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR FlippedHorz$26[rsp], 0
  0098e	74 28		 je	 SHORT $LN46@ppuTick

; 396  :                     {
; 397  :                         LowPattern  = (PatternLow >> RelX) & 1;

  00990	0f b6 44 24 48	 movzx	 eax, BYTE PTR PatternLow$7[rsp]
  00995	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR RelX$4[rsp]
  0099a	d3 f8		 sar	 eax, cl
  0099c	83 e0 01	 and	 eax, 1
  0099f	88 44 24 4b	 mov	 BYTE PTR LowPattern$10[rsp], al

; 398  :                         HighPattern = (PatternHigh >> RelX) & 1;

  009a3	0f b6 44 24 49	 movzx	 eax, BYTE PTR PatternHigh$8[rsp]
  009a8	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR RelX$4[rsp]
  009ad	d3 f8		 sar	 eax, cl
  009af	83 e0 01	 and	 eax, 1
  009b2	88 44 24 4a	 mov	 BYTE PTR HighPattern$9[rsp], al

; 399  :                     }
; 400  :                     else

  009b6	eb 38		 jmp	 SHORT $LN47@ppuTick
$LN46@ppuTick:

; 401  :                     {
; 402  :                         LowPattern  = (PatternLow >> (7 - RelX)) & 1;

  009b8	0f b6 44 24 48	 movzx	 eax, BYTE PTR PatternLow$7[rsp]
  009bd	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR RelX$4[rsp]
  009c2	ba 07 00 00 00	 mov	 edx, 7
  009c7	2b d1		 sub	 edx, ecx
  009c9	8b ca		 mov	 ecx, edx
  009cb	d3 f8		 sar	 eax, cl
  009cd	83 e0 01	 and	 eax, 1
  009d0	88 44 24 4b	 mov	 BYTE PTR LowPattern$10[rsp], al

; 403  :                         HighPattern = (PatternHigh >> (7 - RelX)) & 1;

  009d4	0f b6 44 24 49	 movzx	 eax, BYTE PTR PatternHigh$8[rsp]
  009d9	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR RelX$4[rsp]
  009de	ba 07 00 00 00	 mov	 edx, 7
  009e3	2b d1		 sub	 edx, ecx
  009e5	8b ca		 mov	 ecx, edx
  009e7	d3 f8		 sar	 eax, cl
  009e9	83 e0 01	 and	 eax, 1
  009ec	88 44 24 4a	 mov	 BYTE PTR HighPattern$9[rsp], al
$LN47@ppuTick:

; 404  :                     }
; 405  :                     
; 406  :                     uint8 Value = (HighPattern << 1) | LowPattern;

  009f0	0f b6 44 24 4a	 movzx	 eax, BYTE PTR HighPattern$9[rsp]
  009f5	d1 e0		 shl	 eax, 1
  009f7	0f b6 4c 24 4b	 movzx	 ecx, BYTE PTR LowPattern$10[rsp]
  009fc	0b c1		 or	 eax, ecx
  009fe	88 44 24 4d	 mov	 BYTE PTR Value$12[rsp], al

; 407  :                     
; 408  : 
; 409  :                     if((((PixColourHigh << 2) | Value) % 4) != 0)

  00a02	0f b6 44 24 4c	 movzx	 eax, BYTE PTR PixColourHigh$11[rsp]
  00a07	c1 e0 02	 shl	 eax, 2
  00a0a	0f b6 4c 24 4d	 movzx	 ecx, BYTE PTR Value$12[rsp]
  00a0f	0b c1		 or	 eax, ecx
  00a11	99		 cdq
  00a12	83 e2 03	 and	 edx, 3
  00a15	03 c2		 add	 eax, edx
  00a17	83 e0 03	 and	 eax, 3
  00a1a	2b c2		 sub	 eax, edx
  00a1c	85 c0		 test	 eax, eax
  00a1e	74 13		 je	 SHORT $LN48@ppuTick

; 410  :                         SpriteColourIndex = (PixColourHigh << 2) | Value;

  00a20	0f b6 44 24 4c	 movzx	 eax, BYTE PTR PixColourHigh$11[rsp]
  00a25	c1 e0 02	 shl	 eax, 2
  00a28	0f b6 4c 24 4d	 movzx	 ecx, BYTE PTR Value$12[rsp]
  00a2d	0b c1		 or	 eax, ecx
  00a2f	88 44 24 35	 mov	 BYTE PTR SpriteColourIndex$5[rsp], al
$LN48@ppuTick:
$LN45@ppuTick:

; 411  :                 }
; 412  :             }

  00a33	e9 50 fe ff ff	 jmp	 $LN5@ppuTick
$LN6@ppuTick:

; 413  : 
; 414  :             /** **************/
; 415  :             /* Drawing Pixel */
; 416  :             
; 417  :             uint8 Colour[3] = {};

  00a38	48 8d 44 24 6c	 lea	 rax, QWORD PTR Colour$21[rsp]
  00a3d	48 8b f8	 mov	 rdi, rax
  00a40	33 c0		 xor	 eax, eax
  00a42	b9 03 00 00 00	 mov	 ecx, 3
  00a47	f3 aa		 rep stosb

; 418  :             bool32 BgrdBaseColour = true;

  00a49	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR BgrdBaseColour$22[rsp], 1

; 419  :             
; 420  :             if(BackgroundEnabled)

  00a51	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR BackgroundEnabled$[rsp], 0
  00a59	74 4c		 je	 SHORT $LN49@ppuTick

; 421  :             {
; 422  :                 if((BgrdColourIndex % 4) != 0)

  00a5b	0f b6 44 24 4e	 movzx	 eax, BYTE PTR BgrdColourIndex$13[rsp]
  00a60	99		 cdq
  00a61	83 e2 03	 and	 edx, 3
  00a64	03 c2		 add	 eax, edx
  00a66	83 e0 03	 and	 eax, 3
  00a69	2b c2		 sub	 eax, edx
  00a6b	85 c0		 test	 eax, eax
  00a6d	74 08		 je	 SHORT $LN50@ppuTick

; 423  :                     BgrdBaseColour = false;

  00a6f	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR BgrdBaseColour$22[rsp], 0
$LN50@ppuTick:

; 424  : 
; 425  :                 uint8 BgrdPaletteIndex = readPpu8(BGRD_PALETTE_ADRS + BgrdColourIndex, Ppu->MemoryBase);

  00a77	0f b6 44 24 4e	 movzx	 eax, BYTE PTR BgrdColourIndex$13[rsp]
  00a7c	05 00 3f 00 00	 add	 eax, 16128		; 00003f00H
  00a81	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00a89	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00a8c	0f b7 c8	 movzx	 ecx, ax
  00a8f	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  00a94	88 44 24 63	 mov	 BYTE PTR BgrdPaletteIndex$19[rsp], al

; 426  :                 getPaletteValue(BgrdPaletteIndex, Colour);

  00a98	48 8d 54 24 6c	 lea	 rdx, QWORD PTR Colour$21[rsp]
  00a9d	0f b6 4c 24 63	 movzx	 ecx, BYTE PTR BgrdPaletteIndex$19[rsp]
  00aa2	e8 00 00 00 00	 call	 ?getPaletteValue@@YAXEPEAE@Z ; getPaletteValue
$LN49@ppuTick:

; 427  :             }
; 428  : 
; 429  :             bool32 SprtPixTransparent = true; 

  00aa7	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR SprtPixTransparent$23[rsp], 1

; 430  :             
; 431  :             if(SpritesEnabled)

  00aaf	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR SpritesEnabled$[rsp], 0
  00ab7	0f 84 b0 00 00
	00		 je	 $LN51@ppuTick

; 432  :             {
; 433  :                 bool32 Priority = !(Sprite->Atrb & (1 << 5));

  00abd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Sprite$24[rsp]
  00ac5	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00ac9	83 e0 20	 and	 eax, 32			; 00000020H
  00acc	85 c0		 test	 eax, eax
  00ace	75 0d		 jne	 SHORT $LN79@ppuTick
  00ad0	c7 84 24 9c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv520[rsp], 1
  00adb	eb 0b		 jmp	 SHORT $LN80@ppuTick
$LN79@ppuTick:
  00add	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv520[rsp], 0
$LN80@ppuTick:
  00ae8	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR tv520[rsp]
  00aef	89 84 24 b4 00
	00 00		 mov	 DWORD PTR Priority$27[rsp], eax

; 434  :                 if((SpriteColourIndex % 4) != 0)

  00af6	0f b6 44 24 35	 movzx	 eax, BYTE PTR SpriteColourIndex$5[rsp]
  00afb	99		 cdq
  00afc	83 e2 03	 and	 edx, 3
  00aff	03 c2		 add	 eax, edx
  00b01	83 e0 03	 and	 eax, 3
  00b04	2b c2		 sub	 eax, edx
  00b06	85 c0		 test	 eax, eax
  00b08	74 08		 je	 SHORT $LN52@ppuTick

; 435  :                     SprtPixTransparent = false;

  00b0a	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR SprtPixTransparent$23[rsp], 0
$LN52@ppuTick:

; 436  :                     
; 437  :                 if(SpriteColourIndex != NO_COLOUR && !SprtPixTransparent)

  00b12	0f b6 44 24 35	 movzx	 eax, BYTE PTR SpriteColourIndex$5[rsp]
  00b17	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00b1c	74 4f		 je	 SHORT $LN53@ppuTick
  00b1e	83 7c 24 74 00	 cmp	 DWORD PTR SprtPixTransparent$23[rsp], 0
  00b23	75 48		 jne	 SHORT $LN53@ppuTick

; 438  :                 {
; 439  :                     if(BgrdBaseColour || (!BgrdBaseColour && Priority))

  00b25	83 7c 24 70 00	 cmp	 DWORD PTR BgrdBaseColour$22[rsp], 0
  00b2a	75 11		 jne	 SHORT $LN55@ppuTick
  00b2c	83 7c 24 70 00	 cmp	 DWORD PTR BgrdBaseColour$22[rsp], 0
  00b31	75 3a		 jne	 SHORT $LN54@ppuTick
  00b33	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR Priority$27[rsp], 0
  00b3b	74 30		 je	 SHORT $LN54@ppuTick
$LN55@ppuTick:

; 440  :                     {
; 441  :                         uint8 SprtPaletteIndex = readPpu8(SPRT_PALETTE_ADRS + SpriteColourIndex, Ppu->MemoryBase);                       

  00b3d	0f b6 44 24 35	 movzx	 eax, BYTE PTR SpriteColourIndex$5[rsp]
  00b42	05 10 3f 00 00	 add	 eax, 16144		; 00003f10H
  00b47	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00b4f	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00b52	0f b7 c8	 movzx	 ecx, ax
  00b55	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  00b5a	88 44 24 64	 mov	 BYTE PTR SprtPaletteIndex$20[rsp], al

; 442  :                         getPaletteValue(SprtPaletteIndex, Colour);                        

  00b5e	48 8d 54 24 6c	 lea	 rdx, QWORD PTR Colour$21[rsp]
  00b63	0f b6 4c 24 64	 movzx	 ecx, BYTE PTR SprtPaletteIndex$20[rsp]
  00b68	e8 00 00 00 00	 call	 ?getPaletteValue@@YAXEPEAE@Z ; getPaletteValue
$LN54@ppuTick:
$LN53@ppuTick:
$LN51@ppuTick:

; 443  :                     }
; 444  :                 }
; 445  :             }
; 446  : 
; 447  :             // Sprite 0
; 448  :             if(!BgrdBaseColour && !SprtPixTransparent)

  00b6d	83 7c 24 70 00	 cmp	 DWORD PTR BgrdBaseColour$22[rsp], 0
  00b72	75 1b		 jne	 SHORT $LN56@ppuTick
  00b74	83 7c 24 74 00	 cmp	 DWORD PTR SprtPixTransparent$23[rsp], 0
  00b79	75 14		 jne	 SHORT $LN56@ppuTick

; 449  :                 Registers->Status = Registers->Status | (1 << 6);

  00b7b	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00b80	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00b84	83 c8 40	 or	 eax, 64			; 00000040H
  00b87	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Registers$[rsp]
  00b8c	88 41 02	 mov	 BYTE PTR [rcx+2], al
$LN56@ppuTick:

; 450  : 
; 451  :             // Draw Pixel
; 452  :             if(BackgroundEnabled || SpritesEnabled)

  00b8f	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR BackgroundEnabled$[rsp], 0
  00b97	75 0a		 jne	 SHORT $LN58@ppuTick
  00b99	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR SpritesEnabled$[rsp], 0
  00ba1	74 1d		 je	 SHORT $LN57@ppuTick
$LN58@ppuTick:

; 453  :                 drawPixel(Ppu, PixelX, PixelY, Colour);

  00ba3	4c 8d 4c 24 6c	 lea	 r9, QWORD PTR Colour$21[rsp]
  00ba8	44 0f b7 44 24
	58		 movzx	 r8d, WORD PTR PixelY$14[rsp]
  00bae	0f b7 54 24 38	 movzx	 edx, WORD PTR PixelX$6[rsp]
  00bb3	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00bbb	e8 00 00 00 00	 call	 ?drawPixel@@YAXPEAUppu@@GGPEAE@Z ; drawPixel
$LN57@ppuTick:
$LN42@ppuTick:
$LN35@ppuTick:

; 454  : 
; 455  :         }
; 456  :     }
; 457  :     if(PostRenderLine)

  00bc0	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR PostRenderLine$[rsp], 0
  00bc8	74 0a		 je	 SHORT $LN59@ppuTick

; 458  :     {
; 459  :         DrawScreen = true;

  00bca	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?DrawScreen@@3HA, 1 ; DrawScreen
$LN59@ppuTick:

; 460  :         // NOTE: Ppu sits idle for this scanline
; 461  :     }
; 462  :     if(VBlankLine)

  00bd4	83 bc 24 bc 00
	00 00 00	 cmp	 DWORD PTR VBlankLine$[rsp], 0
  00bdc	74 5a		 je	 SHORT $LN60@ppuTick

; 463  :     {
; 464  :         if(Ppu->Scanline == 241 && Ppu->ScanlineCycle == 1)

  00bde	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00be6	0f b7 80 70 01
	00 00		 movzx	 eax, WORD PTR [rax+368]
  00bed	3d f1 00 00 00	 cmp	 eax, 241		; 000000f1H
  00bf2	75 44		 jne	 SHORT $LN61@ppuTick
  00bf4	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00bfc	0f b7 80 72 01
	00 00		 movzx	 eax, WORD PTR [rax+370]
  00c03	83 f8 01	 cmp	 eax, 1
  00c06	75 30		 jne	 SHORT $LN61@ppuTick

; 465  :         {
; 466  :             // TODO: if turning on NMI when in vblank. The nmi will be generated immediately.
; 467  :             if(Registers->Ctrl1 & (1 << 7))

  00c08	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00c0d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00c10	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00c15	85 c0		 test	 eax, eax
  00c17	74 0a		 je	 SHORT $LN62@ppuTick

; 468  :             {
; 469  :                 NmiTriggered = true;

  00c19	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?NmiTriggered@@3HA, 1 ; NmiTriggered
$LN62@ppuTick:

; 470  :             }
; 471  :             Registers->Status = Registers->Status | (1 << 7); // Set VBlank Status

  00c23	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00c28	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00c2c	0f ba e8 07	 bts	 eax, 7
  00c30	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Registers$[rsp]
  00c35	88 41 02	 mov	 BYTE PTR [rcx+2], al
$LN61@ppuTick:
$LN60@ppuTick:

; 472  :         }
; 473  :     }
; 474  :     if(PreRenderLine)

  00c38	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR PreRenderLine$[rsp], 0
  00c40	0f 84 8c 00 00
	00		 je	 $LN63@ppuTick

; 475  :     {
; 476  :         switch(Ppu->ScanlineCycle)

  00c46	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00c4e	0f b7 80 72 01
	00 00		 movzx	 eax, WORD PTR [rax+370]
  00c55	89 44 24 78	 mov	 DWORD PTR tv572[rsp], eax
  00c59	83 7c 24 78 01	 cmp	 DWORD PTR tv572[rsp], 1
  00c5e	74 16		 je	 SHORT $LN64@ppuTick
  00c60	81 7c 24 78 41
	01 00 00	 cmp	 DWORD PTR tv572[rsp], 321 ; 00000141H
  00c68	74 4b		 je	 SHORT $LN65@ppuTick
  00c6a	81 7c 24 78 49
	01 00 00	 cmp	 DWORD PTR tv572[rsp], 329 ; 00000149H
  00c72	74 41		 je	 SHORT $LN65@ppuTick
  00c74	eb 5c		 jmp	 SHORT $LN8@ppuTick
$LN64@ppuTick:

; 477  :         {
; 478  :             case 1:
; 479  :             {
; 480  :                 Registers->Status = Registers->Status & ~(1 << 5); // Clear Sprite Overflow

  00c76	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00c7b	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00c7f	83 e0 df	 and	 eax, -33		; ffffffffffffffdfH
  00c82	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Registers$[rsp]
  00c87	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 481  :                 Registers->Status = Registers->Status & ~(1 << 6); // Clear Sprite Zero Hit

  00c8a	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00c8f	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00c93	83 e0 bf	 and	 eax, -65		; ffffffffffffffbfH
  00c96	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Registers$[rsp]
  00c9b	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 482  :                 Registers->Status = Registers->Status & ~(1 << 7); // Clear Vblank status

  00c9e	48 8b 44 24 40	 mov	 rax, QWORD PTR Registers$[rsp]
  00ca3	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00ca7	0f ba f0 07	 btr	 eax, 7
  00cab	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Registers$[rsp]
  00cb0	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 483  :                 break;

  00cb3	eb 1d		 jmp	 SHORT $LN8@ppuTick
$LN65@ppuTick:

; 484  :             }
; 485  :             case 321:
; 486  :             case 329:
; 487  :             {
; 488  :                 Ppu->NameTableByte1 = Ppu->NameTableByte2;

  00cb5	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00cbd	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00cc5	0f b6 89 7b 01
	00 00		 movzx	 ecx, BYTE PTR [rcx+379]
  00ccc	88 88 7a 01 00
	00		 mov	 BYTE PTR [rax+378], cl
$LN8@ppuTick:
$LN63@ppuTick:

; 489  :                 //Ppu->NameTableByte2 = getNameTableValue(PixelFetchX, PixelFetchY, TableBaseNum, Ppu->MemoryBase);
; 490  :                 break;
; 491  :             }
; 492  :         }
; 493  :     }
; 494  : 
; 495  :     ++Ppu->ScanlineCycle;

  00cd2	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00cda	0f b7 80 72 01
	00 00		 movzx	 eax, WORD PTR [rax+370]
  00ce1	66 ff c0	 inc	 ax
  00ce4	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00cec	66 89 81 72 01
	00 00		 mov	 WORD PTR [rcx+370], ax

; 496  : 
; 497  :     if(Ppu->ScanlineCycle > 341)

  00cf3	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00cfb	0f b7 80 72 01
	00 00		 movzx	 eax, WORD PTR [rax+370]
  00d02	3d 55 01 00 00	 cmp	 eax, 341		; 00000155H
  00d07	7e 31		 jle	 SHORT $LN66@ppuTick

; 498  :     {
; 499  :         Ppu->Scanline += 1;

  00d09	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00d11	0f b7 80 70 01
	00 00		 movzx	 eax, WORD PTR [rax+368]
  00d18	ff c0		 inc	 eax
  00d1a	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00d22	66 89 81 70 01
	00 00		 mov	 WORD PTR [rcx+368], ax

; 500  :         Ppu->ScanlineCycle = 0;

  00d29	33 c0		 xor	 eax, eax
  00d2b	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00d33	66 89 81 72 01
	00 00		 mov	 WORD PTR [rcx+370], ax
$LN66@ppuTick:

; 501  :     }
; 502  : 
; 503  :     if(Ppu->Scanline == 262)

  00d3a	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR Ppu$[rsp]
  00d42	0f b7 80 70 01
	00 00		 movzx	 eax, WORD PTR [rax+368]
  00d49	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  00d4e	75 11		 jne	 SHORT $LN67@ppuTick

; 504  :     {
; 505  :         Ppu->Scanline = 0;

  00d50	33 c0		 xor	 eax, eax
  00d52	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR Ppu$[rsp]
  00d5a	66 89 81 70 01
	00 00		 mov	 WORD PTR [rcx+368], ax
$LN67@ppuTick:

; 506  :     }
; 507  : }

  00d61	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  00d68	5f		 pop	 rdi
  00d69	c3		 ret	 0
?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z ENDP	; ppuTick
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
OamSpriteCount$1 = 0
PreparedCount$ = 1
index$2 = 4
$T3 = 8
Sprite$4 = 16
Oam$ = 48
PreparedSprites$ = 56
Scanline$ = 64
?evaluateSecondaryOam@@YAXPEAEPEAUoam_sprite@@G@Z PROC	; evaluateSecondaryOam

; 181  : {

  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	57		 push	 rdi
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 182  :     uint8 PreparedCount = 0;

  00015	c6 44 24 01 00	 mov	 BYTE PTR PreparedCount$[rsp], 0

; 183  : 
; 184  :     // NOTE: Clear Secondary OAM
; 185  :     for(uint16 index = 0; index < SECOND_OAM_SPRITE_NUM; ++index)

  0001a	33 c0		 xor	 eax, eax
  0001c	66 89 44 24 04	 mov	 WORD PTR index$2[rsp], ax
  00021	eb 0d		 jmp	 SHORT $LN4@evaluateSe
$LN2@evaluateSe:
  00023	0f b7 44 24 04	 movzx	 eax, WORD PTR index$2[rsp]
  00028	66 ff c0	 inc	 ax
  0002b	66 89 44 24 04	 mov	 WORD PTR index$2[rsp], ax
$LN4@evaluateSe:
  00030	0f b7 44 24 04	 movzx	 eax, WORD PTR index$2[rsp]
  00035	83 f8 08	 cmp	 eax, 8
  00038	7d 24		 jge	 SHORT $LN3@evaluateSe

; 186  :     {
; 187  :         PreparedSprites[index] = {};

  0003a	48 8d 44 24 08	 lea	 rax, QWORD PTR $T3[rsp]
  0003f	48 8b f8	 mov	 rdi, rax
  00042	33 c0		 xor	 eax, eax
  00044	b9 04 00 00 00	 mov	 ecx, 4
  00049	f3 aa		 rep stosb
  0004b	0f b7 44 24 04	 movzx	 eax, WORD PTR index$2[rsp]
  00050	48 8b 4c 24 38	 mov	 rcx, QWORD PTR PreparedSprites$[rsp]
  00055	8b 54 24 08	 mov	 edx, DWORD PTR $T3[rsp]
  00059	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx

; 188  :     }

  0005c	eb c5		 jmp	 SHORT $LN2@evaluateSe
$LN3@evaluateSe:

; 189  :             
; 190  :     for(uint8 OamSpriteCount = 0; OamSpriteCount < OAM_SPRITE_TOTAL; ++OamSpriteCount)

  0005e	c6 04 24 00	 mov	 BYTE PTR OamSpriteCount$1[rsp], 0
  00062	eb 09		 jmp	 SHORT $LN7@evaluateSe
$LN5@evaluateSe:
  00064	0f b6 04 24	 movzx	 eax, BYTE PTR OamSpriteCount$1[rsp]
  00068	fe c0		 inc	 al
  0006a	88 04 24	 mov	 BYTE PTR OamSpriteCount$1[rsp], al
$LN7@evaluateSe:
  0006d	0f b6 04 24	 movzx	 eax, BYTE PTR OamSpriteCount$1[rsp]
  00071	83 f8 40	 cmp	 eax, 64			; 00000040H
  00074	7d 66		 jge	 SHORT $LN6@evaluateSe

; 191  :     {
; 192  :         oam_sprite *Sprite = (oam_sprite *)Oam + OamSpriteCount;

  00076	0f b6 04 24	 movzx	 eax, BYTE PTR OamSpriteCount$1[rsp]
  0007a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Oam$[rsp]
  0007f	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  00083	48 89 44 24 10	 mov	 QWORD PTR Sprite$4[rsp], rax

; 193  :                 
; 194  :         if(Scanline >= (Sprite->Y + 1) && Scanline < ((Sprite->Y + 1) + PIXEL_PER_TILE) ) // Plus one because normally evaluated on previous scanline 

  00088	0f b7 44 24 40	 movzx	 eax, WORD PTR Scanline$[rsp]
  0008d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Sprite$4[rsp]
  00092	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00095	ff c1		 inc	 ecx
  00097	3b c1		 cmp	 eax, ecx
  00099	7c 33		 jl	 SHORT $LN8@evaluateSe
  0009b	0f b7 44 24 40	 movzx	 eax, WORD PTR Scanline$[rsp]
  000a0	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Sprite$4[rsp]
  000a5	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000a8	83 c1 09	 add	 ecx, 9
  000ab	3b c1		 cmp	 eax, ecx
  000ad	7d 1f		 jge	 SHORT $LN8@evaluateSe

; 195  :         {
; 196  :             PreparedSprites[PreparedCount++] = *Sprite;

  000af	48 8b 44 24 10	 mov	 rax, QWORD PTR Sprite$4[rsp]
  000b4	8b 00		 mov	 eax, DWORD PTR [rax]
  000b6	0f b6 4c 24 01	 movzx	 ecx, BYTE PTR PreparedCount$[rsp]
  000bb	48 8b 54 24 38	 mov	 rdx, QWORD PTR PreparedSprites$[rsp]
  000c0	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  000c3	0f b6 44 24 01	 movzx	 eax, BYTE PTR PreparedCount$[rsp]
  000c8	fe c0		 inc	 al
  000ca	88 44 24 01	 mov	 BYTE PTR PreparedCount$[rsp], al
$LN8@evaluateSe:

; 197  :         }
; 198  : 
; 199  :         // NOTE: Filled Secondary Oam with 8 bytes. 
; 200  :         if(PreparedCount == SECOND_OAM_SPRITE_NUM)

  000ce	0f b6 44 24 01	 movzx	 eax, BYTE PTR PreparedCount$[rsp]
  000d3	83 f8 08	 cmp	 eax, 8
  000d6	75 02		 jne	 SHORT $LN9@evaluateSe

; 201  :         {
; 202  :             break;

  000d8	eb 02		 jmp	 SHORT $LN6@evaluateSe
$LN9@evaluateSe:

; 203  :             // TODO: Set sprite overflow flag?? 
; 204  :         }
; 205  :     }

  000da	eb 88		 jmp	 SHORT $LN5@evaluateSe
$LN6@evaluateSe:

; 206  : }

  000dc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e0	5f		 pop	 rdi
  000e1	c3		 ret	 0
?evaluateSecondaryOam@@YAXPEAEPEAUoam_sprite@@G@Z ENDP	; evaluateSecondaryOam
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
Value$ = 32
BlockRelY$ = 33
Attribute$ = 34
BlockRelX$ = 35
AttributeByteY$ = 36
AttributeByteX$ = 37
AtrbByteAdrs$ = 40
X$ = 64
Y$ = 72
AtrbTableBaseAdrs$ = 80
MemoryOffset$ = 88
?getAttributeValue@@YAEGGG_K@Z PROC			; getAttributeValue

; 152  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000b	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00010	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00015	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 153  :     uint8 AttributeByteX = X / PIXELS_PER_ATRB_BYTE;

  00019	0f b7 44 24 40	 movzx	 eax, WORD PTR X$[rsp]
  0001e	99		 cdq
  0001f	83 e2 1f	 and	 edx, 31
  00022	03 c2		 add	 eax, edx
  00024	c1 f8 05	 sar	 eax, 5
  00027	88 44 24 25	 mov	 BYTE PTR AttributeByteX$[rsp], al

; 154  :     uint8 AttributeByteY = Y / PIXELS_PER_ATRB_BYTE;

  0002b	0f b7 44 24 48	 movzx	 eax, WORD PTR Y$[rsp]
  00030	99		 cdq
  00031	83 e2 1f	 and	 edx, 31
  00034	03 c2		 add	 eax, edx
  00036	c1 f8 05	 sar	 eax, 5
  00039	88 44 24 24	 mov	 BYTE PTR AttributeByteY$[rsp], al

; 155  :     
; 156  :     uint16 AtrbByteAdrs = (AtrbTableBaseAdrs + (AttributeByteY * ATRB_BYTE_PER_ROW)) + AttributeByteX;

  0003d	0f b7 44 24 50	 movzx	 eax, WORD PTR AtrbTableBaseAdrs$[rsp]
  00042	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR AttributeByteY$[rsp]
  00047	8d 04 c8	 lea	 eax, DWORD PTR [rax+rcx*8]
  0004a	0f b6 4c 24 25	 movzx	 ecx, BYTE PTR AttributeByteX$[rsp]
  0004f	03 c1		 add	 eax, ecx
  00051	66 89 44 24 28	 mov	 WORD PTR AtrbByteAdrs$[rsp], ax

; 157  :     uint8 Attribute = readPpu8(AtrbByteAdrs, MemoryOffset);

  00056	48 8b 54 24 58	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0005b	0f b7 4c 24 28	 movzx	 ecx, WORD PTR AtrbByteAdrs$[rsp]
  00060	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  00065	88 44 24 22	 mov	 BYTE PTR Attribute$[rsp], al

; 158  :     
; 159  :     uint8 BlockRelX = (X % PIXELS_PER_ATRB_BYTE) / 16;

  00069	0f b7 44 24 40	 movzx	 eax, WORD PTR X$[rsp]
  0006e	99		 cdq
  0006f	83 e2 1f	 and	 edx, 31
  00072	03 c2		 add	 eax, edx
  00074	83 e0 1f	 and	 eax, 31
  00077	2b c2		 sub	 eax, edx
  00079	99		 cdq
  0007a	83 e2 0f	 and	 edx, 15
  0007d	03 c2		 add	 eax, edx
  0007f	c1 f8 04	 sar	 eax, 4
  00082	88 44 24 23	 mov	 BYTE PTR BlockRelX$[rsp], al

; 160  :     uint8 BlockRelY = (Y % PIXELS_PER_ATRB_BYTE) / 16;

  00086	0f b7 44 24 48	 movzx	 eax, WORD PTR Y$[rsp]
  0008b	99		 cdq
  0008c	83 e2 1f	 and	 edx, 31
  0008f	03 c2		 add	 eax, edx
  00091	83 e0 1f	 and	 eax, 31
  00094	2b c2		 sub	 eax, edx
  00096	99		 cdq
  00097	83 e2 0f	 and	 edx, 15
  0009a	03 c2		 add	 eax, edx
  0009c	c1 f8 04	 sar	 eax, 4
  0009f	88 44 24 21	 mov	 BYTE PTR BlockRelY$[rsp], al

; 161  : 
; 162  :     uint8 Value;
; 163  :     
; 164  :     if(BlockRelX == 0)

  000a3	0f b6 44 24 23	 movzx	 eax, BYTE PTR BlockRelX$[rsp]
  000a8	85 c0		 test	 eax, eax
  000aa	75 2a		 jne	 SHORT $LN2@getAttribu

; 165  :         if(BlockRelY == 0)

  000ac	0f b6 44 24 21	 movzx	 eax, BYTE PTR BlockRelY$[rsp]
  000b1	85 c0		 test	 eax, eax
  000b3	75 0b		 jne	 SHORT $LN3@getAttribu

; 166  :             Value = Attribute;

  000b5	0f b6 44 24 22	 movzx	 eax, BYTE PTR Attribute$[rsp]
  000ba	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
  000be	eb 16		 jmp	 SHORT $LN4@getAttribu
$LN3@getAttribu:

; 167  :         else if(BlockRelY == 1)

  000c0	0f b6 44 24 21	 movzx	 eax, BYTE PTR BlockRelY$[rsp]
  000c5	83 f8 01	 cmp	 eax, 1
  000c8	75 0c		 jne	 SHORT $LN5@getAttribu

; 168  :             Value = Attribute >> 4;

  000ca	0f b6 44 24 22	 movzx	 eax, BYTE PTR Attribute$[rsp]
  000cf	c1 f8 04	 sar	 eax, 4
  000d2	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
$LN5@getAttribu:
$LN4@getAttribu:
$LN2@getAttribu:

; 169  :     if(BlockRelX == 1)

  000d6	0f b6 44 24 23	 movzx	 eax, BYTE PTR BlockRelX$[rsp]
  000db	83 f8 01	 cmp	 eax, 1
  000de	75 2d		 jne	 SHORT $LN6@getAttribu

; 170  :         if(BlockRelY == 0)

  000e0	0f b6 44 24 21	 movzx	 eax, BYTE PTR BlockRelY$[rsp]
  000e5	85 c0		 test	 eax, eax
  000e7	75 0e		 jne	 SHORT $LN7@getAttribu

; 171  :             Value = Attribute >> 2;

  000e9	0f b6 44 24 22	 movzx	 eax, BYTE PTR Attribute$[rsp]
  000ee	c1 f8 02	 sar	 eax, 2
  000f1	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
  000f5	eb 16		 jmp	 SHORT $LN8@getAttribu
$LN7@getAttribu:

; 172  :         else if(BlockRelY == 1)

  000f7	0f b6 44 24 21	 movzx	 eax, BYTE PTR BlockRelY$[rsp]
  000fc	83 f8 01	 cmp	 eax, 1
  000ff	75 0c		 jne	 SHORT $LN9@getAttribu

; 173  :             Value = Attribute >> 6;

  00101	0f b6 44 24 22	 movzx	 eax, BYTE PTR Attribute$[rsp]
  00106	c1 f8 06	 sar	 eax, 6
  00109	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
$LN9@getAttribu:
$LN8@getAttribu:
$LN6@getAttribu:

; 174  :     
; 175  :     Value = Value & 3;

  0010d	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  00112	83 e0 03	 and	 eax, 3
  00115	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 176  :     
; 177  :     return(Value);

  00119	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]

; 178  : }

  0011e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00122	c3		 ret	 0
?getAttributeValue@@YAEGGG_K@Z ENDP			; getAttributeValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
TileRelY$ = 32
TileRelX$ = 33
HighPattern$ = 34
LowPattern$ = 35
Value$ = 36
LowAddress$ = 40
HighAddress$ = 48
X$ = 80
Y$ = 88
NameTableValue$ = 96
PatternBase$ = 104
MemoryOffset$ = 112
?getPatternValue@@YAEGGEG_K@Z PROC			; getPatternValue

; 127  : {

  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000b	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00010	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00015	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 128  :     uint8 TileRelX = X % PIXEL_PER_TILE;

  00019	0f b7 44 24 50	 movzx	 eax, WORD PTR X$[rsp]
  0001e	99		 cdq
  0001f	83 e2 07	 and	 edx, 7
  00022	03 c2		 add	 eax, edx
  00024	83 e0 07	 and	 eax, 7
  00027	2b c2		 sub	 eax, edx
  00029	88 44 24 21	 mov	 BYTE PTR TileRelX$[rsp], al

; 129  :     uint8 TileRelY = Y % PIXEL_PER_TILE;

  0002d	0f b7 44 24 58	 movzx	 eax, WORD PTR Y$[rsp]
  00032	99		 cdq
  00033	83 e2 07	 and	 edx, 7
  00036	03 c2		 add	 eax, edx
  00038	83 e0 07	 and	 eax, 7
  0003b	2b c2		 sub	 eax, edx
  0003d	88 44 24 20	 mov	 BYTE PTR TileRelY$[rsp], al

; 130  :     
; 131  :     Assert(0 <= TileRelX && TileRelX < PIXEL_PER_TILE);

  00041	0f b6 44 24 21	 movzx	 eax, BYTE PTR TileRelX$[rsp]
  00046	85 c0		 test	 eax, eax
  00048	7c 0a		 jl	 SHORT $LN3@getPattern
  0004a	0f b6 44 24 21	 movzx	 eax, BYTE PTR TileRelX$[rsp]
  0004f	83 f8 08	 cmp	 eax, 8
  00052	7c 0b		 jl	 SHORT $LN2@getPattern
$LN3@getPattern:
  00054	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@getPattern:

; 132  :     Assert(0 <= TileRelY && TileRelY < PIXEL_PER_TILE);

  0005f	0f b6 44 24 20	 movzx	 eax, BYTE PTR TileRelY$[rsp]
  00064	85 c0		 test	 eax, eax
  00066	7c 0a		 jl	 SHORT $LN5@getPattern
  00068	0f b6 44 24 20	 movzx	 eax, BYTE PTR TileRelY$[rsp]
  0006d	83 f8 08	 cmp	 eax, 8
  00070	7c 0b		 jl	 SHORT $LN4@getPattern
$LN5@getPattern:
  00072	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN4@getPattern:

; 133  :   
; 134  :     uint64 LowAddress = (PatternBase + (NameTableValue * 16)) + TileRelY;

  0007d	0f b7 44 24 68	 movzx	 eax, WORD PTR PatternBase$[rsp]
  00082	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR NameTableValue$[rsp]
  00087	6b c9 10	 imul	 ecx, ecx, 16
  0008a	03 c1		 add	 eax, ecx
  0008c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR TileRelY$[rsp]
  00091	03 c1		 add	 eax, ecx
  00093	48 98		 cdqe
  00095	48 89 44 24 28	 mov	 QWORD PTR LowAddress$[rsp], rax

; 135  :     uint64 HighAddress = (PatternBase + (NameTableValue * 16) + 8) + TileRelY;

  0009a	0f b7 44 24 68	 movzx	 eax, WORD PTR PatternBase$[rsp]
  0009f	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR NameTableValue$[rsp]
  000a4	6b c9 10	 imul	 ecx, ecx, 16
  000a7	03 c1		 add	 eax, ecx
  000a9	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR TileRelY$[rsp]
  000ae	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  000b2	48 98		 cdqe
  000b4	48 89 44 24 30	 mov	 QWORD PTR HighAddress$[rsp], rax

; 136  :     
; 137  :     uint8 LowPattern = readPpu8(LowAddress, MemoryOffset);

  000b9	48 8b 54 24 70	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  000be	0f b7 4c 24 28	 movzx	 ecx, WORD PTR LowAddress$[rsp]
  000c3	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  000c8	88 44 24 23	 mov	 BYTE PTR LowPattern$[rsp], al

; 138  :     uint8 HighPattern = readPpu8(HighAddress, MemoryOffset);

  000cc	48 8b 54 24 70	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  000d1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR HighAddress$[rsp]
  000d6	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  000db	88 44 24 22	 mov	 BYTE PTR HighPattern$[rsp], al

; 139  : 
; 140  :     LowPattern  = (LowPattern >> (7 - TileRelX)) & 1;

  000df	0f b6 44 24 23	 movzx	 eax, BYTE PTR LowPattern$[rsp]
  000e4	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR TileRelX$[rsp]
  000e9	ba 07 00 00 00	 mov	 edx, 7
  000ee	2b d1		 sub	 edx, ecx
  000f0	8b ca		 mov	 ecx, edx
  000f2	d3 f8		 sar	 eax, cl
  000f4	83 e0 01	 and	 eax, 1
  000f7	88 44 24 23	 mov	 BYTE PTR LowPattern$[rsp], al

; 141  :     HighPattern = (HighPattern >> (7 - TileRelX)) & 1;

  000fb	0f b6 44 24 22	 movzx	 eax, BYTE PTR HighPattern$[rsp]
  00100	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR TileRelX$[rsp]
  00105	ba 07 00 00 00	 mov	 edx, 7
  0010a	2b d1		 sub	 edx, ecx
  0010c	8b ca		 mov	 ecx, edx
  0010e	d3 f8		 sar	 eax, cl
  00110	83 e0 01	 and	 eax, 1
  00113	88 44 24 22	 mov	 BYTE PTR HighPattern$[rsp], al

; 142  : 
; 143  :     uint8 Value = (HighPattern << 1) | LowPattern;

  00117	0f b6 44 24 22	 movzx	 eax, BYTE PTR HighPattern$[rsp]
  0011c	d1 e0		 shl	 eax, 1
  0011e	0f b6 4c 24 23	 movzx	 ecx, BYTE PTR LowPattern$[rsp]
  00123	0b c1		 or	 eax, ecx
  00125	88 44 24 24	 mov	 BYTE PTR Value$[rsp], al

; 144  :     
; 145  :     return(Value);

  00129	0f b6 44 24 24	 movzx	 eax, BYTE PTR Value$[rsp]

; 146  : }

  0012e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00132	c3		 ret	 0
?getPatternValue@@YAEGGEG_K@Z ENDP			; getPatternValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
Value$ = 32
TileY$ = 36
TileX$ = 40
Address$ = 44
X$ = 64
Y$ = 72
TableBaseAddress$ = 80
MemoryOffset$ = 88
?getNameTableValue@@YAEGGG_K@Z PROC			; getNameTableValue

; 112  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000b	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00010	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00015	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 113  :     uint16 TileX = X / PIXEL_PER_TILE;

  00019	0f b7 44 24 40	 movzx	 eax, WORD PTR X$[rsp]
  0001e	99		 cdq
  0001f	83 e2 07	 and	 edx, 7
  00022	03 c2		 add	 eax, edx
  00024	c1 f8 03	 sar	 eax, 3
  00027	66 89 44 24 28	 mov	 WORD PTR TileX$[rsp], ax

; 114  :     uint16 TileY = Y / PIXEL_PER_TILE;

  0002c	0f b7 44 24 48	 movzx	 eax, WORD PTR Y$[rsp]
  00031	99		 cdq
  00032	83 e2 07	 and	 edx, 7
  00035	03 c2		 add	 eax, edx
  00037	c1 f8 03	 sar	 eax, 3
  0003a	66 89 44 24 24	 mov	 WORD PTR TileY$[rsp], ax

; 115  :     
; 116  :     Assert(0 <= TileX && TileX < TILES_COUNT_X);

  0003f	0f b7 44 24 28	 movzx	 eax, WORD PTR TileX$[rsp]
  00044	85 c0		 test	 eax, eax
  00046	7c 0a		 jl	 SHORT $LN3@getNameTab
  00048	0f b7 44 24 28	 movzx	 eax, WORD PTR TileX$[rsp]
  0004d	83 f8 20	 cmp	 eax, 32			; 00000020H
  00050	7c 0b		 jl	 SHORT $LN2@getNameTab
$LN3@getNameTab:
  00052	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@getNameTab:

; 117  :     Assert(0 <= TileY && TileY < TILES_COUNT_Y);

  0005d	0f b7 44 24 24	 movzx	 eax, WORD PTR TileY$[rsp]
  00062	85 c0		 test	 eax, eax
  00064	7c 0a		 jl	 SHORT $LN5@getNameTab
  00066	0f b7 44 24 24	 movzx	 eax, WORD PTR TileY$[rsp]
  0006b	83 f8 1e	 cmp	 eax, 30
  0006e	7c 0b		 jl	 SHORT $LN4@getNameTab
$LN5@getNameTab:
  00070	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN4@getNameTab:

; 118  : 
; 119  :     uint16 Address = (TableBaseAddress + (TileY * TILES_COUNT_X)) + TileX;

  0007b	0f b7 44 24 50	 movzx	 eax, WORD PTR TableBaseAddress$[rsp]
  00080	0f b7 4c 24 24	 movzx	 ecx, WORD PTR TileY$[rsp]
  00085	6b c9 20	 imul	 ecx, ecx, 32		; 00000020H
  00088	03 c1		 add	 eax, ecx
  0008a	0f b7 4c 24 28	 movzx	 ecx, WORD PTR TileX$[rsp]
  0008f	03 c1		 add	 eax, ecx
  00091	66 89 44 24 2c	 mov	 WORD PTR Address$[rsp], ax

; 120  :     uint8 Value = readPpu8(Address, MemoryOffset);

  00096	48 8b 54 24 58	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  0009b	0f b7 4c 24 2c	 movzx	 ecx, WORD PTR Address$[rsp]
  000a0	e8 00 00 00 00	 call	 ?readPpu8@@YAEG_K@Z	; readPpu8
  000a5	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 121  :     return(Value);

  000a9	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]

; 122  : }

  000ae	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b2	c3		 ret	 0
?getNameTableValue@@YAEGGG_K@Z ENDP			; getNameTableValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
Byte$ = 48
Address$ = 56
MemoryOffset$ = 64
?writePpu8@@YAXEG_K@Z PROC				; writePpu8

; 100  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 101  :     if(0x3000 <= Address && Address < 0x3F00)

  00012	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00017	3d 00 30 00 00	 cmp	 eax, 12288		; 00003000H
  0001c	7c 2b		 jl	 SHORT $LN2@writePpu8
  0001e	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00023	3d 00 3f 00 00	 cmp	 eax, 16128		; 00003f00H
  00028	7d 1f		 jge	 SHORT $LN2@writePpu8

; 102  :         Address = (Address % (0x3000 - 0x2000)) + 0x2000;

  0002a	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  0002f	99		 cdq
  00030	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  00036	03 c2		 add	 eax, edx
  00038	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0003d	2b c2		 sub	 eax, edx
  0003f	05 00 20 00 00	 add	 eax, 8192		; 00002000H
  00044	66 89 44 24 38	 mov	 WORD PTR Address$[rsp], ax
$LN2@writePpu8:

; 103  :     if(0x3F20 <= Address && Address < 0x4000)

  00049	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  0004e	3d 20 3f 00 00	 cmp	 eax, 16160		; 00003f20H
  00053	7c 26		 jl	 SHORT $LN3@writePpu8
  00055	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  0005a	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  0005f	7d 1a		 jge	 SHORT $LN3@writePpu8

; 104  :         Address = (Address % (0x3F20 - 0x3F00)) + 0x3F00;

  00061	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00066	99		 cdq
  00067	83 e2 1f	 and	 edx, 31
  0006a	03 c2		 add	 eax, edx
  0006c	83 e0 1f	 and	 eax, 31
  0006f	2b c2		 sub	 eax, edx
  00071	05 00 3f 00 00	 add	 eax, 16128		; 00003f00H
  00076	66 89 44 24 38	 mov	 WORD PTR Address$[rsp], ax
$LN3@writePpu8:

; 105  :     if(Address >= 0x4000)

  0007b	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  00080	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  00085	7c 1a		 jl	 SHORT $LN4@writePpu8

; 106  :         Address = Address % 0x4000; 

  00087	0f b7 44 24 38	 movzx	 eax, WORD PTR Address$[rsp]
  0008c	99		 cdq
  0008d	81 e2 ff 3f 00
	00		 and	 edx, 16383		; 00003fffH
  00093	03 c2		 add	 eax, edx
  00095	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  0009a	2b c2		 sub	 eax, edx
  0009c	66 89 44 24 38	 mov	 WORD PTR Address$[rsp], ax
$LN4@writePpu8:

; 107  :     
; 108  :     write8(Byte, Address, MemoryOffset);

  000a1	4c 8b 44 24 40	 mov	 r8, QWORD PTR MemoryOffset$[rsp]
  000a6	0f b7 54 24 38	 movzx	 edx, WORD PTR Address$[rsp]
  000ab	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR Byte$[rsp]
  000b0	e8 00 00 00 00	 call	 ?write8@@YAXEG_K@Z	; write8

; 109  : }

  000b5	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b9	c3		 ret	 0
?writePpu8@@YAXEG_K@Z ENDP				; writePpu8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
_TEXT	SEGMENT
Result$ = 32
Address$ = 64
MemoryOffset$ = 72
?readPpu8@@YAEG_K@Z PROC				; readPpu8

; 88   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 89   :     if(0x3000 <= Address && Address < 0x3F00)

  0000e	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00013	3d 00 30 00 00	 cmp	 eax, 12288		; 00003000H
  00018	7c 2b		 jl	 SHORT $LN2@readPpu8
  0001a	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0001f	3d 00 3f 00 00	 cmp	 eax, 16128		; 00003f00H
  00024	7d 1f		 jge	 SHORT $LN2@readPpu8

; 90   :         Address = (Address % (0x3000 - 0x2000)) + 0x2000;

  00026	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0002b	99		 cdq
  0002c	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  00032	03 c2		 add	 eax, edx
  00034	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00039	2b c2		 sub	 eax, edx
  0003b	05 00 20 00 00	 add	 eax, 8192		; 00002000H
  00040	66 89 44 24 40	 mov	 WORD PTR Address$[rsp], ax
$LN2@readPpu8:

; 91   :     if(0x3F20 <= Address && Address < 0x4000)

  00045	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0004a	3d 20 3f 00 00	 cmp	 eax, 16160		; 00003f20H
  0004f	7c 26		 jl	 SHORT $LN3@readPpu8
  00051	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00056	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  0005b	7d 1a		 jge	 SHORT $LN3@readPpu8

; 92   :         Address = (Address % (0x3F20 - 0x3F00)) + 0x3F00;

  0005d	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00062	99		 cdq
  00063	83 e2 1f	 and	 edx, 31
  00066	03 c2		 add	 eax, edx
  00068	83 e0 1f	 and	 eax, 31
  0006b	2b c2		 sub	 eax, edx
  0006d	05 00 3f 00 00	 add	 eax, 16128		; 00003f00H
  00072	66 89 44 24 40	 mov	 WORD PTR Address$[rsp], ax
$LN3@readPpu8:

; 93   :     if(Address >= 0x4000)

  00077	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0007c	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  00081	7c 1a		 jl	 SHORT $LN4@readPpu8

; 94   :         Address = Address % 0x4000; 

  00083	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00088	99		 cdq
  00089	81 e2 ff 3f 00
	00		 and	 edx, 16383		; 00003fffH
  0008f	03 c2		 add	 eax, edx
  00091	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  00096	2b c2		 sub	 eax, edx
  00098	66 89 44 24 40	 mov	 WORD PTR Address$[rsp], ax
$LN4@readPpu8:

; 95   : 
; 96   :     uint8 Result = read8(Address, MemoryOffset);

  0009d	48 8b 54 24 48	 mov	 rdx, QWORD PTR MemoryOffset$[rsp]
  000a2	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  000a7	e8 00 00 00 00	 call	 ?read8@@YAEG_K@Z	; read8
  000ac	88 44 24 20	 mov	 BYTE PTR Result$[rsp], al

; 97   :     return(Result);

  000b0	0f b6 44 24 20	 movzx	 eax, BYTE PTR Result$[rsp]

; 98   : }

  000b5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b9	c3		 ret	 0
?readPpu8@@YAEG_K@Z ENDP				; readPpu8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\ppu.cpp
;	COMDAT ?drawPixel@@YAXPEAUppu@@GGPEAE@Z
_TEXT	SEGMENT
CurrentPixel$ = 0
Ppu$ = 32
X$ = 40
Y$ = 48
Colour$ = 56
?drawPixel@@YAXPEAUppu@@GGPEAE@Z PROC			; drawPixel, COMDAT

; 82   : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000b	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	48 83 ec 18	 sub	 rsp, 24

; 83   :     uint32 *CurrentPixel = (Ppu->BasePixel + (Y * PIXEL_WIDTH)) + X;

  00019	0f b7 44 24 30	 movzx	 eax, WORD PTR Y$[rsp]
  0001e	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  00024	48 98		 cdqe
  00026	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Ppu$[rsp]
  0002b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0002f	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  00033	0f b7 4c 24 28	 movzx	 ecx, WORD PTR X$[rsp]
  00038	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  0003c	48 89 04 24	 mov	 QWORD PTR CurrentPixel$[rsp], rax

; 84   :     *CurrentPixel  = ((Colour[0] << 16) | (Colour[1] << 8) | Colour[2]);

  00040	b8 01 00 00 00	 mov	 eax, 1
  00045	48 6b c0 00	 imul	 rax, rax, 0
  00049	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Colour$[rsp]
  0004e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00052	c1 e0 10	 shl	 eax, 16
  00055	b9 01 00 00 00	 mov	 ecx, 1
  0005a	48 6b c9 01	 imul	 rcx, rcx, 1
  0005e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Colour$[rsp]
  00063	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00067	c1 e1 08	 shl	 ecx, 8
  0006a	0b c1		 or	 eax, ecx
  0006c	b9 01 00 00 00	 mov	 ecx, 1
  00071	48 6b c9 02	 imul	 rcx, rcx, 2
  00075	48 8b 54 24 38	 mov	 rdx, QWORD PTR Colour$[rsp]
  0007a	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0007e	0b c1		 or	 eax, ecx
  00080	48 8b 0c 24	 mov	 rcx, QWORD PTR CurrentPixel$[rsp]
  00084	89 01		 mov	 DWORD PTR [rcx], eax

; 85   : }

  00086	48 83 c4 18	 add	 rsp, 24
  0008a	c3		 ret	 0
?drawPixel@@YAXPEAUppu@@GGPEAE@Z ENDP			; drawPixel
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\palette.cpp
_TEXT	SEGMENT
Entry$ = 8
Colour$ = 16
?getPaletteValue@@YAXEPEAE@Z PROC			; getPaletteValue

; 31   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 32   :     Colour[0] = Palette[Entry][0];

  00009	0f b6 44 24 08	 movzx	 eax, BYTE PTR Entry$[rsp]
  0000e	48 6b c0 03	 imul	 rax, rax, 3
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Palette@@3PAY02EA ; Palette
  00019	48 03 c8	 add	 rcx, rax
  0001c	48 8b c1	 mov	 rax, rcx
  0001f	b9 01 00 00 00	 mov	 ecx, 1
  00024	48 6b c9 00	 imul	 rcx, rcx, 0
  00028	ba 01 00 00 00	 mov	 edx, 1
  0002d	48 6b d2 00	 imul	 rdx, rdx, 0
  00031	4c 8b 44 24 10	 mov	 r8, QWORD PTR Colour$[rsp]
  00036	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0003a	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 33   :     Colour[1] = Palette[Entry][1];

  0003e	0f b6 44 24 08	 movzx	 eax, BYTE PTR Entry$[rsp]
  00043	48 6b c0 03	 imul	 rax, rax, 3
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Palette@@3PAY02EA ; Palette
  0004e	48 03 c8	 add	 rcx, rax
  00051	48 8b c1	 mov	 rax, rcx
  00054	b9 01 00 00 00	 mov	 ecx, 1
  00059	48 6b c9 01	 imul	 rcx, rcx, 1
  0005d	ba 01 00 00 00	 mov	 edx, 1
  00062	48 6b d2 01	 imul	 rdx, rdx, 1
  00066	4c 8b 44 24 10	 mov	 r8, QWORD PTR Colour$[rsp]
  0006b	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0006f	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 34   :     Colour[2]  = Palette[Entry][2];

  00073	0f b6 44 24 08	 movzx	 eax, BYTE PTR Entry$[rsp]
  00078	48 6b c0 03	 imul	 rax, rax, 3
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Palette@@3PAY02EA ; Palette
  00083	48 03 c8	 add	 rcx, rax
  00086	48 8b c1	 mov	 rax, rcx
  00089	b9 01 00 00 00	 mov	 ecx, 1
  0008e	48 6b c9 02	 imul	 rcx, rcx, 2
  00092	ba 01 00 00 00	 mov	 edx, 1
  00097	48 6b d2 02	 imul	 rdx, rdx, 2
  0009b	4c 8b 44 24 10	 mov	 r8, QWORD PTR Colour$[rsp]
  000a0	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000a4	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 35   : }

  000a8	c3		 ret	 0
?getPaletteValue@@YAXEPEAE@Z ENDP			; getPaletteValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Address$ = 32
CyclesElapsed$ = 36
Instruction$ = 37
idx$1 = 38
AddressMode$ = 39
InstrData$ = 40
InstrLength$ = 44
InstrCycles$ = 45
RelOffset$2 = 46
ZeroAddress$3 = 47
AddedAddress$4 = 48
ZeroAddress$5 = 49
AdditionalCycles$6 = 50
i$7 = 52
CrossedPage$ = 56
IndirectAddress$8 = 60
tv149 = 64
$T9 = 72
$T10 = 80
InstrName$ = 88
tv316 = 96
LogCpu$ = 112
__$ArrayPad$ = 224
Cpu$ = 272
NewInput$ = 280
?cpuTick@@YAEPEAUcpu@@PEAUinput@@@Z PROC		; cpuTick

; 404  : {        

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 405  :     uint8 CyclesElapsed = 0;

  00025	c6 44 24 24 00	 mov	 BYTE PTR CyclesElapsed$[rsp], 0

; 406  : 
; 407  :     uint16 Address = 0;

  0002a	33 c0		 xor	 eax, eax
  0002c	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 408  :     bool32 CrossedPage = 0;

  00031	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR CrossedPage$[rsp], 0

; 409  :     
; 410  :     uint8 Instruction;
; 411  :     uint8 AddressMode;
; 412  :     uint8 InstrLength;
; 413  :     char *InstrName;
; 414  :     uint8 InstrCycles;
; 415  :     uint8 InstrData[3]; // Stores data for each instruction
; 416  : 
; 417  :     // NOTE: Logging: Save Cpu before changes. Print out later
; 418  :     cpu LogCpu = *Cpu;

  00039	48 8d 44 24 70	 lea	 rax, QWORD PTR LogCpu$[rsp]
  0003e	48 8b f8	 mov	 rdi, rax
  00041	48 8b b4 24 10
	01 00 00	 mov	 rsi, QWORD PTR Cpu$[rsp]
  00049	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  0004e	f3 a4		 rep movsb

; 419  : 
; 420  :     if(Cpu->PadStrobe)

  00050	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  00058	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0005c	74 3f		 je	 SHORT $LN10@cpuTick

; 421  :     {
; 422  :         for(uint8 idx = 0; idx < input::BUTTON_NUM; ++idx)

  0005e	c6 44 24 26 00	 mov	 BYTE PTR idx$1[rsp], 0
  00063	eb 0b		 jmp	 SHORT $LN4@cpuTick
$LN2@cpuTick:
  00065	0f b6 44 24 26	 movzx	 eax, BYTE PTR idx$1[rsp]
  0006a	fe c0		 inc	 al
  0006c	88 44 24 26	 mov	 BYTE PTR idx$1[rsp], al
$LN4@cpuTick:
  00070	0f b6 44 24 26	 movzx	 eax, BYTE PTR idx$1[rsp]
  00075	83 f8 08	 cmp	 eax, 8
  00078	7d 23		 jge	 SHORT $LN3@cpuTick

; 423  :             Cpu->InputPad1.buttons[idx] = NewInput->buttons[idx];

  0007a	0f b6 44 24 26	 movzx	 eax, BYTE PTR idx$1[rsp]
  0007f	0f b6 4c 24 26	 movzx	 ecx, BYTE PTR idx$1[rsp]
  00084	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0008c	48 8b bc 24 18
	01 00 00	 mov	 rdi, QWORD PTR NewInput$[rsp]
  00094	8b 04 87	 mov	 eax, DWORD PTR [rdi+rax*4]
  00097	89 44 8a 1c	 mov	 DWORD PTR [rdx+rcx*4+28], eax
  0009b	eb c8		 jmp	 SHORT $LN2@cpuTick
$LN3@cpuTick:
$LN10@cpuTick:

; 424  :     }
; 425  :     
; 426  :     if(NmiTriggered)

  0009d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?NmiTriggered@@3HA, 0 ; NmiTriggered
  000a4	74 5b		 je	 SHORT $LN11@cpuTick

; 427  :     {
; 428  :         LogCpu.PrgCounter = NMI_VEC;

  000a6	b8 fa ff 00 00	 mov	 eax, 65530		; 0000fffaH
  000ab	66 89 44 24 76	 mov	 WORD PTR LogCpu$[rsp+6], ax

; 429  :         Address = NMI_VEC;

  000b0	b8 fa ff 00 00	 mov	 eax, 65530		; 0000fffaH
  000b5	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 430  :         AddressMode = IMPL;

  000ba	c6 44 24 27 09	 mov	 BYTE PTR AddressMode$[rsp], 9

; 431  :         InstrLength = 0;

  000bf	c6 44 24 2c 00	 mov	 BYTE PTR InstrLength$[rsp], 0

; 432  :         InstrName = "NMI";

  000c4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88730
  000cb	48 89 44 24 58	 mov	 QWORD PTR InstrName$[rsp], rax

; 433  :         InstrCycles = 7;

  000d0	c6 44 24 2d 07	 mov	 BYTE PTR InstrCycles$[rsp], 7

; 434  :         InstrData[0] = 0;

  000d5	b8 01 00 00 00	 mov	 eax, 1
  000da	48 6b c0 00	 imul	 rax, rax, 0
  000de	48 89 44 24 48	 mov	 QWORD PTR $T9[rsp], rax
  000e3	48 83 7c 24 48
	03		 cmp	 QWORD PTR $T9[rsp], 3
  000e9	73 02		 jae	 SHORT $LN37@cpuTick
  000eb	eb 05		 jmp	 SHORT $LN38@cpuTick
$LN37@cpuTick:
  000ed	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN38@cpuTick:
  000f2	48 8b 44 24 48	 mov	 rax, QWORD PTR $T9[rsp]
  000f7	c6 44 04 28 00	 mov	 BYTE PTR InstrData$[rsp+rax], 0
  000fc	e9 1c 01 00 00	 jmp	 $LN12@cpuTick
$LN11@cpuTick:

; 435  :     }
; 436  :     else if(IrqTriggered)

  00101	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IrqTriggered@@3HA, 0 ; IrqTriggered
  00108	74 5b		 je	 SHORT $LN13@cpuTick

; 437  :     {
; 438  :         LogCpu.PrgCounter = IRQ_BRK_VEC;

  0010a	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  0010f	66 89 44 24 76	 mov	 WORD PTR LogCpu$[rsp+6], ax

; 439  :         Address = IRQ_BRK_VEC;

  00114	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  00119	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 440  :         AddressMode = IMPL;

  0011e	c6 44 24 27 09	 mov	 BYTE PTR AddressMode$[rsp], 9

; 441  :         InstrLength = 0;

  00123	c6 44 24 2c 00	 mov	 BYTE PTR InstrLength$[rsp], 0

; 442  :         InstrName = "IRQ";

  00128	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG88733
  0012f	48 89 44 24 58	 mov	 QWORD PTR InstrName$[rsp], rax

; 443  :         InstrCycles = 7;

  00134	c6 44 24 2d 07	 mov	 BYTE PTR InstrCycles$[rsp], 7

; 444  :         InstrData[0] = 0;

  00139	b8 01 00 00 00	 mov	 eax, 1
  0013e	48 6b c0 00	 imul	 rax, rax, 0
  00142	48 89 44 24 50	 mov	 QWORD PTR $T10[rsp], rax
  00147	48 83 7c 24 50
	03		 cmp	 QWORD PTR $T10[rsp], 3
  0014d	73 02		 jae	 SHORT $LN39@cpuTick
  0014f	eb 05		 jmp	 SHORT $LN40@cpuTick
$LN39@cpuTick:
  00151	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN40@cpuTick:
  00156	48 8b 44 24 50	 mov	 rax, QWORD PTR $T10[rsp]
  0015b	c6 44 04 28 00	 mov	 BYTE PTR InstrData$[rsp+rax], 0

; 445  :     }
; 446  :     else

  00160	e9 b8 00 00 00	 jmp	 $LN14@cpuTick
$LN13@cpuTick:

; 447  :     {    
; 448  :         Instruction = readCpu8(Cpu->PrgCounter, Cpu);

  00165	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0016d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  00175	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00179	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  0017e	88 44 24 25	 mov	 BYTE PTR Instruction$[rsp], al

; 449  :         AddressMode = instAddressMode[Instruction];

  00182	0f b6 44 24 25	 movzx	 eax, BYTE PTR Instruction$[rsp]
  00187	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instAddressMode@@3PAEA
  0018e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00192	88 44 24 27	 mov	 BYTE PTR AddressMode$[rsp], al

; 450  :         InstrLength = instLength[Instruction];

  00196	0f b6 44 24 25	 movzx	 eax, BYTE PTR Instruction$[rsp]
  0019b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instLength@@3PAEA
  001a2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001a6	88 44 24 2c	 mov	 BYTE PTR InstrLength$[rsp], al

; 451  :         InstrName = instName[Instruction];

  001aa	0f b6 44 24 25	 movzx	 eax, BYTE PTR Instruction$[rsp]
  001af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instName@@3PAPEADA
  001b6	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  001ba	48 89 44 24 58	 mov	 QWORD PTR InstrName$[rsp], rax

; 452  :         InstrCycles = instCycles[Instruction];

  001bf	0f b6 44 24 25	 movzx	 eax, BYTE PTR Instruction$[rsp]
  001c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instCycles@@3PAEA
  001cb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001cf	88 44 24 2d	 mov	 BYTE PTR InstrCycles$[rsp], al

; 453  : 
; 454  :         for(int i = 0; i < InstrLength; ++i)

  001d3	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$7[rsp], 0
  001db	eb 0a		 jmp	 SHORT $LN7@cpuTick
$LN5@cpuTick:
  001dd	8b 44 24 34	 mov	 eax, DWORD PTR i$7[rsp]
  001e1	ff c0		 inc	 eax
  001e3	89 44 24 34	 mov	 DWORD PTR i$7[rsp], eax
$LN7@cpuTick:
  001e7	0f b6 44 24 2c	 movzx	 eax, BYTE PTR InstrLength$[rsp]
  001ec	39 44 24 34	 cmp	 DWORD PTR i$7[rsp], eax
  001f0	7d 2b		 jge	 SHORT $LN6@cpuTick

; 455  :         {
; 456  :             InstrData[i] = readCpu8(Cpu->PrgCounter + i, Cpu); 

  001f2	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  001fa	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  001fe	03 44 24 34	 add	 eax, DWORD PTR i$7[rsp]
  00202	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0020a	0f b7 c8	 movzx	 ecx, ax
  0020d	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00212	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$7[rsp]
  00217	88 44 0c 28	 mov	 BYTE PTR InstrData$[rsp+rcx], al

; 457  :         }

  0021b	eb c0		 jmp	 SHORT $LN5@cpuTick
$LN6@cpuTick:
$LN14@cpuTick:
$LN12@cpuTick:

; 458  :     }
; 459  :     
; 460  :     switch(AddressMode)

  0021d	0f b6 44 24 27	 movzx	 eax, BYTE PTR AddressMode$[rsp]
  00222	89 44 24 40	 mov	 DWORD PTR tv149[rsp], eax
  00226	83 7c 24 40 0d	 cmp	 DWORD PTR tv149[rsp], 13
  0022b	0f 87 bf 02 00
	00		 ja	 $LN8@cpuTick
  00231	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv149[rsp]
  00236	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0023d	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN41@cpuTick[rcx+rax*4]
  00244	48 03 c1	 add	 rax, rcx
  00247	ff e0		 jmp	 rax

; 461  :     {
; 462  :         case ACM:
; 463  :             break;            

  00249	e9 a2 02 00 00	 jmp	 $LN8@cpuTick

; 464  :         case IMPL:
; 465  :             break;

  0024e	e9 9d 02 00 00	 jmp	 $LN8@cpuTick
$LN17@cpuTick:

; 466  :         case IMED:
; 467  :             Address = Cpu->PrgCounter + 1;

  00253	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  0025b	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0025f	ff c0		 inc	 eax
  00261	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 468  :             break;

  00266	e9 85 02 00 00	 jmp	 $LN8@cpuTick
$LN18@cpuTick:

; 469  :         case ZERO:
; 470  :             Address = (uint16)InstrData[1];

  0026b	b8 01 00 00 00	 mov	 eax, 1
  00270	48 6b c0 01	 imul	 rax, rax, 1
  00274	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  00279	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 471  :             break;

  0027e	e9 6d 02 00 00	 jmp	 $LN8@cpuTick
$LN19@cpuTick:

; 472  :         case ZERX:
; 473  :             Address = ((uint16)InstrData[1] + Cpu->X) & 0xFF;

  00283	b8 01 00 00 00	 mov	 eax, 1
  00288	48 6b c0 01	 imul	 rax, rax, 1
  0028c	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  00291	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00299	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0029d	03 c1		 add	 eax, ecx
  0029f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002a4	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 474  :             break;

  002a9	e9 42 02 00 00	 jmp	 $LN8@cpuTick
$LN20@cpuTick:

; 475  :         case ZERY:
; 476  :             Address = ((uint16)InstrData[1] + Cpu->Y) & 0xFF;

  002ae	b8 01 00 00 00	 mov	 eax, 1
  002b3	48 6b c0 01	 imul	 rax, rax, 1
  002b7	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  002bc	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  002c4	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  002c8	03 c1		 add	 eax, ecx
  002ca	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002cf	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 477  :             break;

  002d4	e9 17 02 00 00	 jmp	 $LN8@cpuTick
$LN21@cpuTick:

; 478  :         case ABS:
; 479  :             Address = ((uint16)InstrData[2] << 8) | InstrData[1];

  002d9	b8 01 00 00 00	 mov	 eax, 1
  002de	48 6b c0 02	 imul	 rax, rax, 2
  002e2	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  002e7	c1 e0 08	 shl	 eax, 8
  002ea	b9 01 00 00 00	 mov	 ecx, 1
  002ef	48 6b c9 01	 imul	 rcx, rcx, 1
  002f3	0f b6 4c 0c 28	 movzx	 ecx, BYTE PTR InstrData$[rsp+rcx]
  002f8	0b c1		 or	 eax, ecx
  002fa	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 480  :             break;

  002ff	e9 ec 01 00 00	 jmp	 $LN8@cpuTick
$LN22@cpuTick:

; 481  :         case ABSX:
; 482  :             Address = (((uint16)InstrData[2] << 8) | InstrData[1]) + Cpu->X;

  00304	b8 01 00 00 00	 mov	 eax, 1
  00309	48 6b c0 02	 imul	 rax, rax, 2
  0030d	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  00312	c1 e0 08	 shl	 eax, 8
  00315	b9 01 00 00 00	 mov	 ecx, 1
  0031a	48 6b c9 01	 imul	 rcx, rcx, 1
  0031e	0f b6 4c 0c 28	 movzx	 ecx, BYTE PTR InstrData$[rsp+rcx]
  00323	0b c1		 or	 eax, ecx
  00325	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0032d	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00331	03 c1		 add	 eax, ecx
  00333	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 483  :             CrossedPage = crossedPageCheck(Address - Cpu->X, Address);

  00338	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  0033d	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00345	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00349	2b c1		 sub	 eax, ecx
  0034b	0f b7 54 24 20	 movzx	 edx, WORD PTR Address$[rsp]
  00350	0f b7 c8	 movzx	 ecx, ax
  00353	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  00358	89 44 24 38	 mov	 DWORD PTR CrossedPage$[rsp], eax

; 484  :             break;

  0035c	e9 8f 01 00 00	 jmp	 $LN8@cpuTick
$LN23@cpuTick:

; 485  :         case ABSY:
; 486  :             Address = (((uint16)InstrData[2] << 8) | InstrData[1]) + Cpu->Y;

  00361	b8 01 00 00 00	 mov	 eax, 1
  00366	48 6b c0 02	 imul	 rax, rax, 2
  0036a	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  0036f	c1 e0 08	 shl	 eax, 8
  00372	b9 01 00 00 00	 mov	 ecx, 1
  00377	48 6b c9 01	 imul	 rcx, rcx, 1
  0037b	0f b6 4c 0c 28	 movzx	 ecx, BYTE PTR InstrData$[rsp+rcx]
  00380	0b c1		 or	 eax, ecx
  00382	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0038a	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  0038e	03 c1		 add	 eax, ecx
  00390	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 487  :             CrossedPage = crossedPageCheck(Address - Cpu->Y, Address);

  00395	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  0039a	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  003a2	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  003a6	2b c1		 sub	 eax, ecx
  003a8	0f b7 54 24 20	 movzx	 edx, WORD PTR Address$[rsp]
  003ad	0f b7 c8	 movzx	 ecx, ax
  003b0	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  003b5	89 44 24 38	 mov	 DWORD PTR CrossedPage$[rsp], eax

; 488  :             break;

  003b9	e9 32 01 00 00	 jmp	 $LN8@cpuTick
$LN24@cpuTick:

; 489  :         case REL:
; 490  :         {
; 491  :             int8 RelOffset = InstrData[1];

  003be	b8 01 00 00 00	 mov	 eax, 1
  003c3	48 6b c0 01	 imul	 rax, rax, 1
  003c7	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  003cc	88 44 24 2e	 mov	 BYTE PTR RelOffset$2[rsp], al

; 492  :             Address = Cpu->PrgCounter + 2 + RelOffset;

  003d0	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR Cpu$[rsp]
  003d8	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  003dc	0f be 4c 24 2e	 movsx	 ecx, BYTE PTR RelOffset$2[rsp]
  003e1	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  003e5	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 493  :             break;

  003ea	e9 01 01 00 00	 jmp	 $LN8@cpuTick
$LN25@cpuTick:

; 494  :         }
; 495  :         case INDX:
; 496  :         {
; 497  :             uint8 ZeroAddress = InstrData[1];

  003ef	b8 01 00 00 00	 mov	 eax, 1
  003f4	48 6b c0 01	 imul	 rax, rax, 1
  003f8	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  003fd	88 44 24 2f	 mov	 BYTE PTR ZeroAddress$3[rsp], al

; 498  :             uint8 AddedAddress = (ZeroAddress + Cpu->X) & 0xFF;

  00401	0f b6 44 24 2f	 movzx	 eax, BYTE PTR ZeroAddress$3[rsp]
  00406	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0040e	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00412	03 c1		 add	 eax, ecx
  00414	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00419	88 44 24 30	 mov	 BYTE PTR AddedAddress$4[rsp], al

; 499  :             Address = bugReadCpu16(AddedAddress, Cpu);

  0041d	0f b6 44 24 30	 movzx	 eax, BYTE PTR AddedAddress$4[rsp]
  00422	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0042a	0f b7 c8	 movzx	 ecx, ax
  0042d	e8 00 00 00 00	 call	 ?bugReadCpu16@@YAGGPEAUcpu@@@Z ; bugReadCpu16
  00432	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 500  :             break;

  00437	e9 b4 00 00 00	 jmp	 $LN8@cpuTick
$LN26@cpuTick:

; 501  :         }
; 502  :         case INDY:
; 503  :         {
; 504  :             uint8 ZeroAddress = InstrData[1];

  0043c	b8 01 00 00 00	 mov	 eax, 1
  00441	48 6b c0 01	 imul	 rax, rax, 1
  00445	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  0044a	88 44 24 31	 mov	 BYTE PTR ZeroAddress$5[rsp], al

; 505  :             Address = bugReadCpu16(ZeroAddress, Cpu) + Cpu->Y;

  0044e	0f b6 44 24 31	 movzx	 eax, BYTE PTR ZeroAddress$5[rsp]
  00453	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0045b	0f b7 c8	 movzx	 ecx, ax
  0045e	e8 00 00 00 00	 call	 ?bugReadCpu16@@YAGGPEAUcpu@@@Z ; bugReadCpu16
  00463	0f b7 c0	 movzx	 eax, ax
  00466	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0046e	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  00472	03 c1		 add	 eax, ecx
  00474	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 506  :             CrossedPage = crossedPageCheck(Address - Cpu->Y, Address);

  00479	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  0047e	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00486	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  0048a	2b c1		 sub	 eax, ecx
  0048c	0f b7 54 24 20	 movzx	 edx, WORD PTR Address$[rsp]
  00491	0f b7 c8	 movzx	 ecx, ax
  00494	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  00499	89 44 24 38	 mov	 DWORD PTR CrossedPage$[rsp], eax

; 507  :             break;

  0049d	eb 51		 jmp	 SHORT $LN8@cpuTick
$LN27@cpuTick:

; 508  :         }
; 509  :         case INDI:
; 510  :         {
; 511  :             uint16 IndirectAddress = ((uint16)InstrData[2] << 8) | InstrData[1];

  0049f	b8 01 00 00 00	 mov	 eax, 1
  004a4	48 6b c0 02	 imul	 rax, rax, 2
  004a8	0f b6 44 04 28	 movzx	 eax, BYTE PTR InstrData$[rsp+rax]
  004ad	c1 e0 08	 shl	 eax, 8
  004b0	b9 01 00 00 00	 mov	 ecx, 1
  004b5	48 6b c9 01	 imul	 rcx, rcx, 1
  004b9	0f b6 4c 0c 28	 movzx	 ecx, BYTE PTR InstrData$[rsp+rcx]
  004be	0b c1		 or	 eax, ecx
  004c0	66 89 44 24 3c	 mov	 WORD PTR IndirectAddress$8[rsp], ax

; 512  :             Address = bugReadCpu16(IndirectAddress, Cpu);

  004c5	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR Cpu$[rsp]
  004cd	0f b7 4c 24 3c	 movzx	 ecx, WORD PTR IndirectAddress$8[rsp]
  004d2	e8 00 00 00 00	 call	 ?bugReadCpu16@@YAGGPEAUcpu@@@Z ; bugReadCpu16
  004d7	66 89 44 24 20	 mov	 WORD PTR Address$[rsp], ax

; 513  :             break;

  004dc	eb 12		 jmp	 SHORT $LN8@cpuTick
$LN28@cpuTick:

; 514  :         }
; 515  :         case NUL:
; 516  :         {
; 517  :             Assert(0);

  004de	33 c0		 xor	 eax, eax
  004e0	83 f8 01	 cmp	 eax, 1
  004e3	74 0b		 je	 SHORT $LN29@cpuTick
  004e5	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN29@cpuTick:
$LN8@cpuTick:

; 518  :             break;
; 519  :         }        
; 520  :     }
; 521  :     
; 522  :     Cpu->PrgCounter += InstrLength;

  004f0	0f b6 44 24 2c	 movzx	 eax, BYTE PTR InstrLength$[rsp]
  004f5	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  004fd	0f b7 49 06	 movzx	 ecx, WORD PTR [rcx+6]
  00501	03 c8		 add	 ecx, eax
  00503	8b c1		 mov	 eax, ecx
  00505	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0050d	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 523  :     CyclesElapsed += InstrCycles;

  00511	0f b6 44 24 2d	 movzx	 eax, BYTE PTR InstrCycles$[rsp]
  00516	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR CyclesElapsed$[rsp]
  0051b	03 c8		 add	 ecx, eax
  0051d	8b c1		 mov	 eax, ecx
  0051f	88 44 24 24	 mov	 BYTE PTR CyclesElapsed$[rsp], al

; 524  : 
; 525  :     if(NmiTriggered || IrqTriggered)

  00523	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?NmiTriggered@@3HA, 0 ; NmiTriggered
  0052a	75 09		 jne	 SHORT $LN32@cpuTick
  0052c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IrqTriggered@@3HA, 0 ; IrqTriggered
  00533	74 39		 je	 SHORT $LN30@cpuTick
$LN32@cpuTick:

; 526  :     {
; 527  :         if(NmiTriggered)

  00535	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?NmiTriggered@@3HA, 0 ; NmiTriggered
  0053c	74 0c		 je	 SHORT $LN33@cpuTick

; 528  :         {
; 529  :             NmiTriggered = false;

  0053e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?NmiTriggered@@3HA, 0 ; NmiTriggered

; 530  :         }
; 531  :         else

  00548	eb 0a		 jmp	 SHORT $LN34@cpuTick
$LN33@cpuTick:

; 532  :         {
; 533  :             IrqTriggered = false;

  0054a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?IrqTriggered@@3HA, 0 ; IrqTriggered
$LN34@cpuTick:

; 534  :         }
; 535  :         nmi_irq(Address, Cpu, AddressMode);

  00554	44 0f b6 44 24
	27		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0055a	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00562	0f b7 4c 24 20	 movzx	 ecx, WORD PTR Address$[rsp]
  00567	e8 00 00 00 00	 call	 ?nmi_irq@@YAEGPEAUcpu@@E@Z ; nmi_irq

; 536  :     }
; 537  :     else

  0056c	eb 66		 jmp	 SHORT $LN31@cpuTick
$LN30@cpuTick:

; 538  :     {
; 539  :         // NOTE: This is where the operation is executed, returning extra cycles, for branch ops
; 540  :         if(CrossedPage)

  0056e	83 7c 24 38 00	 cmp	 DWORD PTR CrossedPage$[rsp], 0
  00573	74 1d		 je	 SHORT $LN35@cpuTick

; 541  :             CyclesElapsed += instBoundaryCheck[Instruction];

  00575	0f b6 44 24 25	 movzx	 eax, BYTE PTR Instruction$[rsp]
  0057a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instBoundaryCheck@@3PAEA
  00581	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00585	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR CyclesElapsed$[rsp]
  0058a	03 c8		 add	 ecx, eax
  0058c	8b c1		 mov	 eax, ecx
  0058e	88 44 24 24	 mov	 BYTE PTR CyclesElapsed$[rsp], al
$LN35@cpuTick:

; 542  :      
; 543  :         uint8 AdditionalCycles = instrOps[Instruction](Address, Cpu, AddressMode);

  00592	0f b6 44 24 25	 movzx	 eax, BYTE PTR Instruction$[rsp]
  00597	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?instrOps@@3PAP6AEGPEAUcpu@@E@ZA ; instrOps
  0059e	48 89 4c 24 60	 mov	 QWORD PTR tv316[rsp], rcx
  005a3	44 0f b6 44 24
	27		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  005a9	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR Cpu$[rsp]
  005b1	0f b7 4c 24 20	 movzx	 ecx, WORD PTR Address$[rsp]
  005b6	48 8b 7c 24 60	 mov	 rdi, QWORD PTR tv316[rsp]
  005bb	ff 14 c7	 call	 QWORD PTR [rdi+rax*8]
  005be	88 44 24 32	 mov	 BYTE PTR AdditionalCycles$6[rsp], al

; 544  :         CyclesElapsed += AdditionalCycles;

  005c2	0f b6 44 24 32	 movzx	 eax, BYTE PTR AdditionalCycles$6[rsp]
  005c7	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR CyclesElapsed$[rsp]
  005cc	03 c8		 add	 ecx, eax
  005ce	8b c1		 mov	 eax, ecx
  005d0	88 44 24 24	 mov	 BYTE PTR CyclesElapsed$[rsp], al
$LN31@cpuTick:

; 545  :     }
; 546  : 
; 547  :     #if 0
; 548  :     char LogInstrData[16];
; 549  :     if(InstrLength == 3)
; 550  :         sprintf(LogInstrData, "%2X %2X %2X", InstrData[0], InstrData[1], InstrData[2]);
; 551  :     else if(InstrLength == 2)
; 552  :         sprintf(LogInstrData, "%2X %2X   ", InstrData[0], InstrData[1]);
; 553  :     else
; 554  :         sprintf(LogInstrData, "%2X      ", InstrData[0]);
; 555  : 
; 556  :     char LogOpInfo[64];
; 557  : //    sprintf(LogOpInfo, ""
; 558  :     
; 559  :     char LogCpuInfo[64];
; 560  :     sprintf(LogCpuInfo, "A:%2X X:%2X Y:%2X P:%2X SP:%2X  CYC: %d",
; 561  :             LogCpu.A, LogCpu.X, LogCpu.Y, LogCpu.Flags, LogCpu.StackPtr, CyclesElapsed);
; 562  : 
; 563  :     // NOTE: CPU Log options
; 564  :     char LogBuffer[1024];
; 565  :     sprintf(LogBuffer, "%4X %s    %s\n", LogCpu.PrgCounter, LogInstrData, LogCpuInfo);
; 566  :     OutputDebugString(LogBuffer);
; 567  : #endif
; 568  :     
; 569  :     return(CyclesElapsed);

  005d4	0f b6 44 24 24	 movzx	 eax, BYTE PTR CyclesElapsed$[rsp]
$LN36@cpuTick:

; 570  : }

  005d9	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005e1	48 33 cc	 xor	 rcx, rsp
  005e4	e8 00 00 00 00	 call	 __security_check_cookie
  005e9	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  005f0	5f		 pop	 rdi
  005f1	5e		 pop	 rsi
  005f2	c3		 ret	 0
  005f3	90		 npad	 1
$LN41@cpuTick:
  005f4	00 00 00 00	 DD	 $LN28@cpuTick
  005f8	00 00 00 00	 DD	 $LN8@cpuTick
  005fc	00 00 00 00	 DD	 $LN17@cpuTick
  00600	00 00 00 00	 DD	 $LN18@cpuTick
  00604	00 00 00 00	 DD	 $LN19@cpuTick
  00608	00 00 00 00	 DD	 $LN20@cpuTick
  0060c	00 00 00 00	 DD	 $LN21@cpuTick
  00610	00 00 00 00	 DD	 $LN22@cpuTick
  00614	00 00 00 00	 DD	 $LN23@cpuTick
  00618	00 00 00 00	 DD	 $LN8@cpuTick
  0061c	00 00 00 00	 DD	 $LN24@cpuTick
  00620	00 00 00 00	 DD	 $LN25@cpuTick
  00624	00 00 00 00	 DD	 $LN26@cpuTick
  00628	00 00 00 00	 DD	 $LN27@cpuTick
?cpuTick@@YAEPEAUcpu@@PEAUinput@@@Z ENDP		; cpuTick
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?nmi_irq@@YAEGPEAUcpu@@E@Z PROC				; nmi_irq

; 383  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 384  :     uint8 HighByte = (uint8)(Cpu->PrgCounter >> 8);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0001c	c1 f8 08	 sar	 eax, 8
  0001f	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 385  :     uint8 LowByte = (uint8)Cpu->PrgCounter; 

  00023	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  0002c	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 386  :     push(HighByte, Cpu);

  00030	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00035	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR HighByte$[rsp]
  0003a	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 387  :     push(LowByte, Cpu);

  0003f	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00044	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  00049	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 388  : 
; 389  :     clearBreak(&Cpu->Flags);

  0004e	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00053	48 83 c0 03	 add	 rax, 3
  00057	48 8b c8	 mov	 rcx, rax
  0005a	e8 00 00 00 00	 call	 ?clearBreak@@YAXPEAE@Z	; clearBreak

; 390  :     push(Cpu->Flags, Cpu); 

  0005f	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00064	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00069	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  0006d	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 391  :     setInterrupt(&Cpu->Flags);

  00072	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00077	48 83 c0 03	 add	 rax, 3
  0007b	48 8b c8	 mov	 rcx, rax
  0007e	e8 00 00 00 00	 call	 ?setInterrupt@@YAXPEAE@Z ; setInterrupt

; 392  : 
; 393  :     Cpu->PrgCounter = readCpu16(Address, Cpu);

  00083	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00088	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0008d	e8 00 00 00 00	 call	 ?readCpu16@@YAGGPEAUcpu@@@Z ; readCpu16
  00092	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00097	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 394  :     return(0);

  0009b	32 c0		 xor	 al, al

; 395  : }

  0009d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a1	c3		 ret	 0
?nmi_irq@@YAEGPEAUcpu@@E@Z ENDP				; nmi_irq
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?xaa@@YAEGPEAUcpu@@E@Z PROC				; xaa

; 787  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 788  :     Assert(0);

  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 0b		 je	 SHORT $LN2@xaa
  00016	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@xaa:

; 789  :     return(0);

  00021	32 c0		 xor	 al, al

; 790  : }

  00023	c3		 ret	 0
?xaa@@YAEGPEAUcpu@@E@Z ENDP				; xaa
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?tas@@YAEGPEAUcpu@@E@Z PROC				; tas

; 781  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 782  :     Assert(0);

  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 0b		 je	 SHORT $LN2@tas
  00016	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@tas:

; 783  :     return(0);

  00021	32 c0		 xor	 al, al

; 784  : }

  00023	c3		 ret	 0
?tas@@YAEGPEAUcpu@@E@Z ENDP				; tas
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?sre@@YAEGPEAUcpu@@E@Z PROC				; sre

; 775  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 776  :     lsr(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?lsr@@YAEGPEAUcpu@@E@Z	; lsr

; 777  :     eor(Address, Cpu, AddressMode);

  00028	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0002e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00033	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00038	e8 00 00 00 00	 call	 ?eor@@YAEGPEAUcpu@@E@Z	; eor

; 778  :     return(0);

  0003d	32 c0		 xor	 al, al

; 779  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
?sre@@YAEGPEAUcpu@@E@Z ENDP				; sre
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?slo@@YAEGPEAUcpu@@E@Z PROC				; slo

; 769  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 770  :     asl(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?asl@@YAEGPEAUcpu@@E@Z	; asl

; 771  :     ora(Address, Cpu, AddressMode);

  00028	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0002e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00033	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00038	e8 00 00 00 00	 call	 ?ora@@YAEGPEAUcpu@@E@Z	; ora

; 772  :     return(0);

  0003d	32 c0		 xor	 al, al

; 773  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
?slo@@YAEGPEAUcpu@@E@Z ENDP				; slo
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
ReadValue$ = 32
Value$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?shy@@YAEGPEAUcpu@@E@Z PROC				; shy

; 760  : {

$LN4:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 761  :     uint8 Value = (Cpu->Y & ((Address >> 8) + 1)) & 0xFF;

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00021	c1 f9 08	 sar	 ecx, 8
  00024	ff c1		 inc	 ecx
  00026	23 c1		 and	 eax, ecx
  00028	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0002d	88 44 24 21	 mov	 BYTE PTR Value$[rsp], al

; 762  :     uint8 ReadValue = readCpu8((Cpu->PrgCounter + 1), Cpu);

  00031	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00036	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0003a	ff c0		 inc	 eax
  0003c	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00041	0f b7 c8	 movzx	 ecx, ax
  00044	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00049	88 44 24 20	 mov	 BYTE PTR ReadValue$[rsp], al

; 763  :     
; 764  :     if((Cpu->X + ReadValue) <= 0xFF)

  0004d	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00052	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00056	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR ReadValue$[rsp]
  0005b	03 c1		 add	 eax, ecx
  0005d	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00062	7f 14		 jg	 SHORT $LN2@shy

; 765  :         writeCpu8(Value, Address, Cpu);

  00064	4c 8b 44 24 48	 mov	 r8, QWORD PTR Cpu$[rsp]
  00069	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0006e	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR Value$[rsp]
  00073	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8
$LN2@shy:

; 766  :     return(0);

  00078	32 c0		 xor	 al, al

; 767  : }

  0007a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007e	c3		 ret	 0
?shy@@YAEGPEAUcpu@@E@Z ENDP				; shy
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?shx@@YAEGPEAUcpu@@E@Z PROC				; shx

; 725  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 726  : 
; 727  :     return(0);

  0000f	32 c0		 xor	 al, al

; 728  : }

  00011	c3		 ret	 0
?shx@@YAEGPEAUcpu@@E@Z ENDP				; shx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?sax@@YAEGPEAUcpu@@E@Z PROC				; sax

; 719  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 720  :     uint8 Value = Cpu->A & Cpu->X;

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00020	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00024	23 c1		 and	 eax, ecx
  00026	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 721  :     writeCpu8(Value, Address, Cpu);    

  0002a	4c 8b 44 24 48	 mov	 r8, QWORD PTR Cpu$[rsp]
  0002f	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  00034	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00039	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8

; 722  :     return(0);

  0003e	32 c0		 xor	 al, al

; 723  : }

  00040	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00044	c3		 ret	 0
?sax@@YAEGPEAUcpu@@E@Z ENDP				; sax
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?rra@@YAEGPEAUcpu@@E@Z PROC				; rra

; 713  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 714  :     ror(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?ror@@YAEGPEAUcpu@@E@Z	; ror

; 715  :     adc(Address, Cpu, AddressMode);

  00028	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0002e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00033	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00038	e8 00 00 00 00	 call	 ?adc@@YAEGPEAUcpu@@E@Z	; adc

; 716  :     return(0);

  0003d	32 c0		 xor	 al, al

; 717  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
?rra@@YAEGPEAUcpu@@E@Z ENDP				; rra
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?rla@@YAEGPEAUcpu@@E@Z PROC				; rla

; 707  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 708  :     rol(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?rol@@YAEGPEAUcpu@@E@Z	; rol

; 709  :     AND(Address, Cpu, AddressMode);

  00028	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0002e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00033	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00038	e8 00 00 00 00	 call	 ?AND@@YAEGPEAUcpu@@E@Z	; AND

; 710  :     return(0);

  0003d	32 c0		 xor	 al, al

; 711  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
?rla@@YAEGPEAUcpu@@E@Z ENDP				; rla
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?lax@@YAEGPEAUcpu@@E@Z PROC				; lax

; 701  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 702  :     lda(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?lda@@YAEGPEAUcpu@@E@Z	; lda

; 703  :     ldx(Address, Cpu, AddressMode);

  00028	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0002e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00033	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00038	e8 00 00 00 00	 call	 ?ldx@@YAEGPEAUcpu@@E@Z	; ldx

; 704  :     return(0);

  0003d	32 c0		 xor	 al, al

; 705  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
?lax@@YAEGPEAUcpu@@E@Z ENDP				; lax
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?las@@YAEGPEAUcpu@@E@Z PROC				; las

; 697  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 698  :     return(0); 

  0000f	32 c0		 xor	 al, al

; 699  : }

  00011	c3		 ret	 0
?las@@YAEGPEAUcpu@@E@Z ENDP				; las
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?kil@@YAEGPEAUcpu@@E@Z PROC				; kil

; 692  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 693  :     //Assert(0);
; 694  :     return(0);

  0000f	32 c0		 xor	 al, al

; 695  : }

  00011	c3		 ret	 0
?kil@@YAEGPEAUcpu@@E@Z ENDP				; kil
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?isc@@YAEGPEAUcpu@@E@Z PROC				; isc

; 686  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 687  :     inc(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?inc@@YAEGPEAUcpu@@E@Z	; inc

; 688  :     sbc(Address, Cpu, AddressMode);

  00028	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0002e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00033	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00038	e8 00 00 00 00	 call	 ?sbc@@YAEGPEAUcpu@@E@Z	; sbc

; 689  :     return(0);

  0003d	32 c0		 xor	 al, al

; 690  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
?isc@@YAEGPEAUcpu@@E@Z ENDP				; isc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?dcp@@YAEGPEAUcpu@@E@Z PROC				; dcp

; 680  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 681  :     dec(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?dec@@YAEGPEAUcpu@@E@Z	; dec

; 682  :     cmp(Address, Cpu, AddressMode);

  00028	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  0002e	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00033	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00038	e8 00 00 00 00	 call	 ?cmp@@YAEGPEAUcpu@@E@Z	; cmp

; 683  :     return(0);

  0003d	32 c0		 xor	 al, al

; 684  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
?dcp@@YAEGPEAUcpu@@E@Z ENDP				; dcp
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
ANDValue$ = 32
Value$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?axs@@YAEGPEAUcpu@@E@Z PROC				; axs

; 663  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 664  :     uint8 Value = readCpu8(Address, Cpu);

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00018	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0001d	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00022	88 44 24 21	 mov	 BYTE PTR Value$[rsp], al

; 665  : 
; 666  :     uint8 ANDValue = (Cpu->A & Cpu->X);

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00033	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00037	23 c1		 and	 eax, ecx
  00039	88 44 24 20	 mov	 BYTE PTR ANDValue$[rsp], al

; 667  :     Cpu->X = ANDValue - Value;

  0003d	0f b6 44 24 20	 movzx	 eax, BYTE PTR ANDValue$[rsp]
  00042	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR Value$[rsp]
  00047	2b c1		 sub	 eax, ecx
  00049	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0004e	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 668  : 
; 669  :     if(ANDValue >= Value)

  00051	0f b6 44 24 20	 movzx	 eax, BYTE PTR ANDValue$[rsp]
  00056	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR Value$[rsp]
  0005b	3b c1		 cmp	 eax, ecx
  0005d	7c 13		 jl	 SHORT $LN2@axs

; 670  :         setCarry(&Cpu->Flags);

  0005f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00064	48 83 c0 03	 add	 rax, 3
  00068	48 8b c8	 mov	 rcx, rax
  0006b	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 671  :     else

  00070	eb 11		 jmp	 SHORT $LN3@axs
$LN2@axs:

; 672  :         clearCarry(&Cpu->Flags);

  00072	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00077	48 83 c0 03	 add	 rax, 3
  0007b	48 8b c8	 mov	 rcx, rax
  0007e	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN3@axs:

; 673  :     
; 674  :     setZero(Cpu->X, &Cpu->Flags);

  00083	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00088	48 83 c0 03	 add	 rax, 3
  0008c	48 8b d0	 mov	 rdx, rax
  0008f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00094	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00098	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 675  :     setNegative(Cpu->X, &Cpu->Flags);

  0009d	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000a2	48 83 c0 03	 add	 rax, 3
  000a6	48 8b d0	 mov	 rdx, rax
  000a9	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000ae	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  000b2	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 676  :     
; 677  :     return(0);

  000b7	32 c0		 xor	 al, al

; 678  : }

  000b9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bd	c3		 ret	 0
?axs@@YAEGPEAUcpu@@E@Z ENDP				; axs
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
bit6$ = 32
bit5$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?arr@@YAEGPEAUcpu@@E@Z PROC				; arr

; 639  : {

$LN9:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 640  :     AND(Address, Cpu, AddressMode);    

  00013	44 0f b6 44 24
	50		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?AND@@YAEGPEAUcpu@@E@Z	; AND

; 641  :     ror(Address, Cpu, ACM);

  00028	41 b0 01	 mov	 r8b, 1
  0002b	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00030	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00035	e8 00 00 00 00	 call	 ?ror@@YAEGPEAUcpu@@E@Z	; ror

; 642  : 
; 643  :     uint8 bit5 = Cpu->A & (1<<5);

  0003a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00042	83 e0 20	 and	 eax, 32			; 00000020H
  00045	88 44 24 21	 mov	 BYTE PTR bit5$[rsp], al

; 644  :     uint8 bit6 = Cpu->A & (1<<6);

  00049	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00051	83 e0 40	 and	 eax, 64			; 00000040H
  00054	88 44 24 20	 mov	 BYTE PTR bit6$[rsp], al

; 645  : 
; 646  :     if(bit6)

  00058	0f b6 44 24 20	 movzx	 eax, BYTE PTR bit6$[rsp]
  0005d	85 c0		 test	 eax, eax
  0005f	74 13		 je	 SHORT $LN2@arr

; 647  :         setCarry(&Cpu->Flags);

  00061	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00066	48 83 c0 03	 add	 rax, 3
  0006a	48 8b c8	 mov	 rcx, rax
  0006d	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 648  :     else

  00072	eb 11		 jmp	 SHORT $LN3@arr
$LN2@arr:

; 649  :         clearCarry(&Cpu->Flags);

  00074	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00079	48 83 c0 03	 add	 rax, 3
  0007d	48 8b c8	 mov	 rcx, rax
  00080	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN3@arr:

; 650  : 
; 651  :     if((bit5 && !bit6) || (!bit5 && bit6))

  00085	0f b6 44 24 21	 movzx	 eax, BYTE PTR bit5$[rsp]
  0008a	85 c0		 test	 eax, eax
  0008c	74 09		 je	 SHORT $LN7@arr
  0008e	0f b6 44 24 20	 movzx	 eax, BYTE PTR bit6$[rsp]
  00093	85 c0		 test	 eax, eax
  00095	74 12		 je	 SHORT $LN6@arr
$LN7@arr:
  00097	0f b6 44 24 21	 movzx	 eax, BYTE PTR bit5$[rsp]
  0009c	85 c0		 test	 eax, eax
  0009e	75 1c		 jne	 SHORT $LN4@arr
  000a0	0f b6 44 24 20	 movzx	 eax, BYTE PTR bit6$[rsp]
  000a5	85 c0		 test	 eax, eax
  000a7	74 13		 je	 SHORT $LN4@arr
$LN6@arr:

; 652  :         setOverflow(&Cpu->Flags);

  000a9	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000ae	48 83 c0 03	 add	 rax, 3
  000b2	48 8b c8	 mov	 rcx, rax
  000b5	e8 00 00 00 00	 call	 ?setOverflow@@YAXPEAE@Z	; setOverflow

; 653  :     else

  000ba	eb 11		 jmp	 SHORT $LN5@arr
$LN4@arr:

; 654  :         clearOverflow(&Cpu->Flags);

  000bc	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000c1	48 83 c0 03	 add	 rax, 3
  000c5	48 8b c8	 mov	 rcx, rax
  000c8	e8 00 00 00 00	 call	 ?clearOverflow@@YAXPEAE@Z ; clearOverflow
$LN5@arr:

; 655  :         
; 656  :     setZero(Cpu->A, &Cpu->Flags);

  000cd	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000d2	48 83 c0 03	 add	 rax, 3
  000d6	48 8b d0	 mov	 rdx, rax
  000d9	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000de	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000e1	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 657  :     setNegative(Cpu->A, &Cpu->Flags);

  000e6	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000eb	48 83 c0 03	 add	 rax, 3
  000ef	48 8b d0	 mov	 rdx, rax
  000f2	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000f7	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000fa	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 658  : 
; 659  :     
; 660  :     return(0);

  000ff	32 c0		 xor	 al, al

; 661  : }

  00101	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00105	c3		 ret	 0
?arr@@YAEGPEAUcpu@@E@Z ENDP				; arr
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?anc@@YAEGPEAUcpu@@E@Z PROC				; anc

; 628  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 629  :     AND(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?AND@@YAEGPEAUcpu@@E@Z	; AND

; 630  :     
; 631  :     if(isBitSet(NEGATIVE_BIT, Cpu->Flags))

  00028	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00031	b1 80		 mov	 cl, 128			; 00000080H
  00033	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00038	85 c0		 test	 eax, eax
  0003a	74 13		 je	 SHORT $LN2@anc

; 632  :         setCarry(&Cpu->Flags);

  0003c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	48 83 c0 03	 add	 rax, 3
  00045	48 8b c8	 mov	 rcx, rax
  00048	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 633  :     else

  0004d	eb 11		 jmp	 SHORT $LN3@anc
$LN2@anc:

; 634  :         clearCarry(&Cpu->Flags);

  0004f	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00054	48 83 c0 03	 add	 rax, 3
  00058	48 8b c8	 mov	 rcx, rax
  0005b	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN3@anc:

; 635  :     
; 636  :     return(0);

  00060	32 c0		 xor	 al, al

; 637  : }

  00062	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00066	c3		 ret	 0
?anc@@YAEGPEAUcpu@@E@Z ENDP				; anc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?alr@@YAEGPEAUcpu@@E@Z PROC				; alr

; 622  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 623  :     AND(Address, Cpu, AddressMode);

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR AddressMode$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0001e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00023	e8 00 00 00 00	 call	 ?AND@@YAEGPEAUcpu@@E@Z	; AND

; 624  :     lsr(Address, Cpu, ACM);

  00028	41 b0 01	 mov	 r8b, 1
  0002b	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00030	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Address$[rsp]
  00035	e8 00 00 00 00	 call	 ?lsr@@YAEGPEAUcpu@@E@Z	; lsr

; 625  :     return(0);

  0003a	32 c0		 xor	 al, al

; 626  : }

  0003c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00040	c3		 ret	 0
?alr@@YAEGPEAUcpu@@E@Z ENDP				; alr
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?ahx@@YAEGPEAUcpu@@E@Z PROC				; ahx

; 617  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 618  :     //Assert(0);
; 619  :     return(0);

  0000f	32 c0		 xor	 al, al

; 620  : }

  00011	c3		 ret	 0
?ahx@@YAEGPEAUcpu@@E@Z ENDP				; ahx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?txs@@YAEGPEAUcpu@@E@Z PROC				; txs

; 609  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 610  :     Cpu->StackPtr = Cpu->X;

  0000f	48 8b 44 24 10	 mov	 rax, QWORD PTR Cpu$[rsp]
  00014	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00019	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0001d	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 611  :     return(0);

  00020	32 c0		 xor	 al, al

; 612  : }

  00022	c3		 ret	 0
?txs@@YAEGPEAUcpu@@E@Z ENDP				; txs
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?tya@@YAEGPEAUcpu@@E@Z PROC				; tya

; 602  : {   

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 603  :     Cpu->A = Cpu->Y;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0001d	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  00021	88 08		 mov	 BYTE PTR [rax], cl

; 604  :     setZero(Cpu->A, &Cpu->Flags);

  00023	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	48 83 c0 03	 add	 rax, 3
  0002c	48 8b d0	 mov	 rdx, rax
  0002f	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00034	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00037	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 605  :     setNegative(Cpu->A, &Cpu->Flags);

  0003c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	48 83 c0 03	 add	 rax, 3
  00045	48 8b d0	 mov	 rdx, rax
  00048	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004d	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00050	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 606  :     return(0);

  00055	32 c0		 xor	 al, al

; 607  : }

  00057	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005b	c3		 ret	 0
?tya@@YAEGPEAUcpu@@E@Z ENDP				; tya
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?txa@@YAEGPEAUcpu@@E@Z PROC				; txa

; 595  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 596  :     Cpu->A = Cpu->X;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0001d	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00021	88 08		 mov	 BYTE PTR [rax], cl

; 597  :     setZero(Cpu->A, &Cpu->Flags);

  00023	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	48 83 c0 03	 add	 rax, 3
  0002c	48 8b d0	 mov	 rdx, rax
  0002f	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00034	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00037	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 598  :     setNegative(Cpu->A, &Cpu->Flags);

  0003c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	48 83 c0 03	 add	 rax, 3
  00045	48 8b d0	 mov	 rdx, rax
  00048	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004d	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00050	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 599  :     return(0);

  00055	32 c0		 xor	 al, al

; 600  : }

  00057	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005b	c3		 ret	 0
?txa@@YAEGPEAUcpu@@E@Z ENDP				; txa
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?tsx@@YAEGPEAUcpu@@E@Z PROC				; tsx

; 588  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 589  :     Cpu->X = Cpu->StackPtr;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0001d	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00021	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 590  :     setZero(Cpu->X, &Cpu->Flags);

  00024	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00029	48 83 c0 03	 add	 rax, 3
  0002d	48 8b d0	 mov	 rdx, rax
  00030	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00035	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00039	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 591  :     setNegative(Cpu->X, &Cpu->Flags);

  0003e	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00043	48 83 c0 03	 add	 rax, 3
  00047	48 8b d0	 mov	 rdx, rax
  0004a	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004f	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00053	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 592  :     return(0);

  00058	32 c0		 xor	 al, al

; 593  : }

  0005a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005e	c3		 ret	 0
?tsx@@YAEGPEAUcpu@@E@Z ENDP				; tsx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?tay@@YAEGPEAUcpu@@E@Z PROC				; tay

; 581  : {    

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 582  :     Cpu->Y = Cpu->A;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0001d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00020	88 48 02	 mov	 BYTE PTR [rax+2], cl

; 583  :     setZero(Cpu->Y, &Cpu->Flags);

  00023	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	48 83 c0 03	 add	 rax, 3
  0002c	48 8b d0	 mov	 rdx, rax
  0002f	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00034	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00038	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 584  :     setNegative(Cpu->Y, &Cpu->Flags);

  0003d	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00042	48 83 c0 03	 add	 rax, 3
  00046	48 8b d0	 mov	 rdx, rax
  00049	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004e	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00052	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 585  :     return(0);

  00057	32 c0		 xor	 al, al

; 586  : }

  00059	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005d	c3		 ret	 0
?tay@@YAEGPEAUcpu@@E@Z ENDP				; tay
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?tax@@YAEGPEAUcpu@@E@Z PROC				; tax

; 574  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 575  :     Cpu->X = Cpu->A;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0001d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00020	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 576  :     setZero(Cpu->X, &Cpu->Flags);

  00023	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	48 83 c0 03	 add	 rax, 3
  0002c	48 8b d0	 mov	 rdx, rax
  0002f	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00034	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00038	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 577  :     setNegative(Cpu->X, &Cpu->Flags);

  0003d	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00042	48 83 c0 03	 add	 rax, 3
  00046	48 8b d0	 mov	 rdx, rax
  00049	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004e	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00052	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 578  :     return(0);

  00057	32 c0		 xor	 al, al

; 579  : }

  00059	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005d	c3		 ret	 0
?tax@@YAEGPEAUcpu@@E@Z ENDP				; tax
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?sty@@YAEGPEAUcpu@@E@Z PROC				; sty

; 569  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 570  :     writeCpu8(Cpu->Y, Address, Cpu);

  00013	4c 8b 44 24 38	 mov	 r8, QWORD PTR Cpu$[rsp]
  00018	0f b7 54 24 30	 movzx	 edx, WORD PTR Address$[rsp]
  0001d	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00022	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00026	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8

; 571  :     return(0);

  0002b	32 c0		 xor	 al, al

; 572  : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
?sty@@YAEGPEAUcpu@@E@Z ENDP				; sty
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?stx@@YAEGPEAUcpu@@E@Z PROC				; stx

; 564  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 565  :     writeCpu8(Cpu->X, Address, Cpu);

  00013	4c 8b 44 24 38	 mov	 r8, QWORD PTR Cpu$[rsp]
  00018	0f b7 54 24 30	 movzx	 edx, WORD PTR Address$[rsp]
  0001d	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00022	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00026	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8

; 566  :     return(0);

  0002b	32 c0		 xor	 al, al

; 567  : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
?stx@@YAEGPEAUcpu@@E@Z ENDP				; stx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?sta@@YAEGPEAUcpu@@E@Z PROC				; sta

; 559  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 560  :     writeCpu8(Cpu->A, Address, Cpu);

  00013	4c 8b 44 24 38	 mov	 r8, QWORD PTR Cpu$[rsp]
  00018	0f b7 54 24 30	 movzx	 edx, WORD PTR Address$[rsp]
  0001d	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00022	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00025	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8

; 561  :     return(0);

  0002a	32 c0		 xor	 al, al

; 562  : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
?sta@@YAEGPEAUcpu@@E@Z ENDP				; sta
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?sei@@YAEGPEAUcpu@@E@Z PROC				; sei

; 554  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 555  :     setInterrupt(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?setInterrupt@@YAXPEAE@Z ; setInterrupt

; 556  :     return(0);

  00024	32 c0		 xor	 al, al

; 557  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?sei@@YAEGPEAUcpu@@E@Z ENDP				; sei
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?sed@@YAEGPEAUcpu@@E@Z PROC				; sed

; 549  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 550  :     setDecimal(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?setDecimal@@YAXPEAE@Z	; setDecimal

; 551  :     return(0);

  00024	32 c0		 xor	 al, al

; 552  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?sed@@YAEGPEAUcpu@@E@Z ENDP				; sed
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?sec@@YAEGPEAUcpu@@E@Z PROC				; sec

; 544  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 545  :     setCarry(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 546  :     return(0);

  00024	32 c0		 xor	 al, al

; 547  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?sec@@YAEGPEAUcpu@@E@Z ENDP				; sec
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
A$ = 32
B$ = 33
C$ = 34
Sum$ = 36
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?sbc@@YAEGPEAUcpu@@E@Z PROC				; sbc

; 518  : {

$LN7:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 519  :     uint8 A = Cpu->A;

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001b	88 44 24 20	 mov	 BYTE PTR A$[rsp], al

; 520  :     uint8 B = ~readCpu8(Address, Cpu); // NOTE: Using the inverse

  0001f	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00024	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00029	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  0002e	0f b6 c0	 movzx	 eax, al
  00031	f7 d0		 not	 eax
  00033	88 44 24 21	 mov	 BYTE PTR B$[rsp], al

; 521  :     uint8 C = isBitSet(CARRY_BIT, Cpu->Flags);

  00037	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003c	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00040	b1 01		 mov	 cl, 1
  00042	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00047	88 44 24 22	 mov	 BYTE PTR C$[rsp], al

; 522  : 
; 523  :     uint16 Sum = (uint16)A + (uint16)B + (uint16)C;

  0004b	0f b6 44 24 20	 movzx	 eax, BYTE PTR A$[rsp]
  00050	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR B$[rsp]
  00055	03 c1		 add	 eax, ecx
  00057	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR C$[rsp]
  0005c	03 c1		 add	 eax, ecx
  0005e	66 89 44 24 24	 mov	 WORD PTR Sum$[rsp], ax

; 524  : 
; 525  :     // Overflow check, taken from the web. One day find out how this works
; 526  :     if(((A ^ Sum) & (B ^ Sum) & 0x80) == 0x80)

  00063	0f b6 44 24 20	 movzx	 eax, BYTE PTR A$[rsp]
  00068	0f b7 4c 24 24	 movzx	 ecx, WORD PTR Sum$[rsp]
  0006d	33 c1		 xor	 eax, ecx
  0006f	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR B$[rsp]
  00074	0f b7 54 24 24	 movzx	 edx, WORD PTR Sum$[rsp]
  00079	33 ca		 xor	 ecx, edx
  0007b	23 c1		 and	 eax, ecx
  0007d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00082	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00087	75 13		 jne	 SHORT $LN2@sbc

; 527  :         setOverflow(&Cpu->Flags);

  00089	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0008e	48 83 c0 03	 add	 rax, 3
  00092	48 8b c8	 mov	 rcx, rax
  00095	e8 00 00 00 00	 call	 ?setOverflow@@YAXPEAE@Z	; setOverflow

; 528  :     else

  0009a	eb 11		 jmp	 SHORT $LN3@sbc
$LN2@sbc:

; 529  :         clearOverflow(&Cpu->Flags);

  0009c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000a1	48 83 c0 03	 add	 rax, 3
  000a5	48 8b c8	 mov	 rcx, rax
  000a8	e8 00 00 00 00	 call	 ?clearOverflow@@YAXPEAE@Z ; clearOverflow
$LN3@sbc:

; 530  : 
; 531  :     if(Sum & 0x100)

  000ad	0f b7 44 24 24	 movzx	 eax, WORD PTR Sum$[rsp]
  000b2	25 00 01 00 00	 and	 eax, 256		; 00000100H
  000b7	85 c0		 test	 eax, eax
  000b9	74 13		 je	 SHORT $LN4@sbc

; 532  :         setCarry(&Cpu->Flags);

  000bb	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000c0	48 83 c0 03	 add	 rax, 3
  000c4	48 8b c8	 mov	 rcx, rax
  000c7	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 533  :     else

  000cc	eb 11		 jmp	 SHORT $LN5@sbc
$LN4@sbc:

; 534  :         clearCarry(&Cpu->Flags);

  000ce	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000d3	48 83 c0 03	 add	 rax, 3
  000d7	48 8b c8	 mov	 rcx, rax
  000da	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN5@sbc:

; 535  : 
; 536  :     setZero(Sum, &Cpu->Flags);

  000df	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000e4	48 83 c0 03	 add	 rax, 3
  000e8	48 8b d0	 mov	 rdx, rax
  000eb	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Sum$[rsp]
  000f0	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 537  :     setNegative(Sum, &Cpu->Flags);

  000f5	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000fa	48 83 c0 03	 add	 rax, 3
  000fe	48 8b d0	 mov	 rdx, rax
  00101	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Sum$[rsp]
  00106	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 538  : 
; 539  :     Cpu->A = (uint8)Sum;

  0010b	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00110	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Sum$[rsp]
  00115	88 08		 mov	 BYTE PTR [rax], cl

; 540  : 
; 541  :     return(0);

  00117	32 c0		 xor	 al, al

; 542  : }

  00119	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0011d	c3		 ret	 0
?sbc@@YAEGPEAUcpu@@E@Z ENDP				; sbc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
ReturnAddress$ = 36
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?rts@@YAEGPEAUcpu@@E@Z PROC				; rts

; 510  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 511  :     uint8 LowByte = pop(Cpu);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  0001d	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 512  :     uint8 HighByte = pop(Cpu);

  00021	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00026	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  0002b	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 513  :     uint16 ReturnAddress = ((uint16)HighByte << 8) | (uint16)LowByte;

  0002f	0f b6 44 24 20	 movzx	 eax, BYTE PTR HighByte$[rsp]
  00034	c1 e0 08	 shl	 eax, 8
  00037	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  0003c	0b c1		 or	 eax, ecx
  0003e	66 89 44 24 24	 mov	 WORD PTR ReturnAddress$[rsp], ax

; 514  :     Cpu->PrgCounter = ReturnAddress + 1;

  00043	0f b7 44 24 24	 movzx	 eax, WORD PTR ReturnAddress$[rsp]
  00048	ff c0		 inc	 eax
  0004a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0004f	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 515  :     return(0);

  00053	32 c0		 xor	 al, al

; 516  : }

  00055	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00059	c3		 ret	 0
?rts@@YAEGPEAUcpu@@E@Z ENDP				; rts
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Flags$ = 32
HighByte$ = 33
LowByte$ = 34
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?rti@@YAEGPEAUcpu@@E@Z PROC				; rti

; 500  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 501  :     uint8 Flags = pop(Cpu);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  0001d	88 44 24 20	 mov	 BYTE PTR Flags$[rsp], al

; 502  :     Cpu->Flags = Flags;

  00021	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00026	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Flags$[rsp]
  0002b	88 48 03	 mov	 BYTE PTR [rax+3], cl

; 503  :     
; 504  :     uint8 LowByte = pop(Cpu);

  0002e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00033	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  00038	88 44 24 22	 mov	 BYTE PTR LowByte$[rsp], al

; 505  :     uint8 HighByte = pop(Cpu);

  0003c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00041	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  00046	88 44 24 21	 mov	 BYTE PTR HighByte$[rsp], al

; 506  :     Cpu->PrgCounter = ((uint16)HighByte << 8) | (uint16)LowByte;

  0004a	0f b6 44 24 21	 movzx	 eax, BYTE PTR HighByte$[rsp]
  0004f	c1 e0 08	 shl	 eax, 8
  00052	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  00057	0b c1		 or	 eax, ecx
  00059	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0005e	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 507  :     return(0);

  00062	32 c0		 xor	 al, al

; 508  : }

  00064	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00068	c3		 ret	 0
?rti@@YAEGPEAUcpu@@E@Z ENDP				; rti
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
CarrySet$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?ror@@YAEGPEAUcpu@@E@Z PROC				; ror

; 461  : {

$LN11:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 462  :     uint8 Value = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR Value$[rsp], 0

; 463  :     uint8 CarrySet = isBitSet(CARRY_BIT, Cpu->Flags);

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 01		 mov	 cl, 1
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	88 44 24 21	 mov	 BYTE PTR CarrySet$[rsp], al

; 464  :     
; 465  :     if(AddressMode == ACM)

  0002c	0f b6 44 24 50	 movzx	 eax, BYTE PTR AddressMode$[rsp]
  00031	83 f8 01	 cmp	 eax, 1
  00034	75 65		 jne	 SHORT $LN2@ror

; 466  :     {        
; 467  :         if(Cpu->A & 1)

  00036	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003e	83 e0 01	 and	 eax, 1
  00041	85 c0		 test	 eax, eax
  00043	74 13		 je	 SHORT $LN4@ror

; 468  :             setCarry(&Cpu->Flags);

  00045	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004a	48 83 c0 03	 add	 rax, 3
  0004e	48 8b c8	 mov	 rcx, rax
  00051	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 469  :         else

  00056	eb 11		 jmp	 SHORT $LN5@ror
$LN4@ror:

; 470  :             clearCarry(&Cpu->Flags);

  00058	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005d	48 83 c0 03	 add	 rax, 3
  00061	48 8b c8	 mov	 rcx, rax
  00064	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN5@ror:

; 471  :         
; 472  :         Value = Cpu->A >> 1;

  00069	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0006e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00071	d1 f8		 sar	 eax, 1
  00073	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 473  :         
; 474  :         if(CarrySet)

  00077	0f b6 44 24 21	 movzx	 eax, BYTE PTR CarrySet$[rsp]
  0007c	85 c0		 test	 eax, eax
  0007e	74 0d		 je	 SHORT $LN6@ror

; 475  :             Value = Value | (1 << 7);

  00080	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  00085	0f ba e8 07	 bts	 eax, 7
  00089	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
$LN6@ror:

; 476  :         
; 477  :         Cpu->A = Value;

  0008d	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00092	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00097	88 08		 mov	 BYTE PTR [rax], cl

; 478  :     }
; 479  :     else

  00099	eb 78		 jmp	 SHORT $LN3@ror
$LN2@ror:

; 480  :     {
; 481  :         Value = readCpu8(Address, Cpu);

  0009b	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  000a0	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  000a5	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  000aa	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 482  :         if(Value & 1)

  000ae	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000b3	83 e0 01	 and	 eax, 1
  000b6	85 c0		 test	 eax, eax
  000b8	74 13		 je	 SHORT $LN7@ror

; 483  :             setCarry(&Cpu->Flags);

  000ba	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000bf	48 83 c0 03	 add	 rax, 3
  000c3	48 8b c8	 mov	 rcx, rax
  000c6	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 484  :         else

  000cb	eb 11		 jmp	 SHORT $LN8@ror
$LN7@ror:

; 485  :             clearCarry(&Cpu->Flags);

  000cd	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000d2	48 83 c0 03	 add	 rax, 3
  000d6	48 8b c8	 mov	 rcx, rax
  000d9	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN8@ror:

; 486  :         
; 487  :         Value = Value >> 1;

  000de	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000e3	d1 f8		 sar	 eax, 1
  000e5	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 488  :         
; 489  :         if(CarrySet)

  000e9	0f b6 44 24 21	 movzx	 eax, BYTE PTR CarrySet$[rsp]
  000ee	85 c0		 test	 eax, eax
  000f0	74 0d		 je	 SHORT $LN9@ror

; 490  :             Value = Value | (1 << 7);

  000f2	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000f7	0f ba e8 07	 bts	 eax, 7
  000fb	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
$LN9@ror:

; 491  :         
; 492  :         writeCpu8(Value, Address, Cpu);

  000ff	4c 8b 44 24 48	 mov	 r8, QWORD PTR Cpu$[rsp]
  00104	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  00109	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0010e	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8
$LN3@ror:

; 493  :     }
; 494  :     setZero(Value, &Cpu->Flags);

  00113	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00118	48 83 c0 03	 add	 rax, 3
  0011c	48 8b d0	 mov	 rdx, rax
  0011f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00124	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 495  :     setNegative(Value, &Cpu->Flags);

  00129	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0012e	48 83 c0 03	 add	 rax, 3
  00132	48 8b d0	 mov	 rdx, rax
  00135	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0013a	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 496  :     return(0);

  0013f	32 c0		 xor	 al, al

; 497  : }

  00141	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00145	c3		 ret	 0
?ror@@YAEGPEAUcpu@@E@Z ENDP				; ror
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
CarrySet$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?rol@@YAEGPEAUcpu@@E@Z PROC				; rol

; 422  : {    

$LN11:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 423  :     uint8 Value = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR Value$[rsp], 0

; 424  :     uint8 CarrySet = isBitSet(CARRY_BIT, Cpu->Flags);

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 01		 mov	 cl, 1
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	88 44 24 21	 mov	 BYTE PTR CarrySet$[rsp], al

; 425  :     
; 426  :     if(AddressMode == ACM)

  0002c	0f b6 44 24 50	 movzx	 eax, BYTE PTR AddressMode$[rsp]
  00031	83 f8 01	 cmp	 eax, 1
  00034	75 66		 jne	 SHORT $LN2@rol

; 427  :     {        
; 428  :         if(Cpu->A & (1 << 7))

  00036	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003e	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00043	85 c0		 test	 eax, eax
  00045	74 13		 je	 SHORT $LN4@rol

; 429  :             setCarry(&Cpu->Flags);

  00047	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004c	48 83 c0 03	 add	 rax, 3
  00050	48 8b c8	 mov	 rcx, rax
  00053	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 430  :         else

  00058	eb 11		 jmp	 SHORT $LN5@rol
$LN4@rol:

; 431  :             clearCarry(&Cpu->Flags);

  0005a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005f	48 83 c0 03	 add	 rax, 3
  00063	48 8b c8	 mov	 rcx, rax
  00066	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN5@rol:

; 432  :         
; 433  :         Value = Cpu->A << 1;

  0006b	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00070	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00073	d1 e0		 shl	 eax, 1
  00075	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 434  :         
; 435  :         if(CarrySet)

  00079	0f b6 44 24 21	 movzx	 eax, BYTE PTR CarrySet$[rsp]
  0007e	85 c0		 test	 eax, eax
  00080	74 0c		 je	 SHORT $LN6@rol

; 436  :             Value = Value | 1;

  00082	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  00087	83 c8 01	 or	 eax, 1
  0008a	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
$LN6@rol:

; 437  :         
; 438  :         Cpu->A = Value;

  0008e	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00093	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00098	88 08		 mov	 BYTE PTR [rax], cl

; 439  :     }
; 440  :     else

  0009a	eb 79		 jmp	 SHORT $LN3@rol
$LN2@rol:

; 441  :     {
; 442  :         Value = readCpu8(Address, Cpu);

  0009c	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  000a1	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  000a6	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  000ab	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 443  :         if(Value & (1 << 7))

  000af	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000b4	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000b9	85 c0		 test	 eax, eax
  000bb	74 13		 je	 SHORT $LN7@rol

; 444  :             setCarry(&Cpu->Flags);

  000bd	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000c2	48 83 c0 03	 add	 rax, 3
  000c6	48 8b c8	 mov	 rcx, rax
  000c9	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 445  :         else

  000ce	eb 11		 jmp	 SHORT $LN8@rol
$LN7@rol:

; 446  :             clearCarry(&Cpu->Flags);

  000d0	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000d5	48 83 c0 03	 add	 rax, 3
  000d9	48 8b c8	 mov	 rcx, rax
  000dc	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN8@rol:

; 447  :         
; 448  :         Value = Value << 1;

  000e1	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000e6	d1 e0		 shl	 eax, 1
  000e8	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 449  :         
; 450  :         if(CarrySet)

  000ec	0f b6 44 24 21	 movzx	 eax, BYTE PTR CarrySet$[rsp]
  000f1	85 c0		 test	 eax, eax
  000f3	74 0c		 je	 SHORT $LN9@rol

; 451  :             Value = Value | 1;

  000f5	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000fa	83 c8 01	 or	 eax, 1
  000fd	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al
$LN9@rol:

; 452  :         
; 453  :         writeCpu8(Value, Address, Cpu);

  00101	4c 8b 44 24 48	 mov	 r8, QWORD PTR Cpu$[rsp]
  00106	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0010b	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00110	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8
$LN3@rol:

; 454  :     }
; 455  :     setZero(Value, &Cpu->Flags);

  00115	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0011a	48 83 c0 03	 add	 rax, 3
  0011e	48 8b d0	 mov	 rdx, rax
  00121	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00126	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 456  :     setNegative(Value, &Cpu->Flags);

  0012b	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00130	48 83 c0 03	 add	 rax, 3
  00134	48 8b d0	 mov	 rdx, rax
  00137	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0013c	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 457  :     return(0);

  00141	32 c0		 xor	 al, al

; 458  : }

  00143	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00147	c3		 ret	 0
?rol@@YAEGPEAUcpu@@E@Z ENDP				; rol
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?plp@@YAEGPEAUcpu@@E@Z PROC				; plp

; 417  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 418  :     Cpu->Flags = pop(Cpu);

  00013	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  0001d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00022	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 419  :     return(0);

  00025	32 c0		 xor	 al, al

; 420  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
?plp@@YAEGPEAUcpu@@E@Z ENDP				; plp
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?pla@@YAEGPEAUcpu@@E@Z PROC				; pla

; 410  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 411  :     Cpu->A = pop(Cpu); 

  00013	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00018	e8 00 00 00 00	 call	 ?pop@@YAEPEAUcpu@@@Z	; pop
  0001d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00022	88 01		 mov	 BYTE PTR [rcx], al

; 412  :     setZero(Cpu->A, &Cpu->Flags);

  00024	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00029	48 83 c0 03	 add	 rax, 3
  0002d	48 8b d0	 mov	 rdx, rax
  00030	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00035	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00038	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 413  :     setNegative(Cpu->A, &Cpu->Flags);

  0003d	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00042	48 83 c0 03	 add	 rax, 3
  00046	48 8b d0	 mov	 rdx, rax
  00049	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004e	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00051	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 414  :     return(0);

  00056	32 c0		 xor	 al, al

; 415  : }

  00058	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005c	c3		 ret	 0
?pla@@YAEGPEAUcpu@@E@Z ENDP				; pla
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?php@@YAEGPEAUcpu@@E@Z PROC				; php

; 403  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 404  :     setBreak(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?setBreak@@YAXPEAE@Z	; setBreak

; 405  :     setBlank(&Cpu->Flags);

  00024	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00029	48 83 c0 03	 add	 rax, 3
  0002d	48 8b c8	 mov	 rcx, rax
  00030	e8 00 00 00 00	 call	 ?setBlank@@YAXPEAE@Z	; setBlank

; 406  :     push(Cpu->Flags, Cpu);

  00035	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0003a	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003f	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  00043	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 407  :     return(0);

  00048	32 c0		 xor	 al, al

; 408  : }

  0004a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004e	c3		 ret	 0
?php@@YAEGPEAUcpu@@E@Z ENDP				; php
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?pha@@YAEGPEAUcpu@@E@Z PROC				; pha

; 398  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 399  :     push(Cpu->A, Cpu);

  00013	48 8b 54 24 38	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00018	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00020	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 400  :     return(0);

  00025	32 c0		 xor	 al, al

; 401  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
?pha@@YAEGPEAUcpu@@E@Z ENDP				; pha
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?ora@@YAEGPEAUcpu@@E@Z PROC				; ora

; 390  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 391  :     uint8 Value = readCpu8(Address, Cpu);

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00018	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0001d	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00022	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 392  :     Cpu->A = Cpu->A | Value;

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002e	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00033	0b c1		 or	 eax, ecx
  00035	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0003a	88 01		 mov	 BYTE PTR [rcx], al

; 393  :     setZero(Cpu->A, &Cpu->Flags);

  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	48 83 c0 03	 add	 rax, 3
  00045	48 8b d0	 mov	 rdx, rax
  00048	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004d	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00050	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 394  :     setNegative(Cpu->A, &Cpu->Flags);

  00055	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005a	48 83 c0 03	 add	 rax, 3
  0005e	48 8b d0	 mov	 rdx, rax
  00061	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00066	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00069	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 395  :     return(0);

  0006e	32 c0		 xor	 al, al

; 396  : }

  00070	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00074	c3		 ret	 0
?ora@@YAEGPEAUcpu@@E@Z ENDP				; ora
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?nop@@YAEGPEAUcpu@@E@Z PROC				; nop

; 386  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 387  :     return(0);

  0000f	32 c0		 xor	 al, al

; 388  : }

  00011	c3		 ret	 0
?nop@@YAEGPEAUcpu@@E@Z ENDP				; nop
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?lsr@@YAEGPEAUcpu@@E@Z PROC				; lsr

; 360  : {

$LN9:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 361  :     uint8 Value = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR Value$[rsp], 0

; 362  :     if(AddressMode == ACM)

  00018	0f b6 44 24 50	 movzx	 eax, BYTE PTR AddressMode$[rsp]
  0001d	83 f8 01	 cmp	 eax, 1
  00020	75 52		 jne	 SHORT $LN2@lsr

; 363  :     {        
; 364  :         if(Cpu->A & 1)

  00022	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00027	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002a	83 e0 01	 and	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	74 13		 je	 SHORT $LN4@lsr

; 365  :             setCarry(&Cpu->Flags);

  00031	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00036	48 83 c0 03	 add	 rax, 3
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 366  :         else

  00042	eb 11		 jmp	 SHORT $LN5@lsr
$LN4@lsr:

; 367  :             clearCarry(&Cpu->Flags);

  00044	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00049	48 83 c0 03	 add	 rax, 3
  0004d	48 8b c8	 mov	 rcx, rax
  00050	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN5@lsr:

; 368  :         Cpu->A = Cpu->A >> 1;

  00055	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005d	d1 f8		 sar	 eax, 1
  0005f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00064	88 01		 mov	 BYTE PTR [rcx], al

; 369  :         Value = Cpu->A;

  00066	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0006b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006e	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 370  :     }
; 371  :     else

  00072	eb 62		 jmp	 SHORT $LN3@lsr
$LN2@lsr:

; 372  :     {
; 373  :         Value = readCpu8(Address, Cpu);

  00074	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00079	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0007e	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00083	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 374  :         if(Value & 1)

  00087	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  0008c	83 e0 01	 and	 eax, 1
  0008f	85 c0		 test	 eax, eax
  00091	74 13		 je	 SHORT $LN6@lsr

; 375  :             setCarry(&Cpu->Flags);

  00093	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00098	48 83 c0 03	 add	 rax, 3
  0009c	48 8b c8	 mov	 rcx, rax
  0009f	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 376  :         else

  000a4	eb 11		 jmp	 SHORT $LN7@lsr
$LN6@lsr:

; 377  :             clearCarry(&Cpu->Flags);

  000a6	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000ab	48 83 c0 03	 add	 rax, 3
  000af	48 8b c8	 mov	 rcx, rax
  000b2	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN7@lsr:

; 378  :         Value = Value >> 1;

  000b7	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000bc	d1 f8		 sar	 eax, 1
  000be	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 379  :         writeCpu8(Value, Address, Cpu);

  000c2	4c 8b 44 24 48	 mov	 r8, QWORD PTR Cpu$[rsp]
  000c7	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  000cc	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  000d1	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8
$LN3@lsr:

; 380  :     }
; 381  :     setZero(Value, &Cpu->Flags);

  000d6	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000db	48 83 c0 03	 add	 rax, 3
  000df	48 8b d0	 mov	 rdx, rax
  000e2	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  000e7	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 382  :     setNegative(Value, &Cpu->Flags);

  000ec	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000f1	48 83 c0 03	 add	 rax, 3
  000f5	48 8b d0	 mov	 rdx, rax
  000f8	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  000fd	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 383  :     return(0);

  00102	32 c0		 xor	 al, al

; 384  : }

  00104	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00108	c3		 ret	 0
?lsr@@YAEGPEAUcpu@@E@Z ENDP				; lsr
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?ldy@@YAEGPEAUcpu@@E@Z PROC				; ldy

; 352  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 353  :     uint8 Value = readCpu8(Address, Cpu);

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00018	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0001d	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00022	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 354  :     Cpu->Y = Value;

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00030	88 48 02	 mov	 BYTE PTR [rax+2], cl

; 355  :     setZero(Value, &Cpu->Flags);

  00033	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00038	48 83 c0 03	 add	 rax, 3
  0003c	48 8b d0	 mov	 rdx, rax
  0003f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00044	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 356  :     setNegative(Value, &Cpu->Flags);

  00049	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004e	48 83 c0 03	 add	 rax, 3
  00052	48 8b d0	 mov	 rdx, rax
  00055	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0005a	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 357  :     return(0);

  0005f	32 c0		 xor	 al, al

; 358  : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
?ldy@@YAEGPEAUcpu@@E@Z ENDP				; ldy
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?ldx@@YAEGPEAUcpu@@E@Z PROC				; ldx

; 344  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 345  :     uint8 Value = readCpu8(Address, Cpu);

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00018	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0001d	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00022	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 346  :     Cpu->X = Value;

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00030	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 347  :     setZero(Value, &Cpu->Flags);

  00033	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00038	48 83 c0 03	 add	 rax, 3
  0003c	48 8b d0	 mov	 rdx, rax
  0003f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00044	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 348  :     setNegative(Value, &Cpu->Flags);

  00049	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004e	48 83 c0 03	 add	 rax, 3
  00052	48 8b d0	 mov	 rdx, rax
  00055	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0005a	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 349  :     return(0);

  0005f	32 c0		 xor	 al, al

; 350  : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
?ldx@@YAEGPEAUcpu@@E@Z ENDP				; ldx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?lda@@YAEGPEAUcpu@@E@Z PROC				; lda

; 336  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 337  :     uint8 Value = readCpu8(Address, Cpu);

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00018	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0001d	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00022	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 338  :     Cpu->A = Value;

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00030	88 08		 mov	 BYTE PTR [rax], cl

; 339  :     setZero(Value, &Cpu->Flags);

  00032	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00037	48 83 c0 03	 add	 rax, 3
  0003b	48 8b d0	 mov	 rdx, rax
  0003e	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00043	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 340  :     setNegative(Value, &Cpu->Flags);

  00048	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004d	48 83 c0 03	 add	 rax, 3
  00051	48 8b d0	 mov	 rdx, rax
  00054	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00059	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 341  :     return(0);

  0005e	32 c0		 xor	 al, al

; 342  : }

  00060	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00064	c3		 ret	 0
?lda@@YAEGPEAUcpu@@E@Z ENDP				; lda
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
ReturnAddress$ = 36
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?jsr@@YAEGPEAUcpu@@E@Z PROC				; jsr

; 324  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 325  :     uint16 ReturnAddress = Cpu->PrgCounter - 1;

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0001c	ff c8		 dec	 eax
  0001e	66 89 44 24 24	 mov	 WORD PTR ReturnAddress$[rsp], ax

; 326  :     uint8 HighByte = (uint8)(ReturnAddress >> 8);

  00023	0f b7 44 24 24	 movzx	 eax, WORD PTR ReturnAddress$[rsp]
  00028	c1 f8 08	 sar	 eax, 8
  0002b	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 327  :     uint8 LowByte = (uint8)ReturnAddress; 

  0002f	0f b6 44 24 24	 movzx	 eax, BYTE PTR ReturnAddress$[rsp]
  00034	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 328  : 
; 329  :     push(HighByte, Cpu);

  00038	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0003d	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR HighByte$[rsp]
  00042	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 330  :     push(LowByte, Cpu);

  00047	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0004c	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  00051	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 331  : 
; 332  :     Cpu->PrgCounter = Address;

  00056	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005b	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00060	66 89 48 06	 mov	 WORD PTR [rax+6], cx

; 333  :     return(0);

  00064	32 c0		 xor	 al, al

; 334  : }

  00066	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006a	c3		 ret	 0
?jsr@@YAEGPEAUcpu@@E@Z ENDP				; jsr
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 8
Cpu$ = 16
AddressMode$ = 24
?jmp@@YAEGPEAUcpu@@E@Z PROC				; jmp

; 319  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 320  :     Cpu->PrgCounter = Address;

  0000f	48 8b 44 24 10	 mov	 rax, QWORD PTR Cpu$[rsp]
  00014	0f b7 4c 24 08	 movzx	 ecx, WORD PTR Address$[rsp]
  00019	66 89 48 06	 mov	 WORD PTR [rax+6], cx

; 321  :     return(0);

  0001d	32 c0		 xor	 al, al

; 322  : }

  0001f	c3		 ret	 0
?jmp@@YAEGPEAUcpu@@E@Z ENDP				; jmp
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?iny@@YAEGPEAUcpu@@E@Z PROC				; iny

; 312  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 313  :     ++Cpu->Y;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0001c	fe c0		 inc	 al
  0001e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00023	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 314  :     setZero(Cpu->Y, &Cpu->Flags);

  00026	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	48 83 c0 03	 add	 rax, 3
  0002f	48 8b d0	 mov	 rdx, rax
  00032	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00037	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  0003b	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 315  :     setNegative(Cpu->Y, &Cpu->Flags);

  00040	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00045	48 83 c0 03	 add	 rax, 3
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00055	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 316  :     return(0);

  0005a	32 c0		 xor	 al, al

; 317  : }

  0005c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00060	c3		 ret	 0
?iny@@YAEGPEAUcpu@@E@Z ENDP				; iny
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?inx@@YAEGPEAUcpu@@E@Z PROC				; inx

; 305  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 306  :     ++Cpu->X;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0001c	fe c0		 inc	 al
  0001e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00023	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 307  :     setZero(Cpu->X, &Cpu->Flags);

  00026	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	48 83 c0 03	 add	 rax, 3
  0002f	48 8b d0	 mov	 rdx, rax
  00032	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00037	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  0003b	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 308  :     setNegative(Cpu->X, &Cpu->Flags);

  00040	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00045	48 83 c0 03	 add	 rax, 3
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00055	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 309  :     return(0);

  0005a	32 c0		 xor	 al, al

; 310  : }

  0005c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00060	c3		 ret	 0
?inx@@YAEGPEAUcpu@@E@Z ENDP				; inx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?inc@@YAEGPEAUcpu@@E@Z PROC				; inc

; 297  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 298  :     uint8 Value = readCpu8(Address, Cpu) + 1;

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00018	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0001d	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00022	0f b6 c0	 movzx	 eax, al
  00025	ff c0		 inc	 eax
  00027	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 299  :     writeCpu8(Value, Address, Cpu);

  0002b	4c 8b 44 24 48	 mov	 r8, QWORD PTR Cpu$[rsp]
  00030	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  00035	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0003a	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8

; 300  :     setZero(Value, &Cpu->Flags);

  0003f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00044	48 83 c0 03	 add	 rax, 3
  00048	48 8b d0	 mov	 rdx, rax
  0004b	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00050	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 301  :     setNegative(Value, &Cpu->Flags);

  00055	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005a	48 83 c0 03	 add	 rax, 3
  0005e	48 8b d0	 mov	 rdx, rax
  00061	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00066	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 302  :     return(0);

  0006b	32 c0		 xor	 al, al

; 303  : }

  0006d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00071	c3		 ret	 0
?inc@@YAEGPEAUcpu@@E@Z ENDP				; inc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?eor@@YAEGPEAUcpu@@E@Z PROC				; eor

; 289  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 290  :     uint8 Value = readCpu8(Address, Cpu);

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00018	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0001d	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00022	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 291  :     Cpu->A = Cpu->A ^ Value;

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002e	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00033	33 c1		 xor	 eax, ecx
  00035	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0003a	88 01		 mov	 BYTE PTR [rcx], al

; 292  :     setZero(Cpu->A, &Cpu->Flags);

  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	48 83 c0 03	 add	 rax, 3
  00045	48 8b d0	 mov	 rdx, rax
  00048	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004d	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00050	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 293  :     setNegative(Cpu->A, &Cpu->Flags);

  00055	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005a	48 83 c0 03	 add	 rax, 3
  0005e	48 8b d0	 mov	 rdx, rax
  00061	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00066	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00069	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 294  :     return(0);

  0006e	32 c0		 xor	 al, al

; 295  : }

  00070	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00074	c3		 ret	 0
?eor@@YAEGPEAUcpu@@E@Z ENDP				; eor
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?dey@@YAEGPEAUcpu@@E@Z PROC				; dey

; 282  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 283  :     --Cpu->Y;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0001c	fe c8		 dec	 al
  0001e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00023	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 284  :     setZero(Cpu->Y, &Cpu->Flags);

  00026	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	48 83 c0 03	 add	 rax, 3
  0002f	48 8b d0	 mov	 rdx, rax
  00032	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00037	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  0003b	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 285  :     setNegative(Cpu->Y, &Cpu->Flags);

  00040	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00045	48 83 c0 03	 add	 rax, 3
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00055	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 286  :     return(0);

  0005a	32 c0		 xor	 al, al

; 287  : }

  0005c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00060	c3		 ret	 0
?dey@@YAEGPEAUcpu@@E@Z ENDP				; dey
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?dex@@YAEGPEAUcpu@@E@Z PROC				; dex

; 275  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 276  :     --Cpu->X;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0001c	fe c8		 dec	 al
  0001e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00023	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 277  :     setZero(Cpu->X, &Cpu->Flags);

  00026	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	48 83 c0 03	 add	 rax, 3
  0002f	48 8b d0	 mov	 rdx, rax
  00032	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00037	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  0003b	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 278  :     setNegative(Cpu->X, &Cpu->Flags);

  00040	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00045	48 83 c0 03	 add	 rax, 3
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00051	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00055	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 279  :     return(0);

  0005a	32 c0		 xor	 al, al

; 280  : }

  0005c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00060	c3		 ret	 0
?dex@@YAEGPEAUcpu@@E@Z ENDP				; dex
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?dec@@YAEGPEAUcpu@@E@Z PROC				; dec

; 267  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 268  :     uint8 Value = readCpu8(Address, Cpu) - 1;

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00018	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0001d	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00022	0f b6 c0	 movzx	 eax, al
  00025	ff c8		 dec	 eax
  00027	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 269  :     writeCpu8(Value, Address, Cpu);

  0002b	4c 8b 44 24 48	 mov	 r8, QWORD PTR Cpu$[rsp]
  00030	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  00035	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0003a	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8

; 270  :     setZero(Value, &Cpu->Flags);

  0003f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00044	48 83 c0 03	 add	 rax, 3
  00048	48 8b d0	 mov	 rdx, rax
  0004b	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00050	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 271  :     setNegative(Value, &Cpu->Flags);

  00055	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005a	48 83 c0 03	 add	 rax, 3
  0005e	48 8b d0	 mov	 rdx, rax
  00061	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00066	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 272  :     return(0);

  0006b	32 c0		 xor	 al, al

; 273  : }

  0006d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00071	c3		 ret	 0
?dec@@YAEGPEAUcpu@@E@Z ENDP				; dec
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
CmpValue$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?cpy@@YAEGPEAUcpu@@E@Z PROC				; cpy

; 253  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 254  :     uint8 Value = readCpu8(Address, Cpu);

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00018	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0001d	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00022	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 255  : 
; 256  :     if(Cpu->Y >= Value)

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0002f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00034	3b c1		 cmp	 eax, ecx
  00036	7c 13		 jl	 SHORT $LN2@cpy

; 257  :         setCarry(&Cpu->Flags);

  00038	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003d	48 83 c0 03	 add	 rax, 3
  00041	48 8b c8	 mov	 rcx, rax
  00044	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 258  :     else

  00049	eb 11		 jmp	 SHORT $LN3@cpy
$LN2@cpy:

; 259  :         clearCarry(&Cpu->Flags);

  0004b	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00050	48 83 c0 03	 add	 rax, 3
  00054	48 8b c8	 mov	 rcx, rax
  00057	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN3@cpy:

; 260  :     
; 261  :     uint8 CmpValue = Cpu->Y - Value;

  0005c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00061	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00065	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0006a	2b c1		 sub	 eax, ecx
  0006c	88 44 24 21	 mov	 BYTE PTR CmpValue$[rsp], al

; 262  :     setZero(CmpValue, &Cpu->Flags);

  00070	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00075	48 83 c0 03	 add	 rax, 3
  00079	48 8b d0	 mov	 rdx, rax
  0007c	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  00081	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 263  :     setNegative(CmpValue, &Cpu->Flags);

  00086	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0008b	48 83 c0 03	 add	 rax, 3
  0008f	48 8b d0	 mov	 rdx, rax
  00092	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  00097	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 264  :     return(0);

  0009c	32 c0		 xor	 al, al

; 265  : }

  0009e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a2	c3		 ret	 0
?cpy@@YAEGPEAUcpu@@E@Z ENDP				; cpy
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
CmpValue$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?cpx@@YAEGPEAUcpu@@E@Z PROC				; cpx

; 239  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 240  :     uint8 Value = readCpu8(Address, Cpu);

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00018	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0001d	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00022	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 241  : 
; 242  :     if(Cpu->X >= Value)

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0002f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00034	3b c1		 cmp	 eax, ecx
  00036	7c 13		 jl	 SHORT $LN2@cpx

; 243  :         setCarry(&Cpu->Flags);

  00038	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003d	48 83 c0 03	 add	 rax, 3
  00041	48 8b c8	 mov	 rcx, rax
  00044	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 244  :     else

  00049	eb 11		 jmp	 SHORT $LN3@cpx
$LN2@cpx:

; 245  :         clearCarry(&Cpu->Flags);

  0004b	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00050	48 83 c0 03	 add	 rax, 3
  00054	48 8b c8	 mov	 rcx, rax
  00057	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN3@cpx:

; 246  :     
; 247  :     uint8 CmpValue = Cpu->X - Value;

  0005c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00061	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00065	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0006a	2b c1		 sub	 eax, ecx
  0006c	88 44 24 21	 mov	 BYTE PTR CmpValue$[rsp], al

; 248  :     setZero(CmpValue, &Cpu->Flags);

  00070	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00075	48 83 c0 03	 add	 rax, 3
  00079	48 8b d0	 mov	 rdx, rax
  0007c	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  00081	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 249  :     setNegative(CmpValue, &Cpu->Flags);

  00086	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0008b	48 83 c0 03	 add	 rax, 3
  0008f	48 8b d0	 mov	 rdx, rax
  00092	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  00097	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 250  :     return(0);

  0009c	32 c0		 xor	 al, al

; 251  : }

  0009e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a2	c3		 ret	 0
?cpx@@YAEGPEAUcpu@@E@Z ENDP				; cpx
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
CmpValue$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?cmp@@YAEGPEAUcpu@@E@Z PROC				; cmp

; 225  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 226  :     uint8 Value = readCpu8(Address, Cpu);

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00018	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0001d	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00022	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 227  : 
; 228  :     if(Cpu->A >= Value)

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002e	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00033	3b c1		 cmp	 eax, ecx
  00035	7c 13		 jl	 SHORT $LN2@cmp

; 229  :         setCarry(&Cpu->Flags);

  00037	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0003c	48 83 c0 03	 add	 rax, 3
  00040	48 8b c8	 mov	 rcx, rax
  00043	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 230  :     else

  00048	eb 11		 jmp	 SHORT $LN3@cmp
$LN2@cmp:

; 231  :         clearCarry(&Cpu->Flags);

  0004a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004f	48 83 c0 03	 add	 rax, 3
  00053	48 8b c8	 mov	 rcx, rax
  00056	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN3@cmp:

; 232  :     
; 233  :     uint8 CmpValue = Cpu->A - Value;

  0005b	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00060	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00063	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00068	2b c1		 sub	 eax, ecx
  0006a	88 44 24 21	 mov	 BYTE PTR CmpValue$[rsp], al

; 234  :     setZero(CmpValue, &Cpu->Flags);

  0006e	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00073	48 83 c0 03	 add	 rax, 3
  00077	48 8b d0	 mov	 rdx, rax
  0007a	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  0007f	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 235  :     setNegative(CmpValue, &Cpu->Flags);

  00084	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00089	48 83 c0 03	 add	 rax, 3
  0008d	48 8b d0	 mov	 rdx, rax
  00090	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR CmpValue$[rsp]
  00095	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 236  :     return(0);

  0009a	32 c0		 xor	 al, al

; 237  : }

  0009c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a0	c3		 ret	 0
?cmp@@YAEGPEAUcpu@@E@Z ENDP				; cmp
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?clv@@YAEGPEAUcpu@@E@Z PROC				; clv

; 220  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 221  :     clearOverflow(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?clearOverflow@@YAXPEAE@Z ; clearOverflow

; 222  :     return(0);

  00024	32 c0		 xor	 al, al

; 223  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?clv@@YAEGPEAUcpu@@E@Z ENDP				; clv
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?cli@@YAEGPEAUcpu@@E@Z PROC				; cli

; 215  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 216  :     clearInterrupt(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?clearInterrupt@@YAXPEAE@Z ; clearInterrupt

; 217  :     return(0);

  00024	32 c0		 xor	 al, al

; 218  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?cli@@YAEGPEAUcpu@@E@Z ENDP				; cli
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?cld@@YAEGPEAUcpu@@E@Z PROC				; cld

; 210  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 211  :     clearDecimal(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?clearDecimal@@YAXPEAE@Z ; clearDecimal

; 212  :     return(0);

  00024	32 c0		 xor	 al, al

; 213  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?cld@@YAEGPEAUcpu@@E@Z ENDP				; cld
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Address$ = 48
Cpu$ = 56
AddressMode$ = 64
?clc@@YAEGPEAUcpu@@E@Z PROC				; clc

; 205  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 206  :     clearCarry(&Cpu->Flags);

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	48 83 c0 03	 add	 rax, 3
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry

; 207  :     return(0);

  00024	32 c0		 xor	 al, al

; 208  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?clc@@YAEGPEAUcpu@@E@Z ENDP				; clc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bvs@@YAEGPEAUcpu@@E@Z PROC				; bvs

; 192  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 193  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 194  :     if(isBitSet(OVERFLOW_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 40		 mov	 cl, 64			; 00000040H
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	74 3b		 je	 SHORT $LN2@bvs

; 195  :     {
; 196  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 197  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bvs

; 198  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bvs:

; 199  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bvs:

; 200  :     }   
; 201  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 202  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bvs@@YAEGPEAUcpu@@E@Z ENDP				; bvs
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bvc@@YAEGPEAUcpu@@E@Z PROC				; bvc

; 179  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 180  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 181  :     if(!isBitSet(OVERFLOW_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 40		 mov	 cl, 64			; 00000040H
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	75 3b		 jne	 SHORT $LN2@bvc

; 182  :     {
; 183  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 184  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bvc

; 185  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bvc:

; 186  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bvc:

; 187  :     }   
; 188  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 189  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bvc@@YAEGPEAUcpu@@E@Z ENDP				; bvc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?brk@@YAEGPEAUcpu@@E@Z PROC				; brk

; 163  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 164  :     uint8 HighByte = (uint8)(Cpu->PrgCounter >> 8);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0001c	c1 f8 08	 sar	 eax, 8
  0001f	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 165  :     uint8 LowByte = (uint8)Cpu->PrgCounter; 

  00023	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00028	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  0002c	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 166  :     push(HighByte, Cpu);

  00030	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00035	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR HighByte$[rsp]
  0003a	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 167  :     push(LowByte, Cpu);

  0003f	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00044	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  00049	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 168  : 
; 169  :     setBlank(&Cpu->Flags);

  0004e	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00053	48 83 c0 03	 add	 rax, 3
  00057	48 8b c8	 mov	 rcx, rax
  0005a	e8 00 00 00 00	 call	 ?setBlank@@YAXPEAE@Z	; setBlank

; 170  :     setBreak(&Cpu->Flags);

  0005f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00064	48 83 c0 03	 add	 rax, 3
  00068	48 8b c8	 mov	 rcx, rax
  0006b	e8 00 00 00 00	 call	 ?setBreak@@YAXPEAE@Z	; setBreak

; 171  :     push(Cpu->Flags, Cpu);

  00070	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00075	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0007a	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  0007e	e8 00 00 00 00	 call	 ?push@@YAXEPEAUcpu@@@Z	; push

; 172  :     setInterrupt(&Cpu->Flags);

  00083	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00088	48 83 c0 03	 add	 rax, 3
  0008c	48 8b c8	 mov	 rcx, rax
  0008f	e8 00 00 00 00	 call	 ?setInterrupt@@YAXPEAE@Z ; setInterrupt

; 173  : 
; 174  :     Cpu->PrgCounter = readCpu16(IRQ_BRK_VEC, Cpu);

  00094	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00099	66 b9 fe ff	 mov	 cx, 65534		; 0000fffeH
  0009d	e8 00 00 00 00	 call	 ?readCpu16@@YAGGPEAUcpu@@@Z ; readCpu16
  000a2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  000a7	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 175  :     return(0);

  000ab	32 c0		 xor	 al, al

; 176  : }

  000ad	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b1	c3		 ret	 0
?brk@@YAEGPEAUcpu@@E@Z ENDP				; brk
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bpl@@YAEGPEAUcpu@@E@Z PROC				; bpl

; 150  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 151  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 152  :     if(!isBitSet(NEGATIVE_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 80		 mov	 cl, 128			; 00000080H
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	75 3b		 jne	 SHORT $LN2@bpl

; 153  :     {
; 154  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 155  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bpl

; 156  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bpl:

; 157  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bpl:

; 158  :     }   
; 159  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 160  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bpl@@YAEGPEAUcpu@@E@Z ENDP				; bpl
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bne@@YAEGPEAUcpu@@E@Z PROC				; bne

; 137  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 138  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 139  :     if(!isBitSet(ZERO_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 02		 mov	 cl, 2
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	75 3b		 jne	 SHORT $LN2@bne

; 140  :     {
; 141  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 142  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bne

; 143  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bne:

; 144  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bne:

; 145  :     }   
; 146  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 147  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bne@@YAEGPEAUcpu@@E@Z ENDP				; bne
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bmi@@YAEGPEAUcpu@@E@Z PROC				; bmi

; 124  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 125  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 126  :     if(isBitSet(NEGATIVE_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 80		 mov	 cl, 128			; 00000080H
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	74 3b		 je	 SHORT $LN2@bmi

; 127  :     {
; 128  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 129  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bmi

; 130  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bmi:

; 131  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bmi:

; 132  :     }   
; 133  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 134  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bmi@@YAEGPEAUcpu@@E@Z ENDP				; bmi
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bit@@YAEGPEAUcpu@@E@Z PROC				; bit

; 112  : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 113  :     uint8 Value = readCpu8(Address, Cpu);

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00018	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0001d	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00022	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 114  :     if(Value & (1 << 6))

  00026	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  0002b	83 e0 40	 and	 eax, 64			; 00000040H
  0002e	85 c0		 test	 eax, eax
  00030	74 13		 je	 SHORT $LN2@bit

; 115  :         setOverflow(&Cpu->Flags);

  00032	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00037	48 83 c0 03	 add	 rax, 3
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	e8 00 00 00 00	 call	 ?setOverflow@@YAXPEAE@Z	; setOverflow

; 116  :     else

  00043	eb 11		 jmp	 SHORT $LN3@bit
$LN2@bit:

; 117  :         clearOverflow(&Cpu->Flags);

  00045	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004a	48 83 c0 03	 add	 rax, 3
  0004e	48 8b c8	 mov	 rcx, rax
  00051	e8 00 00 00 00	 call	 ?clearOverflow@@YAXPEAE@Z ; clearOverflow
$LN3@bit:

; 118  :     setNegative(Value, &Cpu->Flags);

  00056	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005b	48 83 c0 03	 add	 rax, 3
  0005f	48 8b d0	 mov	 rdx, rax
  00062	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00067	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 119  :     setZero(Cpu->A & Value, &Cpu->Flags);

  0006c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00071	48 83 c0 03	 add	 rax, 3
  00075	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0007a	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0007d	0f b6 54 24 20	 movzx	 edx, BYTE PTR Value$[rsp]
  00082	23 ca		 and	 ecx, edx
  00084	48 8b d0	 mov	 rdx, rax
  00087	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 120  :     return(0);

  0008c	32 c0		 xor	 al, al

; 121  : }

  0008e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00092	c3		 ret	 0
?bit@@YAEGPEAUcpu@@E@Z ENDP				; bit
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?beq@@YAEGPEAUcpu@@E@Z PROC				; beq

; 99   : {   

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 100  :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 101  :     if(isBitSet(ZERO_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 02		 mov	 cl, 2
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	74 3b		 je	 SHORT $LN2@beq

; 102  :     {
; 103  :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 104  :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@beq

; 105  :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@beq:

; 106  :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@beq:

; 107  :     }   
; 108  :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 109  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?beq@@YAEGPEAUcpu@@E@Z ENDP				; beq
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bcs@@YAEGPEAUcpu@@E@Z PROC				; bcs

; 87   : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 88   :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 89   :     if(isBitSet(CARRY_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 01		 mov	 cl, 1
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	74 3b		 je	 SHORT $LN2@bcs

; 90   :     {
; 91   :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 92   :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN3@bcs

; 93   :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN3@bcs:

; 94   :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN2@bcs:

; 95   :     }   
; 96   :     return(AddCycles);    

  00067	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 97   : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
?bcs@@YAEGPEAUcpu@@E@Z ENDP				; bcs
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
AddCycles$ = 32
Test$1 = 33
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?bcc@@YAEGPEAUcpu@@E@Z PROC				; bcc

; 71   : {

$LN6:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 72   :     uint8 AddCycles = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR AddCycles$[rsp], 0

; 73   :     
; 74   :     if(!isBitSet(CARRY_BIT, Cpu->Flags))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0001d	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00021	b1 01		 mov	 cl, 1
  00023	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00028	85 c0		 test	 eax, eax
  0002a	75 3d		 jne	 SHORT $LN2@bcc

; 75   :     {
; 76   :         ++AddCycles;

  0002c	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00031	fe c0		 inc	 al
  00033	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al

; 77   :         if(crossedPageCheck(Cpu->PrgCounter, Address))

  00037	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00045	e8 00 00 00 00	 call	 ?crossedPageCheck@@YAHGG@Z ; crossedPageCheck
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN4@bcc

; 78   :             ++AddCycles;

  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]
  00053	fe c0		 inc	 al
  00055	88 44 24 20	 mov	 BYTE PTR AddCycles$[rsp], al
$LN4@bcc:

; 79   :         Cpu->PrgCounter = Address;

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005e	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00063	66 89 48 06	 mov	 WORD PTR [rax+6], cx

; 80   :     }
; 81   :     else

  00067	eb 05		 jmp	 SHORT $LN3@bcc
$LN2@bcc:

; 82   :         uint8 Test =0;

  00069	c6 44 24 21 00	 mov	 BYTE PTR Test$1[rsp], 0
$LN3@bcc:

; 83   :     return(AddCycles);

  0006e	0f b6 44 24 20	 movzx	 eax, BYTE PTR AddCycles$[rsp]

; 84   : }

  00073	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00077	c3		 ret	 0
?bcc@@YAEGPEAUcpu@@E@Z ENDP				; bcc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?asl@@YAEGPEAUcpu@@E@Z PROC				; asl

; 44   : {

$LN9:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 45   :     uint8 Value = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR Value$[rsp], 0

; 46   :     if(AddressMode == ACM)

  00018	0f b6 44 24 50	 movzx	 eax, BYTE PTR AddressMode$[rsp]
  0001d	83 f8 01	 cmp	 eax, 1
  00020	75 51		 jne	 SHORT $LN2@asl

; 47   :     {        
; 48   :         if(Cpu->A & (1 << 7))

  00022	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00027	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002a	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0002f	85 c0		 test	 eax, eax
  00031	74 13		 je	 SHORT $LN4@asl

; 49   :             setCarry(&Cpu->Flags);

  00033	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00038	48 83 c0 03	 add	 rax, 3
  0003c	48 8b c8	 mov	 rcx, rax
  0003f	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 50   :         else

  00044	eb 11		 jmp	 SHORT $LN5@asl
$LN4@asl:

; 51   :             clearCarry(&Cpu->Flags);

  00046	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004b	48 83 c0 03	 add	 rax, 3
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN5@asl:

; 52   :         Value = Cpu->A << 1;

  00057	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005f	d1 e0		 shl	 eax, 1
  00061	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 53   :         Cpu->A = Value;

  00065	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0006a	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  0006f	88 08		 mov	 BYTE PTR [rax], cl

; 54   :     }
; 55   :     else

  00071	eb 64		 jmp	 SHORT $LN3@asl
$LN2@asl:

; 56   :     {
; 57   :         Value = readCpu8(Address, Cpu);

  00073	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00078	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0007d	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00082	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 58   :         if(Value & (1 << 7))

  00086	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  0008b	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00090	85 c0		 test	 eax, eax
  00092	74 13		 je	 SHORT $LN6@asl

; 59   :             setCarry(&Cpu->Flags);

  00094	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00099	48 83 c0 03	 add	 rax, 3
  0009d	48 8b c8	 mov	 rcx, rax
  000a0	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 60   :         else

  000a5	eb 11		 jmp	 SHORT $LN7@asl
$LN6@asl:

; 61   :             clearCarry(&Cpu->Flags);

  000a7	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000ac	48 83 c0 03	 add	 rax, 3
  000b0	48 8b c8	 mov	 rcx, rax
  000b3	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN7@asl:

; 62   :         Value = Value << 1;

  000b8	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]
  000bd	d1 e0		 shl	 eax, 1
  000bf	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 63   :         writeCpu8(Value, Address, Cpu);

  000c3	4c 8b 44 24 48	 mov	 r8, QWORD PTR Cpu$[rsp]
  000c8	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  000cd	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  000d2	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8
$LN3@asl:

; 64   :     }
; 65   :     setZero(Value, &Cpu->Flags);

  000d7	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000dc	48 83 c0 03	 add	 rax, 3
  000e0	48 8b d0	 mov	 rdx, rax
  000e3	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  000e8	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 66   :     setNegative(Value, &Cpu->Flags);

  000ed	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000f2	48 83 c0 03	 add	 rax, 3
  000f6	48 8b d0	 mov	 rdx, rax
  000f9	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  000fe	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 67   :     return(0);

  00103	32 c0		 xor	 al, al

; 68   : }

  00105	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00109	c3		 ret	 0
?asl@@YAEGPEAUcpu@@E@Z ENDP				; asl
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
Value$ = 32
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?AND@@YAEGPEAUcpu@@E@Z PROC				; AND

; 35   : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 36   :     uint8 Value = readCpu8(Address, Cpu);

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00018	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  0001d	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00022	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 37   :     Cpu->A = Cpu->A & Value;

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0002b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002e	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Value$[rsp]
  00033	23 c1		 and	 eax, ecx
  00035	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0003a	88 01		 mov	 BYTE PTR [rcx], al

; 38   :     setZero(Cpu->A, &Cpu->Flags);

  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00041	48 83 c0 03	 add	 rax, 3
  00045	48 8b d0	 mov	 rdx, rax
  00048	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0004d	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00050	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 39   :     setNegative(Cpu->A, &Cpu->Flags);

  00055	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0005a	48 83 c0 03	 add	 rax, 3
  0005e	48 8b d0	 mov	 rdx, rax
  00061	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00066	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00069	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 40   :     return(0);

  0006e	32 c0		 xor	 al, al

; 41   : }

  00070	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00074	c3		 ret	 0
?AND@@YAEGPEAUcpu@@E@Z ENDP				; AND
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\operations.cpp
_TEXT	SEGMENT
A$ = 32
B$ = 33
C$ = 34
Sum$ = 36
Address$ = 64
Cpu$ = 72
AddressMode$ = 80
?adc@@YAEGPEAUcpu@@E@Z PROC				; adc

; 9    : {

$LN7:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 10   :     uint8 A = Cpu->A;

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00018	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001b	88 44 24 20	 mov	 BYTE PTR A$[rsp], al

; 11   :     uint8 B = readCpu8(Address, Cpu);

  0001f	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00024	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00029	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  0002e	88 44 24 21	 mov	 BYTE PTR B$[rsp], al

; 12   :     uint8 C = isBitSet(CARRY_BIT, Cpu->Flags);

  00032	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00037	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  0003b	b1 01		 mov	 cl, 1
  0003d	e8 00 00 00 00	 call	 ?isBitSet@@YAHEE@Z	; isBitSet
  00042	88 44 24 22	 mov	 BYTE PTR C$[rsp], al

; 13   : 
; 14   :     uint16 Sum = (uint16)A + (uint16)B + (uint16)C;

  00046	0f b6 44 24 20	 movzx	 eax, BYTE PTR A$[rsp]
  0004b	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR B$[rsp]
  00050	03 c1		 add	 eax, ecx
  00052	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR C$[rsp]
  00057	03 c1		 add	 eax, ecx
  00059	66 89 44 24 24	 mov	 WORD PTR Sum$[rsp], ax

; 15   : 
; 16   :     // Overflow check, taken from the web. One day find out how this works
; 17   :     if(((A ^ Sum) & (B ^ Sum) & 0x80) == 0x80)

  0005e	0f b6 44 24 20	 movzx	 eax, BYTE PTR A$[rsp]
  00063	0f b7 4c 24 24	 movzx	 ecx, WORD PTR Sum$[rsp]
  00068	33 c1		 xor	 eax, ecx
  0006a	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR B$[rsp]
  0006f	0f b7 54 24 24	 movzx	 edx, WORD PTR Sum$[rsp]
  00074	33 ca		 xor	 ecx, edx
  00076	23 c1		 and	 eax, ecx
  00078	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0007d	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00082	75 13		 jne	 SHORT $LN2@adc

; 18   :         setOverflow(&Cpu->Flags);

  00084	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00089	48 83 c0 03	 add	 rax, 3
  0008d	48 8b c8	 mov	 rcx, rax
  00090	e8 00 00 00 00	 call	 ?setOverflow@@YAXPEAE@Z	; setOverflow

; 19   :     else

  00095	eb 11		 jmp	 SHORT $LN3@adc
$LN2@adc:

; 20   :         clearOverflow(&Cpu->Flags);

  00097	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0009c	48 83 c0 03	 add	 rax, 3
  000a0	48 8b c8	 mov	 rcx, rax
  000a3	e8 00 00 00 00	 call	 ?clearOverflow@@YAXPEAE@Z ; clearOverflow
$LN3@adc:

; 21   : 
; 22   :     if(Sum & 0x100)

  000a8	0f b7 44 24 24	 movzx	 eax, WORD PTR Sum$[rsp]
  000ad	25 00 01 00 00	 and	 eax, 256		; 00000100H
  000b2	85 c0		 test	 eax, eax
  000b4	74 13		 je	 SHORT $LN4@adc

; 23   :         setCarry(&Cpu->Flags);

  000b6	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000bb	48 83 c0 03	 add	 rax, 3
  000bf	48 8b c8	 mov	 rcx, rax
  000c2	e8 00 00 00 00	 call	 ?setCarry@@YAXPEAE@Z	; setCarry

; 24   :     else

  000c7	eb 11		 jmp	 SHORT $LN5@adc
$LN4@adc:

; 25   :         clearCarry(&Cpu->Flags);

  000c9	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000ce	48 83 c0 03	 add	 rax, 3
  000d2	48 8b c8	 mov	 rcx, rax
  000d5	e8 00 00 00 00	 call	 ?clearCarry@@YAXPEAE@Z	; clearCarry
$LN5@adc:

; 26   : 
; 27   :     setZero(Sum, &Cpu->Flags);

  000da	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000df	48 83 c0 03	 add	 rax, 3
  000e3	48 8b d0	 mov	 rdx, rax
  000e6	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Sum$[rsp]
  000eb	e8 00 00 00 00	 call	 ?setZero@@YAXEPEAE@Z	; setZero

; 28   :     setNegative(Sum, &Cpu->Flags);

  000f0	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000f5	48 83 c0 03	 add	 rax, 3
  000f9	48 8b d0	 mov	 rdx, rax
  000fc	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Sum$[rsp]
  00101	e8 00 00 00 00	 call	 ?setNegative@@YAXEPEAE@Z ; setNegative

; 29   : 
; 30   :     Cpu->A = (uint8)Sum;

  00106	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0010b	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Sum$[rsp]
  00110	88 08		 mov	 BYTE PTR [rax], cl

; 31   :     return(0);

  00112	32 c0		 xor	 al, al

; 32   : }

  00114	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00118	c3		 ret	 0
?adc@@YAEGPEAUcpu@@E@Z ENDP				; adc
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?crossedPageCheck@@YAHGG@Z
_TEXT	SEGMENT
tv69 = 0
Before$ = 32
Now$ = 40
?crossedPageCheck@@YAHGG@Z PROC				; crossedPageCheck, COMDAT

; 243  : inline bool32 crossedPageCheck(uint16 Before, uint16 Now) { return((Before & 0xFF00) != (Now & 0xFF00));}

$LN5:
  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 18	 sub	 rsp, 24
  0000e	0f b7 44 24 20	 movzx	 eax, WORD PTR Before$[rsp]
  00013	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00018	0f b7 4c 24 28	 movzx	 ecx, WORD PTR Now$[rsp]
  0001d	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00023	3b c1		 cmp	 eax, ecx
  00025	74 09		 je	 SHORT $LN3@crossedPag
  00027	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv69[rsp], 1
  0002e	eb 07		 jmp	 SHORT $LN4@crossedPag
$LN3@crossedPag:
  00030	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv69[rsp], 0
$LN4@crossedPag:
  00037	8b 04 24	 mov	 eax, DWORD PTR tv69[rsp]
  0003a	48 83 c4 18	 add	 rsp, 24
  0003e	c3		 ret	 0
?crossedPageCheck@@YAHGG@Z ENDP				; crossedPageCheck
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?isBitSet@@YAHEE@Z
_TEXT	SEGMENT
Bit$ = 8
Flags$ = 16
?isBitSet@@YAHEE@Z PROC					; isBitSet, COMDAT

; 242  : inline bool32 isBitSet(uint8 Bit, uint8 Flags) { return(Bit & Flags); }

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00008	0f b6 44 24 08	 movzx	 eax, BYTE PTR Bit$[rsp]
  0000d	0f b6 4c 24 10	 movzx	 ecx, BYTE PTR Flags$[rsp]
  00012	23 c1		 and	 eax, ecx
  00014	c3		 ret	 0
?isBitSet@@YAHEE@Z ENDP					; isBitSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setNegative@@YAXEPEAE@Z
_TEXT	SEGMENT
Value$ = 8
Flags$ = 16
?setNegative@@YAXEPEAE@Z PROC				; setNegative, COMDAT

; 236  : {  

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 237  :     if(Value >= 0x00 && Value <= 0x7F)

  00009	0f b6 44 24 08	 movzx	 eax, BYTE PTR Value$[rsp]
  0000e	85 c0		 test	 eax, eax
  00010	7c 1f		 jl	 SHORT $LN2@setNegativ
  00012	0f b6 44 24 08	 movzx	 eax, BYTE PTR Value$[rsp]
  00017	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  0001a	7f 15		 jg	 SHORT $LN2@setNegativ

; 238  :         *Flags = *Flags & ~NEGATIVE_BIT; // clear negative flag

  0001c	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  00021	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00024	0f ba f0 07	 btr	 eax, 7
  00028	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  0002d	88 01		 mov	 BYTE PTR [rcx], al

; 239  :     else

  0002f	eb 13		 jmp	 SHORT $LN3@setNegativ
$LN2@setNegativ:

; 240  :         *Flags = *Flags | NEGATIVE_BIT; // set negative flag

  00031	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  00036	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00039	0f ba e8 07	 bts	 eax, 7
  0003d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  00042	88 01		 mov	 BYTE PTR [rcx], al
$LN3@setNegativ:

; 241  : }

  00044	c3		 ret	 0
?setNegative@@YAXEPEAE@Z ENDP				; setNegative
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setZero@@YAXEPEAE@Z
_TEXT	SEGMENT
Value$ = 8
Flags$ = 16
?setZero@@YAXEPEAE@Z PROC				; setZero, COMDAT

; 229  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 230  :     if(Value == 0x00)

  00009	0f b6 44 24 08	 movzx	 eax, BYTE PTR Value$[rsp]
  0000e	85 c0		 test	 eax, eax
  00010	75 14		 jne	 SHORT $LN2@setZero

; 231  :         *Flags = *Flags | ZERO_BIT;

  00012	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  00017	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001a	83 c8 02	 or	 eax, 2
  0001d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  00022	88 01		 mov	 BYTE PTR [rcx], al

; 232  :     else

  00024	eb 12		 jmp	 SHORT $LN3@setZero
$LN2@setZero:

; 233  :         *Flags = *Flags & ~ZERO_BIT;

  00026	48 8b 44 24 10	 mov	 rax, QWORD PTR Flags$[rsp]
  0002b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002e	83 e0 fd	 and	 eax, -3
  00031	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Flags$[rsp]
  00036	88 01		 mov	 BYTE PTR [rcx], al
$LN3@setZero:

; 234  : }

  00038	c3		 ret	 0
?setZero@@YAXEPEAE@Z ENDP				; setZero
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearOverflow@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearOverflow@@YAXPEAE@Z PROC				; clearOverflow, COMDAT

; 227  : inline void clearOverflow(uint8 *Flags)  { *Flags = *Flags & ~OVERFLOW_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 bf	 and	 eax, -65		; ffffffffffffffbfH
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?clearOverflow@@YAXPEAE@Z ENDP				; clearOverflow
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setOverflow@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setOverflow@@YAXPEAE@Z PROC				; setOverflow, COMDAT

; 226  : inline void setOverflow(uint8 *Flags)    { *Flags = *Flags | OVERFLOW_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 40	 or	 eax, 64			; 00000040H
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?setOverflow@@YAXPEAE@Z ENDP				; setOverflow
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setBlank@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setBlank@@YAXPEAE@Z PROC				; setBlank, COMDAT

; 224  : inline void setBlank(uint8 *Flags)       { *Flags = *Flags | BLANK_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 20	 or	 eax, 32			; 00000020H
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?setBlank@@YAXPEAE@Z ENDP				; setBlank
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearBreak@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearBreak@@YAXPEAE@Z PROC				; clearBreak, COMDAT

; 223  : inline void clearBreak(uint8 *Flags)     { *Flags = *Flags & ~BREAK_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 ef	 and	 eax, -17
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?clearBreak@@YAXPEAE@Z ENDP				; clearBreak
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setBreak@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setBreak@@YAXPEAE@Z PROC				; setBreak, COMDAT

; 222  : inline void setBreak(uint8 *Flags)       { *Flags = *Flags | BREAK_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 10	 or	 eax, 16
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?setBreak@@YAXPEAE@Z ENDP				; setBreak
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearDecimal@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearDecimal@@YAXPEAE@Z PROC				; clearDecimal, COMDAT

; 221  : inline void clearDecimal(uint8 *Flags)   { *Flags = *Flags & ~DECIMAL_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 f7	 and	 eax, -9
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?clearDecimal@@YAXPEAE@Z ENDP				; clearDecimal
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setDecimal@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setDecimal@@YAXPEAE@Z PROC				; setDecimal, COMDAT

; 220  : inline void setDecimal(uint8 *Flags)     { *Flags = *Flags | DECIMAL_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 08	 or	 eax, 8
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?setDecimal@@YAXPEAE@Z ENDP				; setDecimal
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearInterrupt@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearInterrupt@@YAXPEAE@Z PROC				; clearInterrupt, COMDAT

; 219  : inline void clearInterrupt(uint8 *Flags) { *Flags = *Flags & ~INTERRUPT_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 fb	 and	 eax, -5
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?clearInterrupt@@YAXPEAE@Z ENDP				; clearInterrupt
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setInterrupt@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setInterrupt@@YAXPEAE@Z PROC				; setInterrupt, COMDAT

; 218  : inline void setInterrupt(uint8 *Flags)   { *Flags = *Flags | INTERRUPT_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 04	 or	 eax, 4
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?setInterrupt@@YAXPEAE@Z ENDP				; setInterrupt
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?clearCarry@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?clearCarry@@YAXPEAE@Z PROC				; clearCarry, COMDAT

; 217  : inline void clearCarry(uint8 *Flags)     { *Flags = *Flags & ~CARRY_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 e0 fe	 and	 eax, -2
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?clearCarry@@YAXPEAE@Z ENDP				; clearCarry
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
;	COMDAT ?setCarry@@YAXPEAE@Z
_TEXT	SEGMENT
Flags$ = 8
?setCarry@@YAXPEAE@Z PROC				; setCarry, COMDAT

; 216  : inline void setCarry(uint8 *Flags)       { *Flags = *Flags | CARRY_BIT; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR Flags$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0000d	83 c8 01	 or	 eax, 1
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Flags$[rsp]
  00015	88 01		 mov	 BYTE PTR [rcx], al
  00017	c3		 ret	 0
?setCarry@@YAXPEAE@Z ENDP				; setCarry
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Value$ = 32
Cpu$ = 64
?pop@@YAEPEAUcpu@@@Z PROC				; pop

; 201  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 202  :     ++Cpu->StackPtr;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR Cpu$[rsp]
  0000e	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00012	fe c0		 inc	 al
  00014	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00019	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 203  :     uint8 Value = readCpu8((uint16)Cpu->StackPtr | STACK_ADDRESS, Cpu);

  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR Cpu$[rsp]
  00021	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00025	0f ba e8 08	 bts	 eax, 8
  00029	48 8b 54 24 40	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0002e	0f b7 c8	 movzx	 ecx, ax
  00031	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00036	88 44 24 20	 mov	 BYTE PTR Value$[rsp], al

; 204  :     return(Value);

  0003a	0f b6 44 24 20	 movzx	 eax, BYTE PTR Value$[rsp]

; 205  : }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
?pop@@YAEPEAUcpu@@@Z ENDP				; pop
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
Byte$ = 48
Cpu$ = 56
?push@@YAXEPEAUcpu@@@Z PROC				; push

; 196  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 197  :     writeCpu8(Byte, (uint16)Cpu->StackPtr | STACK_ADDRESS, Cpu);

  0000d	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00012	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00016	0f ba e8 08	 bts	 eax, 8
  0001a	4c 8b 44 24 38	 mov	 r8, QWORD PTR Cpu$[rsp]
  0001f	0f b7 d0	 movzx	 edx, ax
  00022	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR Byte$[rsp]
  00027	e8 00 00 00 00	 call	 ?writeCpu8@@YAXEGPEAUcpu@@@Z ; writeCpu8

; 198  :     --Cpu->StackPtr;  

  0002c	48 8b 44 24 38	 mov	 rax, QWORD PTR Cpu$[rsp]
  00031	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00035	fe c8		 dec	 al
  00037	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0003c	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 199  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
?push@@YAXEPEAUcpu@@@Z ENDP				; push
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
Byte2Adrs$ = 36
NewAddress$ = 40
Address$ = 64
Cpu$ = 72
?bugReadCpu16@@YAGGPEAUcpu@@@Z PROC			; bugReadCpu16

; 183  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 184  :     // NOTE: This is a bug in the nes 6502 that will wrap the value instead of going to new page.
; 185  :     //       Only happens with indirect addressing.
; 186  :     
; 187  :     uint8 LowByte = readCpu8(Address, Cpu);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00013	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00018	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  0001d	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 188  :     uint16 Byte2Adrs = (Address & 0xFF00) | (uint16)((uint8)(Address + 1));

  00021	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00026	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  0002b	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00030	ff c1		 inc	 ecx
  00032	0f b6 c9	 movzx	 ecx, cl
  00035	0b c1		 or	 eax, ecx
  00037	66 89 44 24 24	 mov	 WORD PTR Byte2Adrs$[rsp], ax

; 189  :     uint8 HighByte = readCpu8(Byte2Adrs, Cpu);

  0003c	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00041	0f b7 4c 24 24	 movzx	 ecx, WORD PTR Byte2Adrs$[rsp]
  00046	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  0004b	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 190  :         
; 191  :     uint16 NewAddress = (HighByte << 8) | LowByte;

  0004f	0f b6 44 24 20	 movzx	 eax, BYTE PTR HighByte$[rsp]
  00054	c1 e0 08	 shl	 eax, 8
  00057	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  0005c	0b c1		 or	 eax, ecx
  0005e	66 89 44 24 28	 mov	 WORD PTR NewAddress$[rsp], ax

; 192  :     return(NewAddress);

  00063	0f b7 44 24 28	 movzx	 eax, WORD PTR NewAddress$[rsp]

; 193  : }

  00068	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006c	c3		 ret	 0
?bugReadCpu16@@YAGGPEAUcpu@@@Z ENDP			; bugReadCpu16
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
HighByte$ = 32
LowByte$ = 33
NewAddress$ = 36
Address$ = 64
Cpu$ = 72
?readCpu16@@YAGGPEAUcpu@@@Z PROC			; readCpu16

; 172  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 173  :     // NOTE: Little Endian
; 174  :     uint8 LowByte = readCpu8(Address, Cpu);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  00013	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00018	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  0001d	88 44 24 21	 mov	 BYTE PTR LowByte$[rsp], al

; 175  :     uint8 HighByte = readCpu8(Address+1, Cpu);

  00021	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00026	ff c0		 inc	 eax
  00028	48 8b 54 24 48	 mov	 rdx, QWORD PTR Cpu$[rsp]
  0002d	0f b7 c8	 movzx	 ecx, ax
  00030	e8 00 00 00 00	 call	 ?readCpu8@@YAEGPEAUcpu@@@Z ; readCpu8
  00035	88 44 24 20	 mov	 BYTE PTR HighByte$[rsp], al

; 176  :         
; 177  :     uint16 NewAddress = (HighByte << 8) | LowByte;

  00039	0f b6 44 24 20	 movzx	 eax, BYTE PTR HighByte$[rsp]
  0003e	c1 e0 08	 shl	 eax, 8
  00041	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR LowByte$[rsp]
  00046	0b c1		 or	 eax, ecx
  00048	66 89 44 24 24	 mov	 WORD PTR NewAddress$[rsp], ax

; 178  :     return(NewAddress);

  0004d	0f b7 44 24 24	 movzx	 eax, WORD PTR NewAddress$[rsp]

; 179  : }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
?readCpu16@@YAGGPEAUcpu@@@Z ENDP			; readCpu16
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
BtnValue$1 = 32
Bit0$2 = 33
OamAddress$3 = 34
Reg1Value$4 = 35
Reg2Value$5 = 36
index$6 = 40
NewAddress$7 = 44
Byte$ = 64
Address$ = 72
Cpu$ = 80
?writeCpu8@@YAXEGPEAUcpu@@@Z PROC			; writeCpu8

; 96   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 97   :     // NOTE: Mirrors the address for the 2kb ram 
; 98   :     if(0x800 <= Address && Address < 0x2000)

  00012	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  00017	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  0001c	7c 26		 jl	 SHORT $LN5@writeCpu8
  0001e	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  00023	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  00028	7d 1a		 jge	 SHORT $LN5@writeCpu8

; 99   :         Address = (Address % 0x800);

  0002a	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  0002f	99		 cdq
  00030	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  00036	03 c2		 add	 eax, edx
  00038	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0003d	2b c2		 sub	 eax, edx
  0003f	66 89 44 24 48	 mov	 WORD PTR Address$[rsp], ax
$LN5@writeCpu8:

; 100  :     // NOTE: Mirror for PPU Registers
; 101  :     if(0x2008 <= Address && Address < 0x4000)

  00044	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  00049	3d 08 20 00 00	 cmp	 eax, 8200		; 00002008H
  0004e	7c 26		 jl	 SHORT $LN6@writeCpu8
  00050	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  00055	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  0005a	7d 1a		 jge	 SHORT $LN6@writeCpu8

; 102  :         Address = (Address % (0x2008 - 0x2000)) + 0x2000;

  0005c	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  00061	99		 cdq
  00062	83 e2 07	 and	 edx, 7
  00065	03 c2		 add	 eax, edx
  00067	83 e0 07	 and	 eax, 7
  0006a	2b c2		 sub	 eax, edx
  0006c	05 00 20 00 00	 add	 eax, 8192		; 00002000H
  00071	66 89 44 24 48	 mov	 WORD PTR Address$[rsp], ax
$LN6@writeCpu8:

; 103  :     if(Address == 0x2002)

  00076	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  0007b	3d 02 20 00 00	 cmp	 eax, 8194		; 00002002H
  00080	75 12		 jne	 SHORT $LN7@writeCpu8

; 104  :         Assert(0);

  00082	33 c0		 xor	 eax, eax
  00084	83 f8 01	 cmp	 eax, 1
  00087	74 0b		 je	 SHORT $LN8@writeCpu8
  00089	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN8@writeCpu8:
$LN7@writeCpu8:

; 105  :     
; 106  :     write8(Byte, Address, Cpu->MemoryBase);

  00094	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  00099	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  0009d	0f b7 54 24 48	 movzx	 edx, WORD PTR Address$[rsp]
  000a2	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR Byte$[rsp]
  000a7	e8 00 00 00 00	 call	 ?write8@@YAXEG_K@Z	; write8

; 107  : 
; 108  :     if(Address == 0x2004) // OAM data

  000ac	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  000b1	3d 04 20 00 00	 cmp	 eax, 8196		; 00002004H
  000b6	75 0a		 jne	 SHORT $LN9@writeCpu8

; 109  :         OamDataChange = true;

  000b8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?OamDataChange@@3HA, 1 ; OamDataChange
$LN9@writeCpu8:

; 110  :     if(Address == 0x2005) // Scroll address

  000c2	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  000c7	3d 05 20 00 00	 cmp	 eax, 8197		; 00002005H
  000cc	75 0a		 jne	 SHORT $LN10@writeCpu8

; 111  :         ScrollAdrsChange = true;

  000ce	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?ScrollAdrsChange@@3HA, 1 ; ScrollAdrsChange
$LN10@writeCpu8:

; 112  :     if(Address == 0x2006) // Writing to ppu io address register

  000d8	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  000dd	3d 06 20 00 00	 cmp	 eax, 8198		; 00002006H
  000e2	75 0a		 jne	 SHORT $LN11@writeCpu8

; 113  :         VRamAdrsChange = true;

  000e4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?VRamAdrsChange@@3HA, 1 ; VRamAdrsChange
$LN11@writeCpu8:

; 114  :     if(Address == 0x2007) // Write to IO for ppu. Happens after two writes to 0x2006

  000ee	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  000f3	3d 07 20 00 00	 cmp	 eax, 8199		; 00002007H
  000f8	75 0a		 jne	 SHORT $LN12@writeCpu8

; 115  :         IOWriteFromCpu = true;

  000fa	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?IOWriteFromCpu@@3HA, 1 ; IOWriteFromCpu
$LN12@writeCpu8:

; 116  : 
; 117  : 
; 118  :     // NOTE: OAM DMA Write
; 119  :     if(Address == 0x4014)

  00104	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  00109	3d 14 40 00 00	 cmp	 eax, 16404		; 00004014H
  0010e	0f 85 8f 00 00
	00		 jne	 $LN13@writeCpu8

; 120  :     {
; 121  :         uint8 OamAddress = read8(0x2003, Cpu->MemoryBase);

  00114	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  00119	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0011d	66 b9 03 20	 mov	 cx, 8195		; 00002003H
  00121	e8 00 00 00 00	 call	 ?read8@@YAEG_K@Z	; read8
  00126	88 44 24 22	 mov	 BYTE PTR OamAddress$3[rsp], al

; 122  : 
; 123  :         if(OamData == 0)

  0012a	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?OamData@@3PEAEEA, 0
  00132	75 12		 jne	 SHORT $LN14@writeCpu8

; 124  :         {
; 125  :             Assert(0);

  00134	33 c0		 xor	 eax, eax
  00136	83 f8 01	 cmp	 eax, 1
  00139	74 0b		 je	 SHORT $LN15@writeCpu8
  0013b	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN15@writeCpu8:
$LN14@writeCpu8:

; 126  :         }
; 127  :         
; 128  :         for(uint16 index = OamAddress; index < OAM_SIZE; ++index)

  00146	0f b6 44 24 22	 movzx	 eax, BYTE PTR OamAddress$3[rsp]
  0014b	66 89 44 24 28	 mov	 WORD PTR index$6[rsp], ax
  00150	eb 0d		 jmp	 SHORT $LN4@writeCpu8
$LN2@writeCpu8:
  00152	0f b7 44 24 28	 movzx	 eax, WORD PTR index$6[rsp]
  00157	66 ff c0	 inc	 ax
  0015a	66 89 44 24 28	 mov	 WORD PTR index$6[rsp], ax
$LN4@writeCpu8:
  0015f	0f b7 44 24 28	 movzx	 eax, WORD PTR index$6[rsp]
  00164	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00169	7d 38		 jge	 SHORT $LN3@writeCpu8

; 129  :         {
; 130  :             uint16 NewAddress = (Byte << 8) | index; 

  0016b	0f b6 44 24 40	 movzx	 eax, BYTE PTR Byte$[rsp]
  00170	c1 e0 08	 shl	 eax, 8
  00173	0f b7 4c 24 28	 movzx	 ecx, WORD PTR index$6[rsp]
  00178	0b c1		 or	 eax, ecx
  0017a	66 89 44 24 2c	 mov	 WORD PTR NewAddress$7[rsp], ax

; 131  :             OamData[index] = read8(NewAddress, Cpu->MemoryBase);

  0017f	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  00184	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00188	0f b7 4c 24 2c	 movzx	 ecx, WORD PTR NewAddress$7[rsp]
  0018d	e8 00 00 00 00	 call	 ?read8@@YAEG_K@Z	; read8
  00192	0f b7 4c 24 28	 movzx	 ecx, WORD PTR index$6[rsp]
  00197	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?OamData@@3PEAEEA
  0019e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 132  :         }

  001a1	eb af		 jmp	 SHORT $LN2@writeCpu8
$LN3@writeCpu8:
$LN13@writeCpu8:

; 133  :     }
; 134  :     
; 135  :     // Input
; 136  :     if(Address == 0x4016 || Address == 0x4017)

  001a3	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  001a8	3d 16 40 00 00	 cmp	 eax, 16406		; 00004016H
  001ad	74 10		 je	 SHORT $LN17@writeCpu8
  001af	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  001b4	3d 17 40 00 00	 cmp	 eax, 16407		; 00004017H
  001b9	0f 85 e9 00 00
	00		 jne	 $LN16@writeCpu8
$LN17@writeCpu8:

; 137  :     {
; 138  :         uint8 Reg1Value = read8(0x4016, Cpu->MemoryBase);

  001bf	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  001c4	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  001c8	66 b9 16 40	 mov	 cx, 16406		; 00004016H
  001cc	e8 00 00 00 00	 call	 ?read8@@YAEG_K@Z	; read8
  001d1	88 44 24 23	 mov	 BYTE PTR Reg1Value$4[rsp], al

; 139  :         uint8 Reg2Value = read8(0x4017, Cpu->MemoryBase);

  001d5	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  001da	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  001de	66 b9 17 40	 mov	 cx, 16407		; 00004017H
  001e2	e8 00 00 00 00	 call	 ?read8@@YAEG_K@Z	; read8
  001e7	88 44 24 24	 mov	 BYTE PTR Reg2Value$5[rsp], al

; 140  : 
; 141  :         uint8 Bit0 = (Reg1Value | Reg2Value) & 1;

  001eb	0f b6 44 24 23	 movzx	 eax, BYTE PTR Reg1Value$4[rsp]
  001f0	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR Reg2Value$5[rsp]
  001f5	0b c1		 or	 eax, ecx
  001f7	83 e0 01	 and	 eax, 1
  001fa	88 44 24 21	 mov	 BYTE PTR Bit0$2[rsp], al

; 142  : 
; 143  :         if(Bit0 == 0)

  001fe	0f b6 44 24 21	 movzx	 eax, BYTE PTR Bit0$2[rsp]
  00203	85 c0		 test	 eax, eax
  00205	75 2b		 jne	 SHORT $LN18@writeCpu8

; 144  :         {
; 145  :             if(Cpu->PadStrobe)

  00207	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  0020c	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00210	74 12		 je	 SHORT $LN20@writeCpu8

; 146  :             {
; 147  :                 Cpu->Pad1CurrentButton = Cpu->Pad2CurrentButton = input::B_A;

  00212	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  00217	c6 40 60 00	 mov	 BYTE PTR [rax+96], 0
  0021b	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  00220	c6 40 3c 00	 mov	 BYTE PTR [rax+60], 0
$LN20@writeCpu8:

; 148  :             }
; 149  :             Cpu->PadStrobe = false;

  00224	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  00229	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0
  00230	eb 16		 jmp	 SHORT $LN19@writeCpu8
$LN18@writeCpu8:

; 150  :         }
; 151  :         else if(Bit0 == 1)

  00232	0f b6 44 24 21	 movzx	 eax, BYTE PTR Bit0$2[rsp]
  00237	83 f8 01	 cmp	 eax, 1
  0023a	75 0c		 jne	 SHORT $LN21@writeCpu8

; 152  :         {
; 153  :             Cpu->PadStrobe = true;

  0023c	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  00241	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [rax+24], 1
$LN21@writeCpu8:
$LN19@writeCpu8:

; 154  :         }        
; 155  : 
; 156  :         uint8 BtnValue = Cpu->InputPad1.buttons[Cpu->Pad1CurrentButton] & 1;

  00248	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  0024d	0f b6 40 3c	 movzx	 eax, BYTE PTR [rax+60]
  00251	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00256	8b 44 81 1c	 mov	 eax, DWORD PTR [rcx+rax*4+28]
  0025a	83 e0 01	 and	 eax, 1
  0025d	88 44 24 20	 mov	 BYTE PTR BtnValue$1[rsp], al

; 157  :         write8(BtnValue, 0x4016, Cpu->MemoryBase);

  00261	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  00266	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  0026a	66 ba 16 40	 mov	 dx, 16406		; 00004016H
  0026e	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR BtnValue$1[rsp]
  00273	e8 00 00 00 00	 call	 ?write8@@YAXEG_K@Z	; write8

; 158  : 
; 159  :         BtnValue = Cpu->InputPad2.buttons[Cpu->Pad2CurrentButton] & 1;

  00278	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  0027d	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  00281	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Cpu$[rsp]
  00286	8b 44 81 40	 mov	 eax, DWORD PTR [rcx+rax*4+64]
  0028a	83 e0 01	 and	 eax, 1
  0028d	88 44 24 20	 mov	 BYTE PTR BtnValue$1[rsp], al

; 160  :         write8(BtnValue, 0x4017, Cpu->MemoryBase);

  00291	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  00296	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  0029a	66 ba 17 40	 mov	 dx, 16407		; 00004017H
  0029e	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR BtnValue$1[rsp]
  002a3	e8 00 00 00 00	 call	 ?write8@@YAXEG_K@Z	; write8
$LN16@writeCpu8:

; 161  :     }
; 162  : 
; 163  :     if(Address >= 0x8000)

  002a8	0f b7 44 24 48	 movzx	 eax, WORD PTR Address$[rsp]
  002ad	3d 00 80 00 00	 cmp	 eax, 32768		; 00008000H
  002b2	7c 27		 jl	 SHORT $LN22@writeCpu8

; 164  :     {
; 165  :         Cpu->MapperWrite = true;

  002b4	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  002b9	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [rax+20], 1

; 166  :         Cpu->MapperReg = Byte;

  002c0	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  002c5	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR Byte$[rsp]
  002ca	88 48 10	 mov	 BYTE PTR [rax+16], cl

; 167  :         Cpu->MapperWriteAddress = Address;

  002cd	48 8b 44 24 50	 mov	 rax, QWORD PTR Cpu$[rsp]
  002d2	0f b7 4c 24 48	 movzx	 ecx, WORD PTR Address$[rsp]
  002d7	66 89 48 12	 mov	 WORD PTR [rax+18], cx
$LN22@writeCpu8:

; 168  :     }
; 169  : }

  002db	48 83 c4 38	 add	 rsp, 56			; 00000038H
  002df	c3		 ret	 0
?writeCpu8@@YAXEGPEAUcpu@@@Z ENDP			; writeCpu8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\cpu.cpp
_TEXT	SEGMENT
tv137 = 32
tv141 = 33
BtnValue$1 = 34
Value$ = 35
ResetValue$2 = 36
CurrentValue$3 = 37
NewValue$4 = 38
InputAddress$5 = 40
Address$ = 64
Cpu$ = 72
?readCpu8@@YAEGPEAUcpu@@@Z PROC				; readCpu8

; 39   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 40   :     // NOTE: Mirrors the address for the 2kb ram 
; 41   :     if(0x800 <= Address && Address < 0x2000)

  0000e	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00013	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  00018	7c 26		 jl	 SHORT $LN2@readCpu8
  0001a	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0001f	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  00024	7d 1a		 jge	 SHORT $LN2@readCpu8

; 42   :         Address = (Address % 0x800);

  00026	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0002b	99		 cdq
  0002c	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  00032	03 c2		 add	 eax, edx
  00034	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00039	2b c2		 sub	 eax, edx
  0003b	66 89 44 24 40	 mov	 WORD PTR Address$[rsp], ax
$LN2@readCpu8:

; 43   :     // NOTE: Mirror for PPU Registers
; 44   :     if(0x2008 <= Address && Address < 0x4000)

  00040	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00045	3d 08 20 00 00	 cmp	 eax, 8200		; 00002008H
  0004a	7c 26		 jl	 SHORT $LN3@readCpu8
  0004c	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00051	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  00056	7d 1a		 jge	 SHORT $LN3@readCpu8

; 45   :         Address = (Address % (0x2008 - 0x2000)) + 0x2000;

  00058	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  0005d	99		 cdq
  0005e	83 e2 07	 and	 edx, 7
  00061	03 c2		 add	 eax, edx
  00063	83 e0 07	 and	 eax, 7
  00066	2b c2		 sub	 eax, edx
  00068	05 00 20 00 00	 add	 eax, 8192		; 00002000H
  0006d	66 89 44 24 40	 mov	 WORD PTR Address$[rsp], ax
$LN3@readCpu8:

; 46   :     
; 47   :     if(Address == 0x2007) // Reading from the IO of ppu. First read is junk, unless its the colour palette

  00072	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00077	3d 07 20 00 00	 cmp	 eax, 8199		; 00002007H
  0007c	75 0a		 jne	 SHORT $LN4@readCpu8

; 48   :         IOReadFromCpu = true;

  0007e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?IOReadFromCpu@@3HA, 1 ; IOReadFromCpu
$LN4@readCpu8:

; 49   :         
; 50   :     uint8 Value = read8(Address, Cpu->MemoryBase);

  00088	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0008d	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00091	0f b7 4c 24 40	 movzx	 ecx, WORD PTR Address$[rsp]
  00096	e8 00 00 00 00	 call	 ?read8@@YAEG_K@Z	; read8
  0009b	88 44 24 23	 mov	 BYTE PTR Value$[rsp], al

; 51   :             
; 52   :     if(Address == 0x2002)

  0009f	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  000a4	3d 02 20 00 00	 cmp	 eax, 8194		; 00002002H
  000a9	75 39		 jne	 SHORT $LN5@readCpu8

; 53   :     {
; 54   :         // NOTE: Will reset 2005 and 2006 registers, and turn off bit 7 of 0x2002
; 55   :         ResetScrollIOAdrs = true;

  000ab	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?ResetScrollIOAdrs@@3HA, 1 ; ResetScrollIOAdrs

; 56   :         ResetVRamIOAdrs = true;

  000b5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?ResetVRamIOAdrs@@3HA, 1 ; ResetVRamIOAdrs

; 57   :         
; 58   :         uint8 ResetValue = Value & ~(1 << 7);

  000bf	0f b6 44 24 23	 movzx	 eax, BYTE PTR Value$[rsp]
  000c4	0f ba f0 07	 btr	 eax, 7
  000c8	88 44 24 24	 mov	 BYTE PTR ResetValue$2[rsp], al

; 59   :         write8(ResetValue, Address, Cpu->MemoryBase);

  000cc	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  000d1	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  000d5	0f b7 54 24 40	 movzx	 edx, WORD PTR Address$[rsp]
  000da	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR ResetValue$2[rsp]
  000df	e8 00 00 00 00	 call	 ?write8@@YAXEG_K@Z	; write8
$LN5@readCpu8:

; 60   :     }
; 61   : 
; 62   :     // Input
; 63   :     if(Address == 0x4016 || Address == 0x4017)

  000e4	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  000e9	3d 16 40 00 00	 cmp	 eax, 16406		; 00004016H
  000ee	74 10		 je	 SHORT $LN7@readCpu8
  000f0	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  000f5	3d 17 40 00 00	 cmp	 eax, 16407		; 00004017H
  000fa	0f 85 03 01 00
	00		 jne	 $LN6@readCpu8
$LN7@readCpu8:

; 64   :     {
; 65   :         if( !Cpu->PadStrobe )

  00100	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00105	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00109	75 60		 jne	 SHORT $LN8@readCpu8

; 66   :         {
; 67   :             if(Address == 0x4016)

  0010b	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00110	3d 16 40 00 00	 cmp	 eax, 16406		; 00004016H
  00115	75 2b		 jne	 SHORT $LN9@readCpu8

; 68   :                 Cpu->Pad1CurrentButton = ++(Cpu->Pad1CurrentButton);

  00117	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0011c	0f b6 40 3c	 movzx	 eax, BYTE PTR [rax+60]
  00120	fe c0		 inc	 al
  00122	88 44 24 20	 mov	 BYTE PTR tv137[rsp], al
  00126	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  0012b	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR tv137[rsp]
  00130	88 48 3c	 mov	 BYTE PTR [rax+60], cl
  00133	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00138	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR tv137[rsp]
  0013d	88 48 3c	 mov	 BYTE PTR [rax+60], cl

; 69   :             else

  00140	eb 29		 jmp	 SHORT $LN10@readCpu8
$LN9@readCpu8:

; 70   :                 Cpu->Pad2CurrentButton = ++(Cpu->Pad2CurrentButton);

  00142	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00147	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  0014b	fe c0		 inc	 al
  0014d	88 44 24 21	 mov	 BYTE PTR tv141[rsp], al
  00151	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00156	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR tv141[rsp]
  0015b	88 48 60	 mov	 BYTE PTR [rax+96], cl
  0015e	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00163	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR tv141[rsp]
  00168	88 48 60	 mov	 BYTE PTR [rax+96], cl
$LN10@readCpu8:
$LN8@readCpu8:

; 71   :         }
; 72   :         
; 73   :         uint16 InputAddress;
; 74   :         uint8 BtnValue;
; 75   :         if(Address == 0x4016)

  0016b	0f b7 44 24 40	 movzx	 eax, WORD PTR Address$[rsp]
  00170	3d 16 40 00 00	 cmp	 eax, 16406		; 00004016H
  00175	75 25		 jne	 SHORT $LN11@readCpu8

; 76   :         {
; 77   :             InputAddress = 0x4016;

  00177	b8 16 40 00 00	 mov	 eax, 16406		; 00004016H
  0017c	66 89 44 24 28	 mov	 WORD PTR InputAddress$5[rsp], ax

; 78   :             BtnValue = Cpu->InputPad1.buttons[Cpu->Pad1CurrentButton] & 1;

  00181	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  00186	0f b6 40 3c	 movzx	 eax, BYTE PTR [rax+60]
  0018a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  0018f	8b 44 81 1c	 mov	 eax, DWORD PTR [rcx+rax*4+28]
  00193	83 e0 01	 and	 eax, 1
  00196	88 44 24 22	 mov	 BYTE PTR BtnValue$1[rsp], al

; 79   :         }
; 80   :         else

  0019a	eb 23		 jmp	 SHORT $LN12@readCpu8
$LN11@readCpu8:

; 81   :         {
; 82   :             InputAddress = 0x4017;

  0019c	b8 17 40 00 00	 mov	 eax, 16407		; 00004017H
  001a1	66 89 44 24 28	 mov	 WORD PTR InputAddress$5[rsp], ax

; 83   :             BtnValue = Cpu->InputPad2.buttons[Cpu->Pad2CurrentButton] & 1;

  001a6	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  001ab	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  001af	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Cpu$[rsp]
  001b4	8b 44 81 40	 mov	 eax, DWORD PTR [rcx+rax*4+64]
  001b8	83 e0 01	 and	 eax, 1
  001bb	88 44 24 22	 mov	 BYTE PTR BtnValue$1[rsp], al
$LN12@readCpu8:

; 84   :         }
; 85   : 
; 86   :         uint8 CurrentValue = read8(InputAddress, Cpu->MemoryBase);

  001bf	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  001c4	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  001c8	0f b7 4c 24 28	 movzx	 ecx, WORD PTR InputAddress$5[rsp]
  001cd	e8 00 00 00 00	 call	 ?read8@@YAEG_K@Z	; read8
  001d2	88 44 24 25	 mov	 BYTE PTR CurrentValue$3[rsp], al

; 87   :         uint8 NewValue = (CurrentValue & 0xFE) | BtnValue;

  001d6	0f b6 44 24 25	 movzx	 eax, BYTE PTR CurrentValue$3[rsp]
  001db	25 fe 00 00 00	 and	 eax, 254		; 000000feH
  001e0	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR BtnValue$1[rsp]
  001e5	0b c1		 or	 eax, ecx
  001e7	88 44 24 26	 mov	 BYTE PTR NewValue$4[rsp], al

; 88   :         write8(NewValue, InputAddress, Cpu->MemoryBase);

  001eb	48 8b 44 24 48	 mov	 rax, QWORD PTR Cpu$[rsp]
  001f0	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  001f4	0f b7 54 24 28	 movzx	 edx, WORD PTR InputAddress$5[rsp]
  001f9	0f b6 4c 24 26	 movzx	 ecx, BYTE PTR NewValue$4[rsp]
  001fe	e8 00 00 00 00	 call	 ?write8@@YAXEG_K@Z	; write8
$LN6@readCpu8:

; 89   :     }
; 90   :     
; 91   :     
; 92   :     return(Value);

  00203	0f b6 44 24 23	 movzx	 eax, BYTE PTR Value$[rsp]

; 93   : }

  00208	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0020c	c3		 ret	 0
?readCpu8@@YAEGPEAUcpu@@@Z ENDP				; readCpu8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
BytesRead$1 = 64
FileData$ = 72
FileHandle$ = 80
Filesize$2 = 88
Filename$ = 112
Size$ = 120
?LoadFile@@YAPEAXPEADPEAI@Z PROC			; LoadFile

; 288  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 289  :     void *FileData = 0;

  0000e	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR FileData$[rsp], 0

; 290  :     
; 291  :     HANDLE FileHandle = CreateFileA(Filename, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);

  00017	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00020	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00028	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  00030	45 33 c9	 xor	 r9d, r9d
  00033	41 b8 01 00 00
	00		 mov	 r8d, 1
  00039	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  0003e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Filename$[rsp]
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileA
  00049	48 89 44 24 50	 mov	 QWORD PTR FileHandle$[rsp], rax

; 292  :     if(FileHandle != INVALID_HANDLE_VALUE)

  0004e	48 83 7c 24 50
	ff		 cmp	 QWORD PTR FileHandle$[rsp], -1
  00054	0f 84 8b 00 00
	00		 je	 $LN2@LoadFile

; 293  :     {
; 294  :         LARGE_INTEGER Filesize;
; 295  :         if(GetFileSizeEx(FileHandle, &Filesize))

  0005a	48 8d 54 24 58	 lea	 rdx, QWORD PTR Filesize$2[rsp]
  0005f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR FileHandle$[rsp]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileSizeEx
  0006a	85 c0		 test	 eax, eax
  0006c	74 77		 je	 SHORT $LN4@LoadFile

; 296  :         {
; 297  :             FileData = VirtualAlloc(0, Filesize.LowPart, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);

  0006e	8b 44 24 58	 mov	 eax, DWORD PTR Filesize$2[rsp]
  00072	41 b9 04 00 00
	00		 mov	 r9d, 4
  00078	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  0007e	8b d0		 mov	 edx, eax
  00080	33 c9		 xor	 ecx, ecx
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  00088	48 89 44 24 48	 mov	 QWORD PTR FileData$[rsp], rax

; 298  :             if(FileData)

  0008d	48 83 7c 24 48
	00		 cmp	 QWORD PTR FileData$[rsp], 0
  00093	74 50		 je	 SHORT $LN6@LoadFile

; 299  :             {
; 300  :                 DWORD BytesRead;
; 301  :                 if(ReadFile(FileHandle, FileData, Filesize.LowPart, &BytesRead, 0) &&

  00095	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0009e	4c 8d 4c 24 40	 lea	 r9, QWORD PTR BytesRead$1[rsp]
  000a3	44 8b 44 24 58	 mov	 r8d, DWORD PTR Filesize$2[rsp]
  000a8	48 8b 54 24 48	 mov	 rdx, QWORD PTR FileData$[rsp]
  000ad	48 8b 4c 24 50	 mov	 rcx, QWORD PTR FileHandle$[rsp]
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReadFile
  000b8	85 c0		 test	 eax, eax
  000ba	74 17		 je	 SHORT $LN8@LoadFile
  000bc	8b 44 24 40	 mov	 eax, DWORD PTR BytesRead$1[rsp]
  000c0	39 44 24 58	 cmp	 DWORD PTR Filesize$2[rsp], eax
  000c4	75 0d		 jne	 SHORT $LN8@LoadFile

; 302  :                    (Filesize.LowPart == BytesRead))
; 303  :                 {
; 304  :                     *Size = (uint32)BytesRead;

  000c6	48 8b 44 24 78	 mov	 rax, QWORD PTR Size$[rsp]
  000cb	8b 4c 24 40	 mov	 ecx, DWORD PTR BytesRead$1[rsp]
  000cf	89 08		 mov	 DWORD PTR [rax], ecx

; 305  :                     // It worked!
; 306  :                 }
; 307  :                 else

  000d1	eb 12		 jmp	 SHORT $LN9@LoadFile
$LN8@LoadFile:

; 308  :                 {
; 309  :                     Assert(0);

  000d3	33 c0		 xor	 eax, eax
  000d5	83 f8 01	 cmp	 eax, 1
  000d8	74 0b		 je	 SHORT $LN10@LoadFile
  000da	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN10@LoadFile:
$LN9@LoadFile:
$LN6@LoadFile:
$LN4@LoadFile:
$LN2@LoadFile:

; 310  :                 }
; 311  :             }
; 312  :             else
; 313  :             {
; 314  :             }   
; 315  :         }
; 316  :         else
; 317  :         {
; 318  :         }
; 319  :     }
; 320  :     else
; 321  :     {
; 322  : //        Assert(0);
; 323  :     }
; 324  :     return(FileData);

  000e5	48 8b 44 24 48	 mov	 rax, QWORD PTR FileData$[rsp]

; 325  : }

  000ea	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000ee	c3		 ret	 0
?LoadFile@@YAPEAXPEADPEAI@Z ENDP			; LoadFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
tv64 = 32
IsDown$1 = 36
NameSize$2 = 40
tv146 = 44
tv67 = 48
tv70 = 52
tv73 = 56
tv79 = 60
tv83 = 64
tv87 = 68
tv91 = 72
tv95 = 76
tv131 = 80
tv135 = 84
tv139 = 88
tv75 = 96
WasDown$3 = 104
AltPressed$4 = 108
FileOpened$5 = 112
Result$ = 120
newRom$6 = 128
tempFileName$7 = 288
__$ArrayPad$ = 544
WindowHandle$ = 576
Message$ = 584
wParam$ = 592
lParam$ = 600
?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z PROC		; WinInputCallback

; 120  : {

$LN60:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec 30 02
	00 00		 sub	 rsp, 560		; 00000230H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 121  :     LRESULT Result = 0;

  0002d	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR Result$[rsp], 0

; 122  :     
; 123  :     switch(Message) 

  00036	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR Message$[rsp]
  0003d	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  00041	83 7c 24 20 10	 cmp	 DWORD PTR tv64[rsp], 16
  00046	77 21		 ja	 SHORT $LN57@WinInputCa
  00048	83 7c 24 20 10	 cmp	 DWORD PTR tv64[rsp], 16
  0004d	74 67		 je	 SHORT $LN10@WinInputCa
  0004f	83 7c 24 20 01	 cmp	 DWORD PTR tv64[rsp], 1
  00054	74 56		 je	 SHORT $LN8@WinInputCa
  00056	83 7c 24 20 02	 cmp	 DWORD PTR tv64[rsp], 2
  0005b	74 68		 je	 SHORT $LN11@WinInputCa
  0005d	83 7c 24 20 05	 cmp	 DWORD PTR tv64[rsp], 5
  00062	74 4d		 je	 SHORT $LN9@WinInputCa
  00064	e9 92 04 00 00	 jmp	 $LN33@WinInputCa
$LN57@WinInputCa:
  00069	81 7c 24 20 00
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 256 ; 00000100H
  00071	0f 82 84 04 00
	00		 jb	 $LN33@WinInputCa
  00077	81 7c 24 20 01
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 257 ; 00000101H
  0007f	76 49		 jbe	 SHORT $LN12@WinInputCa
  00081	81 7c 24 20 03
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 259 ; 00000103H
  00089	0f 86 6c 04 00
	00		 jbe	 $LN33@WinInputCa
  0008f	81 7c 24 20 05
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 261 ; 00000105H
  00097	76 31		 jbe	 SHORT $LN12@WinInputCa
  00099	81 7c 24 20 11
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 273 ; 00000111H
  000a1	0f 84 c5 02 00
	00		 je	 $LN26@WinInputCa
  000a7	e9 4f 04 00 00	 jmp	 $LN33@WinInputCa
$LN8@WinInputCa:

; 124  :     { 
; 125  :         case WM_CREATE:
; 126  :         {
; 127  :             // Initialize the window. 
; 128  :             break; 

  000ac	e9 74 04 00 00	 jmp	 $LN2@WinInputCa
$LN9@WinInputCa:

; 129  :         }
; 130  :         
; 131  :         case WM_SIZE:
; 132  :         {
; 133  :             // Set the size and position of the window. 
; 134  :             break;

  000b1	e9 6f 04 00 00	 jmp	 $LN2@WinInputCa
$LN10@WinInputCa:

; 135  :         }
; 136  :         case WM_CLOSE:
; 137  :         {
; 138  :             GlobalRunning = false;

  000b6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0

; 139  :             break;

  000c0	e9 60 04 00 00	 jmp	 $LN2@WinInputCa
$LN11@WinInputCa:

; 140  :         }
; 141  :         case WM_DESTROY:
; 142  :         {
; 143  :             break;

  000c5	e9 5b 04 00 00	 jmp	 $LN2@WinInputCa
$LN12@WinInputCa:

; 144  :         }
; 145  :         case WM_SYSKEYDOWN:
; 146  :         case WM_SYSKEYUP:
; 147  :         case WM_KEYDOWN:
; 148  :         case WM_KEYUP:
; 149  :         {
; 150  :             bool32 IsDown = ((lParam & (1<<31)) == 0);

  000ca	48 8b 84 24 58
	02 00 00	 mov	 rax, QWORD PTR lParam$[rsp]
  000d2	48 25 00 00 00
	80		 and	 rax, -2147483648	; ffffffff80000000H
  000d8	48 85 c0	 test	 rax, rax
  000db	75 0a		 jne	 SHORT $LN35@WinInputCa
  000dd	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  000e5	eb 08		 jmp	 SHORT $LN36@WinInputCa
$LN35@WinInputCa:
  000e7	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN36@WinInputCa:
  000ef	8b 44 24 30	 mov	 eax, DWORD PTR tv67[rsp]
  000f3	89 44 24 24	 mov	 DWORD PTR IsDown$1[rsp], eax

; 151  :             bool32 WasDown = ((lParam & (1<<30)) != 0);

  000f7	48 8b 84 24 58
	02 00 00	 mov	 rax, QWORD PTR lParam$[rsp]
  000ff	48 25 00 00 00
	40		 and	 rax, 1073741824		; 40000000H
  00105	48 85 c0	 test	 rax, rax
  00108	74 0a		 je	 SHORT $LN37@WinInputCa
  0010a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00112	eb 08		 jmp	 SHORT $LN38@WinInputCa
$LN37@WinInputCa:
  00114	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN38@WinInputCa:
  0011c	8b 44 24 34	 mov	 eax, DWORD PTR tv70[rsp]
  00120	89 44 24 68	 mov	 DWORD PTR WasDown$3[rsp], eax

; 152  : 
; 153  :             // NOTE: Alt only on SYSDOWN messages
; 154  :             bool32 AltPressed = ((lParam & (1<<29)) != 0);

  00124	48 8b 84 24 58
	02 00 00	 mov	 rax, QWORD PTR lParam$[rsp]
  0012c	48 25 00 00 00
	20		 and	 rax, 536870912		; 20000000H
  00132	48 85 c0	 test	 rax, rax
  00135	74 0a		 je	 SHORT $LN39@WinInputCa
  00137	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  0013f	eb 08		 jmp	 SHORT $LN40@WinInputCa
$LN39@WinInputCa:
  00141	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN40@WinInputCa:
  00149	8b 44 24 38	 mov	 eax, DWORD PTR tv73[rsp]
  0014d	89 44 24 6c	 mov	 DWORD PTR AltPressed$4[rsp], eax

; 155  :             
; 156  :             if(IsDown != WasDown)

  00151	8b 44 24 68	 mov	 eax, DWORD PTR WasDown$3[rsp]
  00155	39 44 24 24	 cmp	 DWORD PTR IsDown$1[rsp], eax
  00159	0f 84 08 02 00
	00		 je	 $LN13@WinInputCa

; 157  :             {  
; 158  :                 switch(wParam)

  0015f	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR wParam$[rsp]
  00167	48 89 44 24 60	 mov	 QWORD PTR tv75[rsp], rax
  0016c	48 8b 44 24 60	 mov	 rax, QWORD PTR tv75[rsp]
  00171	48 83 e8 0d	 sub	 rax, 13
  00175	48 89 44 24 60	 mov	 QWORD PTR tv75[rsp], rax
  0017a	48 83 7c 24 60
	66		 cmp	 QWORD PTR tv75[rsp], 102 ; 00000066H
  00180	0f 87 e1 01 00
	00		 ja	 $LN4@WinInputCa
  00186	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:__ImageBase
  0018d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv75[rsp]
  00192	0f b6 8c 08 00
	00 00 00	 movzx	 ecx, BYTE PTR $LN58@WinInputCa[rax+rcx]
  0019a	8b 8c 88 00 00
	00 00		 mov	 ecx, DWORD PTR $LN59@WinInputCa[rax+rcx*4]
  001a1	48 03 c8	 add	 rcx, rax
  001a4	ff e1		 jmp	 rcx
$LN14@WinInputCa:

; 159  :                 {
; 160  :                     case VK_UP:
; 161  :                     {
; 162  :                         WinInput.buttons[input::B_UP] = IsDown ? 1 : 0;

  001a6	83 7c 24 24 00	 cmp	 DWORD PTR IsDown$1[rsp], 0
  001ab	74 0a		 je	 SHORT $LN41@WinInputCa
  001ad	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  001b5	eb 08		 jmp	 SHORT $LN42@WinInputCa
$LN41@WinInputCa:
  001b7	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN42@WinInputCa:
  001bf	b8 04 00 00 00	 mov	 eax, 4
  001c4	48 6b c0 04	 imul	 rax, rax, 4
  001c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  001cf	8b 54 24 3c	 mov	 edx, DWORD PTR tv79[rsp]
  001d3	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 163  :                         break;

  001d6	e9 8c 01 00 00	 jmp	 $LN4@WinInputCa
$LN15@WinInputCa:

; 164  :                     }
; 165  :                     case VK_DOWN:
; 166  :                     {
; 167  :                         WinInput.buttons[input::B_DOWN] = IsDown ? 1 : 0;

  001db	83 7c 24 24 00	 cmp	 DWORD PTR IsDown$1[rsp], 0
  001e0	74 0a		 je	 SHORT $LN43@WinInputCa
  001e2	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv83[rsp], 1
  001ea	eb 08		 jmp	 SHORT $LN44@WinInputCa
$LN43@WinInputCa:
  001ec	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
$LN44@WinInputCa:
  001f4	b8 04 00 00 00	 mov	 eax, 4
  001f9	48 6b c0 05	 imul	 rax, rax, 5
  001fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00204	8b 54 24 40	 mov	 edx, DWORD PTR tv83[rsp]
  00208	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 168  :                         break;

  0020b	e9 57 01 00 00	 jmp	 $LN4@WinInputCa
$LN16@WinInputCa:

; 169  :                     }
; 170  :                     case VK_LEFT:
; 171  :                     {
; 172  :                         WinInput.buttons[input::B_LEFT] = IsDown ? 1 : 0;

  00210	83 7c 24 24 00	 cmp	 DWORD PTR IsDown$1[rsp], 0
  00215	74 0a		 je	 SHORT $LN45@WinInputCa
  00217	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv87[rsp], 1
  0021f	eb 08		 jmp	 SHORT $LN46@WinInputCa
$LN45@WinInputCa:
  00221	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
$LN46@WinInputCa:
  00229	b8 04 00 00 00	 mov	 eax, 4
  0022e	48 6b c0 06	 imul	 rax, rax, 6
  00232	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  00239	8b 54 24 44	 mov	 edx, DWORD PTR tv87[rsp]
  0023d	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 173  :                         break;

  00240	e9 22 01 00 00	 jmp	 $LN4@WinInputCa
$LN17@WinInputCa:

; 174  :                     }
; 175  :                     case VK_RIGHT:
; 176  :                     {
; 177  :                         WinInput.buttons[input::B_RIGHT] = IsDown ? 1 : 0;

  00245	83 7c 24 24 00	 cmp	 DWORD PTR IsDown$1[rsp], 0
  0024a	74 0a		 je	 SHORT $LN47@WinInputCa
  0024c	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
  00254	eb 08		 jmp	 SHORT $LN48@WinInputCa
$LN47@WinInputCa:
  00256	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
$LN48@WinInputCa:
  0025e	b8 04 00 00 00	 mov	 eax, 4
  00263	48 6b c0 07	 imul	 rax, rax, 7
  00267	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0026e	8b 54 24 48	 mov	 edx, DWORD PTR tv91[rsp]
  00272	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 178  :                         break;

  00275	e9 ed 00 00 00	 jmp	 $LN4@WinInputCa
$LN18@WinInputCa:

; 179  :                     }
; 180  :                     case 'Z':
; 181  :                     {
; 182  :                         WinInput.buttons[input::B_A] = IsDown ? 1 : 0;

  0027a	83 7c 24 24 00	 cmp	 DWORD PTR IsDown$1[rsp], 0
  0027f	74 0a		 je	 SHORT $LN49@WinInputCa
  00281	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv95[rsp], 1
  00289	eb 08		 jmp	 SHORT $LN50@WinInputCa
$LN49@WinInputCa:
  0028b	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
$LN50@WinInputCa:
  00293	b8 04 00 00 00	 mov	 eax, 4
  00298	48 6b c0 00	 imul	 rax, rax, 0
  0029c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  002a3	8b 54 24 4c	 mov	 edx, DWORD PTR tv95[rsp]
  002a7	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 183  :                         break;

  002aa	e9 b8 00 00 00	 jmp	 $LN4@WinInputCa
$LN19@WinInputCa:

; 184  :                     }
; 185  :                     case 'X':
; 186  :                     {
; 187  :                         WinInput.buttons[input::B_B] = IsDown ? 1 : 0;

  002af	83 7c 24 24 00	 cmp	 DWORD PTR IsDown$1[rsp], 0
  002b4	74 0a		 je	 SHORT $LN51@WinInputCa
  002b6	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  002be	eb 08		 jmp	 SHORT $LN52@WinInputCa
$LN51@WinInputCa:
  002c0	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN52@WinInputCa:
  002c8	b8 04 00 00 00	 mov	 eax, 4
  002cd	48 6b c0 01	 imul	 rax, rax, 1
  002d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  002d8	8b 54 24 50	 mov	 edx, DWORD PTR tv131[rsp]
  002dc	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 188  :                         break;

  002df	e9 83 00 00 00	 jmp	 $LN4@WinInputCa
$LN20@WinInputCa:

; 189  :                     }
; 190  :                     case VK_RETURN:
; 191  :                     {
; 192  :                         WinInput.buttons[input::B_START] = IsDown ? 1 : 0;

  002e4	83 7c 24 24 00	 cmp	 DWORD PTR IsDown$1[rsp], 0
  002e9	74 0a		 je	 SHORT $LN53@WinInputCa
  002eb	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv135[rsp], 1
  002f3	eb 08		 jmp	 SHORT $LN54@WinInputCa
$LN53@WinInputCa:
  002f5	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN54@WinInputCa:
  002fd	b8 04 00 00 00	 mov	 eax, 4
  00302	48 6b c0 03	 imul	 rax, rax, 3
  00306	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0030d	8b 54 24 54	 mov	 edx, DWORD PTR tv135[rsp]
  00311	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 193  :                         break;

  00314	eb 51		 jmp	 SHORT $LN4@WinInputCa
$LN21@WinInputCa:

; 194  :                     }
; 195  :                     case VK_SHIFT:
; 196  :                     {
; 197  :                         WinInput.buttons[input::B_SELECT] = IsDown ? 1 : 0;

  00316	83 7c 24 24 00	 cmp	 DWORD PTR IsDown$1[rsp], 0
  0031b	74 0a		 je	 SHORT $LN55@WinInputCa
  0031d	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv139[rsp], 1
  00325	eb 08		 jmp	 SHORT $LN56@WinInputCa
$LN55@WinInputCa:
  00327	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv139[rsp], 0
$LN56@WinInputCa:
  0032f	b8 04 00 00 00	 mov	 eax, 4
  00334	48 6b c0 02	 imul	 rax, rax, 2
  00338	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0033f	8b 54 24 58	 mov	 edx, DWORD PTR tv139[rsp]
  00343	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 198  :                         break;

  00346	eb 1f		 jmp	 SHORT $LN4@WinInputCa

; 199  :                     }
; 200  :                     case VK_SPACE:
; 201  :                     {                        
; 202  :                         break;

  00348	eb 1d		 jmp	 SHORT $LN4@WinInputCa
$LN23@WinInputCa:

; 203  :                     }
; 204  :                     case VK_ESCAPE:
; 205  :                     {
; 206  :                         GlobalRunning = false;

  0034a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0

; 207  :                         break;

  00354	eb 11		 jmp	 SHORT $LN4@WinInputCa
$LN24@WinInputCa:

; 208  :                     }
; 209  :                     case VK_F4:
; 210  :                     {
; 211  :                         if(AltPressed)

  00356	83 7c 24 6c 00	 cmp	 DWORD PTR AltPressed$4[rsp], 0
  0035b	74 0a		 je	 SHORT $LN25@WinInputCa

; 212  :                         {
; 213  :                             GlobalRunning = false;

  0035d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0
$LN25@WinInputCa:
$LN4@WinInputCa:
$LN13@WinInputCa:

; 214  :                         }
; 215  :                         break;
; 216  :                     }
; 217  :                 }
; 218  :             }
; 219  :             break;

  00367	e9 b9 01 00 00	 jmp	 $LN2@WinInputCa
$LN26@WinInputCa:

; 220  :         }
; 221  :         
; 222  :         case WM_COMMAND:
; 223  :         {
; 224  :             switch(LOWORD(wParam))

  0036c	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR wParam$[rsp]
  00374	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  0037a	0f b7 c0	 movzx	 eax, ax
  0037d	89 44 24 2c	 mov	 DWORD PTR tv146[rsp], eax
  00381	81 7c 24 2c e9
	03 00 00	 cmp	 DWORD PTR tv146[rsp], 1001 ; 000003e9H
  00389	74 21		 je	 SHORT $LN27@WinInputCa
  0038b	81 7c 24 2c ea
	03 00 00	 cmp	 DWORD PTR tv146[rsp], 1002 ; 000003eaH
  00393	0f 84 36 01 00
	00		 je	 $LN31@WinInputCa
  00399	81 7c 24 2c eb
	03 00 00	 cmp	 DWORD PTR tv146[rsp], 1003 ; 000003ebH
  003a1	0f 84 48 01 00
	00		 je	 $LN32@WinInputCa
  003a7	e9 4d 01 00 00	 jmp	 $LN6@WinInputCa
$LN27@WinInputCa:

; 225  :             {
; 226  :                 case ID_OPEN_ROM_ITEM:
; 227  :                 {
; 228  :                     char tempFileName[256];
; 229  :                     
; 230  :                     OPENFILENAMEA newRom = {};

  003ac	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR newRom$6[rsp]
  003b4	48 8b f8	 mov	 rdi, rax
  003b7	33 c0		 xor	 eax, eax
  003b9	b9 98 00 00 00	 mov	 ecx, 152		; 00000098H
  003be	f3 aa		 rep stosb

; 231  :                     newRom.lStructSize = sizeof(OPENFILENAME);

  003c0	c7 84 24 80 00
	00 00 98 00 00
	00		 mov	 DWORD PTR newRom$6[rsp], 152 ; 00000098H

; 232  :                     newRom.hwndOwner = WindowHandle;

  003cb	48 8b 84 24 40
	02 00 00	 mov	 rax, QWORD PTR WindowHandle$[rsp]
  003d3	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR newRom$6[rsp+8], rax

; 233  :                     newRom.lpstrFile = tempFileName;

  003db	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR tempFileName$7[rsp]
  003e3	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR newRom$6[rsp+48], rax

; 234  :                     newRom.lpstrFile[0] = '\0';

  003eb	b8 01 00 00 00	 mov	 eax, 1
  003f0	48 6b c0 00	 imul	 rax, rax, 0
  003f4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR newRom$6[rsp+48]
  003fc	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 235  :                     newRom.nMaxFile = sizeof(tempFileName);

  00400	c7 84 24 b8 00
	00 00 00 01 00
	00		 mov	 DWORD PTR newRom$6[rsp+56], 256 ; 00000100H

; 236  :                     newRom.lpstrFilter = ".nes\0*.nes\0";

  0040b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG87668
  00412	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR newRom$6[rsp+24], rax

; 237  :                     newRom.nFilterIndex =1;

  0041a	c7 84 24 ac 00
	00 00 01 00 00
	00		 mov	 DWORD PTR newRom$6[rsp+44], 1

; 238  :                     newRom.lpstrFileTitle = NULL ;

  00425	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR newRom$6[rsp+64], 0

; 239  :                     newRom.nMaxFileTitle = 0 ;

  00431	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR newRom$6[rsp+72], 0

; 240  :                     newRom.lpstrInitialDir=NULL ;

  0043c	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR newRom$6[rsp+80], 0

; 241  :                     newRom.Flags = OFN_PATHMUSTEXIST|OFN_FILEMUSTEXIST ;

  00448	c7 84 24 e0 00
	00 00 00 18 00
	00		 mov	 DWORD PTR newRom$6[rsp+96], 6144 ; 00001800H

; 242  : 
; 243  :                     bool32 FileOpened = GetOpenFileName(&newRom); 

  00453	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR newRom$6[rsp]
  0045b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetOpenFileNameA
  00461	89 44 24 70	 mov	 DWORD PTR FileOpened$5[rsp], eax

; 244  :                     
; 245  :                     if(FileOpened) // If exists then restart emulator with new file 

  00465	83 7c 24 70 00	 cmp	 DWORD PTR FileOpened$5[rsp], 0
  0046a	74 61		 je	 SHORT $LN28@WinInputCa

; 246  :                     {
; 247  :                         ZeroMemory(&RomFileName, sizeof(RomFileName));

  0046c	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00472	33 d2		 xor	 edx, edx
  00474	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?RomFileName@@3PADA
  0047b	e8 00 00 00 00	 call	 memset

; 248  :                         uint8 NameSize = strlen(tempFileName);

  00480	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR tempFileName$7[rsp]
  00488	e8 00 00 00 00	 call	 strlen
  0048d	88 44 24 28	 mov	 BYTE PTR NameSize$2[rsp], al

; 249  :                         cpyMemory((uint8 *)RomFileName, (uint8 *)tempFileName, NameSize);

  00491	0f b6 44 24 28	 movzx	 eax, BYTE PTR NameSize$2[rsp]
  00496	44 0f b7 c0	 movzx	 r8d, ax
  0049a	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR tempFileName$7[rsp]
  004a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?RomFileName@@3PADA
  004a9	e8 00 00 00 00	 call	 ?cpyMemory@@YAXPEAE0G@Z	; cpyMemory

; 250  :                         
; 251  :                         if(PowerOn)

  004ae	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PowerOn@@3HA, 0
  004b5	74 0c		 je	 SHORT $LN29@WinInputCa

; 252  :                         {
; 253  :                             ResetHit = true;

  004b7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?ResetHit@@3HA, 1

; 254  :                         }
; 255  :                         else

  004c1	eb 0a		 jmp	 SHORT $LN30@WinInputCa
$LN29@WinInputCa:

; 256  :                         {
; 257  :                             PowerHit = true;

  004c3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?PowerHit@@3HA, 1
$LN30@WinInputCa:
$LN28@WinInputCa:

; 258  :                         }
; 259  :                     }
; 260  :                     
; 261  :                     break;

  004cd	eb 2a		 jmp	 SHORT $LN6@WinInputCa
$LN31@WinInputCa:

; 262  :                 }
; 263  :                 case ID_CLOSE_ROM_ITEM:
; 264  :                 {
; 265  :                     ZeroMemory(&RomFileName, sizeof(RomFileName));

  004cf	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  004d5	33 d2		 xor	 edx, edx
  004d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?RomFileName@@3PADA
  004de	e8 00 00 00 00	 call	 memset

; 266  :                     PowerHit = true;

  004e3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?PowerHit@@3HA, 1

; 267  :                     break;

  004ed	eb 0a		 jmp	 SHORT $LN6@WinInputCa
$LN32@WinInputCa:

; 268  :                 }
; 269  :                 case ID_QUIT_ITEM:
; 270  :                 {
; 271  :                     GlobalRunning = false;

  004ef	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0
$LN6@WinInputCa:

; 272  :                     break;
; 273  :                 }
; 274  :             }
; 275  :             break;

  004f9	eb 2a		 jmp	 SHORT $LN2@WinInputCa
$LN33@WinInputCa:

; 276  :         }
; 277  :                 
; 278  :         default:
; 279  :         {
; 280  :             Result = DefWindowProc(WindowHandle, Message, wParam, lParam);

  004fb	4c 8b 8c 24 58
	02 00 00	 mov	 r9, QWORD PTR lParam$[rsp]
  00503	4c 8b 84 24 50
	02 00 00	 mov	 r8, QWORD PTR wParam$[rsp]
  0050b	8b 94 24 48 02
	00 00		 mov	 edx, DWORD PTR Message$[rsp]
  00512	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR WindowHandle$[rsp]
  0051a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DefWindowProcA
  00520	48 89 44 24 78	 mov	 QWORD PTR Result$[rsp], rax
$LN2@WinInputCa:

; 281  :             break;
; 282  :         }
; 283  :     }
; 284  :     return Result;

  00525	48 8b 44 24 78	 mov	 rax, QWORD PTR Result$[rsp]

; 285  : }

  0052a	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00532	48 33 cc	 xor	 rcx, rsp
  00535	e8 00 00 00 00	 call	 __security_check_cookie
  0053a	48 81 c4 30 02
	00 00		 add	 rsp, 560		; 00000230H
  00541	5f		 pop	 rdi
  00542	c3		 ret	 0
  00543	90		 npad	 1
$LN59@WinInputCa:
  00544	00 00 00 00	 DD	 $LN20@WinInputCa
  00548	00 00 00 00	 DD	 $LN21@WinInputCa
  0054c	00 00 00 00	 DD	 $LN23@WinInputCa
  00550	00 00 00 00	 DD	 $LN16@WinInputCa
  00554	00 00 00 00	 DD	 $LN14@WinInputCa
  00558	00 00 00 00	 DD	 $LN17@WinInputCa
  0055c	00 00 00 00	 DD	 $LN15@WinInputCa
  00560	00 00 00 00	 DD	 $LN19@WinInputCa
  00564	00 00 00 00	 DD	 $LN18@WinInputCa
  00568	00 00 00 00	 DD	 $LN24@WinInputCa
  0056c	00 00 00 00	 DD	 $LN4@WinInputCa
$LN58@WinInputCa:
  00570	00		 DB	 0
  00571	0a		 DB	 10
  00572	0a		 DB	 10
  00573	01		 DB	 1
  00574	0a		 DB	 10
  00575	0a		 DB	 10
  00576	0a		 DB	 10
  00577	0a		 DB	 10
  00578	0a		 DB	 10
  00579	0a		 DB	 10
  0057a	0a		 DB	 10
  0057b	0a		 DB	 10
  0057c	0a		 DB	 10
  0057d	0a		 DB	 10
  0057e	02		 DB	 2
  0057f	0a		 DB	 10
  00580	0a		 DB	 10
  00581	0a		 DB	 10
  00582	0a		 DB	 10
  00583	0a		 DB	 10
  00584	0a		 DB	 10
  00585	0a		 DB	 10
  00586	0a		 DB	 10
  00587	0a		 DB	 10
  00588	03		 DB	 3
  00589	04		 DB	 4
  0058a	05		 DB	 5
  0058b	06		 DB	 6
  0058c	0a		 DB	 10
  0058d	0a		 DB	 10
  0058e	0a		 DB	 10
  0058f	0a		 DB	 10
  00590	0a		 DB	 10
  00591	0a		 DB	 10
  00592	0a		 DB	 10
  00593	0a		 DB	 10
  00594	0a		 DB	 10
  00595	0a		 DB	 10
  00596	0a		 DB	 10
  00597	0a		 DB	 10
  00598	0a		 DB	 10
  00599	0a		 DB	 10
  0059a	0a		 DB	 10
  0059b	0a		 DB	 10
  0059c	0a		 DB	 10
  0059d	0a		 DB	 10
  0059e	0a		 DB	 10
  0059f	0a		 DB	 10
  005a0	0a		 DB	 10
  005a1	0a		 DB	 10
  005a2	0a		 DB	 10
  005a3	0a		 DB	 10
  005a4	0a		 DB	 10
  005a5	0a		 DB	 10
  005a6	0a		 DB	 10
  005a7	0a		 DB	 10
  005a8	0a		 DB	 10
  005a9	0a		 DB	 10
  005aa	0a		 DB	 10
  005ab	0a		 DB	 10
  005ac	0a		 DB	 10
  005ad	0a		 DB	 10
  005ae	0a		 DB	 10
  005af	0a		 DB	 10
  005b0	0a		 DB	 10
  005b1	0a		 DB	 10
  005b2	0a		 DB	 10
  005b3	0a		 DB	 10
  005b4	0a		 DB	 10
  005b5	0a		 DB	 10
  005b6	0a		 DB	 10
  005b7	0a		 DB	 10
  005b8	0a		 DB	 10
  005b9	0a		 DB	 10
  005ba	0a		 DB	 10
  005bb	07		 DB	 7
  005bc	0a		 DB	 10
  005bd	08		 DB	 8
  005be	0a		 DB	 10
  005bf	0a		 DB	 10
  005c0	0a		 DB	 10
  005c1	0a		 DB	 10
  005c2	0a		 DB	 10
  005c3	0a		 DB	 10
  005c4	0a		 DB	 10
  005c5	0a		 DB	 10
  005c6	0a		 DB	 10
  005c7	0a		 DB	 10
  005c8	0a		 DB	 10
  005c9	0a		 DB	 10
  005ca	0a		 DB	 10
  005cb	0a		 DB	 10
  005cc	0a		 DB	 10
  005cd	0a		 DB	 10
  005ce	0a		 DB	 10
  005cf	0a		 DB	 10
  005d0	0a		 DB	 10
  005d1	0a		 DB	 10
  005d2	0a		 DB	 10
  005d3	0a		 DB	 10
  005d4	0a		 DB	 10
  005d5	0a		 DB	 10
  005d6	09		 DB	 9
?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z ENDP		; WinInputCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Value$ = 0
NewAddress$ = 8
Address$ = 32
MemoryOffset$ = 40
?read8@@YAEG_K@Z PROC					; read8

; 96   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 97   :     uint8 *NewAddress = (uint8 *)(Address + MemoryOffset);

  0000e	0f b7 44 24 20	 movzx	 eax, WORD PTR Address$[rsp]
  00013	48 03 44 24 28	 add	 rax, QWORD PTR MemoryOffset$[rsp]
  00018	48 89 44 24 08	 mov	 QWORD PTR NewAddress$[rsp], rax

; 98   :     uint8 Value = *NewAddress;

  0001d	48 8b 44 24 08	 mov	 rax, QWORD PTR NewAddress$[rsp]
  00022	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00025	88 04 24	 mov	 BYTE PTR Value$[rsp], al

; 99   :     return(Value);

  00028	0f b6 04 24	 movzx	 eax, BYTE PTR Value$[rsp]

; 100  : }

  0002c	48 83 c4 18	 add	 rsp, 24
  00030	c3		 ret	 0
?read8@@YAEG_K@Z ENDP					; read8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
NewAddress$ = 0
Byte$ = 32
Address$ = 40
MemoryOffset$ = 48
?write8@@YAXEG_K@Z PROC					; write8

; 90   : {   

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	48 83 ec 18	 sub	 rsp, 24

; 91   :     uint8 *NewAddress = (uint8 *)(Address + MemoryOffset);

  00012	0f b7 44 24 28	 movzx	 eax, WORD PTR Address$[rsp]
  00017	48 03 44 24 30	 add	 rax, QWORD PTR MemoryOffset$[rsp]
  0001c	48 89 04 24	 mov	 QWORD PTR NewAddress$[rsp], rax

; 92   :     *NewAddress = Byte;

  00020	48 8b 04 24	 mov	 rax, QWORD PTR NewAddress$[rsp]
  00024	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR Byte$[rsp]
  00029	88 08		 mov	 BYTE PTR [rax], cl

; 93   : }

  0002b	48 83 c4 18	 add	 rsp, 24
  0002f	c3		 ret	 0
?write8@@YAXEG_K@Z ENDP					; write8
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
Byte$1 = 0
Dest$ = 32
Src$ = 40
Size$ = 48
?cpyMemory@@YAXPEAE0G@Z PROC				; cpyMemory

; 83   : {

  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	48 83 ec 18	 sub	 rsp, 24

; 84   :     // NOTE: Very basic copy. Not bounds protection
; 85   :     for(uint16 Byte = 0; Byte < Size; ++Byte)

  00014	33 c0		 xor	 eax, eax
  00016	66 89 04 24	 mov	 WORD PTR Byte$1[rsp], ax
  0001a	eb 0b		 jmp	 SHORT $LN4@cpyMemory
$LN2@cpyMemory:
  0001c	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  00020	66 ff c0	 inc	 ax
  00023	66 89 04 24	 mov	 WORD PTR Byte$1[rsp], ax
$LN4@cpyMemory:
  00027	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  0002b	0f b7 4c 24 30	 movzx	 ecx, WORD PTR Size$[rsp]
  00030	3b c1		 cmp	 eax, ecx
  00032	7d 1c		 jge	 SHORT $LN3@cpyMemory

; 86   :         Dest[Byte] = Src[Byte];

  00034	0f b7 04 24	 movzx	 eax, WORD PTR Byte$1[rsp]
  00038	0f b7 0c 24	 movzx	 ecx, WORD PTR Byte$1[rsp]
  0003c	48 8b 54 24 20	 mov	 rdx, QWORD PTR Dest$[rsp]
  00041	4c 8b 44 24 28	 mov	 r8, QWORD PTR Src$[rsp]
  00046	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0004b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0004e	eb cc		 jmp	 SHORT $LN2@cpyMemory
$LN3@cpyMemory:

; 87   : }

  00050	48 83 c4 18	 add	 rsp, 24
  00054	c3		 ret	 0
?cpyMemory@@YAXPEAE0G@Z ENDP				; cpyMemory
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
MSElapsed$ = 32
Counter$ = 40
CounterElapsed$ = 48
PerfCountFrequency$ = 80
?getMilliSeconds@@YAM_K@Z PROC				; getMilliSeconds

; 71   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 72   :     LARGE_INTEGER Counter;
; 73   :     QueryPerformanceCounter(&Counter);

  00009	48 8d 4c 24 28	 lea	 rcx, QWORD PTR Counter$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_QueryPerformanceCounter

; 74   :     
; 75   :     uint64 CounterElapsed = Counter.QuadPart;

  00014	48 8b 44 24 28	 mov	 rax, QWORD PTR Counter$[rsp]
  00019	48 89 44 24 30	 mov	 QWORD PTR CounterElapsed$[rsp], rax

; 76   :     real32 MSElapsed = ((1000.0f * (real32)CounterElapsed) / (real32)PerfCountFrequency);

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR CounterElapsed$[rsp]
  00023	f3 48 0f 2a c0	 cvtsi2ss xmm0, rax
  00028	48 85 c0	 test	 rax, rax
  0002b	7d 08		 jge	 SHORT $LN4@getMilliSe
  0002d	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@5f800000
$LN4@getMilliSe:
  00035	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@447a0000
  0003d	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00041	0f 28 c1	 movaps	 xmm0, xmm1
  00044	48 8b 44 24 50	 mov	 rax, QWORD PTR PerfCountFrequency$[rsp]
  00049	f3 48 0f 2a c8	 cvtsi2ss xmm1, rax
  0004e	48 85 c0	 test	 rax, rax
  00051	7d 08		 jge	 SHORT $LN3@getMilliSe
  00053	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@5f800000
$LN3@getMilliSe:
  0005b	f3 0f 5e c1	 divss	 xmm0, xmm1
  0005f	f3 0f 11 44 24
	20		 movss	 DWORD PTR MSElapsed$[rsp], xmm0

; 77   : 
; 78   :     return(MSElapsed);

  00065	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR MSElapsed$[rsp]

; 79   : }

  0006b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006f	c3		 ret	 0
?getMilliSeconds@@YAM_K@Z ENDP				; getMilliSeconds
_TEXT	ENDS
; Function compile flags: /Odtp
; File y:\nesemud\code\nesemu.cpp
_TEXT	SEGMENT
i$1 = 96
ResScale$ = 97
WindowHeight$ = 100
WindowWidth$ = 104
RenderScaleHeight$ = 108
RenderScaleWidth$ = 112
InitialWindowPosY$ = 116
InitialWindowPosX$ = 120
TickCycles$2 = 124
Window$3 = 128
CpuMemorySize$4 = 136
CpuCyclesElapsed$5 = 140
CurrentSecs$6 = 144
PrevSecs$7 = 148
SubMenu$8 = 152
PpuMemorySize$9 = 160
CpuClockRateHz$10 = 164
ElapsedSecs$11 = 168
WindowMenu$12 = 176
Memory$13 = 184
CpuMemoryBase$14 = 192
DeviceContext$15 = 200
PerfCountFrequency$ = 208
CpuCyclesPerMS$16 = 216
WinPerfCountFrequency$ = 224
PpuRegisterLocation$17 = 232
PpuMemoryBase$18 = 240
tv295 = 248
WindowClass$ = 256
Cartridge$19 = 336
Message$20 = 416
ScreenBackBuffer$ = 464
Cpu$21 = 544
Ppu$22 = 656
__$ArrayPad$ = 1040
WindowInstance$ = 1072
PrevWindowInstance$ = 1080
CommandLine$ = 1088
CommandShow$ = 1096
WinMain	PROC

; 620  : {

$LN21:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 20 04
	00 00		 sub	 rsp, 1056		; 00000420H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 10
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 621  : 
; 622  :     LARGE_INTEGER WinPerfCountFrequency;
; 623  :     QueryPerformanceFrequency(&WinPerfCountFrequency); 

  0002e	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR WinPerfCountFrequency$[rsp]
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_QueryPerformanceFrequency

; 624  :     uint64 PerfCountFrequency = WinPerfCountFrequency.QuadPart;            

  0003c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR WinPerfCountFrequency$[rsp]
  00044	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR PerfCountFrequency$[rsp], rax

; 625  : 
; 626  :     /**************************************/
; 627  :     /* NOTE : Screen back buffer creation */
; 628  :     
; 629  :     uint16 RenderScaleWidth = 256, RenderScaleHeight = 240;

  0004c	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00051	66 89 44 24 70	 mov	 WORD PTR RenderScaleWidth$[rsp], ax
  00056	b8 f0 00 00 00	 mov	 eax, 240		; 000000f0H
  0005b	66 89 44 24 6c	 mov	 WORD PTR RenderScaleHeight$[rsp], ax

; 630  :     uint8 ResScale = 5;

  00060	c6 44 24 61 05	 mov	 BYTE PTR ResScale$[rsp], 5

; 631  :     uint16 WindowWidth = RenderScaleWidth * ResScale, WindowHeight = RenderScaleHeight * ResScale;

  00065	0f b7 44 24 70	 movzx	 eax, WORD PTR RenderScaleWidth$[rsp]
  0006a	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR ResScale$[rsp]
  0006f	0f af c1	 imul	 eax, ecx
  00072	66 89 44 24 68	 mov	 WORD PTR WindowWidth$[rsp], ax
  00077	0f b7 44 24 6c	 movzx	 eax, WORD PTR RenderScaleHeight$[rsp]
  0007c	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR ResScale$[rsp]
  00081	0f af c1	 imul	 eax, ecx
  00084	66 89 44 24 64	 mov	 WORD PTR WindowHeight$[rsp], ax

; 632  :     screen_buffer ScreenBackBuffer = {};

  00089	48 8d 84 24 d0
	01 00 00	 lea	 rax, QWORD PTR ScreenBackBuffer$[rsp]
  00091	48 8b f8	 mov	 rdi, rax
  00094	33 c0		 xor	 eax, eax
  00096	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  0009b	f3 aa		 rep stosb

; 633  :     createBackBuffer(&ScreenBackBuffer, RenderScaleWidth, RenderScaleHeight);

  0009d	44 0f b7 44 24
	6c		 movzx	 r8d, WORD PTR RenderScaleHeight$[rsp]
  000a3	0f b7 54 24 70	 movzx	 edx, WORD PTR RenderScaleWidth$[rsp]
  000a8	48 8d 8c 24 d0
	01 00 00	 lea	 rcx, QWORD PTR ScreenBackBuffer$[rsp]
  000b0	e8 00 00 00 00	 call	 ?createBackBuffer@@YAXPEAUscreen_buffer@@GG@Z ; createBackBuffer

; 634  : 
; 635  :     /**************************/
; 636  :     /* NOTE : Window creation */
; 637  : 
; 638  :     WNDCLASSA WindowClass = {};

  000b5	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR WindowClass$[rsp]
  000bd	48 8b f8	 mov	 rdi, rax
  000c0	33 c0		 xor	 eax, eax
  000c2	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  000c7	f3 aa		 rep stosb

; 639  :     WindowClass.style = CS_HREDRAW | CS_VREDRAW;

  000c9	c7 84 24 00 01
	00 00 03 00 00
	00		 mov	 DWORD PTR WindowClass$[rsp], 3

; 640  :     WindowClass.lpfnWndProc = WinInputCallback;

  000d4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?WinInputCallback@@YA_JPEAUHWND__@@I_K_J@Z ; WinInputCallback
  000db	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR WindowClass$[rsp+8], rax

; 641  :     WindowClass.hInstance = WindowInstance;

  000e3	48 8b 84 24 30
	04 00 00	 mov	 rax, QWORD PTR WindowInstance$[rsp]
  000eb	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR WindowClass$[rsp+24], rax

; 642  :     WindowClass.lpszClassName = "NesEmu";

  000f3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG89256
  000fa	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR WindowClass$[rsp+64], rax

; 643  : 
; 644  :     uint16 InitialWindowPosX = 0;

  00102	33 c0		 xor	 eax, eax
  00104	66 89 44 24 78	 mov	 WORD PTR InitialWindowPosX$[rsp], ax

; 645  :     uint16 InitialWindowPosY = 0;

  00109	33 c0		 xor	 eax, eax
  0010b	66 89 44 24 74	 mov	 WORD PTR InitialWindowPosY$[rsp], ax

; 646  :     
; 647  :     if(RegisterClassA(&WindowClass))

  00110	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR WindowClass$[rsp]
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegisterClassA
  0011e	0f b7 c0	 movzx	 eax, ax
  00121	85 c0		 test	 eax, eax
  00123	0f 84 5f 05 00
	00		 je	 $LN9@WinMain

; 648  :     {        
; 649  :         HWND Window = CreateWindowExA(0, WindowClass.lpszClassName, "NesEmu", WS_OVERLAPPEDWINDOW|WS_VISIBLE,

  00129	0f b7 44 24 64	 movzx	 eax, WORD PTR WindowHeight$[rsp]
  0012e	0f b7 4c 24 68	 movzx	 ecx, WORD PTR WindowWidth$[rsp]
  00133	0f b7 54 24 74	 movzx	 edx, WORD PTR InitialWindowPosY$[rsp]
  00138	0f b7 7c 24 78	 movzx	 edi, WORD PTR InitialWindowPosX$[rsp]
  0013d	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR [rsp+88], 0
  00146	4c 8b 84 24 30
	04 00 00	 mov	 r8, QWORD PTR WindowInstance$[rsp]
  0014e	4c 89 44 24 50	 mov	 QWORD PTR [rsp+80], r8
  00153	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  0015c	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00165	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00169	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  0016d	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  00171	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  00175	41 b9 00 00 cf
	10		 mov	 r9d, 282001408		; 10cf0000H
  0017b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG89259
  00182	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR WindowClass$[rsp+64]
  0018a	33 c9		 xor	 ecx, ecx
  0018c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateWindowExA
  00192	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR Window$3[rsp], rax

; 650  :                                       InitialWindowPosX, InitialWindowPosY, WindowWidth, WindowHeight,
; 651  :                                       0, 0, WindowInstance, 0);
; 652  : 
; 653  :         if(Window) // If window was created successfully

  0019a	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR Window$3[rsp], 0
  001a3	0f 84 cb 04 00
	00		 je	 $LN11@WinMain

; 654  :         {
; 655  :             HMENU WindowMenu = CreateMenu();

  001a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateMenu
  001af	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR WindowMenu$12[rsp], rax

; 656  :             HMENU SubMenu = CreatePopupMenu();

  001b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreatePopupMenu
  001bd	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR SubMenu$8[rsp], rax

; 657  :             
; 658  :             AppendMenu(SubMenu, MF_STRING, ID_OPEN_ROM_ITEM, "&Open Rom");

  001c5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG89262
  001cc	41 b8 e9 03 00
	00		 mov	 r8d, 1001		; 000003e9H
  001d2	33 d2		 xor	 edx, edx
  001d4	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR SubMenu$8[rsp]
  001dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_AppendMenuA

; 659  :             AppendMenu(SubMenu, MF_STRING, ID_CLOSE_ROM_ITEM, "&Close Rom");

  001e2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG89263
  001e9	41 b8 ea 03 00
	00		 mov	 r8d, 1002		; 000003eaH
  001ef	33 d2		 xor	 edx, edx
  001f1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR SubMenu$8[rsp]
  001f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_AppendMenuA

; 660  :             AppendMenu(SubMenu, MF_STRING, ID_QUIT_ITEM, "&Quit");

  001ff	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG89264
  00206	41 b8 eb 03 00
	00		 mov	 r8d, 1003		; 000003ebH
  0020c	33 d2		 xor	 edx, edx
  0020e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR SubMenu$8[rsp]
  00216	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_AppendMenuA

; 661  :             AppendMenu(WindowMenu, MF_STRING | MF_POPUP, (uint64)SubMenu, "&File");

  0021c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG89265
  00223	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR SubMenu$8[rsp]
  0022b	ba 10 00 00 00	 mov	 edx, 16
  00230	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR WindowMenu$12[rsp]
  00238	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_AppendMenuA

; 662  : 
; 663  :             SetMenu(Window, WindowMenu);

  0023e	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR WindowMenu$12[rsp]
  00246	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Window$3[rsp]
  0024e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetMenu

; 664  : 
; 665  :             /**************************************************************************/
; 666  :             /* NOTE : creation and initialization of Emulators Cpu, Ppu, and Cartridge structures */
; 667  : 
; 668  : 
; 669  :             // Memory allocation for the Cpu and Ppu.
; 670  :             uint32 CpuMemorySize = Kilobytes(64);

  00254	c7 84 24 88 00
	00 00 00 00 01
	00		 mov	 DWORD PTR CpuMemorySize$4[rsp], 65536 ; 00010000H

; 671  :             uint32 PpuMemorySize = Kilobytes(64);

  0025f	c7 84 24 a0 00
	00 00 00 00 01
	00		 mov	 DWORD PTR PpuMemorySize$9[rsp], 65536 ; 00010000H

; 672  : 
; 673  :             uint8 * Memory = (uint8 *)VirtualAlloc(0, (size_t)(CpuMemorySize + PpuMemorySize), MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);

  0026a	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR PpuMemorySize$9[rsp]
  00271	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR CpuMemorySize$4[rsp]
  00278	03 c8		 add	 ecx, eax
  0027a	8b c1		 mov	 eax, ecx
  0027c	8b c0		 mov	 eax, eax
  0027e	41 b9 04 00 00
	00		 mov	 r9d, 4
  00284	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  0028a	8b d0		 mov	 edx, eax
  0028c	33 c9		 xor	 ecx, ecx
  0028e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  00294	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR Memory$13[rsp], rax

; 674  : 
; 675  :             uint64 CpuMemoryBase = (uint64)Memory;

  0029c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR Memory$13[rsp]
  002a4	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR CpuMemoryBase$14[rsp], rax

; 676  :             uint64 PpuMemoryBase = (uint64)Memory + CpuMemorySize;

  002ac	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR CpuMemorySize$4[rsp]
  002b3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR Memory$13[rsp]
  002bb	48 03 c8	 add	 rcx, rax
  002be	48 8b c1	 mov	 rax, rcx
  002c1	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR PpuMemoryBase$18[rsp], rax

; 677  :             
; 678  :             // Cpu Init             
; 679  :             cpu Cpu = {};

  002c9	48 8d 84 24 20
	02 00 00	 lea	 rax, QWORD PTR Cpu$21[rsp]
  002d1	48 8b f8	 mov	 rdi, rax
  002d4	33 c0		 xor	 eax, eax
  002d6	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  002db	f3 aa		 rep stosb

; 680  :             
; 681  :             initCpu(&Cpu, CpuMemoryBase);

  002dd	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR CpuMemoryBase$14[rsp]
  002e5	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR Cpu$21[rsp]
  002ed	e8 00 00 00 00	 call	 ?initCpu@@YAXPEAUcpu@@_K@Z ; initCpu

; 682  :             
; 683  :             // Ppu Init            
; 684  :             ppu Ppu = {};

  002f2	48 8d 84 24 90
	02 00 00	 lea	 rax, QWORD PTR Ppu$22[rsp]
  002fa	48 8b f8	 mov	 rdi, rax
  002fd	33 c0		 xor	 eax, eax
  002ff	b9 80 01 00 00	 mov	 ecx, 384		; 00000180H
  00304	f3 aa		 rep stosb

; 685  :             
; 686  :             uint64 PpuRegisterLocation = CpuMemoryBase + PPU_REG_ADRS;

  00306	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR CpuMemoryBase$14[rsp]
  0030e	48 05 00 20 00
	00		 add	 rax, 8192		; 00002000H
  00314	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR PpuRegisterLocation$17[rsp], rax

; 687  :             initPpu(&Ppu, PpuMemoryBase, (uint32 *)ScreenBackBuffer.Memory, (ppu_registers *)PpuRegisterLocation);

  0031c	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR PpuRegisterLocation$17[rsp]
  00324	4c 8b 84 24 00
	02 00 00	 mov	 r8, QWORD PTR ScreenBackBuffer$[rsp+48]
  0032c	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR PpuMemoryBase$18[rsp]
  00334	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR Ppu$22[rsp]
  0033c	e8 00 00 00 00	 call	 ?initPpu@@YAXPEAUppu@@_KPEAIPEAUppu_registers@@@Z ; initPpu

; 688  : 
; 689  :             // Cartidge Loading            
; 690  :             cartridge Cartridge = {};

  00341	48 8d 84 24 50
	01 00 00	 lea	 rax, QWORD PTR Cartridge$19[rsp]
  00349	48 8b f8	 mov	 rdi, rax
  0034c	33 c0		 xor	 eax, eax
  0034e	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00353	f3 aa		 rep stosb

; 691  : 
; 692  :             loadCartridge(&Cartridge, "Balloon Fight.nes", &Cpu, &Ppu);

  00355	4c 8d 8c 24 90
	02 00 00	 lea	 r9, QWORD PTR Ppu$22[rsp]
  0035d	4c 8d 84 24 20
	02 00 00	 lea	 r8, QWORD PTR Cpu$21[rsp]
  00365	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG89266
  0036c	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR Cartridge$19[rsp]
  00374	e8 00 00 00 00	 call	 ?loadCartridge@@YAXPEAUcartridge@@PEADPEAUcpu@@PEAUppu@@@Z ; loadCartridge

; 693  : 
; 694  :             // NOTE: Load the program counter with the reset vector
; 695  :             Cpu.PrgCounter = readCpu16(RESET_VEC, &Cpu);

  00379	48 8d 94 24 20
	02 00 00	 lea	 rdx, QWORD PTR Cpu$21[rsp]
  00381	66 b9 fc ff	 mov	 cx, 65532		; 0000fffcH
  00385	e8 00 00 00 00	 call	 ?readCpu16@@YAGGPEAUcpu@@@Z ; readCpu16
  0038a	66 89 84 24 26
	02 00 00	 mov	 WORD PTR Cpu$21[rsp+6], ax

; 696  : 
; 697  : 
; 698  :             /*****************/
; 699  :             /* NOTE : Timing */
; 700  :             
; 701  :             real32 CpuClockRateHz = 1789772.727272728;

  00392	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@49da7a66
  0039a	f3 0f 11 84 24
	a4 00 00 00	 movss	 DWORD PTR CpuClockRateHz$10[rsp], xmm0

; 702  :             real32 CpuCyclesPerMS = CpuClockRateHz / 1000.0;

  003a3	f3 0f 5a 84 24
	a4 00 00 00	 cvtss2sd xmm0, DWORD PTR CpuClockRateHz$10[rsp]
  003ac	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@408f400000000000
  003b4	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  003b8	f3 0f 11 84 24
	d8 00 00 00	 movss	 DWORD PTR CpuCyclesPerMS$16[rsp], xmm0

; 703  :             
; 704  :             uint32 CpuCyclesElapsed = 0;

  003c1	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR CpuCyclesElapsed$5[rsp], 0

; 705  :             uint32 TickCycles = 0;

  003cc	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR TickCycles$2[rsp], 0

; 706  :             
; 707  :             real32 ElapsedSecs = 0;

  003d4	0f 57 c0	 xorps	 xmm0, xmm0
  003d7	f3 0f 11 84 24
	a8 00 00 00	 movss	 DWORD PTR ElapsedSecs$11[rsp], xmm0

; 708  :             real32 CurrentSecs, PrevSecs = getMilliSeconds(PerfCountFrequency) / 1000.0f;

  003e0	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR PerfCountFrequency$[rsp]
  003e8	e8 00 00 00 00	 call	 ?getMilliSeconds@@YAM_K@Z ; getMilliSeconds
  003ed	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@447a0000
  003f5	f3 0f 11 84 24
	94 00 00 00	 movss	 DWORD PTR PrevSecs$7[rsp], xmm0

; 709  : 
; 710  :             /********************/
; 711  :             /* NOTE : Main Loop */
; 712  :             
; 713  :             GlobalRunning = true; 

  003fe	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 1
$LN2@WinMain:

; 714  :             while(GlobalRunning)

  00408	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?GlobalRunning@@3HA, 0
  0040f	0f 84 5d 02 00
	00		 je	 $LN3@WinMain

; 715  :             {
; 716  :                 MSG Message = {}; 

  00415	48 8d 84 24 a0
	01 00 00	 lea	 rax, QWORD PTR Message$20[rsp]
  0041d	48 8b f8	 mov	 rdi, rax
  00420	33 c0		 xor	 eax, eax
  00422	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00427	f3 aa		 rep stosb
$LN4@WinMain:

; 717  :                 while (PeekMessage(&Message, Window, 0, 0, PM_REMOVE))

  00429	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00431	45 33 c9	 xor	 r9d, r9d
  00434	45 33 c0	 xor	 r8d, r8d
  00437	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR Window$3[rsp]
  0043f	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR Message$20[rsp]
  00447	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PeekMessageA
  0044d	85 c0		 test	 eax, eax
  0044f	74 1e		 je	 SHORT $LN5@WinMain

; 718  :                 {
; 719  :                     TranslateMessage(&Message);

  00451	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR Message$20[rsp]
  00459	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TranslateMessage

; 720  :                     DispatchMessage(&Message);

  0045f	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR Message$20[rsp]
  00467	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DispatchMessageA

; 721  :                 }

  0046d	eb ba		 jmp	 SHORT $LN4@WinMain
$LN5@WinMain:

; 722  : 
; 723  :                 if(PowerHit)

  0046f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PowerHit@@3HA, 0
  00476	74 27		 je	 SHORT $LN13@WinMain

; 724  :                 {
; 725  :                     PowerHit = false;

  00478	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PowerHit@@3HA, 0

; 726  :                     power(&Cpu, &Ppu, &Cartridge);

  00482	4c 8d 84 24 50
	01 00 00	 lea	 r8, QWORD PTR Cartridge$19[rsp]
  0048a	48 8d 94 24 90
	02 00 00	 lea	 rdx, QWORD PTR Ppu$22[rsp]
  00492	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR Cpu$21[rsp]
  0049a	e8 00 00 00 00	 call	 ?power@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z ; power
$LN13@WinMain:

; 727  :                 }
; 728  :                 
; 729  :                 if(ResetHit)

  0049f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ResetHit@@3HA, 0
  004a6	74 4b		 je	 SHORT $LN14@WinMain

; 730  :                 {
; 731  :                     ResetHit = false;

  004a8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ResetHit@@3HA, 0

; 732  :                     loadCartridge(&Cartridge, RomFileName, &Cpu, &Ppu);

  004b2	4c 8d 8c 24 90
	02 00 00	 lea	 r9, QWORD PTR Ppu$22[rsp]
  004ba	4c 8d 84 24 20
	02 00 00	 lea	 r8, QWORD PTR Cpu$21[rsp]
  004c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?RomFileName@@3PADA
  004c9	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR Cartridge$19[rsp]
  004d1	e8 00 00 00 00	 call	 ?loadCartridge@@YAXPEAUcartridge@@PEADPEAUcpu@@PEAUppu@@@Z ; loadCartridge

; 733  :                     reset(&Cpu, &Ppu, &Cartridge);

  004d6	4c 8d 84 24 50
	01 00 00	 lea	 r8, QWORD PTR Cartridge$19[rsp]
  004de	48 8d 94 24 90
	02 00 00	 lea	 rdx, QWORD PTR Ppu$22[rsp]
  004e6	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR Cpu$21[rsp]
  004ee	e8 00 00 00 00	 call	 ?reset@@YAXPEAUcpu@@PEAUppu@@PEAUcartridge@@@Z ; reset
$LN14@WinMain:

; 734  :                 }
; 735  : 
; 736  :                 if(Cpu.MapperWrite)

  004f3	83 bc 24 34 02
	00 00 00	 cmp	 DWORD PTR Cpu$21[rsp+20], 0
  004fb	74 3d		 je	 SHORT $LN15@WinMain

; 737  :                 {
; 738  :                     Cpu.MapperWrite = false;

  004fd	c7 84 24 34 02
	00 00 00 00 00
	00		 mov	 DWORD PTR Cpu$21[rsp+20], 0

; 739  :                     mapperUpdate[Cartridge.MapperNum](&Cpu, &Cartridge);

  00508	0f b6 84 24 89
	01 00 00	 movzx	 eax, BYTE PTR Cartridge$19[rsp+57]
  00510	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mapperUpdate@@3PAP6AXPEAUcpu@@PEAUcartridge@@@ZA ; mapperUpdate
  00517	48 89 8c 24 f8
	00 00 00	 mov	 QWORD PTR tv295[rsp], rcx
  0051f	48 8d 94 24 50
	01 00 00	 lea	 rdx, QWORD PTR Cartridge$19[rsp]
  00527	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR Cpu$21[rsp]
  0052f	48 8b bc 24 f8
	00 00 00	 mov	 rdi, QWORD PTR tv295[rsp]
  00537	ff 14 c7	 call	 QWORD PTR [rdi+rax*8]
$LN15@WinMain:

; 740  :                 }
; 741  :                 
; 742  :                 if(PowerOn)

  0053a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PowerOn@@3HA, 0
  00541	74 68		 je	 SHORT $LN16@WinMain

; 743  :                 {
; 744  :                     TickCycles = cpuTick(&Cpu, &WinInput);

  00543	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?WinInput@@3Uinput@@A
  0054a	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR Cpu$21[rsp]
  00552	e8 00 00 00 00	 call	 ?cpuTick@@YAEPEAUcpu@@PEAUinput@@@Z ; cpuTick
  00557	0f b6 c0	 movzx	 eax, al
  0055a	89 44 24 7c	 mov	 DWORD PTR TickCycles$2[rsp], eax

; 745  :                     
; 746  :                     for(uint8 i = 0; i < (3*TickCycles); ++i)

  0055e	c6 44 24 60 00	 mov	 BYTE PTR i$1[rsp], 0
  00563	eb 0b		 jmp	 SHORT $LN8@WinMain
$LN6@WinMain:
  00565	0f b6 44 24 60	 movzx	 eax, BYTE PTR i$1[rsp]
  0056a	fe c0		 inc	 al
  0056c	88 44 24 60	 mov	 BYTE PTR i$1[rsp], al
$LN8@WinMain:
  00570	0f b6 44 24 60	 movzx	 eax, BYTE PTR i$1[rsp]
  00575	6b 4c 24 7c 03	 imul	 ecx, DWORD PTR TickCycles$2[rsp], 3
  0057a	3b c1		 cmp	 eax, ecx
  0057c	73 17		 jae	 SHORT $LN7@WinMain

; 747  :                     {
; 748  :                         ppuTick(&ScreenBackBuffer, &Ppu);

  0057e	48 8d 94 24 90
	02 00 00	 lea	 rdx, QWORD PTR Ppu$22[rsp]
  00586	48 8d 8c 24 d0
	01 00 00	 lea	 rcx, QWORD PTR ScreenBackBuffer$[rsp]
  0058e	e8 00 00 00 00	 call	 ?ppuTick@@YAXPEAUscreen_buffer@@PEAUppu@@@Z ; ppuTick

; 749  :                     }

  00593	eb d0		 jmp	 SHORT $LN6@WinMain
$LN7@WinMain:

; 750  : 
; 751  :                     CpuCyclesElapsed += TickCycles;

  00595	8b 44 24 7c	 mov	 eax, DWORD PTR TickCycles$2[rsp]
  00599	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR CpuCyclesElapsed$5[rsp]
  005a0	03 c8		 add	 ecx, eax
  005a2	8b c1		 mov	 eax, ecx
  005a4	89 84 24 8c 00
	00 00		 mov	 DWORD PTR CpuCyclesElapsed$5[rsp], eax
$LN16@WinMain:

; 752  :                 }
; 753  :                 
; 754  :                 if(DrawScreen) // NOTE: Gets called everytime the vblank happens in Ppu TODO: Should it be the end of vblank?

  005ab	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DrawScreen@@3HA, 0 ; DrawScreen
  005b2	74 6e		 je	 SHORT $LN17@WinMain

; 755  :                 {
; 756  :                     DrawScreen = false; 

  005b4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?DrawScreen@@3HA, 0 ; DrawScreen

; 757  :                     getWindowSize(Window, &WindowWidth, &WindowHeight);

  005be	4c 8d 44 24 64	 lea	 r8, QWORD PTR WindowHeight$[rsp]
  005c3	48 8d 54 24 68	 lea	 rdx, QWORD PTR WindowWidth$[rsp]
  005c8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Window$3[rsp]
  005d0	e8 00 00 00 00	 call	 ?getWindowSize@@YAXPEAUHWND__@@PEAG1@Z ; getWindowSize

; 758  :                 
; 759  :                     // NOTE: Drawing the backbuffer to the window 
; 760  :                     HDC DeviceContext = GetDC(Window);

  005d5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Window$3[rsp]
  005dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetDC
  005e3	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR DeviceContext$15[rsp], rax

; 761  :                     drawScreenBuffer(&ScreenBackBuffer, DeviceContext,

  005eb	44 0f b7 4c 24
	64		 movzx	 r9d, WORD PTR WindowHeight$[rsp]
  005f1	44 0f b7 44 24
	68		 movzx	 r8d, WORD PTR WindowWidth$[rsp]
  005f7	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR DeviceContext$15[rsp]
  005ff	48 8d 8c 24 d0
	01 00 00	 lea	 rcx, QWORD PTR ScreenBackBuffer$[rsp]
  00607	e8 00 00 00 00	 call	 ?drawScreenBuffer@@YAXPEAUscreen_buffer@@PEAUHDC__@@GG@Z ; drawScreenBuffer

; 762  :                                      WindowWidth, WindowHeight);
; 763  :                     ReleaseDC(Window, DeviceContext);

  0060c	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR DeviceContext$15[rsp]
  00614	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Window$3[rsp]
  0061c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReleaseDC
$LN17@WinMain:

; 764  :                 }
; 765  : 
; 766  :                 
; 767  :                 CurrentSecs = getMilliSeconds(PerfCountFrequency) / 1000.0f;

  00622	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR PerfCountFrequency$[rsp]
  0062a	e8 00 00 00 00	 call	 ?getMilliSeconds@@YAM_K@Z ; getMilliSeconds
  0062f	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@447a0000
  00637	f3 0f 11 84 24
	90 00 00 00	 movss	 DWORD PTR CurrentSecs$6[rsp], xmm0

; 768  :                 ElapsedSecs = CurrentSecs - PrevSecs;

  00640	f3 0f 10 84 24
	90 00 00 00	 movss	 xmm0, DWORD PTR CurrentSecs$6[rsp]
  00649	f3 0f 5c 84 24
	94 00 00 00	 subss	 xmm0, DWORD PTR PrevSecs$7[rsp]
  00652	f3 0f 11 84 24
	a8 00 00 00	 movss	 DWORD PTR ElapsedSecs$11[rsp], xmm0

; 769  :                 PrevSecs = CurrentSecs;

  0065b	f3 0f 10 84 24
	90 00 00 00	 movss	 xmm0, DWORD PTR CurrentSecs$6[rsp]
  00664	f3 0f 11 84 24
	94 00 00 00	 movss	 DWORD PTR PrevSecs$7[rsp], xmm0

; 770  :             }

  0066d	e9 96 fd ff ff	 jmp	 $LN2@WinMain
$LN3@WinMain:

; 771  : 
; 772  :         }
; 773  :         else

  00672	eb 12		 jmp	 SHORT $LN12@WinMain
$LN11@WinMain:

; 774  :         {
; 775  :             // NOTE: Window failed to create
; 776  :             // TODO: Handle this in a better way
; 777  :             Assert(0);

  00674	33 c0		 xor	 eax, eax
  00676	83 f8 01	 cmp	 eax, 1
  00679	74 0b		 je	 SHORT $LN18@WinMain
  0067b	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN18@WinMain:
$LN12@WinMain:

; 778  :         }
; 779  :     }
; 780  :     else

  00686	eb 12		 jmp	 SHORT $LN10@WinMain
$LN9@WinMain:

; 781  :     {
; 782  :         // NOTE: Failed to register window
; 783  :         // TODO: Handle this in a better way
; 784  :         Assert(0);

  00688	33 c0		 xor	 eax, eax
  0068a	83 f8 01	 cmp	 eax, 1
  0068d	74 0b		 je	 SHORT $LN19@WinMain
  0068f	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN19@WinMain:
$LN10@WinMain:

; 785  :     }
; 786  :     return(0);

  0069a	33 c0		 xor	 eax, eax

; 787  : } 

  0069c	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  006a4	48 33 cc	 xor	 rcx, rsp
  006a7	e8 00 00 00 00	 call	 __security_check_cookie
  006ac	48 81 c4 20 04
	00 00		 add	 rsp, 1056		; 00000420H
  006b3	5f		 pop	 rdi
  006b4	c3		 ret	 0
WinMain	ENDP
_TEXT	ENDS
END
